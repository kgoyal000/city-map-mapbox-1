(self.webpackChunkpp_frontend_editor = self.webpackChunkpp_frontend_editor || []).push([[187], {
    1501: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            b: () => pt
        });
        var Ut = $(10467)
          , r = $(54438)
          , Mt = $(9566)
          , s = $(60177)
          , so = $(27617)
          , Wt = $(78606)
          , _t = $(50552)
          , Ae = $(96354)
          , Me = $(7430)
          , ct = $(76675)
          , Tt = $(41046)
          , Qe = $(66985)
          , jt = $(21626);
        const Xe = (Be, ze) => ({
            fill: Be,
            stroke: ze
        })
          , Ce = Be => ({
            fill: Be,
            stroke: "transparent"
        });
        function it(Be, ze) {
            if (1 & Be && r.nrm(0, "div", 11),
            2 & Be) {
                const ye = r.XpG();
                r.xc7("color", ye.moonJewelry.color),
                r.Y8G("innerHTML", ye.exampleInformation, r.npT)
            }
        }
        function et(Be, ze) {
            1 & Be && r.nrm(0, "pp-poster-loaded-element")
        }
        let pt = ( () => {
            var Be;
            class ze extends _t.C {
                constructor(ge, Ie, gt, Ye) {
                    super(ge, Ie),
                    this.host = ge,
                    this.zone = Ie,
                    this.httpClient = gt,
                    this.cdr = Ye,
                    this.exampleInformation = "",
                    this.hideSwitchers = !1,
                    this.showFrontOnInit = !0,
                    this.showAvers = new r.bkB(!1),
                    this.moonJewelry = {
                        textURL: "",
                        titleFontSize: "1px",
                        material: so.Xl7.na,
                        setup: so.Hyl.charm,
                        color: "transparent",
                        moonURL: ""
                    }
                }
                setJewelry(ge, Ie) {
                    var gt = this;
                    return (0,
                    Ut.A)(function*() {
                        var Ye;
                        const yt = Ie.moonConfig[0];
                        gt.moonJewelry.textURL = null !== (Ye = yield gt.httpClient.post("".concat(window.location.origin, "/api/moon/jewelry/text"), {
                            title: yt.title,
                            titleFontScript: yt.titleFontScript,
                            footer: "".concat(yt.footer)
                        }).pipe((0,
                        Ae.T)(ht => (0,
                        ct.ID)("image/svg+xml", ht.image))).toPromise()) && void 0 !== Ye ? Ye : "",
                        gt.moonJewelry.material = Ie.material,
                        gt.moonJewelry.color = ct.fd[Ie.material],
                        gt.moonJewelry.setup = Ie.setup,
                        gt.moonJewelry.moonURL = yt.selectedByDate ? "/assets/pp-posters/moon/jewelry_preview/moon/".concat(yt.moon, ".svg") : "/assets/pp-posters/moon/jewelry_preview/moon_selected/".concat(yt.selectPhase, ".svg"),
                        gt.onImageLoad()
                    })()
                }
                setAllTextSettings(ge, Ie) {}
                setDesign(ge, Ie, gt) {
                    return Promise.resolve(void 0)
                }
                setTextArea(ge, Ie) {}
                ngAfterViewInit() {}
                onImageLoad() {
                    this.load++,
                    1 === this.load && (this.initiateRender(),
                    this.cdr.detectChanges())
                }
            }
            return (Be = ze).\u0275fac = function(ge) {
                return new (ge || Be)(r.rXU(r.aKT),r.rXU(r.SKi),r.rXU(jt.Qq),r.rXU(r.gRc))
            }
            ,
            Be.\u0275cmp = r.VBU({
                type: Be,
                selectors: [["pp-jewelry-moon"]],
                inputs: {
                    exampleInformation: "exampleInformation",
                    hideSwitchers: "hideSwitchers",
                    showFrontOnInit: "showFrontOnInit"
                },
                outputs: {
                    showAvers: "showAvers"
                },
                features: [r.Vt3],
                decls: 12,
                vars: 20,
                consts: [["svgJewelryContour", ""], [3, "background"], [3, "showAvers", "material", "setup", "hideSwitchers", "showFront"], ["slot", "front"], [1, "front-center"], [3, "src", "svgStyle"], ["class", "example-information", 3, "innerHTML", "color", 4, "ngIf"], [3, "showPreview", "marginTop", "maxWidth", "previewType"], ["slot", "back"], [1, "back-center"], [4, "ngIf"], [1, "example-information", 3, "innerHTML"]],
                template: function(ge, Ie) {
                    if (1 & ge) {
                        const gt = r.RV6();
                        r.j41(0, "pp-poster-background", 1)(1, "pp-poster-jewelry-area", 2),
                        r.bIt("showAvers", function(yt) {
                            return r.eBV(gt),
                            r.Njj(Ie.showAvers.emit(yt))
                        }),
                        r.j41(2, "div", 3)(3, "div", 4),
                        r.nrm(4, "svg-icon", 5, 0),
                        r.DNE(6, it, 1, 3, "div", 6),
                        r.nrm(7, "pp-poster-preview", 7),
                        r.k0s()(),
                        r.j41(8, "div", 8)(9, "div", 9),
                        r.nrm(10, "svg-icon", 5),
                        r.k0s()()()(),
                        r.DNE(11, et, 1, 0, "pp-poster-loaded-element", 10)
                    }
                    2 & ge && (r.Y8G("background", "transparent"),
                    r.R7$(),
                    r.Y8G("material", Ie.moonJewelry.material)("setup", Ie.moonJewelry.setup)("hideSwitchers", Ie.hideSwitchers)("showFront", Ie.showFrontOnInit),
                    r.R7$(3),
                    r.Y8G("src", Ie.moonJewelry.moonURL)("svgStyle", r.l_i(15, Xe, Ie.moonJewelry.color, Ie.moonJewelry.color)),
                    r.R7$(2),
                    r.Y8G("ngIf", Ie.exampleInformation),
                    r.R7$(),
                    r.Y8G("showPreview", !Ie.isFinalPoster)("marginTop", !1)("maxWidth", 100)("previewType", "jewelry"),
                    r.R7$(3),
                    r.Y8G("src", Ie.moonJewelry.textURL)("svgStyle", r.eq3(18, Ce, Ie.moonJewelry.color)),
                    r.R7$(),
                    r.Y8G("ngIf", Ie.isImageRendered))
                },
                dependencies: [s.MD, s.bT, Mt.R, Wt.iu, Wt.DM, Me.R, Tt.C, Qe.P],
                styles: ["[_nghost-%COMP%]{width:100%;height:100%;display:block}"]
            }),
            ze
        }
        )()
    }
    ,
    2227: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            $: () => ao
        });
        var Ut = $(10467)
          , r = $(54438)
          , Mt = $(60177)
          , s = $(27617)
          , so = $(78606)
          , Wt = $(50552)
          , _t = $(21626)
          , Ae = $(73955)
          , Me = $(7494)
          , ct = $(9566)
          , Tt = $(13620)
          , Qe = $(61762)
          , jt = $(69847)
          , Xe = $(15996);
        const Ce = (bt, Do, Xt, ie) => {
            switch (bt) {
            case s.C65.FULL_PAGE:
                return Do !== s.eR8.CUSTOM ? "#FFF" : "#".concat(ie);
            case s.C65.PASSEPARTOUT:
                switch (Do) {
                case s.eR8.ADMIRAL:
                case s.eR8.BERMUDA:
                case s.eR8.CASCADE:
                case s.eR8.EVERGLADE:
                case s.eR8.OCEANIC:
                case s.eR8.SAGE:
                case s.eR8.GREY:
                    return "#F8F1EF";
                case s.eR8.SANDSTORM:
                    return "#16212C";
                case s.eR8.PINK:
                    return "#A67978";
                case s.eR8.CLASSIC:
                    return "#f6e9d7";
                case s.eR8.CUSTOM:
                    return "#".concat(ie)
                }
            }
        }
          , it = (bt, Do) => bt ? "/assets/pp-posters/contour/".concat(Do ? "_HQ_/" : "", "background/").concat(bt, "_S.png") : null
          , et = (bt, Do, Xt) => bt ? "#0e1111" : (0,
        Xe.V)(Xt) ? "#FFF" : "#0e1111"
          , re = (bt, Do, Xt, ie) => {
            switch (bt) {
            case s.eR8.CUSTOM:
                return "#".concat(Xt);
            case s.eR8.CLASSIC:
                return "#1A1D29"
            }
            return "url('#shape-".concat(bt, "-").concat(ie, "')")
        }
        ;
        var pt = $(96354)
          , Be = $(1875)
          , ze = $(81572)
          , ye = $(76675)
          , ge = $(41046);
        const Ie = ["svgContour"]
          , gt = (bt, Do) => ({
            x: bt,
            y: Do
        })
          , Ye = (bt, Do, Xt) => ({
            fill: bt,
            width: Do,
            height: Xt
        });
        function yt(bt, Do) {
            if (1 & bt) {
                const Xt = r.RV6();
                r.qSk(),
                r.j41(0, "pattern", 12)(1, "image", 13),
                r.bIt("loadeddata", function() {
                    r.eBV(Xt);
                    const we = r.XpG(3);
                    return r.Njj(we.isDataLoaded())
                }),
                r.k0s()()
            }
            if (2 & bt) {
                const Xt = Do.$implicit
                  , ie = r.XpG(3);
                r.Y8G("id", "shape-" + Xt.name + "-" + ie.uuid),
                r.R7$(),
                r.BMQ("href", Xt.src, null, "xlink")
            }
        }
        function ht(bt, Do) {
            if (1 & bt && (r.qSk(),
            r.j41(0, "svg")(1, "defs"),
            r.DNE(2, yt, 2, 2, "pattern", 11),
            r.k0s()()),
            2 & bt) {
                const Xt = r.XpG(2);
                r.R7$(2),
                r.Y8G("ngForOf", Xt.contourPossibleBackground)
            }
        }
        function mo(bt, Do) {
            1 & bt && r.eu8(0)
        }
        function no(bt, Do) {
            if (1 & bt) {
                const Xt = r.RV6();
                r.j41(0, "pp-poster-printing-registration", 6)(1, "pp-poster-arrangement-wrapper")(2, "pp-poster-image-area")(3, "div", 7)(4, "svg-icon", 8, 2),
                r.bIt("resizeCallback", function() {
                    r.eBV(Xt);
                    const we = r.XpG();
                    return r.Njj(we.onResize())
                }),
                r.k0s(),
                r.DNE(6, ht, 3, 1, "svg", 5)(7, mo, 1, 0, "ng-container", 9),
                r.k0s()(),
                r.nrm(8, "pp-poster-text-area", 10),
                r.nI1(9, "async"),
                r.nI1(10, "async"),
                r.nI1(11, "async"),
                r.nI1(12, "async"),
                r.nI1(13, "async"),
                r.nI1(14, "async"),
                r.nI1(15, "async"),
                r.k0s()()
            }
            if (2 & bt) {
                const Xt = Do.ngIf
                  , ie = r.XpG()
                  , we = r.sdS(6);
                r.Y8G("poster", Xt),
                r.R7$(3),
                r.xc7("margin-top", ie.contour.margin, "px")("width", ie.contour.width, "px")("height", ie.contour.height, "px")("padding", ie.contour.svgMarkerStyle.width),
                r.R7$(),
                r.Y8G("svgStyle", ie.contour.svgStyle)("src", ie.contour.contourUrl),
                r.R7$(2),
                r.Y8G("ngIf", ie.contour.style),
                r.R7$(),
                r.Y8G("ngTemplateOutlet", we),
                r.R7$(),
                r.Y8G("poster", r.bMT(9, 20, ie.poster$))("color", r.bMT(10, 22, ie.textColor$))("textArea", r.bMT(11, 24, ie.textArea$))("title", r.bMT(12, 26, ie.title$))("subtitle", r.bMT(13, 28, ie.subtitle$))("footer", r.bMT(14, 30, ie.footer$))("date", r.bMT(15, 32, ie.date$))
            }
        }
        function Co(bt, Do) {
            1 & bt && r.nrm(0, "pp-poster-loaded-element")
        }
        function Lt(bt, Do) {
            if (1 & bt) {
                const Xt = r.RV6();
                r.j41(0, "svg-icon", 17),
                r.bIt("cdkDragStarted", function() {
                    r.eBV(Xt);
                    const we = r.XpG(2);
                    return r.Njj(we.dragStart())
                })("cdkDragEnded", function(we) {
                    r.eBV(Xt);
                    const Oe = r.XpG(2);
                    return r.Njj(Oe.dragEnd(we))
                })("click", function() {
                    r.eBV(Xt);
                    const we = r.XpG(2);
                    return r.Njj(we.isInteractive ? void 0 : we.openMarkerPopup.emit())
                }),
                r.k0s()
            }
            if (2 & bt) {
                const Xt = r.XpG(2);
                r.AVh("interactive", Xt.isInteractive),
                r.Y8G("cdkDragDisabled", !Xt.isInteractive)("cdkDragFreeDragPosition", r.l_i(6, gt, Xt.markerWrapper.width * Xt.contour.markerPositionX, Xt.markerWrapper.height * Xt.contour.markerPositionY))("svgStyle", r.sMw(9, Ye, Xt.contour.svgMarkerStyle.fill, Xt.contour.svgMarkerStyle.width + "px", Xt.contour.svgMarkerStyle.height + "px"))("src", Xt.contour.markerUrl)
            }
        }
        function Ft(bt, Do) {
            if (1 & bt && (r.j41(0, "div", 14)(1, "div", 15),
            r.DNE(2, Lt, 1, 13, "svg-icon", 16),
            r.k0s()()),
            2 & bt) {
                const Xt = r.XpG();
                r.xc7("width", Xt.markerWrapper.width + 2 * Xt.contour.svgMarkerStyle.width, "px")("height", Xt.markerWrapper.height + 2 * Xt.contour.svgMarkerStyle.height, "px")("left", Xt.markerWrapper.left - Xt.contour.svgMarkerStyle.width, "px")("top", Xt.markerWrapper.top - Xt.contour.svgMarkerStyle.height, "px"),
                r.R7$(),
                r.xc7("width", Xt.markerWrapper.width, "px")("height", Xt.markerWrapper.height, "px")("left", Xt.contour.svgMarkerStyle.width, "px")("top", Xt.contour.svgMarkerStyle.height, "px"),
                r.R7$(),
                r.Y8G("ngIf", Xt.contour.isMarkerEnabled)
            }
        }
        let Jt = ( () => {
            var bt;
            class Do extends Wt.C {
                constructor(ie, we, Oe, ee) {
                    super(ie, we),
                    this.host = ie,
                    this.zone = we,
                    this.httpClient = Oe,
                    this.cdr = ee,
                    this.openMarkerPopup = new r.bkB,
                    this.setMarkerPosition = new r.bkB,
                    this.markerDraggingInProgress = new r.bkB,
                    this.markerWrapper = {
                        width: 0,
                        height: 0,
                        left: 0,
                        top: 0
                    },
                    this.contourPossibleBackground = this.isFinalPoster ? [] : Object.keys(s.eR8).map(W => ({
                        name: W,
                        src: it(W, this.isFinalPoster)
                    })),
                    this.contour = {
                        background: "#FFF",
                        style: s.eR8.GREY,
                        contourName: "japan",
                        contourUrl: "",
                        margin: 0,
                        width: 0,
                        height: 0,
                        svgStyle: {
                            fill: "#FFF",
                            width: "100%",
                            height: "100%",
                            "max-width": "100%",
                            "max-height": "100%"
                        },
                        markerUrl: "",
                        markerPositionX: 0,
                        markerPositionY: 0,
                        isMarkerEnabled: !1,
                        svgMarkerStyle: {
                            fill: "red",
                            width: 24,
                            height: 24
                        }
                    },
                    this.uuid = 0,
                    this.uuid = (new Date).getTime(),
                    this.careAboutSvgVisibility()
                }
                setAllTextSettings(ie, we) {
                    var Oe, ee;
                    if (!(ie.contourId || null != we && we.contourId))
                        return;
                    const W = ie.contourId || ie.title ? ie.title : null !== (Oe = null == we ? void 0 : we.title) && void 0 !== Oe ? Oe : ""
                      , ae = {
                        text: ie.customMessage ? W : "",
                        isDefaultFont: !ie.titleFontScript
                    };
                    this.setText(ae, this.title$, {
                        font: null != ae && ae.isDefaultFont ? s.n3q.CAPSUULA_BOLD : s.n3q.HELLO_OCTOBER,
                        portrait: {
                            sizeFactor: null != ae && ae.isDefaultFont ? .07 : .088,
                            bottomFactor: (ie.subtitle || ie.footer ? 1 : 1.35) * (null != ae && ae.isDefaultFont ? .014 : .018),
                            topFactor: 0,
                            isBold: !1
                        },
                        horizontal: {
                            sizeFactor: null != ae && ae.isDefaultFont ? .07 : .08,
                            bottomFactor: null != ae && ae.isDefaultFont ? .014 : .018,
                            topFactor: 0,
                            isBold: !1
                        }
                    });
                    const Ve = ie.contourId || ie.subtitle ? ie.subtitle : null !== (ee = null == we ? void 0 : we.subtitle) && void 0 !== ee ? ee : ""
                      , fe = {
                        text: ie.customMessage ? Ve : "",
                        isDefaultFont: !ie.subtitleFontScript
                    };
                    this.setText(fe, this.subtitle$, {
                        font: null != fe && fe.isDefaultFont ? s.n3q.CAPSUULA : s.n3q.HELLO_OCTOBER,
                        portrait: {
                            sizeFactor: null != fe && fe.isDefaultFont ? .036 : .052,
                            bottomFactor: null != fe && fe.isDefaultFont ? .034 : .024,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: null != fe && fe.isDefaultFont ? .036 : .052,
                            bottomFactor: null != fe && fe.isDefaultFont ? .034 : .024,
                            topFactor: 0
                        }
                    }),
                    this.setText({
                        text: ie.customMessage ? ie.footer : "",
                        isDefaultFont: !0
                    }, this.footer$, {
                        font: s.n3q.CAPSUULA,
                        portrait: {
                            sizeFactor: .025,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: .016,
                            bottomFactor: 0,
                            topFactor: 0
                        }
                    })
                }
                setTextArea(ie) {
                    this.textArea$.next({
                        bottomFactor: .04,
                        marginFactor: ie.isPortrait ? .08 : .04
                    })
                }
                setDesign(ie, we, Oe) {
                    var ee = this;
                    return (0,
                    Ut.A)(function*() {
                        var W, ae;
                        !we.contourId && (null == Oe || !Oe.contourId) || (ee.contour.width = ie.isPortrait ? .86 * ie.size.width : .84 * ie.size.width,
                        ee.contour.height = we.customMessage && ie.isPortrait ? .92 * ie.size.width : .7 * ie.size.height,
                        ee.contour.margin = we.customMessage ? ie.isPortrait ? .08 * ie.size.width : .06 * ie.size.width : (ie.size.height - ee.contour.height) / 2,
                        ee.contour.style = we.style,
                        ee.contour.background = Ce(we.layout, we.style, 0, we.backgroundColor),
                        ee.isFinalPoster && ee.contourPossibleBackground.push({
                            name: we.style,
                            src: it(we.style, ee.isFinalPoster)
                        }),
                        ee.contour.contourName = we.contourName,
                        ee.contour.svgStyle.fill = re(we.style, 0, we.contourColor, ee.uuid),
                        ee.textColor$.next(et(we.style, 0, we.backgroundColor)),
                        ee.contour.contourUrl = null !== (W = yield ee.httpClient.get((bt => "".concat(window.location.origin, "/api/files-management/").concat(bt, "/").concat(s.Iwg.primary, "?editor=").concat(s.hb4.contour))(null !== (ae = we.contourId) && void 0 !== ae ? ae : null == Oe ? void 0 : Oe.contourId)).pipe((0,
                        pt.T)(Ve => (0,
                        ye.ID)("image/svg+xml", Ve.image))).toPromise()) && void 0 !== W ? W : "",
                        ee.setMarkerConfig(ie, we),
                        ee.onResize())
                    })()
                }
                setMarkerConfig(ie, we) {
                    this.contour.isMarkerEnabled = we.showMarker,
                    this.contour.markerPositionX = we.markerPosition.x,
                    this.contour.markerPositionY = we.markerPosition.y,
                    this.contour.markerUrl = "/assets/pp-posters/contour/markers/poster/".concat(s.sKi[we.shapeMarker].toLowerCase(), ".svg");
                    const Oe = () => {
                        var ee, W;
                        return ie.isPortrait ? .06 * (null !== (ee = this.contour.width) && void 0 !== ee ? ee : 0) : .06 * (null !== (W = this.contour.height) && void 0 !== W ? W : 0)
                    }
                    ;
                    this.contour.svgMarkerStyle = {
                        fill: "#".concat(we.markerColor),
                        width: Oe(),
                        height: Oe()
                    }
                }
                onResize() {
                    setTimeout( () => {
                        this.cdr.detectChanges(),
                        setTimeout( () => {
                            this.svgLoaded(),
                            setTimeout( () => {
                                this.cdr.detectChanges()
                            }
                            )
                        }
                        )
                    }
                    )
                }
                svgLoaded() {
                    var ie, we;
                    const Oe = null === (ie = this.svgContour) || void 0 === ie || null === (ie = ie.element) || void 0 === ie || null === (ie = ie.nativeElement) || void 0 === ie ? void 0 : ie.tagName;
                    if (!Oe)
                        return;
                    const W = this.host.nativeElement.getElementsByTagName(Oe)[0].getElementsByClassName("contour-wrapper")[0]
                      , ae = null == W ? void 0 : W.getBoundingClientRect()
                      , Ve = null === (we = this.svgContour) || void 0 === we || null === (we = we.element) || void 0 === we || null === (we = we.nativeElement) || void 0 === we || null === (we = we.getElementsByTagName("svg")[0]) || void 0 === we ? void 0 : we.getBoundingClientRect();
                    ae && Ve ? this.markerWrapper = {
                        top: (Ve.height - ae.height) / 2,
                        left: (Ve.width - ae.width) / 2,
                        width: ae.width,
                        height: ae.height
                    } : ae || console.warn("This file doesn't have a correct group or single path approach")
                }
                careAboutSvgVisibility() {
                    var ie;
                    const we = null === (ie = this.svgContour) || void 0 === ie || null === (ie = ie.element) || void 0 === ie || null === (ie = ie.nativeElement) || void 0 === ie ? void 0 : ie.querySelector("svg");
                    we && we.clientWidth > 0 ? this.onImageLoad() : setTimeout( () => {
                        this.careAboutSvgVisibility()
                    }
                    , 100)
                }
                dragStart() {
                    console.log("DRAG START"),
                    this.markerDraggingInProgress.emit(!0)
                }
                dragEnd(ie) {
                    var we, Oe;
                    const ee = null !== (we = this.markerWrapper.width) && void 0 !== we ? we : 0
                      , W = null !== (Oe = this.markerWrapper.height) && void 0 !== Oe ? Oe : 0;
                    if (W && ee) {
                        const {x: ae, y: Ve} = ie.source.getFreeDragPosition();
                        this.setMarkerPosition.emit({
                            x: ae / ee,
                            y: Ve / W
                        })
                    }
                    console.log("emit"),
                    this.markerDraggingInProgress.emit(!1)
                }
                isDataLoaded() {
                    console.log("isDataLoaded")
                }
                onImageLoad() {
                    this.load++,
                    1 === this.load && (this.initiateRender(),
                    this.cdr.detectChanges())
                }
            }
            return (bt = Do).\u0275fac = function(ie) {
                return new (ie || bt)(r.rXU(r.aKT),r.rXU(r.SKi),r.rXU(_t.Qq),r.rXU(r.gRc))
            }
            ,
            bt.\u0275cmp = r.VBU({
                type: bt,
                selectors: [["pp-poster-contour-full-page"]],
                viewQuery: function(ie, we) {
                    if (1 & ie && r.GBs(Ie, 5),
                    2 & ie) {
                        let Oe;
                        r.mGM(Oe = r.lsd()) && (we.svgContour = Oe.first)
                    }
                },
                outputs: {
                    openMarkerPopup: "openMarkerPopup",
                    setMarkerPosition: "setMarkerPosition",
                    markerDraggingInProgress: "markerDraggingInProgress"
                },
                features: [r.Vt3],
                decls: 7,
                vars: 5,
                consts: [["posterWrapper", ""], ["marker", ""], ["svgContour", ""], [3, "background"], [3, "poster", 4, "ngIf"], [4, "ngIf"], [3, "poster"], [1, "contour-instance"], ["ppPosterResizeObserver", "", 3, "resizeCallback", "svgStyle", "src"], [4, "ngTemplateOutlet"], [3, "poster", "color", "textArea", "title", "subtitle", "footer", "date"], ["height", "100%", "width", "100%", "patternUnits", "objectBoundingBox", "viewBox", "0 0 1 1", "preserveAspectRatio", "xMidYMid slice", 3, "id", 4, "ngFor", "ngForOf"], ["height", "100%", "width", "100%", "patternUnits", "objectBoundingBox", "viewBox", "0 0 1 1", "preserveAspectRatio", "xMidYMid slice", 3, "id"], ["height", "1", "width", "1", 3, "loadeddata"], [1, "marker-instance-wrapper"], [1, "marker-instance"], ["class", "marker", "cdkDrag", "", "cdkDragBoundary", ".marker-instance-wrapper", 3, "interactive", "cdkDragDisabled", "cdkDragFreeDragPosition", "svgStyle", "src", "cdkDragStarted", "cdkDragEnded", "click", 4, "ngIf"], ["cdkDrag", "", "cdkDragBoundary", ".marker-instance-wrapper", 1, "marker", 3, "cdkDragStarted", "cdkDragEnded", "click", "cdkDragDisabled", "cdkDragFreeDragPosition", "svgStyle", "src"]],
                template: function(ie, we) {
                    1 & ie && (r.j41(0, "pp-poster-background", 3, 0),
                    r.DNE(2, no, 16, 34, "pp-poster-printing-registration", 4),
                    r.nI1(3, "async"),
                    r.k0s(),
                    r.DNE(4, Co, 1, 0, "pp-poster-loaded-element", 5)(5, Ft, 3, 17, "ng-template", null, 1, r.C5r)),
                    2 & ie && (r.Y8G("background", we.contour.background),
                    r.R7$(2),
                    r.Y8G("ngIf", r.bMT(3, 3, we.poster$)),
                    r.R7$(2),
                    r.Y8G("ngIf", we.isImageRendered))
                },
                dependencies: [Mt.MD, Mt.Sq, Mt.bT, Mt.T3, Mt.Jj, Me.Z, ct.R, jt.c, Tt.y, Qe.W, so.iu, so.DM, _t.q1, ze.h, Be.T1, Ae.h, ge.C],
                styles: ['@font-face{font-family:Leander Script Pro;font-weight:700;src:url(/assets/pp-posters/fonts/leanderscriptpro-bold.otf) format("opentype")}@font-face{font-family:Leander Script Pro;src:url(/assets/pp-posters/fonts/leanderscriptpro-regular.otf) format("opentype")}@font-face{font-family:Madina Script;src:url(/assets/pp-posters/fonts/Madina-Script.otf) format("opentype")}@font-face{font-family:Proxima Nova;font-weight:700;src:url(/assets/pp-posters/fonts/proximanova-bold.otf) format("opentype")}@font-face{font-family:SourceCodePro-Regular;src:url(/assets/pp-posters/fonts/SourceCodePro-Regular.ttf) format("truetype")}@font-face{font-family:Proxima Nova;src:url(/assets/pp-posters/fonts/proximanova-regular.otf) format("opentype")}@font-face{font-family:Macho;font-weight:700;src:url(/assets/pp-posters/fonts/Macho-Medium.woff) format("opentype")}@font-face{font-family:Macho;src:url(/assets/pp-posters/fonts/Macho-Regular.woff) format("opentype")}@font-face{font-family:Capsuula;src:url(/assets/pp-posters/fonts/Capsuula.ttf) format("truetype")}@font-face{font-family:Capsuula Bold;src:url(/assets/pp-posters/fonts/Capsuula-bold.ttf) format("truetype")}@font-face{font-family:YesevaOne;src:url(/assets/pp-posters/fonts/YesevaOne-Regular.ttf)}@font-face{font-family:LuxusBrut;src:url(/assets/pp-posters/fonts/LuxusBrut.otf) format("opentype")}@font-face{font-family:PositivePrintsScript2;src:url(/assets/pp-posters/fonts/positive-prints-script-2.otf) format("opentype")}@font-face{font-family:PositivePrintsScript;src:url(/assets/pp-posters/fonts/PositivePrintsScript.ttf) format("opentype")}@font-face{font-family:Dejavu Sans;src:url(/assets/pp-posters/fonts/DejaVuSans.ttf) format("opentype")}@font-face{font-family:Roboto Thin;src:url(/assets/pp-posters/fonts/Roboto-Thin.ttf) format("opentype")}@font-face{font-family:roobert;font-weight:400;src:url(/assets/pp-posters/fonts/roobert-regular.otf) format("opentype")}@font-face{font-family:roobert;font-weight:700;src:url(/assets/pp-posters/fonts/roobert-bold.otf) format("opentype")}@font-face{font-family:Sophia Ronald;src:url(/assets/pp-posters/fonts/SophiaRonald.ttf) format("opentype")}@font-face{font-family:Hello October;src:url(/assets/pp-posters/fonts/Hello_October.otf) format("opentype")}@font-face{font-family:SignatureFont;src:url(/assets/pp-posters/fonts/SignatureFont.otf) format("opentype")}@font-face{font-family:EBGaramond-Bold;src:url(/assets/pp-posters/fonts/EBGaramond-Bold.ttf) format("opentype")}@font-face{font-family:EBGaramond-SemiBold;src:url(/assets/pp-posters/fonts/EBGaramond-SemiBold.ttf) format("opentype")}@font-face{font-family:EBGaramond-Regular;src:url(/assets/pp-posters/fonts/EBGaramond-Regular.ttf) format("opentype")}@font-face{font-family:Montserrat-ExtraBold;src:url(/assets/pp-posters/fonts/Montserrat-ExtraBold.ttf) format("opentype")}@font-face{font-family:Montserrat-Medium;src:url(/assets/pp-posters/fonts/Montserrat-Medium.ttf) format("opentype")}@font-face{font-family:Montserrat-Thin;src:url(/assets/pp-posters/fonts/Montserrat-Thin.ttf) format("opentype")}@font-face{font-family:Montserrat-Light;src:url(/assets/pp-posters/fonts/Montserrat-Light.ttf) format("opentype")}@font-face{font-family:Montserrat-ExtraBold;src:url(/assets/pp-posters/fonts/Montserrat-ExtraBold.ttf) format("opentype")}@font-face{font-family:Montserrat-Medium;src:url(/assets/pp-posters/fonts/Montserrat-Medium.ttf) format("opentype")}@font-face{font-family:Montserrat-Thin;src:url(/assets/pp-posters/fonts/Montserrat-Thin.ttf) format("opentype")}@font-face{font-family:AbrilFatface-Regular;src:url(/assets/pp-posters/fonts/AbrilFatface-Regular.ttf) format("opentype")}@font-face{font-family:MenloRegular;src:url(/assets/pp-posters/fonts/MenloRegular.ttf) format("opentype")}@font-face{font-family:MenloBoldItalic;src:url(/assets/pp-posters/fonts/MenloBoldItalic.ttf) format("opentype")}[_nghost-%COMP%]{width:100%;height:100%;display:block}[_nghost-%COMP%]   .image-area[_ngcontent-%COMP%]{display:flex;width:100%;height:100%;justify-content:center}[_nghost-%COMP%]   .contour-instance[_ngcontent-%COMP%]{box-sizing:border-box;position:relative}[_nghost-%COMP%]   .marker-instance-wrapper[_ngcontent-%COMP%]{position:absolute}[_nghost-%COMP%]   .marker-instance[_ngcontent-%COMP%]{position:absolute}[_nghost-%COMP%]   svg-icon.marker[_ngcontent-%COMP%]{position:absolute;top:0;left:0}[_nghost-%COMP%]   svg-icon.marker[_ngcontent-%COMP%]   svg[_ngcontent-%COMP%]{display:block;cursor:pointer}[_nghost-%COMP%]   svg-icon.marker.interactive[_ngcontent-%COMP%]   svg[_ngcontent-%COMP%]{cursor:move}[_nghost-%COMP%]   .sign[_ngcontent-%COMP%]{display:flex;width:100%;justify-content:center}']
            }),
            Do
        }
        )();
        const po = ["svgContour"]
          , Et = (bt, Do) => ({
            x: bt,
            y: Do
        })
          , Kt = (bt, Do, Xt) => ({
            fill: bt,
            width: Do,
            height: Xt
        });
        function At(bt, Do) {
            if (1 & bt) {
                const Xt = r.RV6();
                r.qSk(),
                r.j41(0, "pattern", 13)(1, "image", 14),
                r.bIt("loadeddata", function() {
                    r.eBV(Xt);
                    const we = r.XpG(3);
                    return r.Njj(we.isDataLoaded())
                }),
                r.k0s()()
            }
            if (2 & bt) {
                const Xt = Do.$implicit
                  , ie = r.XpG(3);
                r.Y8G("id", "shape-" + Xt.name + "-" + ie.uuid),
                r.R7$(),
                r.BMQ("href", Xt.src, null, "xlink")
            }
        }
        function Re(bt, Do) {
            if (1 & bt && (r.qSk(),
            r.j41(0, "svg")(1, "defs"),
            r.DNE(2, At, 2, 2, "pattern", 12),
            r.k0s()()),
            2 & bt) {
                const Xt = r.XpG(2);
                r.R7$(2),
                r.Y8G("ngForOf", Xt.contourPossibleBackground)
            }
        }
        function ve(bt, Do) {
            1 & bt && r.eu8(0)
        }
        function ne(bt, Do) {
            if (1 & bt) {
                const Xt = r.RV6();
                r.j41(0, "pp-poster-printing-registration", 6)(1, "pp-poster-arrangement-wrapper", 7)(2, "pp-poster-image-area")(3, "div", 8)(4, "svg-icon", 9, 2),
                r.bIt("resizeCallback", function() {
                    r.eBV(Xt);
                    const we = r.XpG();
                    return r.Njj(we.onResize())
                }),
                r.k0s(),
                r.DNE(6, Re, 3, 1, "svg", 5)(7, ve, 1, 0, "ng-container", 10),
                r.k0s()(),
                r.nrm(8, "pp-poster-text-area", 11),
                r.nI1(9, "async"),
                r.nI1(10, "async"),
                r.nI1(11, "async"),
                r.nI1(12, "async"),
                r.nI1(13, "async"),
                r.nI1(14, "async"),
                r.nI1(15, "async"),
                r.k0s()()
            }
            if (2 & bt) {
                const Xt = Do.ngIf
                  , ie = r.XpG()
                  , we = r.sdS(6);
                r.Y8G("poster", Xt)("withPassepartout", ie.contour.passepartoutSize > 0),
                r.R7$(),
                r.Y8G("passepartoutSize", ie.contour.passepartoutSize),
                r.R7$(2),
                r.xc7("margin-top", ie.contour.margin, "px")("width", ie.contour.width, "px")("height", ie.contour.height, "px")("padding", ie.contour.svgMarkerStyle.width),
                r.R7$(),
                r.Y8G("svgStyle", ie.contour.svgStyle)("src", ie.contour.contourUrl),
                r.R7$(2),
                r.Y8G("ngIf", ie.contour.style),
                r.R7$(),
                r.Y8G("ngTemplateOutlet", we),
                r.R7$(),
                r.Y8G("background", ie.contour.textBackground)("poster", r.bMT(9, 23, ie.poster$))("color", r.bMT(10, 25, ie.textColor$))("textArea", r.bMT(11, 27, ie.textArea$))("title", r.bMT(12, 29, ie.title$))("subtitle", r.bMT(13, 31, ie.subtitle$))("footer", r.bMT(14, 33, ie.footer$))("date", r.bMT(15, 35, ie.date$))
            }
        }
        function B(bt, Do) {
            1 & bt && r.nrm(0, "pp-poster-loaded-element")
        }
        function de(bt, Do) {
            if (1 & bt) {
                const Xt = r.RV6();
                r.j41(0, "svg-icon", 18),
                r.bIt("cdkDragStarted", function() {
                    r.eBV(Xt);
                    const we = r.XpG(2);
                    return r.Njj(we.dragStart())
                })("cdkDragEnded", function(we) {
                    r.eBV(Xt);
                    const Oe = r.XpG(2);
                    return r.Njj(Oe.dragEnd(we))
                })("click", function() {
                    r.eBV(Xt);
                    const we = r.XpG(2);
                    return r.Njj(we.isInteractive ? void 0 : we.openMarkerPopup.emit())
                }),
                r.k0s()
            }
            if (2 & bt) {
                const Xt = r.XpG(2);
                r.AVh("interactive", Xt.isInteractive),
                r.Y8G("cdkDragDisabled", !Xt.isInteractive)("cdkDragFreeDragPosition", r.l_i(6, Et, Xt.markerWrapper.width * Xt.contour.markerPositionX, Xt.markerWrapper.height * Xt.contour.markerPositionY))("svgStyle", r.sMw(9, Kt, Xt.contour.svgMarkerStyle.fill, Xt.contour.svgMarkerStyle.width + "px", Xt.contour.svgMarkerStyle.height + "px"))("src", Xt.contour.markerUrl)
            }
        }
        function lt(bt, Do) {
            if (1 & bt && (r.j41(0, "div", 15)(1, "div", 16),
            r.DNE(2, de, 1, 13, "svg-icon", 17),
            r.k0s()()),
            2 & bt) {
                const Xt = r.XpG();
                r.xc7("width", Xt.markerWrapper.width + 2 * Xt.contour.svgMarkerStyle.width, "px")("height", Xt.markerWrapper.height + 2 * Xt.contour.svgMarkerStyle.height, "px")("left", Xt.markerWrapper.left - Xt.contour.svgMarkerStyle.width, "px")("top", Xt.markerWrapper.top - Xt.contour.svgMarkerStyle.height, "px"),
                r.R7$(),
                r.xc7("width", Xt.markerWrapper.width, "px")("height", Xt.markerWrapper.height, "px")("left", Xt.contour.svgMarkerStyle.width, "px")("top", Xt.contour.svgMarkerStyle.height, "px"),
                r.R7$(),
                r.Y8G("ngIf", Xt.contour.isMarkerEnabled)
            }
        }
        let tt = ( () => {
            var bt;
            class Do extends Wt.C {
                constructor(ie, we, Oe, ee) {
                    super(ie, we),
                    this.host = ie,
                    this.zone = we,
                    this.httpClient = Oe,
                    this.cdr = ee,
                    this.openMarkerPopup = new r.bkB,
                    this.setMarkerPosition = new r.bkB,
                    this.markerDraggingInProgress = new r.bkB,
                    this.markerWrapper = {
                        width: 0,
                        height: 0,
                        left: 0,
                        top: 0
                    },
                    this.contourPossibleBackground = this.isFinalPoster ? [] : Object.keys(s.eR8).map(W => ({
                        name: W,
                        src: it(W, this.isFinalPoster)
                    })),
                    this.contour = {
                        background: "#FFF",
                        textBackground: "#FFF",
                        style: s.eR8.GREY,
                        contourName: "japan",
                        contourUrl: "",
                        passepartoutSize: 0,
                        margin: 0,
                        width: 0,
                        height: 0,
                        svgStyle: {
                            fill: "#FFF",
                            width: "100%",
                            height: "100%",
                            "max-width": "100%",
                            "max-height": "100%"
                        },
                        markerUrl: "",
                        markerPositionX: 0,
                        markerPositionY: 0,
                        isMarkerEnabled: !1,
                        svgMarkerStyle: {
                            fill: "red",
                            width: 24,
                            height: 24
                        }
                    },
                    this.uuid = 0,
                    this.uuid = (new Date).getTime(),
                    this.careAboutSvgVisibility()
                }
                setAllTextSettings(ie, we) {
                    var Oe, ee;
                    if (!(ie.contourId || null != we && we.contourId))
                        return;
                    const W = ie.contourId || ie.title ? ie.title : null !== (Oe = null == we ? void 0 : we.title) && void 0 !== Oe ? Oe : ""
                      , ae = {
                        text: ie.customMessage ? W : "",
                        isDefaultFont: !ie.titleFontScript
                    }
                      , Ve = ie.contourId || ie.subtitle ? ie.subtitle : null !== (ee = null == we ? void 0 : we.subtitle) && void 0 !== ee ? ee : ""
                      , fe = {
                        text: ie.customMessage ? Ve : "",
                        isDefaultFont: !0
                    };
                    this.setText(ae, this.title$, {
                        font: null != ae && ae.isDefaultFont ? s.n3q.MACHO : s.n3q.LUXUS_BRUT,
                        portrait: {
                            sizeFactor: .058,
                            topFactor: .03,
                            bottomFactor: fe.text ? 0 : .014,
                            letterSpacingFactor: null != ae && ae.isDefaultFont ? 0 : .004,
                            isBold: !(null == ae || !ae.isDefaultFont)
                        },
                        square: {
                            sizeFactor: null != ae && ae.isDefaultFont ? .046 : .041,
                            topFactor: .03,
                            bottomFactor: fe.text ? 0 : .014,
                            letterSpacingFactor: null != ae && ae.isDefaultFont ? 0 : .004,
                            isBold: !(null == ae || !ae.isDefaultFont)
                        },
                        horizontal: {
                            sizeFactor: null != ae && ae.isDefaultFont ? .046 : .056,
                            topFactor: .03,
                            bottomFactor: fe.text ? 0 : .014,
                            letterSpacingFactor: null != ae && ae.isDefaultFont ? 0 : .004,
                            isBold: !(null == ae || !ae.isDefaultFont)
                        }
                    }),
                    this.setText(fe, this.subtitle$, {
                        font: s.n3q.MACHO,
                        portrait: {
                            sizeFactor: .024,
                            bottomFactor: 0,
                            topFactor: ae.text ? .01 : .03
                        },
                        horizontal: {
                            sizeFactor: .024,
                            bottomFactor: 0,
                            topFactor: .02
                        }
                    })
                }
                setTextArea(ie) {
                    this.textArea$.next({
                        bottomFactor: ie.isPortrait ? .04 : .03,
                        marginFactor: ie.isPortrait ? .03 : .02,
                        topFactor: 0
                    })
                }
                setDesign(ie, we, Oe) {
                    var ee = this;
                    return (0,
                    Ut.A)(function*() {
                        var W, ae;
                        !we.contourId && (null == Oe || !Oe.contourId) || (ee.contour.passepartoutSize = .05 * (ie.isPortrait ? ie.size.width : ie.size.height),
                        ee.contour.width = ie.isPortrait ? .86 * ie.size.width : .84 * ie.size.width,
                        ee.contour.height = we.customMessage && ie.isPortrait ? .92 * ie.size.width : .7 * ie.size.height,
                        ee.contour.margin = we.customMessage ? ie.isPortrait ? .08 * ie.size.width : .06 * ie.size.width : (ie.size.height - ee.contour.height) / 2,
                        ee.contour.style = we.style,
                        ee.contour.background = Ce(we.layout, we.style, 0, we.backgroundColor),
                        ee.isFinalPoster && ee.contourPossibleBackground.push({
                            name: we.style,
                            src: it(we.style, ee.isFinalPoster)
                        }),
                        ee.contour.contourName = we.contourName,
                        ee.contour.svgStyle.fill = re(we.style, 0, we.contourColor, ee.uuid),
                        ee.textColor$.next(et(we.style, 0, we.backgroundColor)),
                        ee.contour.contourUrl = null !== (W = yield ee.httpClient.get((bt => "".concat(window.location.origin, "/api/files-management/").concat(bt, "/").concat(s.Iwg.primary, "?editor=").concat(s.hb4.contour))(null !== (ae = we.contourId) && void 0 !== ae ? ae : null == Oe ? void 0 : Oe.contourId)).pipe((0,
                        pt.T)(Ve => (0,
                        ye.ID)("image/svg+xml", Ve.image))).toPromise()) && void 0 !== W ? W : "",
                        ee.setMarkerConfig(ie, we),
                        ee.onResize())
                    })()
                }
                setMarkerConfig(ie, we) {
                    this.contour.isMarkerEnabled = we.showMarker,
                    this.contour.markerPositionX = we.markerPosition.x,
                    this.contour.markerPositionY = we.markerPosition.y,
                    this.contour.markerUrl = "/assets/pp-posters/contour/markers/poster/".concat(s.sKi[we.shapeMarker].toLowerCase(), ".svg");
                    const Oe = () => {
                        var ee, W;
                        return ie.isPortrait ? .06 * (null !== (ee = this.contour.width) && void 0 !== ee ? ee : 0) : .06 * (null !== (W = this.contour.height) && void 0 !== W ? W : 0)
                    }
                    ;
                    this.contour.svgMarkerStyle = {
                        fill: "#".concat(we.markerColor),
                        width: Oe(),
                        height: Oe()
                    }
                }
                onResize() {
                    setTimeout( () => {
                        this.cdr.detectChanges(),
                        setTimeout( () => {
                            this.svgLoaded(),
                            setTimeout( () => {
                                this.cdr.detectChanges()
                            }
                            )
                        }
                        )
                    }
                    )
                }
                svgLoaded() {
                    var ie, we;
                    const Oe = null === (ie = this.svgContour) || void 0 === ie || null === (ie = ie.element) || void 0 === ie || null === (ie = ie.nativeElement) || void 0 === ie ? void 0 : ie.tagName;
                    if (!Oe)
                        return;
                    const W = this.host.nativeElement.getElementsByTagName(Oe)[0].getElementsByClassName("contour-wrapper")[0]
                      , ae = null == W ? void 0 : W.getBoundingClientRect()
                      , Ve = null === (we = this.svgContour) || void 0 === we || null === (we = we.element) || void 0 === we || null === (we = we.nativeElement) || void 0 === we || null === (we = we.getElementsByTagName("svg")[0]) || void 0 === we ? void 0 : we.getBoundingClientRect();
                    ae && Ve ? this.markerWrapper = {
                        top: (Ve.height - ae.height) / 2,
                        left: (Ve.width - ae.width) / 2,
                        width: ae.width,
                        height: ae.height
                    } : ae || console.warn("This file doesn't have a correct group or single path approach")
                }
                careAboutSvgVisibility() {
                    var ie;
                    const we = null === (ie = this.svgContour) || void 0 === ie || null === (ie = ie.element) || void 0 === ie || null === (ie = ie.nativeElement) || void 0 === ie ? void 0 : ie.querySelector("svg");
                    we && we.clientWidth > 0 ? this.onImageLoad() : setTimeout( () => {
                        this.careAboutSvgVisibility()
                    }
                    , 100)
                }
                dragStart() {
                    this.markerDraggingInProgress.emit(!0)
                }
                dragEnd(ie) {
                    var we, Oe;
                    const ee = null !== (we = this.markerWrapper.width) && void 0 !== we ? we : 0
                      , W = null !== (Oe = this.markerWrapper.height) && void 0 !== Oe ? Oe : 0;
                    if (W && ee) {
                        const {x: ae, y: Ve} = ie.source.getFreeDragPosition();
                        this.setMarkerPosition.emit({
                            x: ae / ee,
                            y: Ve / W
                        })
                    }
                    this.markerDraggingInProgress.emit(!1)
                }
                isDataLoaded() {
                    console.log("isDataLoaded")
                }
                onImageLoad() {
                    this.load++,
                    1 === this.load && (this.initiateRender(),
                    this.cdr.detectChanges())
                }
            }
            return (bt = Do).\u0275fac = function(ie) {
                return new (ie || bt)(r.rXU(r.aKT),r.rXU(r.SKi),r.rXU(_t.Qq),r.rXU(r.gRc))
            }
            ,
            bt.\u0275cmp = r.VBU({
                type: bt,
                selectors: [["pp-poster-contour-passepartout"]],
                viewQuery: function(ie, we) {
                    if (1 & ie && r.GBs(po, 5),
                    2 & ie) {
                        let Oe;
                        r.mGM(Oe = r.lsd()) && (we.svgContour = Oe.first)
                    }
                },
                outputs: {
                    openMarkerPopup: "openMarkerPopup",
                    setMarkerPosition: "setMarkerPosition",
                    markerDraggingInProgress: "markerDraggingInProgress"
                },
                features: [r.Vt3],
                decls: 7,
                vars: 5,
                consts: [["posterWrapper", ""], ["marker", ""], ["svgContour", ""], [3, "background"], [3, "poster", "withPassepartout", 4, "ngIf"], [4, "ngIf"], [3, "poster", "withPassepartout"], [3, "passepartoutSize"], [1, "contour-instance"], ["ppPosterResizeObserver", "", 3, "resizeCallback", "svgStyle", "src"], [4, "ngTemplateOutlet"], [3, "background", "poster", "color", "textArea", "title", "subtitle", "footer", "date"], ["height", "100%", "width", "100%", "patternUnits", "objectBoundingBox", "viewBox", "0 0 1 1", "preserveAspectRatio", "xMidYMid slice", 3, "id", 4, "ngFor", "ngForOf"], ["height", "100%", "width", "100%", "patternUnits", "objectBoundingBox", "viewBox", "0 0 1 1", "preserveAspectRatio", "xMidYMid slice", 3, "id"], ["height", "1", "width", "1", 3, "loadeddata"], [1, "marker-instance-wrapper"], [1, "marker-instance"], ["class", "marker", "cdkDrag", "", "cdkDragBoundary", ".marker-instance-wrapper", 3, "interactive", "cdkDragDisabled", "cdkDragFreeDragPosition", "svgStyle", "src", "cdkDragStarted", "cdkDragEnded", "click", 4, "ngIf"], ["cdkDrag", "", "cdkDragBoundary", ".marker-instance-wrapper", 1, "marker", 3, "cdkDragStarted", "cdkDragEnded", "click", "cdkDragDisabled", "cdkDragFreeDragPosition", "svgStyle", "src"]],
                template: function(ie, we) {
                    1 & ie && (r.j41(0, "pp-poster-background", 3, 0),
                    r.DNE(2, ne, 16, 37, "pp-poster-printing-registration", 4),
                    r.nI1(3, "async"),
                    r.k0s(),
                    r.DNE(4, B, 1, 0, "pp-poster-loaded-element", 5)(5, lt, 3, 17, "ng-template", null, 1, r.C5r)),
                    2 & ie && (r.Y8G("background", we.contour.background),
                    r.R7$(2),
                    r.Y8G("ngIf", r.bMT(3, 3, we.poster$)),
                    r.R7$(2),
                    r.Y8G("ngIf", we.isImageRendered))
                },
                dependencies: [Mt.MD, Mt.Sq, Mt.bT, Mt.T3, Mt.Jj, Me.Z, ct.R, jt.c, Tt.y, Qe.W, so.iu, so.DM, _t.q1, ze.h, Be.T1, Ae.h, ge.C],
                styles: ['@font-face{font-family:Leander Script Pro;font-weight:700;src:url(/assets/pp-posters/fonts/leanderscriptpro-bold.otf) format("opentype")}@font-face{font-family:Leander Script Pro;src:url(/assets/pp-posters/fonts/leanderscriptpro-regular.otf) format("opentype")}@font-face{font-family:Madina Script;src:url(/assets/pp-posters/fonts/Madina-Script.otf) format("opentype")}@font-face{font-family:Proxima Nova;font-weight:700;src:url(/assets/pp-posters/fonts/proximanova-bold.otf) format("opentype")}@font-face{font-family:SourceCodePro-Regular;src:url(/assets/pp-posters/fonts/SourceCodePro-Regular.ttf) format("truetype")}@font-face{font-family:Proxima Nova;src:url(/assets/pp-posters/fonts/proximanova-regular.otf) format("opentype")}@font-face{font-family:Macho;font-weight:700;src:url(/assets/pp-posters/fonts/Macho-Medium.woff) format("opentype")}@font-face{font-family:Macho;src:url(/assets/pp-posters/fonts/Macho-Regular.woff) format("opentype")}@font-face{font-family:Capsuula;src:url(/assets/pp-posters/fonts/Capsuula.ttf) format("truetype")}@font-face{font-family:Capsuula Bold;src:url(/assets/pp-posters/fonts/Capsuula-bold.ttf) format("truetype")}@font-face{font-family:YesevaOne;src:url(/assets/pp-posters/fonts/YesevaOne-Regular.ttf)}@font-face{font-family:LuxusBrut;src:url(/assets/pp-posters/fonts/LuxusBrut.otf) format("opentype")}@font-face{font-family:PositivePrintsScript2;src:url(/assets/pp-posters/fonts/positive-prints-script-2.otf) format("opentype")}@font-face{font-family:PositivePrintsScript;src:url(/assets/pp-posters/fonts/PositivePrintsScript.ttf) format("opentype")}@font-face{font-family:Dejavu Sans;src:url(/assets/pp-posters/fonts/DejaVuSans.ttf) format("opentype")}@font-face{font-family:Roboto Thin;src:url(/assets/pp-posters/fonts/Roboto-Thin.ttf) format("opentype")}@font-face{font-family:roobert;font-weight:400;src:url(/assets/pp-posters/fonts/roobert-regular.otf) format("opentype")}@font-face{font-family:roobert;font-weight:700;src:url(/assets/pp-posters/fonts/roobert-bold.otf) format("opentype")}@font-face{font-family:Sophia Ronald;src:url(/assets/pp-posters/fonts/SophiaRonald.ttf) format("opentype")}@font-face{font-family:Hello October;src:url(/assets/pp-posters/fonts/Hello_October.otf) format("opentype")}@font-face{font-family:SignatureFont;src:url(/assets/pp-posters/fonts/SignatureFont.otf) format("opentype")}@font-face{font-family:EBGaramond-Bold;src:url(/assets/pp-posters/fonts/EBGaramond-Bold.ttf) format("opentype")}@font-face{font-family:EBGaramond-SemiBold;src:url(/assets/pp-posters/fonts/EBGaramond-SemiBold.ttf) format("opentype")}@font-face{font-family:EBGaramond-Regular;src:url(/assets/pp-posters/fonts/EBGaramond-Regular.ttf) format("opentype")}@font-face{font-family:Montserrat-ExtraBold;src:url(/assets/pp-posters/fonts/Montserrat-ExtraBold.ttf) format("opentype")}@font-face{font-family:Montserrat-Medium;src:url(/assets/pp-posters/fonts/Montserrat-Medium.ttf) format("opentype")}@font-face{font-family:Montserrat-Thin;src:url(/assets/pp-posters/fonts/Montserrat-Thin.ttf) format("opentype")}@font-face{font-family:Montserrat-Light;src:url(/assets/pp-posters/fonts/Montserrat-Light.ttf) format("opentype")}@font-face{font-family:Montserrat-ExtraBold;src:url(/assets/pp-posters/fonts/Montserrat-ExtraBold.ttf) format("opentype")}@font-face{font-family:Montserrat-Medium;src:url(/assets/pp-posters/fonts/Montserrat-Medium.ttf) format("opentype")}@font-face{font-family:Montserrat-Thin;src:url(/assets/pp-posters/fonts/Montserrat-Thin.ttf) format("opentype")}@font-face{font-family:AbrilFatface-Regular;src:url(/assets/pp-posters/fonts/AbrilFatface-Regular.ttf) format("opentype")}@font-face{font-family:MenloRegular;src:url(/assets/pp-posters/fonts/MenloRegular.ttf) format("opentype")}@font-face{font-family:MenloBoldItalic;src:url(/assets/pp-posters/fonts/MenloBoldItalic.ttf) format("opentype")}[_nghost-%COMP%]{width:100%;height:100%;display:block}[_nghost-%COMP%]   .image-area[_ngcontent-%COMP%]{display:flex;width:100%;height:100%;justify-content:center}[_nghost-%COMP%]   .contour-instance[_ngcontent-%COMP%]{box-sizing:border-box;position:relative}[_nghost-%COMP%]   .marker-instance-wrapper[_ngcontent-%COMP%]{position:absolute}[_nghost-%COMP%]   .marker-instance[_ngcontent-%COMP%]{position:absolute}[_nghost-%COMP%]   svg-icon.marker[_ngcontent-%COMP%]{position:absolute;top:0;left:0}[_nghost-%COMP%]   svg-icon.marker[_ngcontent-%COMP%]   svg[_ngcontent-%COMP%]{display:block;cursor:pointer}[_nghost-%COMP%]   svg-icon.marker.interactive[_ngcontent-%COMP%]   svg[_ngcontent-%COMP%]{cursor:move}[_nghost-%COMP%]   .sign[_ngcontent-%COMP%]{display:flex;width:100%;justify-content:center}']
            }),
            Do
        }
        )();
        function $t(bt, Do) {
            if (1 & bt) {
                const Xt = r.RV6();
                r.j41(0, "pp-poster-contour-full-page", 2),
                r.nI1(1, "async"),
                r.bIt("openMarkerPopup", function(we) {
                    r.eBV(Xt);
                    const Oe = r.XpG(4);
                    return r.Njj(Oe.openMarkerPopup.emit(we))
                })("setMarkerPosition", function(we) {
                    r.eBV(Xt);
                    const Oe = r.XpG(4);
                    return r.Njj(Oe.setMarkerPosition.emit(we))
                })("markerDraggingInProgress", function(we) {
                    r.eBV(Xt);
                    const Oe = r.XpG(4);
                    return r.Njj(Oe.markerDraggingInProgress.emit(we))
                }),
                r.k0s()
            }
            if (2 & bt) {
                const Xt = r.XpG(2)
                  , ie = r.XpG()
                  , we = r.XpG();
                r.Y8G("isFinalPoster", we.isFinalPoster)("isInteractive", we.isInteractive)("printingRegistration", Xt)("defaultConfiguration", r.bMT(1, 5, we.defaultConfiguration$))("posterConfig", ie)
            }
        }
        function Nt(bt, Do) {
            if (1 & bt) {
                const Xt = r.RV6();
                r.j41(0, "pp-poster-contour-passepartout", 3),
                r.nI1(1, "async"),
                r.bIt("openMarkerPopup", function(we) {
                    r.eBV(Xt);
                    const Oe = r.XpG(4);
                    return r.Njj(Oe.openMarkerPopup.emit(we))
                })("setMarkerPosition", function(we) {
                    r.eBV(Xt);
                    const Oe = r.XpG(4);
                    return r.Njj(Oe.setMarkerPosition.emit(we))
                })("markerDraggingInProgress", function(we) {
                    r.eBV(Xt);
                    const Oe = r.XpG(4);
                    return r.Njj(Oe.markerDraggingInProgress.emit(we))
                }),
                r.k0s()
            }
            if (2 & bt) {
                const Xt = r.XpG(2)
                  , ie = r.XpG()
                  , we = r.XpG();
                r.Y8G("isFinalPoster", we.isFinalPoster)("isInteractive", we.isInteractive)("printingRegistration", Xt)("posterConfig", ie)("defaultConfiguration", r.bMT(1, 5, we.defaultConfiguration$))
            }
        }
        function Vt(bt, Do) {
            if (1 & bt && r.DNE(0, $t, 2, 7, "pp-poster-contour-full-page", 0)(1, Nt, 2, 7, "pp-poster-contour-passepartout", 1),
            2 & bt) {
                const Xt = r.XpG(2)
                  , ie = r.XpG();
                r.vxM(Xt.layout === ie.ContourLayouts.FULL_PAGE ? 0 : 1)
            }
        }
        function _o(bt, Do) {
            if (1 & bt && r.DNE(0, Vt, 2, 1),
            2 & bt) {
                const Xt = r.XpG();
                r.vxM(Xt && Do ? 0 : -1)
            }
        }
        function Lo(bt, Do) {
            if (1 & bt && (r.DNE(0, _o, 1, 1),
            r.nI1(1, "async")),
            2 & bt) {
                let Xt;
                const ie = r.XpG();
                r.vxM((Xt = r.bMT(1, 1, ie._printingRegistration$)) ? 0 : -1, Xt)
            }
        }
        let ao = ( () => {
            var bt;
            class Do extends Wt.C {
                constructor() {
                    super(...arguments),
                    this.openMarkerPopup = new r.bkB,
                    this.setMarkerPosition = new r.bkB,
                    this.markerDraggingInProgress = new r.bkB,
                    this.ContourLayouts = s.C65
                }
                setAllTextSettings(ie, we) {}
                setDesign(ie, we, Oe) {
                    return (0,
                    Ut.A)(function*() {})()
                }
                setTextArea(ie, we) {}
            }
            return (bt = Do).\u0275fac = ( () => {
                let Xt;
                return function(we) {
                    return (Xt || (Xt = r.xGo(bt)))(we || bt)
                }
            }
            )(),
            bt.\u0275cmp = r.VBU({
                type: bt,
                selectors: [["pp-poster-contour"]],
                outputs: {
                    openMarkerPopup: "openMarkerPopup",
                    setMarkerPosition: "setMarkerPosition",
                    markerDraggingInProgress: "markerDraggingInProgress"
                },
                features: [r.Vt3],
                decls: 2,
                vars: 3,
                consts: [[3, "isFinalPoster", "isInteractive", "printingRegistration", "defaultConfiguration", "posterConfig"], [3, "isFinalPoster", "isInteractive", "printingRegistration", "posterConfig", "defaultConfiguration"], [3, "openMarkerPopup", "setMarkerPosition", "markerDraggingInProgress", "isFinalPoster", "isInteractive", "printingRegistration", "defaultConfiguration", "posterConfig"], [3, "openMarkerPopup", "setMarkerPosition", "markerDraggingInProgress", "isFinalPoster", "isInteractive", "printingRegistration", "posterConfig", "defaultConfiguration"]],
                template: function(ie, we) {
                    if (1 & ie && (r.DNE(0, Lo, 2, 3),
                    r.nI1(1, "async")),
                    2 & ie) {
                        let Oe;
                        r.vxM((Oe = r.bMT(1, 1, we.posterConfiguration$)) ? 0 : -1, Oe)
                    }
                },
                dependencies: [Mt.MD, Mt.Jj, so.iu, _t.q1, Ae.h, Jt, tt],
                encapsulation: 2
            }),
            Do
        }
        )()
    }
    ,
    2745: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            G: () => Wt
        });
        var Ut = $(60177)
          , r = $(54438);
        const Mt = [[["", "first", ""]], [["", "second", ""]], [["", "third", ""]]]
          , s = ["[first]", "[second]", "[third]"];
        function so(_t, Ae) {
            if (1 & _t && (r.j41(0, "div", 3),
            r.SdG(1, 2),
            r.k0s()),
            2 & _t) {
                const Me = r.XpG();
                r.xc7("margin-left", Me.spaceBetween, "px")("width", Me.thirdCustomWidth ? Me.thirdCustomWidth : Me.isTriple ? 33.333 : 50, "%")
            }
        }
        let Wt = ( () => {
            var _t;
            class Ae {
                constructor() {
                    this.isTriple = !1,
                    this.isRestricted = !0,
                    this.spaceBetween = 0
                }
            }
            return (_t = Ae).\u0275fac = function(ct) {
                return new (ct || _t)
            }
            ,
            _t.\u0275cmp = r.VBU({
                type: _t,
                selectors: [["pp-poster-space-splitter"]],
                inputs: {
                    isTriple: "isTriple",
                    isRestricted: "isRestricted",
                    spaceBetween: "spaceBetween",
                    firstCustomWidth: "firstCustomWidth",
                    secondCustomWidth: "secondCustomWidth",
                    thirdCustomWidth: "thirdCustomWidth"
                },
                ngContentSelectors: s,
                decls: 6,
                vars: 17,
                consts: [[1, "splitter-first"], [1, "splitter-second"], ["class", "splitter-third", 3, "margin-left", "width", 4, "ngIf"], [1, "splitter-third"]],
                template: function(ct, Tt) {
                    1 & ct && (r.NAR(Mt),
                    r.j41(0, "div")(1, "div", 0),
                    r.SdG(2),
                    r.k0s(),
                    r.j41(3, "div", 1),
                    r.SdG(4, 1),
                    r.k0s(),
                    r.DNE(5, so, 2, 4, "div", 2),
                    r.k0s()),
                    2 & ct && (r.AVh("double-splitter", !Tt.isTriple)("triple-splitter", Tt.isTriple)("restrictedSize", Tt.isRestricted),
                    r.R7$(),
                    r.xc7("margin-right", Tt.spaceBetween, "px")("width", Tt.firstCustomWidth ? Tt.firstCustomWidth : Tt.isTriple ? 33.333 : 50, "%"),
                    r.R7$(2),
                    r.xc7("margin-left", Tt.spaceBetween, "px")("margin-right", Tt.isTriple ? Tt.spaceBetween : 0, "px")("width", Tt.secondCustomWidth ? Tt.secondCustomWidth : Tt.isTriple ? 33.333 : 50, "%"),
                    r.R7$(2),
                    r.Y8G("ngIf", Tt.isTriple))
                },
                dependencies: [Ut.MD, Ut.bT],
                styles: ["[_nghost-%COMP%]   .double-splitter[_ngcontent-%COMP%]{width:100%;height:100%;display:flex;justify-content:space-between}[_nghost-%COMP%]   .double-splitter.restrictedSize[_ngcontent-%COMP%]   .splitter-first[_ngcontent-%COMP%], [_nghost-%COMP%]   .double-splitter.restrictedSize[_ngcontent-%COMP%]   .splitter-second[_ngcontent-%COMP%]{position:relative}[_nghost-%COMP%]   .triple-splitter[_ngcontent-%COMP%]{width:100%;height:100%;display:flex;justify-content:space-between}[_nghost-%COMP%]   .triple-splitter.restrictedSize[_ngcontent-%COMP%]   .splitter-first[_ngcontent-%COMP%], [_nghost-%COMP%]   .triple-splitter.restrictedSize[_ngcontent-%COMP%]   .splitter-second[_ngcontent-%COMP%], [_nghost-%COMP%]   .triple-splitter.restrictedSize[_ngcontent-%COMP%]   .splitter-third[_ngcontent-%COMP%]{position:relative}"]
            }),
            Ae
        }
        )()
    }
    ,
    5116: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            Gj: () => Mt,
            Jr: () => r,
            t2: () => Ut
        });
        const Ut = (Me, ct, Tt=!1) => {
            for (let Qe = -3; Qe <= 12; Qe++) {
                const jt = Me.getElementsByClassName("StarMag-".concat(Qe));
                for (let Xe = 0; Xe < jt.length; Xe++) {
                    const Ce = Tt ? 2 : _t(Qe, ct);
                    jt[Xe].setAttribute("r", Ce + "px")
                }
            }
            return Me
        }
          , r = Me => {
            const ct = Me.getElementsByClassName("planets");
            for (let Qe = 0; Qe < ct.length; Qe++) {
                const Xe = ct[Qe].classList.value.replace("planets ", "")
                  , Ce = Ae(Xe);
                ct[Qe].setAttribute("r", Ce + "px"),
                ct[Qe].setAttribute("ppr:id", Ce.toString())
            }
            const Tt = Array.prototype.slice.call(ct);
            Tt.sort( (Qe, jt) => {
                const Xe = parseFloat(Qe.getAttribute("ppr:id"));
                return parseFloat(jt.getAttribute("ppr:id")) - Xe
            }
            );
            for (let Qe = 0, jt = Tt.length; Qe < jt; Qe++) {
                const Xe = Tt[Qe].parentNode
                  , Ce = Xe.removeChild(Tt[Qe]);
                Xe.appendChild(Ce)
            }
            return Me
        }
          , Mt = Me => {
            const ct = Me.querySelector("#background");
            if (!ct)
                return;
            const Tt = ct.getBBox()
              , Qe = .92 * (Tt.width / 2 + Tt.x)
              , jt = Tt.width / 2 + Tt.x;
            ct.remove();
            const Xe = Me.querySelector("#planetNames").childNodes
              , Ce = Me.querySelector("#constNames").childNodes;
            return s(Xe, jt, Qe).forEach(it => {
                Xe[it].remove()
            }
            ),
            s(Ce, jt, Qe).forEach(it => {
                Ce[it].remove()
            }
            ),
            Me
        }
          , s = (Me, ct, Tt) => {
            const Qe = [];
            for (let jt = 0; jt < Me.length; jt++) {
                const Xe = Me[jt]
                  , Ce = Xe.getBBox();
                let it = Xe.getAttribute("transform");
                const et = {
                    name: Xe.innerHTML,
                    x: Ce.x,
                    y: Ce.y,
                    width: Ce.width,
                    height: Ce.height
                };
                if (it) {
                    it = it.replace("translate(", "").replace(")", "");
                    const re = it.split(",");
                    re && re.length > 0 && (re[0] && "number" == typeof parseFloat(re[0]) && (et.x += parseFloat(re[0])),
                    re[1] && "number" == typeof parseFloat(re[1]) && (et.y += parseFloat(re[1])))
                }
                so(et, ct, ct, Tt) && Qe.push(jt)
            }
            return _.reverse(Qe)
        }
          , so = (Me, ct, Tt, Qe) => {
            const jt = !Wt(Me.x + Me.width, Me.y, ct, Tt, Qe)
              , Xe = !Wt(Me.x + Me.width, Me.y + Me.height, ct, Tt, Qe)
              , Ce = !Wt(Me.x, Me.y + Me.height, ct, Tt, Qe)
              , it = !Wt(Me.x, Me.y, ct, Tt, Qe);
            return jt || Xe || Ce || it
        }
          , Wt = (Me, ct, Tt, Qe, jt) => (Me - Tt) * (Me - Tt) + (ct - Qe) * (ct - Qe) <= jt * jt
          , _t = (Me, ct) => {
            let Tt = 0;
            switch (Me) {
            case -3:
                Tt = 12;
                break;
            case -2:
                Tt = 11.5;
                break;
            case -1:
                Tt = 11;
                break;
            case 0:
                Tt = 10.2;
                break;
            case 1:
                Tt = 9.6;
                break;
            case 2:
                Tt = 8.4;
                break;
            case 3:
                Tt = 7.5;
                break;
            case 4:
                Tt = 6.6;
                break;
            case 5:
                Tt = 5.7;
                break;
            case 6:
                Tt = 4.8;
                break;
            case 7:
                Tt = 3.9;
                break;
            case 8:
                Tt = 3;
                break;
            case 9:
                Tt = 2.4;
                break;
            case 10:
                Tt = 1.5;
                break;
            case 11:
                Tt = 1.25;
                break;
            case 12:
                Tt = 1
            }
            return ct || (Tt *= 1.2),
            ct && Tt < 1.2 ? Tt *= 1 : ct && Tt < 3 ? Tt *= 2 : ct && Tt < 5 ? Tt *= 1.75 : ct && Tt < 7.5 ? Tt *= 1.25 : ct && Tt < 10 && (Tt *= 1.1),
            .24 * Tt
        }
          , Ae = Me => {
            let ct = 0;
            switch (Me) {
            case "mer":
                ct = 5;
                break;
            case "ven":
                ct = 9;
                break;
            case "mar":
            case "ura":
                ct = 8;
                break;
            case "jup":
                ct = 14;
                break;
            case "sat":
                ct = 10;
                break;
            case "nep":
                ct = 7;
                break;
            case "sol":
                ct = 16;
                break;
            case "lun":
                ct = 1
            }
            return ct / 2 / 1.7 * .8055
        }
    }
    ,
    5829: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            F: () => po
        });
        var Ut = $(10467)
          , r = $(54438)
          , Mt = $(7494)
          , s = $(9566)
          , so = $(13620)
          , Wt = $(61762)
          , _t = $(69847)
          , Ae = $(60177)
          , Me = $(27617)
          , ct = $(15996)
          , Tt = $(50552)
          , Qe = $(74412)
          , jt = $(84572)
          , Xe = $(56977)
          , Ce = $(49427)
          , it = $(41046)
          , et = $(2745)
          , re = $(84412)
          , pt = $(70152)
          , Be = $(73955)
          , ze = $(66985);
        const ye = (Et, Kt, At, Re) => ({
            title$: Et,
            footer$: Kt,
            photo$: At,
            moonElement: Re,
            moonId: 0
        })
          , ge = (Et, Kt, At, Re) => ({
            title$: Et,
            footer$: Kt,
            photo$: At,
            moonElement: Re,
            moonId: 1
        })
          , Ie = () => [".jpeg", ".jpg", ".png", ".heic"];
        function gt(Et, Kt) {
            if (1 & Et && (r.j41(0, "pp-poster-space-splitter", 8),
            r.eu8(1, 9)(2, 10),
            r.k0s()),
            2 & Et) {
                const At = r.XpG().ngIf
                  , Re = r.XpG(2)
                  , ve = r.sdS(5);
                r.xc7("width", At.width, "px")("height", At.height, "px")("margin-top", At.marginTop, "px"),
                r.Y8G("isRestricted", Re.moon.layout !== Re.MoonShapesEnum.DOUBLE_WITH_PHOTO),
                r.R7$(),
                r.Y8G("ngTemplateOutlet", ve)("ngTemplateOutletContext", r.ziG(11, ye, Re.title1$, Re.footer1$, Re.photo1$, Re.moonElement1)),
                r.R7$(),
                r.Y8G("ngTemplateOutlet", ve)("ngTemplateOutletContext", r.ziG(16, ge, Re.title2$, Re.footer2$, Re.photo2$, Re.moonElement2))
            }
        }
        function Ye(Et, Kt) {
            if (1 & Et && (r.qex(0),
            r.DNE(1, gt, 3, 21, "pp-poster-space-splitter", 7),
            r.bVm()),
            2 & Et) {
                const At = Kt.ngIf;
                r.R7$(),
                r.Y8G("ngIf", At.width && At.height)
            }
        }
        function yt(Et, Kt) {
            if (1 & Et) {
                const At = r.RV6();
                r.j41(0, "pp-poster-printing-registration", 5)(1, "pp-poster-arrangement-wrapper")(2, "pp-poster-text-area", 6),
                r.nI1(3, "async"),
                r.nI1(4, "async"),
                r.nI1(5, "async"),
                r.nI1(6, "async"),
                r.nI1(7, "async"),
                r.bIt("textareaHeightCallback", function(ve) {
                    r.eBV(At);
                    const ne = r.XpG();
                    return r.Njj(ne.newTopTextareaHeight(ve))
                })("textareaWidthCallback", function(ve) {
                    r.eBV(At);
                    const ne = r.XpG();
                    return r.Njj(ne.newTopTextareaWidth(ve))
                }),
                r.k0s(),
                r.DNE(8, Ye, 2, 1, "ng-container", 4),
                r.nI1(9, "async"),
                r.k0s()()
            }
            if (2 & Et) {
                const At = Kt.ngIf
                  , Re = r.XpG();
                r.Y8G("poster", At),
                r.R7$(2),
                r.Y8G("poster", r.bMT(3, 7, Re.poster$))("color", r.bMT(4, 9, Re.textColor$))("textArea", r.bMT(5, 11, Re.topTextArea$))("title", r.bMT(6, 13, Re.title$))("subtitle", Re.moon.layout === Re.MoonShapesEnum.DOUBLE_WITH_PHOTO ? void 0 : r.bMT(7, 15, Re.subtitle$)),
                r.R7$(6),
                r.Y8G("ngIf", r.bMT(9, 17, Re.splitElementsSize$))
            }
        }
        function ht(Et, Kt) {
            if (1 & Et) {
                const At = r.RV6();
                r.j41(0, "pp-poster-image-area", 15)(1, "img", 17),
                r.bIt("load", function() {
                    r.eBV(At);
                    const ve = r.XpG(3);
                    return r.Njj(ve.onImageLoad())
                }),
                r.k0s(),
                r.nrm(2, "pp-poster-preview", 18),
                r.k0s()
            }
            if (2 & Et) {
                const At = r.XpG(2).moonElement
                  , Re = r.XpG();
                r.Y8G("relative", !0),
                r.R7$(),
                r.xc7("margin-top", Re.moon.margin, "px")("width", Re.moon.width, "px")("height", Re.moon.width, "px")("transform", "rotate(" + At.rotation + "deg)"),
                r.Y8G("src", At.image, r.B4B),
                r.R7$(),
                r.Y8G("showPreview", !Re.isFinalPoster)("marginTop", !1)("previewType", "moon")
            }
        }
        function mo(Et, Kt) {
            if (1 & Et) {
                const At = r.RV6();
                r.j41(0, "img", 21),
                r.bIt("load", function() {
                    r.eBV(At);
                    const ve = r.XpG(4);
                    return r.Njj(ve.onImageLoad())
                })("click", function() {
                    r.eBV(At);
                    const ve = r.XpG(4);
                    return r.Njj(ve.onPhotoSelect())
                }),
                r.k0s()
            }
            if (2 & Et) {
                const At = r.XpG(2).ngIf
                  , Re = r.XpG(2);
                r.Y8G("src", Re.getPhotoWithType(At).imageUrl, r.B4B)
            }
        }
        function no(Et, Kt) {
            if (1 & Et) {
                const At = r.RV6();
                r.j41(0, "pp-controls-file-uploader-photo", 22),
                r.nI1(1, "translate"),
                r.bIt("setFileUploadingProgress", function(ve) {
                    r.eBV(At);
                    const ne = r.XpG(4);
                    return r.Njj(ne.setFileUpploadingProgress.emit(ve))
                }),
                r.k0s()
            }
            if (2 & Et) {
                const At = r.XpG(4);
                r.Y8G("photoFileGroup", At.photoFileGroup)("photoCropGroup", At.photoCropGroup)("photoId", At.photoId)("multiFile", At.multiFile)("isSubmitted", !1)("acceptable", r.lJ4(14, Ie))("isBase64Response", !0)("fullHeight", !0)("isBigPictureMode", !0)("withBackgroundGray", !0)("isFileUploadingInProgress", At.isFileUploadingInProgress)("legalNote", r.bMT(1, 12, "soundwave.details.instruction"))
            }
        }
        function Co(Et, Kt) {
            if (1 & Et && (r.j41(0, "div", 16),
            r.DNE(1, mo, 1, 1, "img", 19)(2, no, 2, 15, "pp-controls-file-uploader-photo", 20),
            r.k0s()),
            2 & Et) {
                const At = r.XpG().ngIf
                  , Re = r.XpG(2);
                r.R7$(),
                r.Y8G("ngIf", !Re.getPhotoWithType(At).showAddPhoto),
                r.R7$(),
                r.Y8G("ngIf", Re.photoFileGroup && Re.getPhotoWithType(At).showAddPhoto)
            }
        }
        function Lt(Et, Kt) {
            if (1 & Et && (r.j41(0, "div", 14),
            r.DNE(1, ht, 3, 13, "pp-poster-image-area", 15)(2, Co, 3, 2, "div", 16),
            r.k0s()),
            2 & Et) {
                const At = r.XpG().moonId
                  , Re = r.XpG();
                r.xc7("width", Re.moon.height, "px")("height", Re.moon.height, "px"),
                r.R7$(),
                r.vxM(Re.moon.layout !== Re.MoonShapesEnum.DOUBLE_WITH_PHOTO || Re.moon.layout === Re.MoonShapesEnum.DOUBLE_WITH_PHOTO && 0 === At ? 1 : 2)
            }
        }
        function Ft(Et, Kt) {
            if (1 & Et && (r.nrm(0, "pp-poster-text-area", 23),
            r.nI1(1, "async"),
            r.nI1(2, "async"),
            r.nI1(3, "async"),
            r.nI1(4, "async"),
            r.nI1(5, "async")),
            2 & Et) {
                const At = r.XpG()
                  , Re = At.title$
                  , ve = At.footer$
                  , ne = r.XpG();
                r.Y8G("poster", r.bMT(1, 5, ne.poster$))("color", r.bMT(2, 7, ne.textColor$))("textArea", r.bMT(3, 9, ne.textArea$))("title", r.bMT(4, 11, ne.moon.layout !== ne.MoonShapesEnum.DOUBLE_WITH_PHOTO ? Re : ne.subtitle$))("footer", r.bMT(5, 13, ve))
            }
        }
        function co(Et, Kt) {
            if (1 & Et && (r.j41(0, "pp-poster-image-area")(1, "div", 11),
            r.DNE(2, Lt, 3, 5, "div", 12),
            r.nI1(3, "async"),
            r.k0s()(),
            r.DNE(4, Ft, 6, 15, "pp-poster-text-area", 13),
            r.nI1(5, "async")),
            2 & Et) {
                const At = Kt.photo$
                  , Re = r.XpG();
                r.R7$(),
                r.xc7("margin-top", Re.moon.marginTop, "px")("width", Re.moon.width, "px")("height", Re.moon.height, "px"),
                r.R7$(),
                r.Y8G("ngIf", r.bMT(3, 8, At)),
                r.R7$(2),
                r.Y8G("ngIf", Re.moon.layout !== Re.MoonShapesEnum.DOUBLE_WITH_PHOTO || Re.moon.layout === Re.MoonShapesEnum.DOUBLE_WITH_PHOTO && !Re.getPhotoWithType(r.bMT(5, 10, At)).isPhoto)
            }
        }
        function Jt(Et, Kt) {
            1 & Et && r.nrm(0, "pp-poster-loaded-element")
        }
        let po = ( () => {
            var Et;
            class Kt extends Tt.C {
                constructor(Re, ve, ne) {
                    super(Re, ve),
                    this.host = Re,
                    this.zone = ve,
                    this.cdr = ne,
                    this.photoId = 0,
                    this.multiFile = !1,
                    this.photoSelect = new r.bkB,
                    this.setFileUpploadingProgress = new r.bkB,
                    this.isFileUploadingInProgress = !1,
                    this.MoonShapesEnum = Me.HmI,
                    this.topTextAreaHeight$ = new re.t(null),
                    this.topTextAreaWidth$ = new re.t(null),
                    this.title1$ = new re.t(null),
                    this.footer1$ = new re.t(null),
                    this.photo1$ = new re.t(null),
                    this.title2$ = new re.t(null),
                    this.footer2$ = new re.t(null),
                    this.photo2$ = new re.t(null),
                    this.splitElementsSize$ = new re.t({
                        width: 0,
                        height: 0,
                        marginTop: 0
                    }),
                    this.moon = {
                        marginTop: 0,
                        width: 0,
                        height: 0,
                        padding: 0,
                        margin: 0,
                        background: "#FFF",
                        layout: Me.HmI.DOUBLE,
                        punchingDiePadding: 0,
                        punchingDieLineSize: 0
                    },
                    this.moonElement1 = {
                        image: "",
                        rotation: 0
                    },
                    this.moonElement2 = {
                        image: "",
                        rotation: 0
                    }
                }
                ngAfterViewInit() {
                    (0,
                    jt.z)([this.poster$, this.topTextArea$, this.topTextAreaHeight$, this.topTextAreaWidth$, this.posterConfiguration$]).pipe((0,
                    Xe.Q)(this.ngUnsubscribe), (0,
                    pt.B)(100)).subscribe( ([Re,ve,ne,B,de]) => {
                        var lt, St;
                        if (!Re)
                            return;
                        ne || (ne = 0),
                        B || (B = 0);
                        const tt = null !== (lt = Re.size.height) && void 0 !== lt ? lt : 0;
                        let $t = Re.size.height - (ne + (null !== (St = ve.topFactor) && void 0 !== St ? St : 0) * tt)
                          , Nt = 0;
                        !(null != de && de.title) && null != de && de.subtitle && (Nt = .02 * Re.size.height,
                        $t -= 2 * Nt),
                        null != de && de.title && !(null != de && de.subtitle) && (null == de ? void 0 : de.layout) === Me.HmI.DOUBLE_WITH_PHOTO && ($t -= .06 * Re.size.height),
                        ((null == de || !de.title) && (null == de || !de.subtitle) || !de.mainTextEnable) && (Nt = .044 * Re.size.height,
                        $t -= 2 * Nt);
                        let Vt = null != B ? B : 0;
                        (null == de ? void 0 : de.layout) === Me.HmI.DOUBLE_WITH_PHOTO && (Vt *= 1.055),
                        null != de && de.mainTextEnable && null != de && de.title && null != de && de.titleFont && ($t *= .98),
                        null != de && de.mainTextEnable && null != de && de.subtitle && null != de && de.subtitleFont && ($t *= .97),
                        this.isWideRatio(Re, !0) && ($t *= 1.02),
                        this.isNarrowRatio(Re) && ($t *= .95),
                        this.splitElementsSize$.next({
                            width: Vt,
                            height: $t,
                            marginTop: Nt
                        })
                    }
                    )
                }
                isNarrowRatio(Re) {
                    return Re.size.height / Re.size.width >= .8
                }
                setAllTextSettings(Re) {
                    const ve = Re.moonConfig[0]
                      , ne = Re.moonConfig[1]
                      , B = Re.layout === Me.HmI.DOUBLE_WITH_PHOTO
                      , de = {
                        text: Re.mainTextEnable ? Re.title : "",
                        isDefaultFont: !Re.titleFont
                    }
                      , lt = {
                        text: Re.mainTextEnable ? Re.subtitle : "",
                        isDefaultFont: !Re.subtitleFont
                    }
                      , St = null != de && de.isDefaultFont ? .045 : .08;
                    this.setText(de, this.title$, {
                        font: null != de && de.isDefaultFont ? Me.n3q.CAPSUULA_BOLD : Me.n3q.POSITIVE_PRINTS_SCRIPT_2,
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: St,
                            bottomFactor: 0,
                            lineHeightFactor: St * (null != de && de.isDefaultFont ? 1.8 : 1.35),
                            topFactor: (lt.text ? 0 : .015) + (null != de && de.isDefaultFont ? .01 : 0),
                            isBold: !1
                        }
                    });
                    const tt = B ? null != lt && lt.isDefaultFont ? .036 : .052 : .032;
                    this.setText(lt, this.subtitle$, {
                        font: B ? null != lt && lt.isDefaultFont ? Me.n3q.CAPSUULA : Me.n3q.POSITIVE_PRINTS_SCRIPT_2 : Me.n3q.CAPSUULA,
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: tt,
                            bottomFactor: 0,
                            lineHeightFactor: tt * (B ? 1.34 : 1.25),
                            maxLines: 3,
                            heightLines: B ? 3 : void 0,
                            topFactor: B ? 0 : de.text ? -.01 : .025,
                            isBold: !1,
                            startFromMiddle: B
                        }
                    });
                    const $t = {
                        text: ve.title,
                        isDefaultFont: !ve.titleFontScript,
                        showEmptyLine: !0
                    }
                      , Nt = {
                        text: ne.title,
                        isDefaultFont: !ne.titleFontScript,
                        showEmptyLine: !0
                    }
                      , Vt = ao => ({
                        font: null != ao && ao.isDefaultFont ? Me.n3q.CAPSUULA_BOLD : Me.n3q.POSITIVE_PRINTS_SCRIPT_2,
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: null != ao && ao.isDefaultFont ? .036 : .052,
                            bottomFactor: 0,
                            lineHeightFactor: .058 * 1.34,
                            topFactor: 0,
                            maxLines: 1,
                            isBold: !1
                        }
                    });
                    this.setText($t, this.title1$, Vt($t)),
                    this.setText(Nt, this.title2$, Vt(Nt));
                    const Lo = {
                        font: Me.n3q.CAPSUULA,
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: .018,
                            bottomFactor: 0,
                            lineHeightFactor: .018 * 1.22,
                            heightLines: 2,
                            startFromBottom: !1,
                            topFactor: B ? 0 : .008
                        }
                    };
                    this.setText({
                        text: ve.footer,
                        isDefaultFont: !0,
                        showEmptyLine: !0
                    }, this.footer1$, Lo),
                    this.setText({
                        text: ne.footer,
                        isDefaultFont: !0,
                        showEmptyLine: !0
                    }, this.footer2$, Lo)
                }
                setTextArea(Re, ve) {
                    this.topTextArea$.next({
                        topFactor: this.isWideRatio(Re, !1) ? .04 : .07,
                        marginFactor: .09
                    });
                    let ne = .058
                      , B = .013;
                    (null == ve ? void 0 : ve.layout) === Me.HmI.DOUBLE_WITH_PHOTO && (ne *= .75,
                    B = .09),
                    this.textArea$.next({
                        bottomFactor: ne,
                        marginFactor: B
                    })
                }
                setDesign(Re, ve) {
                    var ne = this;
                    return (0,
                    Ut.A)(function*() {
                        const B = (lt, St) => {
                            var tt;
                            lt.selectedByDate ? (St.image = "/assets/pp-posters/moon/".concat(ne.isFinalPoster ? "_HQ_/" : "", "moon_").concat(ve.shadowMoon ? "shadow" : "transparent", "/").concat(lt.moon, ".png"),
                            St.rotation = lt.moonRotation) : (St.image = "/assets/pp-posters/moon/".concat(ne.isFinalPoster ? "_HQ_/" : "", "moon_selected_").concat(ve.shadowMoon ? "shadow" : "transparent", "/").concat(lt.selectPhase, ".png"),
                            null !== (tt = lt.place) && void 0 !== tt && null !== (tt = tt.center) && void 0 !== tt && tt.latitude && (St.rotation = lt.place.center.latitude > 0 ? 0 : 180))
                        }
                        ;
                        B(ve.moonConfig[0], ne.moonElement1),
                        B(ve.moonConfig[1], ne.moonElement2),
                        ne.setSizes(Re, ve),
                        ne.moon.layout = ve.layout,
                        ne.moon.background = (0,
                        Qe.G)(ve.style, ne.isFinalPoster, ve.customBackground, "landscape"),
                        ne.photo1$.next({
                            isPhoto: !1,
                            uuid: "",
                            imageUrl: "",
                            showAddPhoto: !1
                        });
                        const de = ve.moonConfig[1];
                        ne.photo2$.next({
                            isPhoto: (null == ve ? void 0 : ve.layout) === Me.HmI.DOUBLE_WITH_PHOTO,
                            uuid: de.photoFiles[0].uuid,
                            imageUrl: "".concat(ne.environmentPhotoApi, "/v2/").concat(ne.isFinalPoster ? "photo" : "image", "/").concat(de.photoFiles[0].uuid, "?type=").concat(de.cropsData[0].filter, "&left=").concat(de.cropsData[0].cropData.x, "&top=").concat(de.cropsData[0].cropData.y, "&width=").concat(de.cropsData[0].cropData.width, "&height=").concat(de.cropsData[0].cropData.height, "&rotate=").concat(de.cropsData[0].rotate, "&flipped=").concat(de.cropsData[0].flip),
                            showAddPhoto: !de.photoFiles[0].uuid
                        }),
                        ne.textColor$.next(ne.getTextColor(ve.style, ve.customBackground))
                    })()
                }
                setSizes(Re, ve) {
                    this.moon.width = .82 * Re.size.width / 2,
                    this.moon.height = this.moon.width,
                    this.imageInstanceSize = {
                        width: this.moon.width,
                        height: this.moon.width
                    },
                    this.moon.padding = .01 * this.moon.width,
                    (null == ve ? void 0 : ve.layout) === Me.HmI.DOUBLE_WITH_PHOTO ? (this.moon.punchingDieLineSize = .015 * this.moon.width,
                    this.moon.punchingDiePadding = .005 * this.moon.width) : (this.moon.punchingDieLineSize = .059 * this.moon.width,
                    this.moon.punchingDiePadding = .055 * this.moon.width)
                }
                getPhotoWithType(Re) {
                    return Re
                }
                onPhotoSelect() {
                    this.photoSelect.emit([this.imageInstanceSize.width, this.imageInstanceSize.height])
                }
                onImageLoad() {
                    this.load++,
                    2 === this.load && (this.initiateRender(),
                    this.cdr.detectChanges())
                }
                newTopTextareaHeight(Re) {
                    this.topTextAreaHeight$.next(Re)
                }
                newTopTextareaWidth(Re) {
                    this.topTextAreaWidth$.next(Re)
                }
                getTextColor(Re, ve) {
                    return Re === Me.O8Z.CUSTOM ? (0,
                    ct.V)(ve) ? "#FFF" : "#000" : Re === Me.O8Z.MARSHMALLOW ? "#666666" : [Me.O8Z.WHITE, Me.O8Z.CREAM].includes(Re) ? "#000" : "#FFF"
                }
            }
            return (Et = Kt).\u0275fac = function(Re) {
                return new (Re || Et)(r.rXU(r.aKT),r.rXU(r.SKi),r.rXU(r.gRc))
            }
            ,
            Et.\u0275cmp = r.VBU({
                type: Et,
                selectors: [["pp-poster-moon-double"]],
                inputs: {
                    photoFileGroup: "photoFileGroup",
                    photoCropGroup: "photoCropGroup",
                    photoId: "photoId",
                    multiFile: "multiFile",
                    environmentPhotoApi: "environmentPhotoApi",
                    isFileUploadingInProgress: "isFileUploadingInProgress"
                },
                outputs: {
                    photoSelect: "photoSelect",
                    setFileUpploadingProgress: "setFileUpploadingProgress"
                },
                features: [r.Vt3],
                decls: 7,
                vars: 5,
                consts: [["posterWrapper", ""], ["singleElement", ""], [3, "background"], [3, "poster", 4, "ngIf"], [4, "ngIf"], [3, "poster"], [3, "textareaHeightCallback", "textareaWidthCallback", "poster", "color", "textArea", "title", "subtitle"], [3, "width", "height", "marginTop", "isRestricted", 4, "ngIf"], [3, "isRestricted"], ["first", "", 3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["second", "", 3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "moon-instance"], ["class", "moon-area", 3, "width", "height", 4, "ngIf"], [3, "poster", "color", "textArea", "title", "footer", 4, "ngIf"], [1, "moon-area"], [3, "relative"], [1, "photo-instance"], [1, "moon-image", 3, "load", "src"], [3, "showPreview", "marginTop", "previewType"], [3, "src", "load", "click", 4, "ngIf"], [3, "photoFileGroup", "photoCropGroup", "photoId", "multiFile", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "withBackgroundGray", "isFileUploadingInProgress", "legalNote", "setFileUploadingProgress", 4, "ngIf"], [3, "load", "click", "src"], [3, "setFileUploadingProgress", "photoFileGroup", "photoCropGroup", "photoId", "multiFile", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "withBackgroundGray", "isFileUploadingInProgress", "legalNote"], [3, "poster", "color", "textArea", "title", "footer"]],
                template: function(Re, ve) {
                    1 & Re && (r.j41(0, "pp-poster-background", 2, 0),
                    r.DNE(2, yt, 10, 19, "pp-poster-printing-registration", 3),
                    r.nI1(3, "async"),
                    r.k0s(),
                    r.DNE(4, co, 6, 12, "ng-template", null, 1, r.C5r)(6, Jt, 1, 0, "pp-poster-loaded-element", 4)),
                    2 & Re && (r.Y8G("background", ve.moon.background),
                    r.R7$(2),
                    r.Y8G("ngIf", r.bMT(3, 3, ve.poster$)),
                    r.R7$(4),
                    r.Y8G("ngIf", ve.isImageRendered))
                },
                dependencies: [Mt.Z, s.R, _t.c, so.y, Wt.W, Ae.MD, Ae.bT, Ae.T3, Ae.Jj, Ce.ex, it.C, et.G, Be.h, Be.D9, ze.P],
                styles: ["[_nghost-%COMP%]{width:100%;height:100%;display:block}[_nghost-%COMP%]   .moon-instance[_ngcontent-%COMP%]{box-sizing:border-box;position:relative;overflow:hidden}[_nghost-%COMP%]   .moon-instance[_ngcontent-%COMP%]   .moon-area[_ngcontent-%COMP%]{margin:auto;position:absolute;top:0;right:0;bottom:0;left:0}[_nghost-%COMP%]   .moon-instance[_ngcontent-%COMP%]   .moon-area[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:100%;height:100%;object-fit:cover;box-sizing:border-box}[_nghost-%COMP%]   .moon-instance[_ngcontent-%COMP%]   .moon-area[_ngcontent-%COMP%]   img.photo-instance[_ngcontent-%COMP%]{border-radius:50%;padding:5%}[_nghost-%COMP%]   .moon-instance[_ngcontent-%COMP%]   .moon-area[_ngcontent-%COMP%]   div.photo-instance[_ngcontent-%COMP%]{border-radius:50%;margin-top:5%;width:90%;height:90%;overflow:hidden}[_nghost-%COMP%]   .moon-instance[_ngcontent-%COMP%]   .moon-area[_ngcontent-%COMP%]   div.photo-instance[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{cursor:pointer}"]
            }),
            Kt
        }
        )()
    }
    ,
    7335: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            H: () => Ce
        });
        var Ut = $(27617);
        const Ce = it => {
            switch (it) {
            case Ut.sKi.HOME:
                return '\n      <svg xmlns="http://www.w3.org/2000/svg" width="35.908" height="30.522" viewBox="0 0 35.908 30.522">\n        // ___marker_color___\n        <path class="marker-fill" fill="#E53422" d="M30.5,18.1v13.1h-8.9v-9.3h-7.4v9.3H5.4V18.1L18,6.1L30.5,18.1z M18,3.9l-15,14.3c-1.6,1.6-4-0.9-2.4-2.5\n        L16.8,0.5c0.7-0.6,1.7-0.6,2.4,0l7.6,7.2V4.3c0-0.4,0.4-0.8,0.8-0.8h2.2c0.4,0,0.8,0.4,0.8,0.8v6.9l4.8,4.5c1.7,1.6-0.7,4.1-2.4,2.5\n        C28,13.4,23,8.7,18,3.9L18,3.9z"/>\n      </svg>\n    ';
            case Ut.sKi.HEART:
                return '\n      <svg xmlns="http://www.w3.org/2000/svg" width="35.908" height="32.946" viewBox="0 0 35.908 32.946">\n      // ___marker_color___\n        <path class="marker-fill" data-name="Path 515" d="M19.954,35.946l-2.6-2.37C8.1,25.191,2,19.661,2,12.875A9.779,\n        9.779,0,0,1,11.875,3a10.752,10.752,0,0,1,8.079,3.752A10.752,10.752,0,0,1,28.033,3a9.779,9.779,0,0,1,9.875,9.875c0,\n        6.787-6.1,12.316-15.351,20.719Z" transform="translate(-2 -3)"/>\n      </svg>\n    ';
            case Ut.sKi.SCHOOL:
                return '\n      <svg xmlns="http://www.w3.org/2000/svg" width="39.499" height="32.317" viewBox="0 0 39.499 32.317">\n      // ___marker_color___\n        <path class="marker-fill" data-name="Path 519" d="M8.182,21.277v7.182l12.568,6.858,12.568-6.858V21.277L20.749,\n        28.136ZM20.749,3,1,13.772,20.749,24.545l16.159-8.815V28.136H40.5V13.772Z" transform="translate(-1 -3)"/>\n      </svg>\n    ';
            case Ut.sKi.HEART_EMPTY:
                return '\n      <svg version="1.1" id="Warstwa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n      viewBox="0 0 38.91 36.47" style="enable-background:new 0 0 38.91 36.47;" xml:space="preserve" width="35.908" height="32.946">\n      // ___marker_color___\n        <path class="marker-stroke" d="M19.45,34.45l-2.6-2.37C7.6,23.69,1.5,18.16,1.5,11.38c-0.05-5.4,4.28-9.82,9.68-9.88\n          c0.06,0,0.13,0,0.19,0c3.11,0.02,6.06,1.39,8.08,3.75c2.02-2.36,4.97-3.73,8.08-3.75c5.4-0.05,9.82,4.28,9.87,9.68\n          c0,0.06,0,0.13,0,0.19c0,6.79-6.1,12.32-15.35,20.72L19.45,34.45z"/>\n      </svg>\n    ';
            case Ut.sKi.DOUBLE_HEART:
                return '\n      <svg version="1.1" id="Warstwa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n      viewBox="0 0 980.36 839.49" style="enable-background:new 0 0 980.36 839.49;" xml:space="preserve">\n      // ___marker_color___\n          <path class="marker-fill"  d="M979.64,451.35c-0.01,0.07-0.01,0.13-0.01,0.18c-0.28,3.18-0.63,6.34-1.18,9.47\n          c-3.85,21.56-9.11,42.72-16.64,63.39c-10.55,28.95-24.71,55.94-41.39,81.73c-16.55,25.6-35.68,49.24-56.6,71.29\n          c-15.18,15.99-31.19,31.3-47.82,45.76c-16.56,14.41-34.16,27.67-51.68,40.94c-32.03,24.28-66.11,45.38-101.59,64.24\n          c-6.74,3.58-13.33,7.42-19.99,11.14h-2c-3.63-2.05-7.27-4.06-10.88-6.14c-23.4-13.52-47.38-26.13-70.01-40.82\n          c-23.33-15.14-45.77-31.75-67.82-48.74c-16.93-13.06-32.92-27.39-48.8-41.75c-9.22-8.33-17.63-17.6-25.97-26.85\n          c-10.8-12-21.55-24.08-31.64-36.68c-18.49-23.08-34.47-47.88-47.67-74.34c-5.83-11.69-10.83-23.84-15.64-36\n          c-12.08-30.51-19.53-62.25-21.18-94.95c-1.56-30.85-0.66-61.72,7.7-91.92c7.09-25.63,18.1-49.28,35.46-69.43\n          c16.66-19.34,36.85-34.16,60.7-43.96c19.61-8.06,39.94-12.71,60.94-14.09c10.7-0.7,21.53,0.37,32.3,0.84\n          c15.82,0.68,31.09,4.27,46.14,8.99c22.48,7.04,43.05,17.82,60.8,33.23c15.89,13.79,28.83,30.1,35.93,50.71\n          c0.61-0.97,1.06-1.48,1.29-2.07c9.64-24.79,26.45-43.88,48.09-58.65c29.93-20.44,63.58-30.72,99.51-33.08\n          c21.13-1.39,42.15,0.47,62.82,5.79c36.54,9.42,67.09,28.34,90.15,58.14c14.79,19.12,24.65,40.34,30.66,63.03\n          C983.07,384.74,979.91,446.35,979.64,451.35z M682.59,194.67c-0.64-11.04-0.52-22.2-2.18-33.09c-2.22-14.66-4.97-29.35-9.02-43.6\n          c-7.14-25.14-20.19-47.23-38.17-66.26c-16.18-17.11-35.46-29.71-57.31-38.41c-11.07-4.42-22.36-7.83-33.93-10.02\n          c0,0-0.09-0.02-0.26-0.05c-0.19-0.04-0.38-0.07-0.57-0.11c-0.86-0.15-1.72-0.31-2.59-0.45c-0.31-0.05-0.64-0.11-0.99-0.16\n          c-0.28-0.05-0.56-0.09-0.84-0.13c-10.4-1.53-35.37-4.09-67.26,0.31c-15.99,2.38-31.53,6.61-46.24,13.4\n          c-11.84,5.47-23.43,11.83-34.25,19.1c-20.81,13.99-36.31,32.67-45.53,56.25c-0.23,0.6-0.68,1.11-0.94,1.53\n          c-4.2-7.56-8.07-15.42-12.74-22.76c-7.08-11.11-15.77-20.48-25.63-28.61c0,0-0.01-0.01-0.03-0.03c-4.88-4.01-10.04-7.73-15.44-11.2\n          c-0.07-0.05-0.14-0.09-0.22-0.14c-2.26-1.46-4.56-2.86-6.89-4.23c-20.18-11.82-42.03-18.81-64.8-23.18\n          c-3.66-0.7-7.37-1.07-11.1-1.37c-3.33-0.28-6.68-0.49-9.99-0.86c-0.25-0.03-0.51-0.07-0.76-0.13h-0.04\n          c-11.59-0.78-24.01-0.64-37.17,0.73c-1.06,0.15-2.12,0.29-3.18,0.4c-2.11,0.22-4.2,0.49-6.29,0.79c-0.05,0-0.09,0.01-0.14,0.02\n          c-14.73,2.14-28.98,6.19-42.66,12.1C85.34,23.18,67.25,34.92,52,50.87C40.55,62.84,31.26,76.11,23.95,90.6c0,0,0,0,0,0.01\n          c-0.01,0.01-0.01,0.01-0.02,0.02c-1.11,1.85-55.59,93.23,3.62,235.49c0.34,0.83,0.69,1.66,1.05,2.5c0.35,0.83,0.71,1.67,1.07,2.51\n          c0.72,1.67,1.46,3.36,2.22,5.05c10.79,24.06,24.24,46.83,39.64,68.64c19.83,28.08,41.78,54.26,66.97,77.63\n          c15.73,14.6,31.4,29.35,48.06,42.85c18.57,15.05,37.87,29.27,57.5,42.92c16.38,11.39,33.62,21.55,50.62,32.02\n          c6.89,4.25,14.15,7.88,21.24,11.79c-4.07-8.83-8.91-16.77-13.13-25.04c-16.03-31.44-28.45-64.25-36.12-98.76\n          c-4.71-21.2-7.61-42.69-7.97-64.41c-0.23-13.1,0.39-26.21,0.96-39.3c0.34-7.72,0.77-15.51,2.13-23.1\n          c3.27-18.32,7.21-36.49,13.8-54.01c8.87-23.56,21.18-45.16,37.74-63.98c19.79-22.51,43.5-40,71.14-52.13\n          c27.03-11.87,55.31-18.29,84.61-19.74c12.8-0.63,25.74,0.94,38.6,1.8c18.73,1.25,36.79,5.88,54.39,12.14\n          c28.43,10.12,54.46,24.4,76.12,45.81c2.32,2.29,3.59,2.07,6.12,0.07c10.03-7.9,20.03-15.93,30.71-22.89\n          C680.54,204.89,682.94,200.84,682.59,194.67z"/>\n      </svg>\n    ';
            case Ut.sKi.DOT:
                return '\n    <svg version="1.1" id="Warstwa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n           viewBox="0 0 24.9 24.9" style="enable-background:new 0 0 24.9 24.9;" xml:space="preserve">\n           // ___marker_color___\n        <path class="marker-fill" d="M12.4,24.9C5.6,24.9,0,19.3,0,12.4S5.6,0,12.4,0s12.4,5.6,12.4,12.4S19.3,24.9,12.4,24.9z M12.4,6.2\n      \tC9,6.2,6.2,9,6.2,12.4s2.8,6.2,6.2,6.2s6.2-2.8,6.2-6.2S15.9,6.2,12.4,6.2z"/>\n      </svg>\n    ';
            case Ut.sKi.HEART_MARKER:
                return '\n      <svg version="1.1" id="Warstwa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n           viewBox="0 0 867.2 839.5" style="enable-background:new 0 0 867.2 839.5;" xml:space="preserve">\n           // ___marker_color___\n      <path class="marker-fill" d="M835.1,119.7c-24.2-27.9-56.6-39.3-91.9-40.6c-8.2-2.8-17.8-3.6-28-1.6c-8.9,1.7-17.5,3.9-25.9,6.5\n          c-54.6,10.9-109.8,37.4-148.8,59.7c-41.1,23.6-77.1,51.5-107.1,82.6c-17.3-40.6-43.6-79.1-78.3-113.5\n          C299.2,57.4,200.1-15.1,95.8,2.8C40.3,12.2,16,46.7,8.9,85.5c-8.8,48-10.9,96.4-7,144.7c7.9,97,38.2,192.4,79.8,284.4\n          c47.8,105.7,109.9,207.5,172.4,308.8c18.9,30.5,73.2,13,76.6-14.8c10,1.7,20.6,0.9,28.7-3.7C551.3,695.6,704.2,553,799.4,388.2\n          C845,309.3,905.4,200.7,835.1,119.7z M540,289.6c29-30.7,59.6-60.6,92-89.4c6.3-5.6,12.6-11.3,19.2-16.9\n          c-55.6,105.9-147.4,200.6-217,302.5c-0.3-11.1-0.6-22.2-0.9-33.3c-0.2-8.9-4.6-15.8-11.2-20.7C457.6,382.9,496.8,335.3,540,289.6z\n           M188.1,152.6c0.5,0.4,0.8,0.8,1,1c7,7.2,13.7,14.6,20.3,22c3.9,4.4,7.7,8.9,11.5,13.4c-5.2,4.8-8.3,11.2-7.7,19\n          c2.4,31.9,4.5,63.7,6.5,95.5c-0.9-3.3-1.9-6.6-2.8-10c-11.5-41.4-24-82.8-28.9-125C187.6,164,187.9,158.3,188.1,152.6z M439.3,671.5\n          c0.2,0,0.4,0.1,0.5,0.1c-0.2,0.1-0.3,0.2-0.5,0.4C439.3,671.9,439.3,671.7,439.3,671.5z M491.1,559.4\n          c40.5-51.3,85.3-100.4,134.1-147.3C584.8,463,538.7,511.8,491.1,559.4z M782.4,212.7c-13-2.2-27.4-0.2-38.4,7.7\n          c-14.2,10.2-28.1,20.6-41.9,31.1c21.7-33.9,40.6-68.7,54.5-105.2c6.3,4.1,11.2,10,15.4,17.5C780.6,179.3,783.2,195.9,782.4,212.7z\n           M349.3,235.6c-20-33-43.6-64.7-70.6-94.9C309.6,169.1,333.3,201.3,349.3,235.6z M91.4,94.5c2.5-12.5,4-27.2,22.7-31.2\n          c14.8-3.2,33.7,0.8,48.1,5.1c-12.9,0.8-26,5.4-38.6,15.4c-38.3,30.2-20.3,86.7-13.5,122.8c19.6,103.5,54.5,206.1,83,308.5\n          c8,28.7,14.1,57.5,21,86.1C167,514.3,127,425.5,103.5,333.4C83.7,255.5,75.8,173.2,91.4,94.5z"/>\n      </svg>\n    ';
            case Ut.sKi.HEART_ARROW:
                return '\n      <svg version="1.1" id="Warstwa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n           viewBox="0 0 986.4 839.5" style="enable-background:new 0 0 986.4 839.5;" xml:space="preserve">\n           // ___marker_color___\n    <path class="marker-fill" d="M855.3,12.4L711.8,53.1l-23.8,6.8l17.5,17.5l29.3,29.3l-47.7,47c-25.7-14.1-54.8-21.8-83.3-21.8\n        c-52.4,0-101.5,23-137.4,63.6c-35.9-40.7-85.1-63.6-137.4-63.6c-21.7,0-42.9,4-63.2,12c-20.9,8.2-39.7,20.2-55.7,35.6\n        c-17,16.4-30.3,36.1-39.6,58.5c-9.9,24-14.9,50.7-14.9,79.5c0,68.2,44.5,146.7,132.3,233.3l-64.3,64.3l-39-14.9l-8.8-3.4l-6.7,6.6\n        L62.2,709.3l-15.9,15.8l20.9,8.1l56.8,22l20.2,57.8l7.5,21.5l16.3-15.9L276,713.7l6.6-6.4l-3-8.7l-13.4-39.3l66.4-66.4\n        c58.4,50.5,110.8,85.5,117.1,89.3l10.2,6.1l7.5,4.5l7.5-4.5l10.2-6.1l0.6-0.3l0.5-0.4c0.4-0.3,1.7-1.2,3.2-2.2\n        c73.3-50.5,125.2-96.9,155.9-126.9c38.7-37.8,69.4-74.7,91.3-109.5c27.6-43.9,41.6-85.4,41.6-123.3c0-28.7-4.9-55.3-14.4-79\n        c-7.1-17.5-16.7-33.6-28.8-47.8l43-43l29.4,29.4l17.3,17.3l6.9-23.5l41.7-142.5l7.4-25.3L855.3,12.4z M711.4,319.7\n        c0.2,26.1-10.2,56.1-31,89.2c-17.9,28.5-43.4,59.2-75.7,91.3c-56.1,55.7-116.2,99-138.3,114.2c-22.2-15.4-82.7-58.9-138.4-114\n        c-32.5-32.1-58-62.9-76-91.6c-21-33.4-31.6-63.8-31.6-90.4c0-37.5,11.9-68.9,34.3-90.9c9.9-9.7,21.6-17.3,34.7-22.4\n        c12.7-5,26-7.5,39.7-7.5c42.9,0,81.7,24,106.3,65.8c0.8,1.6,1.6,2.7,2.2,3.6c0.4,0.5,0.5,0.8,0.6,1l0,0.1l0.1,0.1l15.3,29.5l12.9,25\n        l12.9-25l15.3-29.5l0.1-0.1l0-0.1c0.3-0.5,0.7-1.4,1-2l0.6-0.6l0.9-1.5c12.5-20.8,28.2-37.1,46.5-48.4c18.2-11.2,38-16.8,59.1-16.8\n        c27.6,0,54.7,11,74.3,30.3c22.5,22.1,34.3,53.4,34.3,90.5L711.4,319.7L711.4,319.7z"/>\n      </svg>\n    ';
            case Ut.sKi.LOVE_HOUSE:
                return '\n<svg version="1.1" id="Warstwa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n\t viewBox="0 0 41.1 41.1" style="enable-background:new 0 0 41.1 41.1;" xml:space="preserve">\n\t // ___marker_color___\n<circle fill="#FFFFFF" cx="20.5" cy="20.6" r="20.5"/>\n<path class="marker-fill" d="M20,32.4c0.2,0.2,0.5,0.3,0.6,0.3h0c0.2,0,0.4,0,0.6-0.3l5.9-5.9c1.2-1.2,1.7-2.9,1.2-4.5\n\tc-0.4-1.7-1.7-2.9-3.3-3.3c-1.6-0.4-3.1,0-4.3,1c-0.9-0.8-2-1.1-3.1-1c-1.4-0.1-2.7,0.4-3.7,1.4c-0.9,0.9-1.3,2.1-1.2,3.3\n\tc0,1.2,0.5,2.4,1.4,3.2L20,32.4z M17.4,20.2c0.7,0,1.6,0.3,2.2,0.9l0.3,0.3c0.2,0.2,0.5,0.3,0.6,0.3s0.4,0,0.6-0.3l0.4-0.4\n\tc0.7-0.8,1.9-1.1,2.9-0.8c1,0.2,1.8,1.1,2.1,2.1c0.3,1.1,0,2.2-0.8,2.9l-5.3,5.3l-5.1-5.1c-0.5-0.5-0.9-1.3-0.9-2.1\n\tc0-0.9,0.3-1.6,0.9-2.1C15.8,20.6,16.6,20.2,17.4,20.2z M36.7,19.9l-1.4,1.4L20.5,6.5L5.7,21.3l-1.4-1.4L19.9,4.5\n\tc0.4-0.4,1-0.4,1.4,0l0.2,0.2l10.9,10.8l1,1.1L36.7,19.9z M32.2,19.9L21.1,8.8c-0.4-0.4-1-0.4-1.3,0l-10.9,11\n\tc-0.2,0.2-0.2,0.5-0.2,0.6v13.8c0,0.2,0.1,0.3,0.1,0.3v0.2l0.1,0.1C9.1,35,9.4,35,9.5,35h21.9c0.2,0,0.3-0.1,0.3-0.1l0.2,0\n\tc0.4-0.2,0.4-0.6,0.4-0.7V20.4c0-0.2-0.1-0.3-0.1-0.3V19.9z M20.5,10.7l10.1,10.1v12.5H10.4V20.8L20.5,10.7z M31.9,34.2L31.9,34.2\n\tL31.9,34.2L31.9,34.2z"/>\n</svg>\n    ';
            case Ut.sKi.GRADUATION_HAT:
                return '\n<svg version="1.1" id="Warstwa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n    viewBox="0 0 576 576" style="enable-background:new 0 0 576 576;" xml:space="preserve">\n    // ___marker_color___\n<path class="marker-fill" d="M295.37,376.38c-4.72,2.14-10.13,2.14-14.85,0l-172.55-77.41V396c0,40.95,92.71,63.01,180.01,63.01\n    S468,436.95,468,396v-97.03L295.37,376.38z M540,323.99v-67.14l12.69-5.67v0c3.21-1.46,5.27-4.66,5.27-8.19s-2.06-6.73-5.27-8.19\n    L291.67,117.79c-2.35-1.06-5.03-1.06-7.38,0L23.27,234.8c-3.21,1.46-5.27,4.66-5.27,8.19s2.06,6.73,5.27,8.19l261.02,117.01\n    c2.35,1.06,5.03,1.06,7.38,0L522,264.95v59.04c-4.77,0-9.35,1.9-12.73,5.27s-5.27,7.96-5.27,12.73v27c0,2.39,0.95,4.68,2.64,6.36\n    c1.69,1.69,3.98,2.64,6.36,2.64h36c2.39,0,4.68-0.95,6.36-2.64c1.69-1.69,2.64-3.98,2.64-6.36v-27c0-4.77-1.9-9.35-5.27-12.73\n    C549.35,325.89,544.77,323.99,540,323.99L540,323.99z"/>\n</svg>\n';
            case Ut.sKi.TROPHY:
                return '\n<svg version="1.1" id="Warstwa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n    viewBox="0 0 576 576" style="enable-background:new 0 0 576 576;" xml:space="preserve">\n    // ___marker_color___\n<path class="marker-fill" d="M557.95,75.54c0.4-4.99-1.33-9.93-4.72-13.61c-3.41-3.68-8.2-5.77-13.21-5.77h-72.69\n    c0.4-6.66,0.7-13.36,0.7-20.16c0-9.94-8.08-18-18.01-18H126c-9.94,0-18,8.06-18,18c0,6.8,0.27,13.5,0.69,20.16H36\n    c-5.02,0-9.8,2.08-13.21,5.77c-3.4,3.68-5.13,8.61-4.73,13.61c6.48,84.38,57.85,241.53,204.08,249.85\n    c20.24,29.74,38.87,59.82,38.87,84.12c0,74.45-102.04,112.72-103.08,112.96c-8.89,2.09-14.83,10.53-13.79,19.61\n    c1.05,9.07,8.72,15.93,17.87,15.93H414c0.14-0.01,0.26,0,0.38,0c9.95,0,18.01-8.04,18.01-18c0-9.1-6.74-16.59-15.45-17.81\n    C405.65,519.24,315,480.03,315,409.5c0-24.3,18.63-54.38,38.88-84.12C500.12,317.06,551.48,159.9,557.95,75.54L557.95,75.54z\n     M56.37,92.16h56.51c12.79,76.38,49.13,141.87,82.45,193.22C93.12,260.63,63.91,140.14,56.37,92.16L56.37,92.16z M519.65,92.16\n    c-7.57,47.98-36.78,168.47-138.99,193.22c33.33-51.35,69.65-116.84,82.43-193.22L519.65,92.16z"/>\n</svg>\n';
            default:
                return '\n<svg version="1.1" id="Warstwa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n    viewBox="0 0 576 576" style="enable-background:new 0 0 576 576;" xml:space="preserve">\n    // ___marker_color___\n<path class="marker-fill" d="M419.4,19.3H156.3c-74.7,0-135.2,60.5-135.2,135.2v263.1c0,74.6,60.5,135.2,135.2,135.2h263.1\n    c74.7,0,135.2-60.5,135.2-135.2V154.4C554.6,79.8,494.1,19.3,419.4,19.3z M414.4,267.4l-56.2,51.2c-1.7,1.6-3.3,5-1.7,8.3l13.2,74.3\n    c1.6,6.6-5,11.6-11.6,8.3l-66.1-36.3c-3.3-1.7-6.6-1.7-8.3,0l-66.1,36.3c-6.6,3.3-13.2-1.6-13.2-8.3l14.9-74.3c0-3.3,0-6.6-1.6-8.3\n    l-56.2-51.2c-5-5-1.7-14.9,5-14.9l74.3-9.9c3.3,0,6.6-1.7,6.6-5l33-67.7c3.3-6.6,11.6-6.6,14.9,0h0l31.4,67.7c1.7,3.3,5,5,6.6,5\n    l76,9.9C416,252.5,419.3,262.4,414.4,267.4z"/>\n</svg>\n\n'
            }
        }
    }
    ,
    7430: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            R: () => _t
        });
        var Ut = $(54438)
          , r = $(60177)
          , s = ($(27617),
        $(73955));
        const so = [[["", "slot", "front"]], [["", "slot", "back"]]]
          , Wt = ["[slot=front]", "[slot=back]"];
        let _t = ( () => {
            var Ae;
            class Me {
                constructor() {
                    this._showFront = !0,
                    this.hideSwitchers = !0,
                    this.showAvers = new Ut.bkB(!1)
                }
                set showFront(Tt) {
                    this._showFront = Tt
                }
                showCoinFront(Tt) {
                    this.showAvers.emit(Tt)
                }
            }
            return (Ae = Me).\u0275fac = function(Tt) {
                return new (Tt || Ae)
            }
            ,
            Ae.\u0275cmp = Ut.VBU({
                type: Ae,
                selectors: [["pp-poster-jewelry-area"]],
                inputs: {
                    material: "material",
                    setup: "setup",
                    hideSwitchers: "hideSwitchers",
                    showFront: "showFront"
                },
                outputs: {
                    showAvers: "showAvers"
                },
                ngContentSelectors: Wt,
                decls: 12,
                vars: 29,
                consts: [[1, "switcher"], [1, "button", 3, "click"]],
                template: function(Tt, Qe) {
                    1 & Tt && (Ut.NAR(so),
                    Ut.j41(0, "div", 0)(1, "div", 1),
                    Ut.bIt("click", function() {
                        return Qe.showCoinFront(!0)
                    }),
                    Ut.EFF(2),
                    Ut.nI1(3, "translate"),
                    Ut.k0s(),
                    Ut.j41(4, "div", 1),
                    Ut.bIt("click", function() {
                        return Qe.showCoinFront(!1)
                    }),
                    Ut.EFF(5),
                    Ut.nI1(6, "translate"),
                    Ut.k0s()(),
                    Ut.j41(7, "div")(8, "div"),
                    Ut.SdG(9),
                    Ut.k0s(),
                    Ut.j41(10, "div"),
                    Ut.SdG(11, 1),
                    Ut.k0s()()),
                    2 & Tt && (Ut.xc7("visibility", Qe.hideSwitchers ? "hidden" : "visible"),
                    Ut.R7$(),
                    Ut.AVh("active", Qe._showFront),
                    Ut.R7$(),
                    Ut.SpI(" ", Ut.bMT(3, 25, "jewelry.front"), " "),
                    Ut.R7$(2),
                    Ut.AVh("active", !Qe._showFront),
                    Ut.R7$(),
                    Ut.SpI(" ", Ut.bMT(6, 27, "jewelry.back"), " "),
                    Ut.R7$(2),
                    Ut.ZvI("jewelry-background bg-setup-", Qe.setup, ""),
                    Ut.R7$(),
                    Ut.ZvI("jewelry-background-inn setup-", Qe.setup, ""),
                    Ut.xc7("background-image", "url('/assets/pp-posters/jewelry/" + Qe.setup + "/" + Qe.material + "-front.png')"),
                    Ut.AVh("side-is-hidden", !Qe._showFront),
                    Ut.R7$(2),
                    Ut.ZvI("jewelry-background-inn setup-", Qe.setup, ""),
                    Ut.xc7("background-image", "url('/assets/pp-posters/jewelry/" + Qe.setup + "/" + Qe.material + "-back.png')"),
                    Ut.AVh("side-is-hidden", Qe._showFront))
                },
                dependencies: [r.MD, s.h, s.D9],
                styles: ["[_nghost-%COMP%]{width:100%;height:100%;position:relative}[_nghost-%COMP%]   .switcher[_ngcontent-%COMP%]{position:absolute;bottom:0%;left:0;right:0;display:flex;justify-content:center;gap:20%}[_nghost-%COMP%]   .switcher[_ngcontent-%COMP%]   .button[_ngcontent-%COMP%]{display:flex;justify-content:center;text-align:center;align-items:center;padding:16px 28px;box-sizing:border-box;border-radius:44px;font-family:roobert,Arial,sans-serif;font-size:1.25em;margin:10px 0;cursor:pointer;-webkit-user-select:none;user-select:none;border:1px solid #f77147;background:transparent;color:#f77147}[_nghost-%COMP%]   .switcher[_ngcontent-%COMP%]   .button.active[_ngcontent-%COMP%]{background:#f77147;color:#fff}[_nghost-%COMP%]   .jewelry-background[_ngcontent-%COMP%]{position:absolute;aspect-ratio:1/1}[_nghost-%COMP%]   .jewelry-background.bg-setup-charm[_ngcontent-%COMP%]{top:5%;left:10%;width:80%}[_nghost-%COMP%]   .jewelry-background.bg-setup-charm-with-chain[_ngcontent-%COMP%]{top:3%;left:8%;width:84%}[_nghost-%COMP%]   .jewelry-background.bg-setup-black-cord-bracelet[_ngcontent-%COMP%], [_nghost-%COMP%]   .jewelry-background.bg-setup-silver-bracelet[_ngcontent-%COMP%]{top:-5%;left:0;width:100%}[_nghost-%COMP%]   .jewelry-background[_ngcontent-%COMP%]   .jewelry-background-inn[_ngcontent-%COMP%]{position:absolute;width:100%;height:100%;top:0;right:0;bottom:0;left:0;background-repeat:no-repeat;background-size:contain;background-position:center;overflow:hidden}[_nghost-%COMP%]   .jewelry-background[_ngcontent-%COMP%]   .jewelry-background-inn.side-is-hidden[_ngcontent-%COMP%]{transform:translate(-1000%,-1000%)}[_nghost-%COMP%]   .jewelry-background[_ngcontent-%COMP%]   .jewelry-background-inn[_ngcontent-%COMP%]     .front-center, [_nghost-%COMP%]   .jewelry-background[_ngcontent-%COMP%]   .jewelry-background-inn[_ngcontent-%COMP%]     .back-center{aspect-ratio:1/1;position:absolute;top:0;left:0}[_nghost-%COMP%]   .jewelry-background[_ngcontent-%COMP%]   .jewelry-background-inn[_ngcontent-%COMP%]     .front-center svg-icon, [_nghost-%COMP%]   .jewelry-background[_ngcontent-%COMP%]   .jewelry-background-inn[_ngcontent-%COMP%]     .back-center svg-icon{display:block;overflow:hidden}[_nghost-%COMP%]   .jewelry-background[_ngcontent-%COMP%]   .jewelry-background-inn[_ngcontent-%COMP%]     .front-center svg-icon   .pp-printing-wrapper, [_nghost-%COMP%]   .jewelry-background[_ngcontent-%COMP%]   .jewelry-background-inn[_ngcontent-%COMP%]     .back-center svg-icon   .pp-printing-wrapper{display:none}[_nghost-%COMP%]   .jewelry-background[_ngcontent-%COMP%]   .jewelry-background-inn[_ngcontent-%COMP%]     .front-center .example-information{position:absolute;line-height:1.1em;font-size:1.3em;text-align:center;padding:4px;transform:rotate(346.8deg);top:0;bottom:0;left:0;right:0;display:flex;justify-content:center;align-items:center}@media (max-width: 510px){[_nghost-%COMP%]   .jewelry-background[_ngcontent-%COMP%]   .jewelry-background-inn[_ngcontent-%COMP%]     .front-center .example-information{font-size:1.2em}}@media (max-width: 450px){[_nghost-%COMP%]   .jewelry-background[_ngcontent-%COMP%]   .jewelry-background-inn[_ngcontent-%COMP%]     .front-center .example-information{font-size:1.1em}}[_nghost-%COMP%]   .jewelry-background[_ngcontent-%COMP%]   .jewelry-background-inn.setup-charm[_ngcontent-%COMP%]     .front-center, [_nghost-%COMP%]   .jewelry-background[_ngcontent-%COMP%]   .jewelry-background-inn.setup-charm[_ngcontent-%COMP%]     .back-center{width:84%;margin-left:7.9%;margin-top:16.2%}[_nghost-%COMP%]   .jewelry-background[_ngcontent-%COMP%]   .jewelry-background-inn.setup-charm-with-chain[_ngcontent-%COMP%]     .front-center, [_nghost-%COMP%]   .jewelry-background[_ngcontent-%COMP%]   .jewelry-background-inn.setup-charm-with-chain[_ngcontent-%COMP%]     .back-center{width:73.6%;margin-left:13%;margin-top:25.4%}[_nghost-%COMP%]   .jewelry-background[_ngcontent-%COMP%]   .jewelry-background-inn.setup-black-cord-bracelet[_ngcontent-%COMP%]     .front-center, [_nghost-%COMP%]   .jewelry-background[_ngcontent-%COMP%]   .jewelry-background-inn.setup-black-cord-bracelet[_ngcontent-%COMP%]     .back-center, [_nghost-%COMP%]   .jewelry-background[_ngcontent-%COMP%]   .jewelry-background-inn.setup-silver-bracelet[_ngcontent-%COMP%]     .front-center, [_nghost-%COMP%]   .jewelry-background[_ngcontent-%COMP%]   .jewelry-background-inn.setup-silver-bracelet[_ngcontent-%COMP%]     .back-center{width:66.4%;margin-left:17.5%;margin-top:20.6%}"]
            }),
            Me
        }
        )()
    }
    ,
    8427: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            h: () => yt
        });
        var Ut = $(10467)
          , r = $(54438)
          , Mt = $(9566)
          , s = $(60177)
          , so = $(27617)
          , Wt = $(78606)
          , _t = $(50552)
          , Ae = $(21626)
          , Me = $(54843)
          , ct = $(96354)
          , Tt = $(1875)
          , Qe = $(81572)
          , jt = $(7430)
          , Xe = $(73955)
          , Ce = $(76675);
        const it = ["svgContour"]
          , et = ["svgJewelryContour"]
          , re = ht => ({
            fill: ht,
            stroke: "none"
        })
          , pt = ht => ({
            fill: ht,
            stroke: "transparent"
        })
          , Be = (ht, mo) => ({
            x: ht,
            y: mo
        })
          , ze = (ht, mo, no) => ({
            fill: ht,
            width: mo,
            height: no
        });
        function ye(ht, mo) {
            1 & ht && r.eu8(0)
        }
        function ge(ht, mo) {
            if (1 & ht) {
                const no = r.RV6();
                r.j41(0, "svg-icon", 14),
                r.bIt("cdkDragStarted", function() {
                    r.eBV(no);
                    const Lt = r.XpG(2);
                    return r.Njj(Lt.dragStart())
                })("cdkDragEnded", function(Lt) {
                    r.eBV(no);
                    const Ft = r.XpG(2);
                    return r.Njj(Ft.dragEnd(Lt))
                })("click", function() {
                    r.eBV(no);
                    const Lt = r.XpG(2);
                    return r.Njj(Lt.isInteractive ? void 0 : Lt.openMarkerPopup.emit())
                }),
                r.k0s()
            }
            if (2 & ht) {
                const no = r.XpG(2);
                r.AVh("interactive", no.isInteractive),
                r.Y8G("cdkDragDisabled", !no.isInteractive)("cdkDragFreeDragPosition", r.l_i(6, Be, no.markerWrapper.width * no.contourJewelry.markerPositionX, no.markerWrapper.height * no.contourJewelry.markerPositionY))("svgStyle", r.sMw(9, ze, no.contourJewelry.svgMarkerStyle.fill, no.contourJewelry.svgMarkerStyle.width + "px", no.contourJewelry.svgMarkerStyle.height + "px"))("src", no.contourJewelry.markerUrl)
            }
        }
        function Ie(ht, mo) {
            if (1 & ht && (r.j41(0, "div", 11)(1, "div", 12),
            r.DNE(2, ge, 1, 13, "svg-icon", 13),
            r.k0s()()),
            2 & ht) {
                const no = r.XpG();
                r.xc7("width", no.markerWrapper.width, "px")("height", no.markerWrapper.height, "px")("left", no.markerWrapper.left, "px")("top", no.markerWrapper.top, "px"),
                r.R7$(),
                r.xc7("width", no.markerWrapper.width, "px")("height", no.markerWrapper.height, "px")("left", 0, "px")("top", 0, "px"),
                r.R7$(),
                r.Y8G("ngIf", no.contourJewelry.isMarkerEnabled)
            }
        }
        let yt = ( () => {
            var ht;
            class mo extends _t.C {
                constructor(Co, Lt, Ft, co) {
                    super(Co, Lt),
                    this.host = Co,
                    this.zone = Lt,
                    this.httpClient = Ft,
                    this.cdr = co,
                    this.hideSwitchers = !1,
                    this.showFrontOnInit = !0,
                    this.openMarkerPopup = new r.bkB,
                    this.setMarkerPosition = new r.bkB,
                    this.markerDraggingInProgress = new r.bkB,
                    this.showAvers = new r.bkB(!1),
                    this.markerWrapper = {
                        width: 0,
                        height: 0,
                        left: 0,
                        top: 0
                    },
                    this.contourJewelry = {
                        contourUrl: "",
                        textUrl: "",
                        titleFontSize: "1px",
                        material: so.Xl7.na,
                        setup: so.Hyl.charm,
                        color: "transparent",
                        markerUrl: "",
                        markerPositionX: 0,
                        markerPositionY: 0,
                        isMarkerEnabled: !1,
                        svgMarkerStyle: {
                            fill: "red",
                            width: 24,
                            height: 24
                        }
                    },
                    this.uuid = 0,
                    this.previousJewelryContour = null,
                    this.uuid = (new Date).getTime()
                }
                setJewelry(Co, Lt, Ft) {
                    var co = this;
                    return (0,
                    Ut.A)(function*() {
                        var Jt, po, Et;
                        if (co.previousJewelryContour !== (null !== (Jt = Lt.contourId) && void 0 !== Jt ? Jt : null == Ft ? void 0 : Ft.contourId))
                            try {
                                var Kt, At;
                                co.contourJewelry.contourUrl = null !== (Kt = yield(0,
                                Me._)(yield co.httpClient.get((ht => "".concat(window.location.origin, "/api/files-management/").concat(ht, "/").concat(so.Iwg.jewelry, "?editor=").concat(so.hb4.contour))(null !== (At = Lt.contourId) && void 0 !== At ? At : null == Ft ? void 0 : Ft.contourId)).pipe((0,
                                ct.T)(Re => (0,
                                Ce.ID)("image/svg+xml", Re.image))))) && void 0 !== Kt ? Kt : ""
                            } catch {
                                co.contourJewelry.contourUrl = "/assets/pp-posters/contour/fallback_contour.svg"
                            }
                        co.contourJewelry.textUrl = null !== (po = yield(0,
                        Me._)(yield co.httpClient.post("".concat(window.location.origin, "/api/contour/jewelry/text"), {
                            title: Lt.customMessage ? Lt.title : "",
                            titleFontScript: Lt.titleFontScript,
                            footer: Lt.customMessage ? Lt.footer : ""
                        }).pipe((0,
                        ct.T)(Re => (0,
                        Ce.ID)("image/svg+xml", Re.image))))) && void 0 !== po ? po : "",
                        co.contourJewelry.material = Lt.material,
                        co.contourJewelry.setup = Lt.setup,
                        co.contourJewelry.color = Ce.fd[Lt.material],
                        co.previousJewelryContour = null !== (Et = Lt.contourId) && void 0 !== Et ? Et : null == Ft ? void 0 : Ft.contourId,
                        co.setMarkerConfig(Co, Lt),
                        co.onResize()
                    })()
                }
                setAllTextSettings(Co, Lt) {}
                setDesign(Co, Lt, Ft) {
                    return Promise.resolve(void 0)
                }
                setTextArea(Co, Lt) {}
                ngAfterViewInit() {}
                setMarkerConfig(Co, Lt) {
                    this.contourJewelry.isMarkerEnabled = Lt.showMarker,
                    this.contourJewelry.markerPositionX = Lt.markerPosition.x,
                    this.contourJewelry.markerPositionY = Lt.markerPosition.y,
                    this.contourJewelry.markerUrl = "/assets/pp-posters/contour/markers/".concat(this.isJewelry ? "jewelry" : "poster", "/").concat(so.sKi[Lt.shapeMarker].toLowerCase(), ".svg");
                    const Ft = () => {
                        var co;
                        return .08 * (null !== (co = this.markerWrapper.width) && void 0 !== co ? co : 0)
                    }
                    ;
                    setTimeout( () => {
                        this.contourJewelry.svgMarkerStyle = {
                            fill: Ce.fd[Lt.material],
                            width: Ft(),
                            height: Ft()
                        }
                    }
                    )
                }
                onResize() {
                    setTimeout( () => {
                        this.cdr.detectChanges(),
                        setTimeout( () => {
                            this.svgLoaded(),
                            setTimeout( () => {
                                this.cdr.detectChanges()
                            }
                            )
                        }
                        )
                    }
                    )
                }
                svgLoaded() {
                    var Co, Lt;
                    const Ft = null === (Co = this.svgJewelryContour) || void 0 === Co || null === (Co = Co.element) || void 0 === Co || null === (Co = Co.nativeElement) || void 0 === Co ? void 0 : Co.tagName;
                    if (!Ft)
                        return;
                    const Jt = this.host.nativeElement.getElementsByTagName(Ft)[0].getElementsByClassName("jewelry-positive-prints")[0]
                      , po = null == Jt ? void 0 : Jt.getBoundingClientRect()
                      , Et = null === (Lt = this.svgJewelryContour) || void 0 === Lt || null === (Lt = Lt.element) || void 0 === Lt || null === (Lt = Lt.nativeElement) || void 0 === Lt || null === (Lt = Lt.getElementsByTagName("svg")[0]) || void 0 === Lt ? void 0 : Lt.getBoundingClientRect();
                    po && Et ? this.markerWrapper = {
                        left: 0,
                        top: 0,
                        width: Et.width,
                        height: Et.height
                    } : po || console.warn("This file doesn't have a correct group or single path approach")
                }
                dragStart() {
                    this.markerDraggingInProgress.emit(!0)
                }
                dragEnd(Co) {
                    var Lt, Ft;
                    const co = null !== (Lt = this.markerWrapper.width) && void 0 !== Lt ? Lt : 0
                      , Jt = null !== (Ft = this.markerWrapper.height) && void 0 !== Ft ? Ft : 0;
                    if (Jt && co) {
                        const {x: po, y: Et} = Co.source.getFreeDragPosition();
                        this.setMarkerPosition.emit({
                            x: po / co,
                            y: Et / Jt
                        })
                    }
                    this.markerDraggingInProgress.emit(!1)
                }
                isDataLoaded() {
                    console.log("isDataLoaded")
                }
            }
            return (ht = mo).\u0275fac = function(Co) {
                return new (Co || ht)(r.rXU(r.aKT),r.rXU(r.SKi),r.rXU(Ae.Qq),r.rXU(r.gRc))
            }
            ,
            ht.\u0275cmp = r.VBU({
                type: ht,
                selectors: [["pp-jewelry-contour"]],
                viewQuery: function(Co, Lt) {
                    if (1 & Co && (r.GBs(it, 5),
                    r.GBs(et, 5)),
                    2 & Co) {
                        let Ft;
                        r.mGM(Ft = r.lsd()) && (Lt.svgContour = Ft.first),
                        r.mGM(Ft = r.lsd()) && (Lt.svgJewelryContour = Ft.first)
                    }
                },
                inputs: {
                    hideSwitchers: "hideSwitchers",
                    showFrontOnInit: "showFrontOnInit"
                },
                outputs: {
                    openMarkerPopup: "openMarkerPopup",
                    setMarkerPosition: "setMarkerPosition",
                    markerDraggingInProgress: "markerDraggingInProgress",
                    showAvers: "showAvers"
                },
                features: [r.Vt3],
                decls: 12,
                vars: 14,
                consts: [["svgJewelryContour", ""], ["marker", ""], [3, "background"], [3, "showAvers", "material", "setup", "hideSwitchers", "showFront"], ["slot", "front"], [1, "front-center"], ["ppPosterResizeObserver", "", 3, "resizeCallback", "src", "svgStyle"], [4, "ngTemplateOutlet"], ["slot", "back"], [1, "back-center"], [3, "src", "svgStyle"], [1, "marker-instance-wrapper"], [1, "marker-instance"], ["class", "marker", "cdkDrag", "", "cdkDragBoundary", ".marker-instance-wrapper", 3, "interactive", "cdkDragDisabled", "cdkDragFreeDragPosition", "svgStyle", "src", "cdkDragStarted", "cdkDragEnded", "click", 4, "ngIf"], ["cdkDrag", "", "cdkDragBoundary", ".marker-instance-wrapper", 1, "marker", 3, "cdkDragStarted", "cdkDragEnded", "click", "cdkDragDisabled", "cdkDragFreeDragPosition", "svgStyle", "src"]],
                template: function(Co, Lt) {
                    if (1 & Co) {
                        const Ft = r.RV6();
                        r.j41(0, "pp-poster-background", 2)(1, "pp-poster-jewelry-area", 3),
                        r.bIt("showAvers", function(Jt) {
                            return r.eBV(Ft),
                            r.Njj(Lt.showAvers.emit(Jt))
                        }),
                        r.j41(2, "div", 4)(3, "div", 5)(4, "svg-icon", 6, 0),
                        r.bIt("resizeCallback", function() {
                            return r.eBV(Ft),
                            r.Njj(Lt.onResize())
                        }),
                        r.k0s(),
                        r.DNE(6, ye, 1, 0, "ng-container", 7),
                        r.k0s()(),
                        r.j41(7, "div", 8)(8, "div", 9),
                        r.nrm(9, "svg-icon", 10),
                        r.k0s()()()(),
                        r.DNE(10, Ie, 3, 17, "ng-template", null, 1, r.C5r)
                    }
                    if (2 & Co) {
                        const Ft = r.sdS(11);
                        r.Y8G("background", "transparent"),
                        r.R7$(),
                        r.Y8G("material", Lt.contourJewelry.material)("setup", Lt.contourJewelry.setup)("hideSwitchers", Lt.hideSwitchers)("showFront", Lt.showFrontOnInit),
                        r.R7$(3),
                        r.Y8G("src", Lt.contourJewelry.contourUrl)("svgStyle", r.eq3(10, re, Lt.contourJewelry.color)),
                        r.R7$(2),
                        r.Y8G("ngTemplateOutlet", Ft),
                        r.R7$(3),
                        r.Y8G("src", Lt.contourJewelry.textUrl)("svgStyle", r.eq3(12, pt, Lt.contourJewelry.color))
                    }
                },
                dependencies: [s.MD, s.bT, s.T3, Mt.R, Wt.iu, Wt.DM, Ae.q1, Qe.h, Tt.T1, jt.R, Xe.h],
                styles: ['@font-face{font-family:Leander Script Pro;font-weight:700;src:url(/assets/pp-posters/fonts/leanderscriptpro-bold.otf) format("opentype")}@font-face{font-family:Leander Script Pro;src:url(/assets/pp-posters/fonts/leanderscriptpro-regular.otf) format("opentype")}@font-face{font-family:Madina Script;src:url(/assets/pp-posters/fonts/Madina-Script.otf) format("opentype")}@font-face{font-family:Proxima Nova;font-weight:700;src:url(/assets/pp-posters/fonts/proximanova-bold.otf) format("opentype")}@font-face{font-family:SourceCodePro-Regular;src:url(/assets/pp-posters/fonts/SourceCodePro-Regular.ttf) format("truetype")}@font-face{font-family:Proxima Nova;src:url(/assets/pp-posters/fonts/proximanova-regular.otf) format("opentype")}@font-face{font-family:Macho;font-weight:700;src:url(/assets/pp-posters/fonts/Macho-Medium.woff) format("opentype")}@font-face{font-family:Macho;src:url(/assets/pp-posters/fonts/Macho-Regular.woff) format("opentype")}@font-face{font-family:Capsuula;src:url(/assets/pp-posters/fonts/Capsuula.ttf) format("truetype")}@font-face{font-family:Capsuula Bold;src:url(/assets/pp-posters/fonts/Capsuula-bold.ttf) format("truetype")}@font-face{font-family:YesevaOne;src:url(/assets/pp-posters/fonts/YesevaOne-Regular.ttf)}@font-face{font-family:LuxusBrut;src:url(/assets/pp-posters/fonts/LuxusBrut.otf) format("opentype")}@font-face{font-family:PositivePrintsScript2;src:url(/assets/pp-posters/fonts/positive-prints-script-2.otf) format("opentype")}@font-face{font-family:PositivePrintsScript;src:url(/assets/pp-posters/fonts/PositivePrintsScript.ttf) format("opentype")}@font-face{font-family:Dejavu Sans;src:url(/assets/pp-posters/fonts/DejaVuSans.ttf) format("opentype")}@font-face{font-family:Roboto Thin;src:url(/assets/pp-posters/fonts/Roboto-Thin.ttf) format("opentype")}@font-face{font-family:roobert;font-weight:400;src:url(/assets/pp-posters/fonts/roobert-regular.otf) format("opentype")}@font-face{font-family:roobert;font-weight:700;src:url(/assets/pp-posters/fonts/roobert-bold.otf) format("opentype")}@font-face{font-family:Sophia Ronald;src:url(/assets/pp-posters/fonts/SophiaRonald.ttf) format("opentype")}@font-face{font-family:Hello October;src:url(/assets/pp-posters/fonts/Hello_October.otf) format("opentype")}@font-face{font-family:SignatureFont;src:url(/assets/pp-posters/fonts/SignatureFont.otf) format("opentype")}@font-face{font-family:EBGaramond-Bold;src:url(/assets/pp-posters/fonts/EBGaramond-Bold.ttf) format("opentype")}@font-face{font-family:EBGaramond-SemiBold;src:url(/assets/pp-posters/fonts/EBGaramond-SemiBold.ttf) format("opentype")}@font-face{font-family:EBGaramond-Regular;src:url(/assets/pp-posters/fonts/EBGaramond-Regular.ttf) format("opentype")}@font-face{font-family:Montserrat-ExtraBold;src:url(/assets/pp-posters/fonts/Montserrat-ExtraBold.ttf) format("opentype")}@font-face{font-family:Montserrat-Medium;src:url(/assets/pp-posters/fonts/Montserrat-Medium.ttf) format("opentype")}@font-face{font-family:Montserrat-Thin;src:url(/assets/pp-posters/fonts/Montserrat-Thin.ttf) format("opentype")}@font-face{font-family:Montserrat-Light;src:url(/assets/pp-posters/fonts/Montserrat-Light.ttf) format("opentype")}@font-face{font-family:Montserrat-ExtraBold;src:url(/assets/pp-posters/fonts/Montserrat-ExtraBold.ttf) format("opentype")}@font-face{font-family:Montserrat-Medium;src:url(/assets/pp-posters/fonts/Montserrat-Medium.ttf) format("opentype")}@font-face{font-family:Montserrat-Thin;src:url(/assets/pp-posters/fonts/Montserrat-Thin.ttf) format("opentype")}@font-face{font-family:AbrilFatface-Regular;src:url(/assets/pp-posters/fonts/AbrilFatface-Regular.ttf) format("opentype")}@font-face{font-family:MenloRegular;src:url(/assets/pp-posters/fonts/MenloRegular.ttf) format("opentype")}@font-face{font-family:MenloBoldItalic;src:url(/assets/pp-posters/fonts/MenloBoldItalic.ttf) format("opentype")}[_nghost-%COMP%]{width:100%;height:100%;display:block}[_nghost-%COMP%]   .image-area[_ngcontent-%COMP%]{display:flex;width:100%;height:100%;justify-content:center}[_nghost-%COMP%]   .contour-instance[_ngcontent-%COMP%]{box-sizing:border-box;position:relative}[_nghost-%COMP%]   .marker-instance-wrapper[_ngcontent-%COMP%]{position:absolute}[_nghost-%COMP%]   .marker-instance[_ngcontent-%COMP%]{position:absolute}[_nghost-%COMP%]   svg-icon.marker[_ngcontent-%COMP%]{position:absolute;top:0;left:0}[_nghost-%COMP%]   svg-icon.marker[_ngcontent-%COMP%]   svg[_ngcontent-%COMP%]{display:block;cursor:pointer}[_nghost-%COMP%]   svg-icon.marker.interactive[_ngcontent-%COMP%]   svg[_ngcontent-%COMP%]{cursor:move}[_nghost-%COMP%]   .sign[_ngcontent-%COMP%]{display:flex;width:100%;justify-content:center}']
            }),
            mo
        }
        )()
    }
    ,
    14308: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            D: () => de
        });
        var Ut = $(10467)
          , r = $(54438)
          , Mt = $(7494)
          , s = $(9566)
          , so = $(13620)
          , Wt = $(61762)
          , _t = $(69847)
          , Ae = $(60177)
          , Me = $(27617)
          , ct = $(78606)
          , Tt = $(50552)
          , Qe = $(54843)
          , jt = $(41046)
          , Xe = $(21626);
        const Be = (lt, St, tt) => {
            switch (St) {
            case Me.wvv.ROSE:
                return lt === Me.N6e.PLATTER ? "#1D1C25" : "#DE254D";
            case Me.wvv.COFFEE:
                return lt === Me.N6e.PLATTER ? "#1D1C25" : "#ae7c62";
            case Me.wvv.BLUE_GREY:
            case Me.wvv.COSMIC_LATTE:
                return "#1D1C25";
            case Me.wvv.DEEP_SPACE_BLUE:
                return "#F6E5CE";
            case Me.wvv.STONE:
                return "#4D6F87";
            case Me.wvv.BLACK:
                return "#FFFFFF";
            case Me.wvv.SIMPLE:
                return "#111111";
            case Me.wvv.CUSTOM:
                return "#".concat(tt.text)
            }
        }
        ;
        var ze = $(49427)
          , ye = $(84412);
        const Ie = ["en", "pl", "de", "fr", "es", "it"]
          , gt = {
            en: "Good Vibes Only",
            pl: "Dobre Wibracje",
            de: "Nur Gute Vibes",
            fr: "Que des Ondes Positives",
            es: "Buenas Vibras",
            it: "Solo Buone Vibrazioni"
        }
          , Ye = {
            en: "",
            pl: "",
            de: "",
            fr: "",
            es: "",
            it: ""
        }
          , yt = {
            en: "Woke up this morning with a smile on my face,\nLeaving all the worries, I\u2019m finding my space.\nThe sun\u2019s shining bright, and the sky\u2019s so blue,\nGot nothing but love and a fresh point of view.\n\nI\u2019m chasing the light, letting go of the past,\nEvery moment I live, I\u2019m making it last.\nThe energy\u2019s high, the rhythm feels right,\nSpreading good vibes, from morning till night.\n\nGood vibes only, that\u2019s how I roll,\nLifting my spirit, healing my soul.\nIn every heartbeat, in every step,\nI\u2019m vibing with love, I\u2019ve got no regrets.\nGood vibes only, let\u2019s light up the day,\nTogether we\u2019ll shine and dance all the way.\n\nDon\u2019t need no reason, just living the flow,\nPlanting the seeds and watching them grow.\nA smile\u2019s contagious, let\u2019s pass it around,\nWith every good vibe, we lift off the ground.\n\nI\u2019m chasing the light, leaving fear far behind,\nIn this groove of life, I\u2019m feeling so aligned.\nThe energy\u2019s high, the rhythm feels sweet,\nDancing through life with joy in my feet.\n\nGood vibes only, that\u2019s how I roll,\nLifting my spirit, healing my soul.\nIn every heartbeat, in every step,\nI\u2019m vibing with love, I\u2019ve got no regrets.\nGood vibes only, let\u2019s light up the day,\nTogether we\u2019ll shine and dance all the way.\n\nSo when the world feels heavy, just let it all go,\nTune into the love, let your positivity grow.\nWe\u2019ve got the power to make it alright,\nWith every good vibe, we\u2019re lighting up the night.\n\nGood vibes only, that\u2019s how I roll,\nLifting my spirit, healing my soul.\nIn every heartbeat, in every step,\nI\u2019m vibing with love, I\u2019ve got no regrets.\nGood vibes only, let\u2019s light up the day,\nTogether we\u2019ll shine and dance all the way.\n\nGood vibes only, yeah, we\u2019re shining so bright,\nSpreading love and joy, we\u2019re living the light.",
            pl: "Dzi\u015b wsta\u0142em z u\u015bmiechem, s\u0142o\u0144ce wita mnie,\nPorzucam troski, serce l\u017cej ma si\u0119.\nNiebo bez chmur, wiatr cicho gra,\nDobra energia, pogodny dzie\u0144 trwa.\n\n\u0141api\u0119 to \u015bwiat\u0142o, zostawiam co z\u0142e,\nKa\u017cda chwila \u017cyje we mnie.\nEnergia wysoko, rytm w sercu gra,\nDobre wibracje, dzie\u0144 i noc mam.\n\nTylko dobre wibracje, tak id\u0119 w \u015bwiat,\nDuch si\u0119 podnosi, przygarnia go wiatr.\nW ka\u017cdym kroku serca wibracja,\nCzuj\u0119 mi\u0142o\u015b\u0107, to inspiracja.\nDobre wibracje, niech trwaj\u0105 w nas,\nId\u017amy przez \u017cycie, p\xf3ki mamy czas.\n\nNie szukam powodu, by si\u0119 \u015bmia\u0107,\nDobro dooko\u0142a, chc\u0119 je bra\u0107.\nU\u015bmiech zara\u017ca, niech idzie w kr\u0105g,\nZ dobrymi wibracjami polecisz st\u0105d.\n\n\u015awiat\u0142o chwytam, l\u0119ki znikaj\u0105,\nZ rytmem \u017cycia si\u0119 zestrajam.\nEnergia wysoko, rytm jest w nas,\nDobre wibracje wype\u0142ni\u0105 czas.\n\nTylko dobre wibracje, tak id\u0119 w \u015bwiat,\nDuch si\u0119 podnosi, przygarnia go wiatr.\nW ka\u017cdym kroku serca wibracja,\nCzuj\u0119 mi\u0142o\u015b\u0107, to inspiracja.\nDobre wibracje, niech trwaj\u0105 w nas,\nId\u017amy przez \u017cycie, p\xf3ki mamy czas.\n\nKiedy \u015bwiat p\u0119dzi, gubi sw\xf3j ton,\nOddaj si\u0119 mi\u0142o\u015bci, to lepszy dom.\nMamy moc, by pokona\u0107 mrok,\nZ dobrymi wibracjami si\u0119gamy gwiazd w lot.\n\nTylko dobre wibracje, tak id\u0119 w \u015bwiat,\nDuch si\u0119 podnosi, przygarnia go wiatr.\nW ka\u017cdym kroku serca wibracja,\nCzuj\u0119 mi\u0142o\u015b\u0107, to inspiracja.\nDobre wibracje, niech trwaj\u0105 w nas,\nId\u017amy przez \u017cycie, p\xf3ki mamy czas.",
            de: "Heute wach ich auf, mit L\xe4cheln im Gesicht,\nLass alles Schwere los, die Sonne zeigt ihr Licht.\nDer Himmel so klar, die Luft ist so rein,\nNur gute Energie, das Leben ist fein.\n\nIch folge dem Licht, lass Sorgen hinter mir,\nJeder Moment z\xe4hlt, die Liebe ist hier.\nDie Vibes sind hoch, der Rhythmus stimmt,\nGute Energie, der Tag beginnt.\n\nNur gute Vibes, das ist mein Plan,\nHeb meinen Geist, f\xfchl mich wie im Wahn.\nMit jedem Schritt, mit jedem Ton,\nLiebesenergie, die tr\xe4gt mich davon.\nNur gute Vibes, komm und tanz mit mir,\nZusammen leuchten, in Harmonie hier.\n\nIch brauch keinen Grund, um fr\xf6hlich zu sein,\nGute Vibes um mich, das Leben ist mein.\nEin L\xe4cheln breitet sich, \xfcberall rum,\nMit guten Vibes erreichen wir den Schwung.\n\nIch folge dem Licht, und lass alles los,\nDie Liebe in mir, f\xfchlt sich riesengro\xdf.\nDie Vibes sind hoch, im Takt mit dem Herz,\nNur gute Vibes, ganz ohne Schmerz.\n\nNur gute Vibes, das ist mein Plan,\nHeb meinen Geist, f\xfchl mich wie im Wahn.\nMit jedem Schritt, mit jedem Ton,\nLiebesenergie, die tr\xe4gt mich davon.\nNur gute Vibes, komm und tanz mit mir,\nZusammen leuchten, in Harmonie hier.\n\nWenn das Leben zu schnell, wird es zu schwer,\nLass es los und f\xfchl die Liebe mehr.\nWir haben die Kraft, das Dunkel zu sehn,\nMit guten Vibes lassen wir es geschehn.\n\nNur gute Vibes, das ist mein Plan,\nHeb meinen Geist, f\xfchl mich wie im Wahn.\nMit jedem Schritt, mit jedem Ton,\nLiebesenergie, die tr\xe4gt mich davon.\nNur gute Vibes, komm und tanz mit mir,\nZusammen leuchten, in Harmonie hier.",
            fr: "Ce matin, je me r\xe9veille, le sourire \xe9clatant,\nJe laisse les soucis, je vis dans l\u2019instant.\nLe ciel est si bleu, le soleil brille fort,\nJe sens l\u2019\xe9nergie, l\u2019amour est d\u2019accord.\n\nJe suis la lumi\xe8re, les peurs s\u2019\xe9vanouissent,\nChaque instant qui passe, la joie fleurit.\nLes ondes montent, je me sens l\xe9ger,\nTout est possible, rien \xe0 regretter.\n\nQue des ondes positives, c\u2019est tout ce qu\u2019il faut,\nJe l\xe8ve l\u2019esprit, je suis bien dans ma peau.\n\xc0 chaque pas, \xe0 chaque battement,\nL\u2019amour me guide, comme un courant.\nQue des ondes positives, viens, dansons ensemble,\nBrillons si fort, rien ne nous ressemble.\n\nPas besoin de raison pour sourire aujourd'hui,\nLa vie est douce, je vis sans bruit.\nUn sourire partag\xe9, une \xe9nergie donn\xe9e,\nAvec des ondes, on va tout soulever.\n\nJe suis la lumi\xe8re, les nuages s\u2019en vont,\nChaque instant m\u2019appelle, avec de l\u2019\xe9motion.\nLes ondes montent, je m\u2019y accroche,\nEt dans le rythme, rien ne s\u2019effiloche.\n\nQue des ondes positives, c\u2019est tout ce qu\u2019il faut,\nJe l\xe8ve l\u2019esprit, je suis bien dans ma peau.\n\xc0 chaque pas, \xe0 chaque battement,\nL\u2019amour me guide, comme un courant.\nQue des ondes positives, viens, dansons ensemble,\nBrillons si fort, rien ne nous ressemble.\n\nQuand la vie s\u2019acc\xe9l\xe8re et tout devient flou,\n\xc9coute ton c\u0153ur, la lumi\xe8re est en nous.\nOn a le pouvoir d'\xe9clairer nos nuits,\nAvec des ondes, tout devient infini.\n\nQue des ondes positives, c\u2019est tout ce qu\u2019il faut,\nJe l\xe8ve l\u2019esprit, je suis bien dans ma peau.\n\xc0 chaque pas, \xe0 chaque battement,\nL\u2019amour me guide, comme un courant.\nQue des ondes positives, viens, dansons ensemble,\nBrillons si fort, rien ne nous ressemble.",
            es: "Hoy me levanto, sonr\xedo sin m\xe1s,\nDejo atr\xe1s lo malo, ya pas\xf3 el mal.\nEl cielo est\xe1 claro, el sol brilla aqu\xed,\nBuenas vibras vienen, hoy soy feliz.\n\nSigo la luz, dejo el ayer,\nCada momento lo siento crecer.\nLa energ\xeda sube, todo est\xe1 bien,\nLas buenas vibras, siempre se ven.\n\nSolo buenas vibras, es mi verdad,\nLevanto mi alma, y siento la paz.\nCon cada paso, con cada latido,\nEl amor vibra, nada est\xe1 perdido.\nBuenas vibras, ven a bailar,\nJuntos brillamos, nada que ocultar.\n\nNo hace falta un motivo, para sonre\xedr,\nLa vida es bonita, me hace re\xedr.\nUna sonrisa que se va a contagiar,\nCon buenas vibras, todo puede cambiar.\n\nSigo la luz, dejo atr\xe1s el dolor,\nLa energ\xeda me lleva con su calor.\nLas vibras suben, el ritmo es real,\nBuenas sensaciones, todo va genial.\n\nSolo buenas vibras, es mi verdad,\nLevanto mi alma, y siento la paz.\nCon cada paso, con cada latido,\nEl amor vibra, nada est\xe1 perdido.\nBuenas vibras, ven a bailar,\nJuntos brillamos, nada que ocultar.\n\nCuando la vida corre y pierdes el comp\xe1s,\nSuelta tus miedos, y siente la paz.\nTenemos el poder de iluminar,\nCon buenas vibras, vamos a brillar.\n\nSolo buenas vibras, es mi verdad,\nLevanto mi alma, y siento la paz.\nCon cada paso, con cada latido,\nEl amor vibra, nada est\xe1 perdido.\nBuenas vibras, ven a bailar,\nJuntos brillamos, nada que ocultar.\n",
            it: "Oggi mi sveglio, col sorriso sul viso,\nLascio le paure, mi sento deciso.\nIl sole \xe8 alto, il cielo cos\xec blu,\nBuone vibrazioni, la vita \xe8 lass\xf9.\n\nSeguo la luce, il passato \xe8 via,\nOgni istante lo vivo con energia.\nL\u2019energia cresce, mi sento cos\xec,\nSolo vibrazioni buone, resta qui.\n\nSolo buone vibrazioni, cos\xec vivo io,\nAlzo lo spirito, in questo flusso mio.\nCon ogni passo, con ogni battito,\nL\u2019amore mi guida, non perdo il ritmo.\nBuone vibrazioni, vieni e balliamo,\nInsieme brilliamo, cos\xec ci amiamo.\n\nNon serve una scusa per sorridere,\nLa vita \xe8 bella, non posso nascondere.\nUn sorriso che si sparge intorno,\nCon buone vibrazioni, arriva il giorno.\n\nSeguo la luce, le paure svaniscono,\nOgni attimo \xe8 perfetto, le emozioni crescono.\nL\u2019energia sale, mi riempio di pi\xf9,\nBuone vibrazioni, mi danno virt\xf9.\n\nSolo buone vibrazioni, cos\xec vivo io,\nAlzo lo spirito, in questo flusso mio.\nCon ogni passo, con ogni battito,\nL\u2019amore mi guida, non perdo il ritmo.\nBuone vibrazioni, vieni e balliamo,\nInsieme brilliamo, cos\xec ci amiamo.\n\nQuando la vita corre e sembra pesante,\nTrova l\u2019amore, \xe8 cos\xec importante.\nAbbiamo il potere di rischiarare,\nCon buone vibrazioni possiamo volare.\n\nSolo buone vibrazioni, cos\xec vivo io,\nAlzo lo spirito, in questo flusso mio.\nCon ogni passo, con ogni battito,\nL\u2019amore mi guida, non perdo il ritmo.\nBuone vibrazioni, vieni e balliamo,\nInsieme brilliamo, cos\xec ci amiamo."
        };
        var ht = $(88455)
          , mo = $(73955)
          , no = $(345);
        const Co = () => [".jpeg", ".jpg", ".png", ".heic"];
        function Lt(lt, St) {
            1 & lt && r.eu8(0)
        }
        function Ft(lt, St) {
            if (1 & lt && r.DNE(0, Lt, 1, 0, "ng-container", 8),
            2 & lt) {
                r.XpG(2);
                const tt = r.sdS(8);
                r.Y8G("ngTemplateOutlet", tt)
            }
        }
        function co(lt, St) {
            1 & lt && r.eu8(0)
        }
        function Jt(lt, St) {
            if (1 & lt && r.DNE(0, co, 1, 0, "ng-container", 8),
            2 & lt) {
                r.XpG(2);
                const tt = r.sdS(6);
                r.Y8G("ngTemplateOutlet", tt)
            }
        }
        function po(lt, St) {
            if (1 & lt && (r.j41(0, "pp-poster-printing-registration", 6)(1, "pp-poster-arrangement-wrapper"),
            r.DNE(2, Ft, 1, 1, "ng-container")(3, Jt, 1, 1, "ng-container"),
            r.nrm(4, "pp-poster-text-area", 7),
            r.nI1(5, "async"),
            r.nI1(6, "async"),
            r.nI1(7, "async"),
            r.nI1(8, "async"),
            r.nI1(9, "async"),
            r.nI1(10, "async"),
            r.k0s()()),
            2 & lt) {
                const tt = St.ngIf
                  , $t = r.XpG();
                r.Y8G("poster", tt),
                r.R7$(2),
                r.vxM($t.lyrics.layout === $t.LyricsLayoutsEnum.PLATTER ? 2 : 3),
                r.R7$(2),
                r.Y8G("poster", r.bMT(5, 8, $t.poster$))("color", r.bMT(6, 10, $t.textColor$))("textArea", r.bMT(7, 12, $t.textArea$))("title", r.bMT(8, 14, $t.title$))("subtitle", r.bMT(9, 16, $t.subtitle$))("footer", r.bMT(10, 18, $t.footer$))
            }
        }
        function Et(lt, St) {
            1 & lt && r.nrm(0, "pp-poster-loaded-element")
        }
        function Kt(lt, St) {
            if (1 & lt) {
                const tt = r.RV6();
                r.j41(0, "img", 16),
                r.bIt("load", function() {
                    r.eBV(tt);
                    const Nt = r.XpG(3);
                    return r.Njj(Nt.onImageLoad())
                })("click", function() {
                    r.eBV(tt);
                    const Nt = r.XpG(3);
                    return r.Njj(Nt.onPhotoSelect())
                }),
                r.k0s()
            }
            if (2 & lt) {
                const tt = r.XpG().ngIf
                  , $t = r.XpG(2);
                r.Y8G("src", $t.getPhotoWithType(tt).imageUrl, r.B4B)
            }
        }
        function At(lt, St) {
            if (1 & lt) {
                const tt = r.RV6();
                r.j41(0, "pp-controls-file-uploader-photo", 17),
                r.nI1(1, "translate"),
                r.bIt("setFileUploadingProgress", function(Nt) {
                    r.eBV(tt);
                    const Vt = r.XpG(3);
                    return r.Njj(Vt.setFileUpploadingProgress.emit(Nt))
                }),
                r.k0s()
            }
            if (2 & lt) {
                const tt = r.XpG(3);
                r.Y8G("photoFileGroup", tt.photoFileGroup)("photoCropGroup", tt.photoCropGroup)("photoId", tt.photoId)("multiFile", tt.multiFile)("isSubmitted", !1)("acceptable", r.lJ4(14, Co))("isBase64Response", !0)("fullHeight", !0)("isBigPictureMode", !0)("withBackgroundGray", !0)("isFileUploadingInProgress", tt.isFileUploadingInProgress)("legalNote", r.bMT(1, 12, "soundwave.details.instruction"))
            }
        }
        function Re(lt, St) {
            if (1 & lt && (r.j41(0, "div", 13),
            r.DNE(1, Kt, 1, 1, "img", 14)(2, At, 2, 15, "pp-controls-file-uploader-photo", 15),
            r.k0s()),
            2 & lt) {
                const tt = St.ngIf
                  , $t = r.XpG(2);
                r.R7$(),
                r.Y8G("ngIf", !$t.getPhotoWithType(tt).showAddPhoto),
                r.R7$(),
                r.Y8G("ngIf", $t.photoFileGroup && $t.getPhotoWithType(tt).showAddPhoto)
            }
        }
        function ve(lt, St) {
            if (1 & lt && (r.j41(0, "div", 9),
            r.nrm(1, "div", 10),
            r.j41(2, "div", 11),
            r.DNE(3, Re, 3, 2, "div", 12),
            r.nI1(4, "async"),
            r.k0s()()),
            2 & lt) {
                const tt = r.XpG();
                r.xc7("top", tt.lyrics.imageArea.top, "px")("width", tt.lyrics.imageArea.width, "px")("height", tt.lyrics.imageArea.height, "px"),
                r.R7$(),
                r.xc7("padding", tt.lyrics.spiralPadding, "px"),
                r.Y8G("innerHTML", tt.lyrics.lyricsText, r.npT),
                r.R7$(),
                r.xc7("width", tt.lyrics.photoCircle.width, "px")("height", tt.lyrics.photoCircle.width, "px"),
                r.R7$(),
                r.Y8G("ngIf", r.bMT(4, 14, tt.photo$))
            }
        }
        function ne(lt, St) {
            if (1 & lt && r.nrm(0, "div", 24),
            2 & lt) {
                const tt = r.XpG(2);
                r.xc7("border-color", tt.lyrics.background)("border-width", tt.lyrics.circle.border, "px")
            }
        }
        function B(lt, St) {
            if (1 & lt && (r.j41(0, "pp-poster-image-area")(1, "div", 9)(2, "div", 18),
            r.DNE(3, ne, 1, 4, "div", 19),
            r.k0s(),
            r.nrm(4, "div", 10),
            r.j41(5, "div", 11),
            r.nrm(6, "div", 20)(7, "div", 21),
            r.k0s(),
            r.nrm(8, "div", 22)(9, "div", 23),
            r.k0s()()),
            2 & lt) {
                const tt = r.XpG();
                r.R7$(),
                r.xc7("top", tt.lyrics.imageArea.top, "px")("width", tt.lyrics.imageArea.width, "px")("height", tt.lyrics.imageArea.height, "px")("background", tt.lyrics.imageArea.background),
                r.R7$(),
                r.xc7("width", tt.lyrics.imageArea.width, "px")("height", tt.lyrics.imageArea.height, "px"),
                r.R7$(),
                r.vxM(tt.lyrics.border ? 3 : -1),
                r.R7$(),
                r.xc7("padding", tt.lyrics.spiralPadding, "px"),
                r.Y8G("innerHTML", tt.lyrics.lyricsText, r.npT),
                r.R7$(),
                r.xc7("width", tt.lyrics.circle.width, "px")("height", tt.lyrics.circle.width, "px")("background", tt.lyrics.circle.background),
                r.R7$(),
                r.xc7("width", tt.lyrics.lyricsTitle.width, "px")("margin-left", tt.lyrics.lyricsTitle.margin, "px")("color", tt.lyrics.circle.textColor)("font-size", tt.lyrics.lyricsTitle.fontSize, "px"),
                r.Y8G("innerHTML", tt.lyrics.lyricsTitle.text, r.npT),
                r.R7$(),
                r.xc7("width", tt.lyrics.lyricsArtist.width, "px")("margin-left", tt.lyrics.lyricsArtist.margin, "px")("color", tt.lyrics.circle.textColor)("font-size", tt.lyrics.lyricsArtist.fontSize, "px"),
                r.Y8G("innerHTML", tt.lyrics.lyricsArtist.text, r.npT),
                r.R7$(),
                r.xc7("width", tt.lyrics.circle.width, "px")("height", tt.lyrics.circle.delimiter, "px")("background", tt.lyrics.imageArea.background),
                r.R7$(),
                r.xc7("width", tt.lyrics.circle.circle, "px")("height", tt.lyrics.circle.circle, "px")("background", tt.lyrics.imageArea.background)
            }
        }
        let de = ( () => {
            var lt;
            class St extends Tt.C {
                constructor($t, Nt, Vt, _o, Lo) {
                    super($t, Nt),
                    this.host = $t,
                    this.zone = Nt,
                    this.cdr = Vt,
                    this.httpClient = _o,
                    this.sanitize = Lo,
                    this.photoId = 0,
                    this.multiFile = !1,
                    this.language = "en",
                    this.lyricsTooLongState = new r.bkB,
                    this.photoSelect = new r.bkB,
                    this.setFileUpploadingProgress = new r.bkB,
                    this.isFileUploadingInProgress = !1,
                    this.lyrics = {
                        background: "#DCCCC0",
                        border: !1,
                        layout: Me.N6e.PLATTER,
                        spiralPadding: 0,
                        imageArea: {
                            top: 0,
                            width: 0,
                            height: 0,
                            background: "transparent"
                        },
                        circle: {
                            width: 0,
                            height: 0,
                            delimiter: 0,
                            circle: 0,
                            textColor: "transparent",
                            background: "transparent",
                            border: 0
                        },
                        photoCircle: {
                            width: 0,
                            height: 0
                        },
                        lyricsText: "",
                        lyricsTitle: {
                            text: "",
                            fontSize: 0,
                            width: 0,
                            margin: 0
                        },
                        lyricsArtist: {
                            text: "",
                            fontSize: 0,
                            width: 0,
                            margin: 0
                        }
                    },
                    this.photo$ = new ye.t(null),
                    this.LyricsLayoutsEnum = Me.N6e
                }
                setAllTextSettings($t) {
                    const Nt = {
                        text: $t.customMessage ? $t.title : "",
                        isDefaultFont: !$t.titleFontScript
                    }
                      , Vt = this.isLessThan80($t) ? .9 : 1;
                    this.setText(Nt, this.title$, {
                        font: null != Nt && Nt.isDefaultFont ? Me.n3q.ROBOTO_THIN : Me.n3q.HELLO_OCTOBER,
                        portrait: {
                            sizeFactor: (null != Nt && Nt.isDefaultFont ? .058 : .088) * Vt,
                            bottomFactor: 1.35 * (null != Nt && Nt.isDefaultFont ? .014 : .018),
                            topFactor: .03,
                            isBold: !1
                        },
                        horizontal: {
                            sizeFactor: null != Nt && Nt.isDefaultFont ? .058 : .08,
                            bottomFactor: null != Nt && Nt.isDefaultFont ? .014 : .018,
                            topFactor: .03,
                            isBold: !1
                        }
                    });
                    const _o = {
                        text: $t.customMessage ? $t.subtitle : "",
                        isDefaultFont: !$t.subtitleFontScript
                    };
                    this.setText(_o, this.subtitle$, {
                        font: null != _o && _o.isDefaultFont ? Me.n3q.ROBOTO_THIN : Me.n3q.HELLO_OCTOBER,
                        portrait: {
                            sizeFactor: (null != _o && _o.isDefaultFont ? .032 : .052) * Vt,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: null != _o && _o.isDefaultFont ? .032 : .052,
                            bottomFactor: 0,
                            topFactor: 0
                        }
                    })
                }
                setTextArea($t, Nt) {
                    this.textArea$.next({
                        bottomFactor: .04,
                        marginFactor: $t.isPortrait ? .07 : .04,
                        topFactor: 0
                    }),
                    this.topTextArea$.next({
                        topFactor: .04,
                        marginFactor: $t.isPortrait ? .08 : .04
                    })
                }
                setDesign($t, Nt) {
                    var Vt = this;
                    return (0,
                    Ut.A)(function*() {
                        Vt.lyrics.background = ( (lt, St, tt) => {
                            switch (St) {
                            case Me.wvv.ROSE:
                                return "#F3EDE5";
                            case Me.wvv.COFFEE:
                                return lt === Me.N6e.PLATTER ? "#F5E1D4" : "#eceae2";
                            case Me.wvv.BLUE_GREY:
                                return "#D2D3D4";
                            case Me.wvv.COSMIC_LATTE:
                                return "#F6E5CE";
                            case Me.wvv.DEEP_SPACE_BLUE:
                                return "#0F1721";
                            case Me.wvv.STONE:
                                return "#F1F1E9";
                            case Me.wvv.BLACK:
                                return "#282828";
                            case Me.wvv.SIMPLE:
                                return "#FFFFFF";
                            case Me.wvv.CUSTOM:
                                return "#".concat(tt.background)
                            }
                        }
                        )(Nt.layout, Nt.colorScheme, Nt.customColors);
                        const _o = Nt.layout === Me.N6e.PLATTER;
                        Vt.lyrics.imageArea.top = $t.isPortrait ? $t.size.width * (_o ? .08 : .04) * (Vt.isLessThan80(Nt) ? .7 : 1) : $t.size.height * (_o ? .04 : .02),
                        Vt.lyrics.imageArea.width = $t.isPortrait ? $t.size.width * (_o ? .92 : .96) : .74 * $t.size.height,
                        Vt.lyrics.imageArea.height = Vt.lyrics.imageArea.width,
                        Vt.lyrics.imageArea.background = ( (lt, St) => {
                            switch (lt) {
                            case Me.wvv.ROSE:
                            case Me.wvv.COFFEE:
                            case Me.wvv.BLUE_GREY:
                                return "#1D1C25";
                            case Me.wvv.COSMIC_LATTE:
                                return "#0F1721";
                            case Me.wvv.DEEP_SPACE_BLUE:
                                return "#F6E5CE";
                            case Me.wvv.STONE:
                                return "#4D6F87";
                            case Me.wvv.BLACK:
                                return "#282828";
                            case Me.wvv.SIMPLE:
                                return "#FFFFFF";
                            case Me.wvv.CUSTOM:
                                return "#".concat(St.text)
                            }
                        }
                        )(Nt.colorScheme, Nt.customColors),
                        Vt.lyrics.spiralPadding = $t.isPortrait ? .02 * $t.size.width : .02 * $t.size.height,
                        Vt.lyrics.photoCircle.width = $t.isPortrait ? .53 * $t.size.width : .39 * $t.size.height,
                        Vt.lyrics.photoCircle.height = Vt.lyrics.photoCircle.width,
                        Vt.lyrics.circle.width = $t.isPortrait ? .43 * $t.size.width : .35 * $t.size.height,
                        Vt.lyrics.circle.height = Vt.lyrics.circle.width,
                        Vt.lyrics.circle.delimiter = $t.isPortrait ? .01 * $t.size.width : .01 * $t.size.height,
                        Vt.lyrics.circle.circle = $t.isPortrait ? .05 * $t.size.width : .05 * $t.size.height,
                        Vt.lyrics.circle.border = Vt.isFinalPoster ? $t.isPortrait ? 67e-5 * $t.size.width : 67e-5 * $t.size.height : 1,
                        console.log(Vt.lyrics.circle.border),
                        Vt.lyrics.border = ![Me.wvv.SIMPLE, Me.wvv.BLACK].includes(Nt.colorScheme),
                        Vt.lyrics.circle.background = ( (lt, St) => {
                            switch (lt) {
                            case Me.wvv.ROSE:
                                return "#DE254D";
                            case Me.wvv.COFFEE:
                                return "#C8A4A5";
                            case Me.wvv.BLUE_GREY:
                                return "#546189";
                            case Me.wvv.COSMIC_LATTE:
                                return "#F77147";
                            case Me.wvv.DEEP_SPACE_BLUE:
                                return "#0F1721";
                            case Me.wvv.STONE:
                                return "#F1F1E9";
                            case Me.wvv.BLACK:
                                return "#FFFFFF";
                            case Me.wvv.SIMPLE:
                                return "#111111";
                            case Me.wvv.CUSTOM:
                                return "#".concat(St.background)
                            }
                        }
                        )(Nt.colorScheme, Nt.customColors),
                        Vt.lyrics.circle.textColor = ( (lt, St) => {
                            switch (lt) {
                            case Me.wvv.ROSE:
                            case Me.wvv.COFFEE:
                            case Me.wvv.BLUE_GREY:
                            case Me.wvv.COSMIC_LATTE:
                                return "#FFFFFF";
                            case Me.wvv.DEEP_SPACE_BLUE:
                                return "#F6E5CE";
                            case Me.wvv.STONE:
                                return "#4D6F87";
                            case Me.wvv.BLACK:
                                return "#282828";
                            case Me.wvv.SIMPLE:
                                return "#FFFFFF";
                            case Me.wvv.CUSTOM:
                                return "#".concat(St.text)
                            }
                        }
                        )(Nt.colorScheme, Nt.customColors),
                        Vt.textColor$.next(Be(Nt.layout, Nt.colorScheme, Nt.customColors));
                        const Lo = Vt.getLyrics(Nt);
                        Vt.lyrics.layout = Nt.layout;
                        const ao = Nt.layout === Me.N6e.PLATTER ? "platter-spiral" : "photo-spiral"
                          , bt = Nt.layout === Me.N6e.PLATTER ? "" : "".concat(Lo.title, " \xb7 ").concat(Lo.artist, " &hearts; ")
                          , Do = Nt.layout === Me.N6e.PLATTER ? "" : '<tspan font-family="'.concat(Me.n3q.SOURCE_CODE_PRO, '" fill="red">&hearts;</tspan> ')
                          , Xt = "".concat(bt).concat(Lo.lyrics).replace(/(?:\r\n|\r|\n)/g, " ")
                          , ie = '<tspan font-family="'.concat(Me.n3q.EB_GARAMOND_BOLD, '">').concat(bt.replace("&hearts; ", ""), "</tspan>").concat(Do).concat(Lo.lyrics).replace(/(?:\r\n|\r|\n)/g, " ")
                          , [we,Oe] = yield Vt.getLines(Xt, Nt.layout, $t);
                        let ee = yield(0,
                        Qe._)(Vt.httpClient.get("/assets/pp-posters/lyrics/".concat(ao, "/").concat(we, "-lines.svg"), {
                            responseType: "text"
                        }));
                        const W = Nt.layout === Me.N6e.PLATTER ? ( (lt, St) => {
                            switch (lt) {
                            case Me.wvv.ROSE:
                            case Me.wvv.COFFEE:
                            case Me.wvv.BLUE_GREY:
                            case Me.wvv.COSMIC_LATTE:
                                return "#FFFFFF";
                            case Me.wvv.DEEP_SPACE_BLUE:
                                return "#0F1721";
                            case Me.wvv.STONE:
                                return "#F1F1E9";
                            case Me.wvv.BLACK:
                                return "#FFFFFF";
                            case Me.wvv.SIMPLE:
                                return "#111111";
                            case Me.wvv.CUSTOM:
                                return "#".concat(St.background)
                            }
                        }
                        )(Nt.colorScheme, Nt.customColors) : Be(Nt.layout, Nt.colorScheme, Nt.customColors);
                        ee = ee.replace(">______REPLACE_LYRICS______", 'font-family="'.concat(Me.n3q.EB_GARAMOND, '" style="fill: ').concat(W, ';" font-size=').concat(Oe, " >").concat(ie)),
                        ee = ee.replace("______REPLACE_STROKE_LYRICS______", Nt.showSpiralLine ? "".concat(W) : "transparent"),
                        Vt.lyrics.lyricsText = Vt.sanitize.bypassSecurityTrustHtml(ee);
                        const ae = Lo.title.length
                          , Ve = Vt.lyrics.circle.width * (ae < 8 ? 1 : ae < 20 ? .8 : ae < 40 ? .65 : .55);
                        Vt.lyrics.lyricsTitle = {
                            width: Ve,
                            margin: (Vt.lyrics.circle.width - Ve) / 2,
                            text: Lo.title.replace(/\n/g, "<br>"),
                            fontSize: ($t.isPortrait ? $t.size.width : $t.size.height) * (ae < 8 ? .06 : ae < 12 ? .05 : ae < 20 ? .038 : ae < 40 ? .032 : .03)
                        };
                        const fe = Lo.artist.length
                          , Pt = Vt.lyrics.circle.width * (fe < 8 ? 1 : fe < 20 ? .8 : fe < 40 ? .65 : .55);
                        Vt.lyrics.lyricsArtist = {
                            width: Pt,
                            margin: (Vt.lyrics.circle.width - Pt) / 2,
                            text: Lo.artist.replace(/\n/g, "<br>"),
                            fontSize: $t.isPortrait ? $t.size.width * (fe < 40 ? .03 : .025) : $t.size.height * (fe < 40 ? .03 : .025)
                        },
                        Vt.photo$.next({
                            isPhoto: (null == Nt ? void 0 : Nt.layout) === Me.N6e.PHOTO_CIRCLE,
                            uuid: Nt.photoFiles[0].uuid,
                            imageUrl: "".concat(Vt.environmentPhotoApi, "/v2/").concat(Vt.isFinalPoster ? "photo" : "image", "/").concat(Nt.photoFiles[0].uuid, "?type=").concat(Nt.cropsData[0].filter, "&left=").concat(Nt.cropsData[0].cropData.x, "&top=").concat(Nt.cropsData[0].cropData.y, "&width=").concat(Nt.cropsData[0].cropData.width, "&height=").concat(Nt.cropsData[0].cropData.height, "&rotate=").concat(Nt.cropsData[0].rotate, "&flipped=").concat(Nt.cropsData[0].flip),
                            showAddPhoto: !Nt.photoFiles[0].uuid
                        }),
                        Vt.onImageLoad()
                    })()
                }
                getLines($t, Nt, Vt) {
                    var _o = this;
                    return (0,
                    Ut.A)(function*() {
                        let Lo = Vt.isPortrait ? .038 * Vt.size.width : .05 * Vt.size.height;
                        $t.length < 10 && (Lo *= 1.5),
                        yield(0,
                        ht.A)(Me.n3q.EB_GARAMOND);
                        const ao = _o.getTextWidth($t, Me.n3q.EB_GARAMOND, Lo) / Vt.size.width * 540;
                        let bt = 1;
                        return Nt === Me.N6e.PLATTER ? (bt = ao < 1290 ? 1 : ao < 1640 ? 1.2 : ao < 2020 ? 1.4 : ao < 2415 ? 1.6 : ao < 2805 ? 1.8 : ao < 3200 ? 2 : ao < 3595 ? 2.2 : ao < 4015 ? 2.4 : ao < 4445 ? 2.6 : ao < 4880 ? 2.8 : ao < 5310 ? 3 : ao < 5745 ? 3.2 : ao < 6205 ? 3.4 : ao < 6670 ? 3.6 : ao < 7155 ? 3.8 : ao < 7630 ? 4 : ao < 8105 ? 4.2 : ao < 8600 ? 4.4 : ao < 9115 ? 4.6 : ao < 9635 ? 4.8 : ao < 10145 ? 5 : ao < 10655 ? 5.2 : ao < 11205 ? 5.4 : ao < 11765 ? 5.6 : ao < 12320 ? 5.8 : ao < 12860 ? 6 : ao < 13425 ? 6.2 : ao < 14015 ? 6.4 : ao < 14610 ? 6.6 : ao < 15210 ? 6.8 : 7,
                        _o.lyricsTooLongState.emit(ao > 15814)) : (bt = ao < 1970 ? 1 : ao < 2385 ? 1.2 : ao < 2825 ? 1.4 : ao < 3280 ? 1.6 : ao < 3730 ? 1.8 : ao < 4185 ? 2 : ao < 4650 ? 2.2 : ao < 5130 ? 2.4 : ao < 5625 ? 2.6 : ao < 6120 ? 2.8 : ao < 6615 ? 3 : ao < 7120 ? 3.2 : ao < 7640 ? 3.4 : ao < 8185 ? 3.6 : ao < 8726 ? 3.8 : ao < 9268 ? 4 : ao < 9810 ? 4.2 : ao < 10375 ? 4.4 : ao < 10960 ? 4.6 : ao < 11538 ? 4.8 : ao < 12120 ? 5 : ao < 12700 ? 5.2 : ao < 13320 ? 5.4 : ao < 13940 ? 5.6 : ao < 14565 ? 5.8 : 6,
                        _o.lyricsTooLongState.emit(ao > 15199)),
                        console.log("Text length: ".concat(ao), "Lines file: ".concat(bt), "Poster size: ".concat(Vt.size.width)),
                        [bt, Lo / Vt.size.width * 540]
                    })()
                }
                getPhotoWithType($t) {
                    return $t
                }
                onPhotoSelect() {
                    this.photoSelect.emit([this.lyrics.photoCircle.width, this.lyrics.photoCircle.height])
                }
                onImageLoad() {
                    this.load++,
                    this.load === (this.lyrics.layout === Me.N6e.PLATTER ? 1 : 2) && (this.initiateRender(),
                    this.cdr.detectChanges())
                }
                getTextWidth($t, Nt, Vt) {
                    const Lo = document.createElement("canvas").getContext("2d");
                    if (!Lo)
                        throw new Error("Failed to get canvas context");
                    return Lo.font = "".concat(Vt, "px ").concat(Nt),
                    Lo.measureText($t).width
                }
                getLyrics($t) {
                    const Nt = $t.lyricsSource === Me.r1B.CUSTOM ? {
                        lyrics: $t.customLyrics,
                        title: $t.customTitle,
                        artist: $t.customArtist
                    } : {
                        lyrics: $t.geniusLyrics,
                        title: $t.geniusTitle,
                        artist: $t.geniusArtist
                    };
                    if (!Nt.lyrics && !Nt.title && !Nt.artist) {
                        let Vt = "en";
                        return Ie.includes(this.language) && (Vt = this.language),
                        {
                            lyrics: yt[Vt],
                            title: gt[Vt],
                            artist: Ye[Vt]
                        }
                    }
                    return Nt
                }
                isLessThan80($t) {
                    return $t.width / $t.height >= .8
                }
            }
            return (lt = St).\u0275fac = function($t) {
                return new ($t || lt)(r.rXU(r.aKT),r.rXU(r.SKi),r.rXU(r.gRc),r.rXU(Xe.Qq),r.rXU(no.up))
            }
            ,
            lt.\u0275cmp = r.VBU({
                type: lt,
                selectors: [["pp-poster-lyrics"]],
                inputs: {
                    photoFileGroup: "photoFileGroup",
                    photoCropGroup: "photoCropGroup",
                    photoId: "photoId",
                    multiFile: "multiFile",
                    environmentPhotoApi: "environmentPhotoApi",
                    language: "language",
                    isFileUploadingInProgress: "isFileUploadingInProgress"
                },
                outputs: {
                    lyricsTooLongState: "lyricsTooLongState",
                    photoSelect: "photoSelect",
                    setFileUpploadingProgress: "setFileUpploadingProgress"
                },
                features: [r.Vt3],
                decls: 9,
                vars: 5,
                consts: [["posterWrapper", ""], ["photoCircle", ""], ["platter", ""], [3, "background"], [3, "poster", 4, "ngIf"], [4, "ngIf"], [3, "poster"], [3, "poster", "color", "textArea", "title", "subtitle", "footer"], [4, "ngTemplateOutlet"], [1, "lyrics-image-instance"], [1, "lyrics-spiral", 3, "innerHTML"], [1, "internal-circle"], ["class", "photo-instance", 4, "ngIf"], [1, "photo-instance"], [3, "src", "load", "click", 4, "ngIf"], [3, "photoFileGroup", "photoCropGroup", "photoId", "multiFile", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "withBackgroundGray", "isFileUploadingInProgress", "legalNote", "setFileUploadingProgress", 4, "ngIf"], [3, "load", "click", "src"], [3, "setFileUploadingProgress", "photoFileGroup", "photoCropGroup", "photoId", "multiFile", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "withBackgroundGray", "isFileUploadingInProgress", "legalNote"], [1, "border-margin"], [1, "border-element", 3, "borderColor", "borderWidth"], [1, "internal-circle-top-text", 3, "innerHTML"], [1, "internal-circle-bottom-text", 3, "innerHTML"], [1, "internal-circle-line"], [1, "internal-circle-circle"], [1, "border-element"]],
                template: function($t, Nt) {
                    1 & $t && (r.j41(0, "pp-poster-background", 3, 0),
                    r.DNE(2, po, 11, 20, "pp-poster-printing-registration", 4),
                    r.nI1(3, "async"),
                    r.k0s(),
                    r.DNE(4, Et, 1, 0, "pp-poster-loaded-element", 5)(5, ve, 5, 16, "ng-template", null, 1, r.C5r)(7, B, 10, 52, "ng-template", null, 2, r.C5r)),
                    2 & $t && (r.Y8G("background", Nt.lyrics.background),
                    r.R7$(2),
                    r.Y8G("ngIf", r.bMT(3, 3, Nt.poster$)),
                    r.R7$(2),
                    r.Y8G("ngIf", Nt.isImageRendered))
                },
                dependencies: [Ae.MD, Ae.bT, Ae.T3, Ae.Jj, Xe.q1, Mt.Z, s.R, _t.c, so.y, Wt.W, ct.iu, jt.C, ze.ex, mo.h, mo.D9],
                styles: ['@font-face{font-family:Leander Script Pro;font-weight:700;src:url(/assets/pp-posters/fonts/leanderscriptpro-bold.otf) format("opentype")}@font-face{font-family:Leander Script Pro;src:url(/assets/pp-posters/fonts/leanderscriptpro-regular.otf) format("opentype")}@font-face{font-family:Madina Script;src:url(/assets/pp-posters/fonts/Madina-Script.otf) format("opentype")}@font-face{font-family:Proxima Nova;font-weight:700;src:url(/assets/pp-posters/fonts/proximanova-bold.otf) format("opentype")}@font-face{font-family:SourceCodePro-Regular;src:url(/assets/pp-posters/fonts/SourceCodePro-Regular.ttf) format("truetype")}@font-face{font-family:Proxima Nova;src:url(/assets/pp-posters/fonts/proximanova-regular.otf) format("opentype")}@font-face{font-family:Macho;font-weight:700;src:url(/assets/pp-posters/fonts/Macho-Medium.woff) format("opentype")}@font-face{font-family:Macho;src:url(/assets/pp-posters/fonts/Macho-Regular.woff) format("opentype")}@font-face{font-family:Capsuula;src:url(/assets/pp-posters/fonts/Capsuula.ttf) format("truetype")}@font-face{font-family:Capsuula Bold;src:url(/assets/pp-posters/fonts/Capsuula-bold.ttf) format("truetype")}@font-face{font-family:YesevaOne;src:url(/assets/pp-posters/fonts/YesevaOne-Regular.ttf)}@font-face{font-family:LuxusBrut;src:url(/assets/pp-posters/fonts/LuxusBrut.otf) format("opentype")}@font-face{font-family:PositivePrintsScript2;src:url(/assets/pp-posters/fonts/positive-prints-script-2.otf) format("opentype")}@font-face{font-family:PositivePrintsScript;src:url(/assets/pp-posters/fonts/PositivePrintsScript.ttf) format("opentype")}@font-face{font-family:Dejavu Sans;src:url(/assets/pp-posters/fonts/DejaVuSans.ttf) format("opentype")}@font-face{font-family:Roboto Thin;src:url(/assets/pp-posters/fonts/Roboto-Thin.ttf) format("opentype")}@font-face{font-family:roobert;font-weight:400;src:url(/assets/pp-posters/fonts/roobert-regular.otf) format("opentype")}@font-face{font-family:roobert;font-weight:700;src:url(/assets/pp-posters/fonts/roobert-bold.otf) format("opentype")}@font-face{font-family:Sophia Ronald;src:url(/assets/pp-posters/fonts/SophiaRonald.ttf) format("opentype")}@font-face{font-family:Hello October;src:url(/assets/pp-posters/fonts/Hello_October.otf) format("opentype")}@font-face{font-family:SignatureFont;src:url(/assets/pp-posters/fonts/SignatureFont.otf) format("opentype")}@font-face{font-family:EBGaramond-Bold;src:url(/assets/pp-posters/fonts/EBGaramond-Bold.ttf) format("opentype")}@font-face{font-family:EBGaramond-SemiBold;src:url(/assets/pp-posters/fonts/EBGaramond-SemiBold.ttf) format("opentype")}@font-face{font-family:EBGaramond-Regular;src:url(/assets/pp-posters/fonts/EBGaramond-Regular.ttf) format("opentype")}@font-face{font-family:Montserrat-ExtraBold;src:url(/assets/pp-posters/fonts/Montserrat-ExtraBold.ttf) format("opentype")}@font-face{font-family:Montserrat-Medium;src:url(/assets/pp-posters/fonts/Montserrat-Medium.ttf) format("opentype")}@font-face{font-family:Montserrat-Thin;src:url(/assets/pp-posters/fonts/Montserrat-Thin.ttf) format("opentype")}@font-face{font-family:Montserrat-Light;src:url(/assets/pp-posters/fonts/Montserrat-Light.ttf) format("opentype")}@font-face{font-family:Montserrat-ExtraBold;src:url(/assets/pp-posters/fonts/Montserrat-ExtraBold.ttf) format("opentype")}@font-face{font-family:Montserrat-Medium;src:url(/assets/pp-posters/fonts/Montserrat-Medium.ttf) format("opentype")}@font-face{font-family:Montserrat-Thin;src:url(/assets/pp-posters/fonts/Montserrat-Thin.ttf) format("opentype")}@font-face{font-family:AbrilFatface-Regular;src:url(/assets/pp-posters/fonts/AbrilFatface-Regular.ttf) format("opentype")}@font-face{font-family:MenloRegular;src:url(/assets/pp-posters/fonts/MenloRegular.ttf) format("opentype")}@font-face{font-family:MenloBoldItalic;src:url(/assets/pp-posters/fonts/MenloBoldItalic.ttf) format("opentype")}[_nghost-%COMP%]{width:100%;height:100%;display:block}[_nghost-%COMP%]   .lyrics-image-instance[_ngcontent-%COMP%]{box-sizing:border-box;display:flex;justify-content:center;align-items:center;border-radius:50%;position:absolute;left:0;right:0;margin:auto}[_nghost-%COMP%]   .lyrics-image-instance[_ngcontent-%COMP%]     svg{overflow:visible}[_nghost-%COMP%]   .lyrics-image-instance[_ngcontent-%COMP%]   .border-margin[_ngcontent-%COMP%]{padding:1%;position:absolute;box-sizing:border-box}[_nghost-%COMP%]   .lyrics-image-instance[_ngcontent-%COMP%]   .border-margin[_ngcontent-%COMP%]   .border-element[_ngcontent-%COMP%]{width:100%;height:100%;border-radius:50%;box-sizing:border-box;border:0px solid transparent}[_nghost-%COMP%]   .lyrics-image-instance[_ngcontent-%COMP%]   .lyrics-spiral[_ngcontent-%COMP%]{width:100%;height:100%;box-sizing:border-box}[_nghost-%COMP%]   .lyrics-image-instance[_ngcontent-%COMP%]   .internal-circle[_ngcontent-%COMP%]{position:absolute;border-radius:50%;overflow:hidden}[_nghost-%COMP%]   .lyrics-image-instance[_ngcontent-%COMP%]   .internal-circle[_ngcontent-%COMP%]   .photo-instance[_ngcontent-%COMP%]{position:absolute;width:100%;height:100%}[_nghost-%COMP%]   .lyrics-image-instance[_ngcontent-%COMP%]   .internal-circle[_ngcontent-%COMP%]   .photo-instance[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:100%;height:100%;object-fit:cover;cursor:pointer}[_nghost-%COMP%]   .lyrics-image-instance[_ngcontent-%COMP%]   .internal-circle-line[_ngcontent-%COMP%]{position:absolute}[_nghost-%COMP%]   .lyrics-image-instance[_ngcontent-%COMP%]   .internal-circle-circle[_ngcontent-%COMP%]{position:absolute;border-radius:50%}[_nghost-%COMP%]   .lyrics-image-instance[_ngcontent-%COMP%]   .internal-circle-top-text[_ngcontent-%COMP%]{font-family:EBGaramond-Regular,sans-serif;line-height:1.2em;width:100%;height:50%;text-align:center;justify-content:center;align-items:center;display:flex}[_nghost-%COMP%]   .lyrics-image-instance[_ngcontent-%COMP%]   .internal-circle-bottom-text[_ngcontent-%COMP%]{font-family:Roboto Thin,sans-serif;line-height:1.2em;width:100%;height:50%;text-align:center;justify-content:center;align-items:center;display:flex}']
            }),
            St
        }
        )()
    }
    ,
    16968: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            f: () => it
        });
        var Ut = $(10467)
          , r = $(54438)
          , Mt = $(60177)
          , s = $(27617);
        const so = (re, pt, Be) => {
            switch (pt) {
            case s.c_T.MINIMAL:
                return "".concat(re, "/styles/minimal/style.json");
            case s.c_T.BEACHGLASS:
                return "".concat(re, "/styles/beachglass/style.json");
            case s.c_T.CARBON:
                return "".concat(re, "/styles/carbon/style.json");
            case s.c_T.BLACK:
                return "".concat(re, "/styles/black/style.json");
            case s.c_T.INTENSE:
                return "".concat(re, "/styles/intense/style.json");
            case s.c_T.VINTAGE:
                return "".concat(re, "/styles/vintage/style.json");
            case s.c_T.CUSTOM:
                return "".concat(re, "/styles/custom/style.json");
            case s.c_T.ANTIQUA:
                return "".concat(re, "/styles/antiqua/style.json");
            case s.c_T.CLASSIC:
                return "".concat(re, "/styles/classic/style.json");
            case s.c_T.WANDERLUST:
                return "".concat(re, "/styles/wanderlust/style.json");
            case s.c_T.COSY:
                return "".concat(re, "/styles/cosy/style.json");
            case s.c_T.BEACHGLASS_CARBON:
                return "".concat(re, Be ? "/styles/beachglass/style.json" : "/styles/carbon/style.json");
            case s.c_T.MINIMAL_WANDERLUST:
                return "".concat(re, Be ? "/styles/minimal/style.json" : "/styles/wanderlust/style.json")
            }
        }
          , Wt = {
            land: [{
                name: "background",
                attrib: "background-color"
            }, {
                name: "landusage",
                attrib: "fill-color"
            }],
            water: [{
                name: "water",
                attrib: "fill-color"
            }, {
                name: "water-rivers",
                attrib: "line-color"
            }],
            roads: [{
                name: "buildings",
                attrib: "line-color"
            }, {
                name: "rails",
                attrib: "line-color"
            }, {
                name: "service",
                attrib: "line-color"
            }, {
                name: "track",
                attrib: "line-color"
            }, {
                name: "streets",
                attrib: "line-color"
            }, {
                name: "Primary-Motorway",
                attrib: "line-color"
            }, {
                name: "Trunks",
                attrib: "line-color"
            }, {
                name: "teritary roads",
                attrib: "line-color"
            }, {
                name: "secondary roads",
                attrib: "line-color"
            }]
        };
        var _t = $(84412)
          , Ae = $(7335)
          , Me = $(81247);
        class ct {
            constructor(pt) {
                this.mapIsLoaded$ = new _t.t(!1),
                this.currentMarkers = [],
                this.selectedMapStyle = new _t.t(s.c_T.BEACHGLASS),
                Me.accessToken = pt
            }
            setMapStyle(pt, Be) {
                this.selectedMapStyle.next(Be),
                this.changeMapStyle(pt)
            }
            getSelectedMapStyle() {
                return this.selectedMapStyle.getValue()
            }
            changeMapColorByLayer(pt, Be) {
                var ze = this;
                return (0,
                Ut.A)(function*() {
                    if (!ze.map.isStyleLoaded())
                        return;
                    const ye = Wt[Be];
                    for (const ge of ye)
                        if (ze.map.getLayer(ge.name))
                            try {
                                yield ze.map.setPaintProperty(ge.name, ge.attrib, "#" + pt)
                            } catch (Ie) {
                                console.log("error when paint a map", Ie)
                            }
                        else
                            console.log("Unfounded name: ", ge.name)
                })()
            }
            changeMapStyle(pt) {
                try {
                    this.map.setStyle(so(pt, this.getSelectedMapStyle(), 1))
                } catch {
                    return
                }
            }
            clearMarkers() {
                if (this.currentMarkers && this.currentMarkers.length > 0)
                    for (let pt = 0; pt < this.currentMarkers.length; pt++)
                        this.currentMarkers[pt].el.remove();
                this.currentMarkers = []
            }
            getMarkerSize(pt=!0) {
                const Be = document.getElementsByClassName("mapboxgl-canvas-container")[0];
                if (!Be)
                    return 21;
                const ye = pt ? Be.offsetWidth : Be.offsetHeight;
                return 21 * (ye / 460 > 1 ? 1 : ye / 460)
            }
            changeMarkerSize(pt=!0) {
                const Be = document.getElementsByClassName("pp-marker-el");
                Be && Array.from(Be).forEach(ye => {
                    ye.style.width = "".concat(this.getMarkerSize(pt), "px"),
                    ye.style.height = "".concat(this.getMarkerSize(pt), "px")
                }
                )
            }
            setMapSettings(pt, Be, ze=!0) {
                setTimeout( () => {
                    this.clearMarkers();
                    const ye = document.createElement("div");
                    ye.classList.add("marker"),
                    ye.classList.add("pp-marker-el"),
                    ye.style.width = "".concat(this.getMarkerSize(ze), "px"),
                    ye.style.height = "".concat(this.getMarkerSize(ze), "px"),
                    ye.innerHTML = (0,
                    Ae.H)(pt);
                    const ge = {
                        lng: Be[1],
                        lat: Be[0]
                    };
                    new Me.Marker(ye).setLngLat(Be).addTo(this.map),
                    this.currentMarkers.push({
                        el: ye,
                        pos: ge
                    })
                }
                )
            }
            getMapStructuredObject() {
                var pt, Be, ze, ye, ge, Ie;
                const {mapboxElement: gt} = this.getMapDetails()
                  , Ye = this.map.getBounds();
                return {
                    center: this.map.getCenter(),
                    boundaries: {
                        west: null !== (pt = null == Ye ? void 0 : Ye.getWest()) && void 0 !== pt ? pt : 0,
                        south: null !== (Be = null == Ye ? void 0 : Ye.getSouth()) && void 0 !== Be ? Be : 0,
                        east: null !== (ze = null == Ye ? void 0 : Ye.getEast()) && void 0 !== ze ? ze : 0,
                        north: null !== (ye = null == Ye ? void 0 : Ye.getNorth()) && void 0 !== ye ? ye : 0
                    },
                    userZoom: this.map.getZoom(),
                    map: {
                        width: null !== (ge = null == gt ? void 0 : gt.getBoundingClientRect().width) && void 0 !== ge ? ge : 0,
                        height: null !== (Ie = null == gt ? void 0 : gt.getBoundingClientRect().height) && void 0 !== Ie ? Ie : 0
                    }
                }
            }
            getMarkerStructuredObject(pt) {
                const {width: Be, height: ze, x: ye, y: ge} = this.getMarkerDetails(pt);
                return ye && ge && Be && ze ? {
                    marker: {
                        location: {
                            x: ye,
                            y: ge
                        },
                        size: {
                            width: Be,
                            height: ze
                        }
                    }
                } : {}
            }
            getMarkerDetails(pt) {
                const ze = pt.nativeElement.getElementsByClassName("pp-marker-el")[0];
                let ye = null
                  , ge = null
                  , Ie = null
                  , gt = null
                  , Ye = null
                  , yt = ""
                  , ht = "";
                if (ze) {
                    ye = ze ? ze.clientWidth : null,
                    ge = ze ? ze.clientHeight : null,
                    Ie = ze ? ze.style.transform : "";
                    const mo = this.getTranslateValues(Ie);
                    mo && (gt = mo[0],
                    Ye = mo[1])
                }
                return this.currentMarkers.length && (yt = this.currentMarkers[0].pos.lat,
                ht = this.currentMarkers[0].pos.lng),
                {
                    width: null != ye ? ye : 0,
                    height: ge,
                    x: gt,
                    y: Ye,
                    lat: yt,
                    lng: ht
                }
            }
            getTranslateValues(pt) {
                const ze = pt.match(/translate\((\d+)px,\s(\d+)px\)/);
                return ze ? [parseInt(ze[1]), parseInt(ze[2])] : null
            }
            getMapDetails() {
                return {
                    mapboxElement: document.querySelector("pp-poster-map-wrapper")
                }
            }
        }
        var Tt = $(78606);
        const Qe = ["mapElement"];
        function jt(re, pt) {
            1 & re && r.nrm(0, "div", 4)
        }
        function Xe(re, pt) {
            if (1 & re) {
                const Be = r.RV6();
                r.j41(0, "button", 8),
                r.bIt("click", function() {
                    r.eBV(Be);
                    const ye = r.XpG(2);
                    return r.Njj(ye.switchMapLock())
                }),
                r.nrm(1, "svg-icon", 9),
                r.k0s()
            }
            if (2 & re) {
                const Be = r.XpG(2);
                r.R7$(),
                r.Y8G("src", "/assets/pp-posters/maps/icons/padlock-" + (Be.isLocked ? "closed" : "open") + ".svg")
            }
        }
        function Ce(re, pt) {
            if (1 & re) {
                const Be = r.RV6();
                r.j41(0, "div", 5),
                r.DNE(1, Xe, 2, 1, "button", 6),
                r.j41(2, "button", 7),
                r.bIt("click", function() {
                    r.eBV(Be);
                    const ye = r.XpG();
                    return r.Njj(ye.increaseZoom())
                }),
                r.EFF(3, "+"),
                r.k0s(),
                r.j41(4, "button", 7),
                r.bIt("click", function() {
                    r.eBV(Be);
                    const ye = r.XpG();
                    return r.Njj(ye.decreaseZoom())
                }),
                r.EFF(5, "-"),
                r.k0s()()
            }
            if (2 & re) {
                const Be = r.XpG();
                r.AVh("new-zoom", Be.newZoom)("map-navigation-left", Be.navigationLeft),
                r.R7$(),
                r.vxM(Be.isMobile && !Be.hideNativeLock ? 1 : -1)
            }
        }
        let it = ( () => {
            var re;
            class pt {
                set mapboxAccessToken(ze) {
                    this.interactiveMapService = new ct(ze)
                }
                constructor(ze, ye, ge) {
                    this.elementRef = ze,
                    this.renderer2 = ye,
                    this.cdr = ge,
                    this.isSmaller = !1,
                    this.navigationLeft = !1,
                    this.markerByWidth = !1,
                    this.newZoom = !1,
                    this.land = null,
                    this.water = null,
                    this.roads = null,
                    this.isInteractive = !0,
                    this.isMobile = !1,
                    this.isActiveMap = !1,
                    this.blockMapUpdate = !1,
                    this.showMarker = !1,
                    this.markerColor = "#333",
                    this.markerPosition = [0, 0],
                    this.isLocked = !1,
                    this.hideNativeLock = !1,
                    this.markerType = s.sKi.HEART,
                    this.updateMapConfig = new r.bkB,
                    this.updateMarkerConfig = new r.bkB,
                    this.isInitialized = !1,
                    this.lastWidth = 0,
                    this.lastHeight = 0
                }
                ngAfterViewInit() {
                    var ze = this;
                    this.lastHeight !== this.mapElement.nativeElement.offsetHeight && (this.lastHeight = this.mapElement.nativeElement.offsetHeight),
                    this.lastWidth !== this.mapElement.nativeElement.offsetWidth && (this.lastWidth = this.mapElement.nativeElement.offsetWidth),
                    this.interactiveMapService.map = new Me.Map({
                        container: this.mapElement.nativeElement,
                        style: so(this.mapsEndpoint, this.style, 1),
                        bounds: this.viewPort,
                        minZoom: 2,
                        maxZoom: 14,
                        preserveDrawingBuffer: !0,
                        pitchWithRotate: !1
                    }),
                    this.interactiveMapService.map.dragRotate.disable(),
                    this.interactiveMapService.map.touchPitch.disable(),
                    this.interactiveMapService.map.touchZoomRotate.disableRotation(),
                    this.interactiveMapService.mapIsLoaded$.next(!0),
                    document.addEventListener("touchstart", ye => {
                        this.isLocked ? this.interactiveMapService.map.dragPan.disable() : this.interactiveMapService.map.dragPan.enable()
                    }
                    ),
                    document.addEventListener("touchend", ye => {
                        this.interactiveMapService.map.dragPan.enable()
                    }
                    ),
                    this.interactiveMapService.map.on("moveend", (0,
                    Ut.A)(function*() {
                        ze.isInitialized && (yield ze.checkIfCanProcessMapResponse(),
                        ze.interactiveMapService.changeMarkerSize(ze.markerByWidth),
                        yield ze.emitMapStructure())
                    })),
                    this.interactiveMapService.map.resize(),
                    this.interactiveMapService.map.on("styledata", function() {
                        var ye = (0,
                        Ut.A)(function*(ge) {
                            ze.interactiveMapService.changeMarkerSize(ze.markerByWidth),
                            yield ze.checkIfCanProcessMapResponse(),
                            requestAnimationFrame((0,
                            Ut.A)(function*() {
                                ze.recolorWhenCustom(),
                                yield ze.updateMarker()
                            }))
                        });
                        return function(ge) {
                            return ye.apply(this, arguments)
                        }
                    }()),
                    this.interactiveMapService.map.on("sourcedata", function() {
                        var ye = (0,
                        Ut.A)(function*(ge) {
                            ge.isSourceLoaded && !ze.isInitialized && (ze.isInitialized = !0,
                            yield ze.checkIfCanProcessMapResponse(),
                            yield ze.emitMapStructure()),
                            requestAnimationFrame( () => {
                                ze.recolorWhenCustom()
                            }
                            )
                        });
                        return function(ge) {
                            return ye.apply(this, arguments)
                        }
                    }())
                }
                ngOnChanges(ze) {
                    var ye = this;
                    return (0,
                    Ut.A)(function*() {
                        yield ye.mapChanges(ze),
                        setTimeout((0,
                        Ut.A)(function*() {
                            yield ye.mapChanges(ze)
                        }), 100)
                    })()
                }
                mapChanges(ze) {
                    var ye = this;
                    return (0,
                    Ut.A)(function*() {
                        var ge;
                        if (ye.mapElement) {
                            let Ie = !1;
                            ye.lastHeight !== ye.mapElement.nativeElement.offsetHeight && (Ie = !0,
                            ye.lastHeight = ye.mapElement.nativeElement.offsetHeight),
                            ye.lastWidth !== ye.mapElement.nativeElement.offsetWidth && (Ie = !0,
                            ye.lastWidth = ye.mapElement.nativeElement.offsetWidth),
                            Ie && ye.interactiveMapService.map.resize()
                        }
                        null !== (ge = ye.interactiveMapService) && void 0 !== ge && ge.map && (ze.viewPort ? ye.interactiveMapService.map.fitBounds(ye.viewPort, {
                            animate: !1
                        }) : ze.zoom && ye.interactiveMapService.map.setZoom(ye.zoom),
                        ze.style && (ye.interactiveMapService.setMapStyle(ye.mapsEndpoint, ye.style),
                        requestAnimationFrame( () => {
                            ye.recolorWhenCustom()
                        }
                        )),
                        (ze.land || ze.roads || ze.water) && requestAnimationFrame( () => {
                            ye.recolorWhenCustom()
                        }
                        ),
                        (ze.showMarker || ze.markerPosition || ze.markerType || ze.markerColor) && (yield ye.updateMarker()),
                        ye.cdr.detectChanges())
                    })()
                }
                ngOnDestroy() {
                    console.log("DESTROY")
                }
                updateMarker() {
                    var ze = this;
                    return (0,
                    Ut.A)(function*() {
                        ze.showMarker ? yield ze.setMarkers(ze.markerType, ze.markerPosition, ze.markerColor) : yield ze.clearMarkers()
                    })()
                }
                recolorWhenCustom() {
                    var ze = this;
                    return (0,
                    Ut.A)(function*() {
                        if (ze.style === s.c_T.CUSTOM) {
                            ze.land && "null" !== ze.land && (yield ze.interactiveMapService.changeMapColorByLayer(ze.land, "land")),
                            ze.roads && "null" !== ze.roads && (yield ze.interactiveMapService.changeMapColorByLayer(ze.roads, "roads")),
                            ze.water && "null" !== ze.water && (yield ze.interactiveMapService.changeMapColorByLayer(ze.water, "water"));
                            try {
                                yield ze.emitMapStructureEvent()
                            } catch {
                                console.log("catched")
                            }
                        }
                    })()
                }
                setMarkers(ze, ye, ge) {
                    var Ie = this;
                    return (0,
                    Ut.A)(function*() {
                        Ie.interactiveMapService.setMapSettings(ze, ye, Ie.markerByWidth),
                        Ie.renderer2.setProperty(Ie.elementRef.nativeElement, "style", "--marker-color: #".concat(ge));
                        try {
                            yield Ie.emitMapStructureEvent()
                        } catch {
                            console.log("catched")
                        }
                    })()
                }
                clearMarkers() {
                    var ze = this;
                    return (0,
                    Ut.A)(function*() {
                        ze.interactiveMapService.clearMarkers();
                        try {
                            yield ze.emitMapStructureEvent()
                        } catch {
                            console.log("catched")
                        }
                    })()
                }
                emitMapStructureEvent() {
                    var ze = this;
                    return (0,
                    Ut.A)(function*() {
                        ze.isInitialized && (yield ze.emitMapStructure())
                    })()
                }
                checkIfCanProcessMapResponse() {
                    var ze = this;
                    return (0,
                    Ut.A)(function*() {
                        if (ze.blockMapUpdate)
                            return yield function et(re) {
                                return new Promise(pt => {
                                    setTimeout(pt, re)
                                }
                                )
                            }(100),
                            yield ze.checkIfCanProcessMapResponse()
                    })()
                }
                emitMapStructure() {
                    var ze = this;
                    return (0,
                    Ut.A)(function*() {
                        yield ze.checkIfCanProcessMapResponse(),
                        setTimeout( () => {
                            ze.updateMapConfig.emit(ze.interactiveMapService.getMapStructuredObject()),
                            ze.updateMarkerConfig.emit(ze.interactiveMapService.getMarkerStructuredObject(ze.mapElement))
                        }
                        )
                    })()
                }
                increaseZoom() {
                    this.interactiveMapService.map.setZoom(this.interactiveMapService.map.getZoom() + .5)
                }
                decreaseZoom() {
                    this.interactiveMapService.map.setZoom(this.interactiveMapService.map.getZoom() - .5)
                }
                generateSVG() {
                    return this.interactiveMapService.map.getCanvas().toDataURL()
                }
                switchMapLock() {
                    this.isLocked = !this.isLocked
                }
            }
            return (re = pt).\u0275fac = function(ze) {
                return new (ze || re)(r.rXU(r.aKT),r.rXU(r.sFG),r.rXU(r.gRc))
            }
            ,
            re.\u0275cmp = r.VBU({
                type: re,
                selectors: [["pp-poster-map-wrapper"]],
                viewQuery: function(ze, ye) {
                    if (1 & ze && r.GBs(Qe, 5),
                    2 & ze) {
                        let ge;
                        r.mGM(ge = r.lsd()) && (ye.mapElement = ge.first)
                    }
                },
                inputs: {
                    mapsEndpoint: "mapsEndpoint",
                    isSmaller: "isSmaller",
                    mode: "mode",
                    idx: "idx",
                    navigationLeft: "navigationLeft",
                    markerByWidth: "markerByWidth",
                    newZoom: "newZoom",
                    viewPort: "viewPort",
                    zoom: "zoom",
                    style: "style",
                    land: "land",
                    water: "water",
                    roads: "roads",
                    isInteractive: "isInteractive",
                    isMobile: "isMobile",
                    isActiveMap: "isActiveMap",
                    blockMapUpdate: "blockMapUpdate",
                    showMarker: "showMarker",
                    markerColor: "markerColor",
                    markerPosition: "markerPosition",
                    isLocked: "isLocked",
                    hideNativeLock: "hideNativeLock",
                    markerType: "markerType",
                    mapboxAccessToken: "mapboxAccessToken"
                },
                outputs: {
                    updateMapConfig: "updateMapConfig",
                    updateMarkerConfig: "updateMarkerConfig"
                },
                features: [r.OA$],
                decls: 4,
                vars: 5,
                consts: [["mapElement", ""], ["class", "cover", 4, "ngIf"], ["class", "map-navigation", 3, "new-zoom", "map-navigation-left", 4, "ngIf"], ["id", "map"], [1, "cover"], [1, "map-navigation"], [1, "padlock"], [3, "click"], [1, "padlock", 3, "click"], [3, "src"]],
                template: function(ze, ye) {
                    1 & ze && (r.DNE(0, jt, 1, 0, "div", 1)(1, Ce, 6, 5, "div", 2),
                    r.nrm(2, "div", 3, 0)),
                    2 & ze && (r.Y8G("ngIf", !ye.isInteractive),
                    r.R7$(),
                    r.Y8G("ngIf", ye.isActiveMap),
                    r.R7$(),
                    r.ZvI("mapboxgl-map map-mode-", ye.mode, ""))
                },
                dependencies: [Mt.MD, Mt.bT, Tt.DM],
                styles: ['[_nghost-%COMP%]{--marker-color: #E53422;width:100%;height:100%;display:block;position:relative}[_nghost-%COMP%]     .mapboxgl-canvas-container{width:100%;height:100%}[_nghost-%COMP%]   .cover[_ngcontent-%COMP%]{position:absolute;width:100%;height:100%;background:transparent;opacity:.5;z-index:9}[_nghost-%COMP%]   .mapboxgl-map[_ngcontent-%COMP%]{width:100%;height:100%;outline:unset}[_nghost-%COMP%]   .mapboxgl-map[_ngcontent-%COMP%]:before{content:"";position:absolute;height:2px;width:100%}[_nghost-%COMP%]   .mapboxgl-map[_ngcontent-%COMP%]     canvas{outline:unset}[_nghost-%COMP%]   .mapboxgl-map[_ngcontent-%COMP%]     .mapboxgl-control-container{display:none}[_nghost-%COMP%]   .mapboxgl-map[_ngcontent-%COMP%]     .mapbox-canvas{outline:unset}[_nghost-%COMP%]     .mapboxgl-ctrl-bottom-right>.mapboxgl-ctrl-attrib.mapboxgl-compact:after{display:none}[_nghost-%COMP%]     .mapboxgl-ctrl-top-right{display:none}[_nghost-%COMP%]     .mapboxgl-ctrl-top-right .mapboxgl-ctrl-compass{display:none}[_nghost-%COMP%]:hover     .mapboxgl-ctrl-top-right{display:initial;position:relative;z-index:1000}  svg   .marker-stroke{fill:none;stroke:var(--marker-color);stroke-width:3}  svg   .marker-fill{fill:var(--marker-color)}.map-navigation[_ngcontent-%COMP%]{position:absolute;top:2%;right:2%;width:14%;height:40%;max-width:30px;max-height:60px;min-width:30px;min-height:40px;z-index:10}.map-navigation.map-navigation-left[_ngcontent-%COMP%]{right:unset;left:2%}.map-navigation[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{width:100%;height:50%;padding:0;z-index:5;min-width:20px;min-height:20px;background:#fff;border:1px solid #797979;font-size:1.75em;cursor:pointer;outline:unset;display:flex;justify-content:center;align-items:center}.map-navigation[_ngcontent-%COMP%]   button.padlock[_ngcontent-%COMP%]{margin-bottom:4px}.map-navigation[_ngcontent-%COMP%]   button.padlock[_ngcontent-%COMP%]     svg{width:30px;display:block;height:30px;padding:6px;box-sizing:border-box}.map-navigation[_ngcontent-%COMP%]   button.padlock[_ngcontent-%COMP%]     svg path{fill:#fff}.map-navigation[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:hover{opacity:.5}.map-navigation[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:first-child{border-top-left-radius:5px;border-top-right-radius:5px}.map-navigation[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:last-child{border-top:unset;border-bottom-left-radius:5px;border-bottom-right-radius:5px}.map-navigation.new-zoom[_ngcontent-%COMP%]{left:-5%;top:-4%;right:unset;width:18%;height:44%}.map-navigation.new-zoom[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{background:#f77147;border:1px solid #f77147;color:#fff}.map-navigation.new-zoom[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:hover{opacity:1;background:#ea4714}.map-navigation.new-zoom[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:first-child{border-top-left-radius:0;border-top-right-radius:0}.map-navigation.new-zoom[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:last-child{border-top:unset;border-bottom-left-radius:0;border-bottom-right-radius:0}  .marker{position:absolute;left:0;right:0;top:0;bottom:0}  .map-mode-1 .marker{white-space:initial;width:21px;height:21px}  .map-mode-1 .marker svg{width:100%;height:100%}  .map-mode-2 .marker{white-space:initial;width:16px;height:16px}  .map-mode-2 .marker svg{width:100%;height:100%}  .map-mode-3 .marker{white-space:initial;width:11px;height:11px}  .map-mode-3 .marker svg{width:100%;height:100%}']
            }),
            pt
        }
        )()
    }
    ,
    28105: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            Y: () => Be
        });
        var Ut = $(10467)
          , r = $(60177)
          , Mt = $(84412)
          , s = $(21413)
          , so = $(84572)
          , Wt = $(56977)
          , _t = $(5964)
          , Ae = $(67376)
          , Me = $(27617);
        const Tt = (ze, ye) => {
            const ge = function ct(ze, ye, ge, Ie) {
                if (Ie)
                    return {
                        line: ge.jewelryColors,
                        stars: ge.jewelryColors,
                        planets: ge.jewelryColors,
                        moon: ge.jewelryColors,
                        moonBackground: "transparent",
                        sun: ge.jewelryColors,
                        texts: ge.jewelryColors,
                        mapFontSizeFactor: 1,
                        milkyWayFill: ge.jewelryColors,
                        milkyWayOpacity: 0
                    };
                const gt = "#555577"
                  , Ye = {
                    line: "#F6E9D7",
                    stars: "#F6E9D7",
                    planets: "#F37223",
                    moon: "#F6E9D7",
                    moonBackground: gt,
                    sun: "#F3B543",
                    texts: "#F6E9D7",
                    mapFontSizeFactor: 1,
                    milkyWayFill: "#fff",
                    milkyWayOpacity: .1
                }
                  , yt = {
                    line: "#FFF",
                    stars: "#FFF",
                    planets: "#FFF",
                    moon: "#FFF",
                    moonBackground: gt,
                    sun: "#FFF",
                    texts: "#FFF",
                    mapFontSizeFactor: 1.1,
                    milkyWayFill: "#fff",
                    milkyWayOpacity: .1
                };
                switch (ze) {
                case Me.th1.COSMIC_LATTE:
                    return Ye;
                case Me.th1.NAVY:
                case Me.th1.MIDNIGHT_BLUE:
                case Me.th1.BLACK_HOLE:
                case Me.th1.SUPERNOVA:
                case Me.th1.SKY:
                case Me.th1.EMERALD:
                case Me.th1.PURPLE_GALAXY:
                    return yt;
                case Me.th1.COSMIC_LOVE:
                    return {
                        ...yt,
                        mapFontSizeFactor: 1.047617854
                    };
                case Me.th1.DEEP_SPACE_BLUE:
                    return {
                        line: "#0F1C27",
                        stars: "#0F1C27",
                        planets: "#F37223",
                        moon: "#0F1C27",
                        moonBackground: gt,
                        sun: "#F3B543",
                        texts: "#0F1C27",
                        mapFontSizeFactor: 1,
                        milkyWayFill: "#243746",
                        milkyWayOpacity: .1
                    };
                case Me.th1.CUSTOM:
                    return {
                        ...yt,
                        line: "#".concat(ge.starMapsElements),
                        stars: "#".concat(ge.starMapsElements),
                        planets: "#".concat(ge.starMapsElements),
                        moon: "#".concat(ge.starMapsElements),
                        sun: "#".concat(ge.starMapsElements),
                        texts: "#".concat(ge.starMapsElements),
                        milkyWayFill: "#".concat(ge.starMapsElements),
                        mapFontSizeFactor: 1
                    };
                default:
                    return ze
                }
            }(ye.colorScheme, 0, ye, ze.isJewelry)
              , Ie = ge.mapFontSizeFactor
              , gt = 12.43006;
            return {
                width: ze.size,
                language: ye.language,
                planets: {
                    show: ye.planets,
                    names: ye.planetNames,
                    nameStyle: {
                        fill: ge.texts,
                        font: 7.51722 * Ie + 'px Dejavu Sans, "sans-serif", Consolas, sans-serif',
                        fontSize: 7.51722 * Ie + "px",
                        fontFamily: 'Dejavu Sans, "sans-serif", Consolas, sans-serif',
                        align: "left",
                        baseline: "top",
                        threshold: .75
                    },
                    symbols: {
                        sol: {
                            symbol: "\u2609",
                            letter: "Su",
                            stroke: "yellow",
                            fill: ge.sun,
                            text: ge.texts,
                            size: gt
                        },
                        mer: {
                            symbol: "\u263f",
                            letter: "Me",
                            stroke: "aquamarine",
                            fill: ge.planets,
                            text: ge.texts,
                            size: .55 * gt
                        },
                        ven: {
                            symbol: "\u2640",
                            letter: "V",
                            stroke: "orange",
                            fill: ge.planets,
                            text: ge.texts,
                            size: .5 * gt
                        },
                        lun: {
                            symbol: "\u25cf",
                            showAsPlanet: !0,
                            enabled: ye.moon,
                            background: ge.moonBackground,
                            letter: "L",
                            stroke: "blue",
                            fill: ge.moon,
                            text: ge.texts,
                            size: .8 * gt
                        },
                        mar: {
                            symbol: "\u2642",
                            letter: "Ma",
                            stroke: "gold",
                            fill: ge.planets,
                            text: ge.texts,
                            size: .2 * gt
                        },
                        jup: {
                            symbol: "\u2643",
                            letter: "J",
                            stroke: "blanchedalmond",
                            fill: ge.planets,
                            text: ge.texts,
                            size: .9 * gt
                        },
                        sat: {
                            symbol: "\u2644",
                            letter: "Sa",
                            stroke: "violet",
                            fill: ge.planets,
                            text: ge.texts,
                            size: .6 * gt
                        },
                        ura: {
                            symbol: "\u2645",
                            letter: "U",
                            stroke: "pink",
                            fill: ge.planets,
                            text: ge.texts,
                            size: .4 * gt
                        },
                        nep: {
                            symbol: "\u2646",
                            letter: "N",
                            stroke: "turquoise",
                            fill: ge.planets,
                            text: ge.texts,
                            size: .4 * gt
                        },
                        plu: {
                            symbol: "\u2647",
                            letter: "P",
                            stroke: "tomato",
                            fill: ge.planets,
                            text: ge.texts,
                            size: .4 * gt
                        }
                    }
                },
                stars: {
                    show: !0,
                    style: {
                        stroke: ze.isJewelry,
                        strokeColor: ye.jewelryColors,
                        strokeWidth: 4,
                        svgWidth: 1.5,
                        fill: ze.isJewelry ? ye.jewelryBackground : ge.stars,
                        svgFill: ze.isJewelry ? "#FFF" : ge.stars,
                        opacity: 1
                    }
                },
                constellations: {
                    names: ye.constellationsName,
                    lines: ye.constellations,
                    nameStyle: {
                        fill: [ge.texts, ge.texts, ge.texts],
                        opacity: [1, 1, 1],
                        threshold: .9,
                        align: "center",
                        baseline: "middle",
                        font: [6.68855 * Ie + 'px Dejavu Sans, "sans-serif", Helvetica, Arial, sans-serif', 6.68855 * Ie + 'px Dejavu Sans, "sans-serif", Helvetica, Arial, sans-serif', 6.68855 * Ie + 'px Dejavu Sans, "sans-serif", Helvetica, Arial, sans-serif'],
                        fontSize: 6.68855 * Ie + "px",
                        fontFamily: 'Dejavu Sans, "sans-serif", Consolas, sans-serif'
                    },
                    lineStyle: {
                        stroke: [ge.line, ge.line, ge.line],
                        width: [ze.lineWidth, ze.lineWidth, ze.lineWidth],
                        opacity: [1, 1, 1]
                    },
                    bounds: !1
                },
                mw: {
                    show: ye.milkyWay,
                    style: {
                        fill: ge.milkyWayFill,
                        opacity: ge.milkyWayOpacity
                    }
                },
                lines: {
                    ecliptic: {
                        show: ye.ecliptic,
                        stroke: ge.line,
                        dash: [16, 1056 / 72],
                        width: ze.lineWidth,
                        opacity: 1
                    },
                    graticule: {
                        show: ye.grid,
                        stroke: ge.line,
                        width: ze.lineWidth,
                        major: {
                            latitudeLine: ze.isJewelry ? 360 : 15,
                            longitudeLine: 360
                        },
                        minor: {
                            latitudeLine: ze.isJewelry ? 30 : 15,
                            longitudeLine: ze.isJewelry ? 20 : 10
                        },
                        majorExtend: ze.isJewelry ? [[-180, -80], [180, 80]] : [[-180, -90], [180, 90]],
                        opacity: 1
                    },
                    equatorial: {
                        show: !1
                    },
                    galactic: {
                        show: !1
                    },
                    supergalactic: {
                        show: !1
                    }
                }
            }
        }
        ;
        var jt = $(21626)
          , Xe = $(70152)
          , Ce = $(97586)
          , it = $(54438);
        const et = ["d3parent"];
        function re(ze, ye) {
            1 & ze && it.nrm(0, "div", 3),
            2 & ze && it.Y8G("id", ye.ngIf.containerId)
        }
        function pt(ze) {
            return !0
        }
        let Be = ( () => {
            var ze;
            class ye {
                set appConfiguration(Ie) {
                    this.appConfiguration$.next(Ie)
                }
                set skyConfiguration(Ie) {
                    this.skyConfiguration$.next(Ie)
                }
                set location(Ie) {
                    this.location$.next(Ie)
                }
                constructor(Ie) {
                    this.httpClient = Ie,
                    this.appConfiguration$ = new Mt.t(null),
                    this.skyConfiguration$ = new Mt.t(null),
                    this.prevSkyConfiguration = void 0,
                    this.location$ = new Mt.t(null),
                    this.prevLocation = void 0,
                    this.ngUnsubscribe = new s.B,
                    this.isD3Initialized = !1,
                    this.initializationTryCounter = 0,
                    this.previousTimestamp = 0,
                    this.previousLatitude = 0,
                    this.previousLongitude = 0
                }
                ngAfterViewInit() {
                    var Ie = this;
                    (0,
                    so.z)([this.appConfiguration$, this.skyConfiguration$, this.location$]).pipe((0,
                    Wt.Q)(this.ngUnsubscribe), (0,
                    _t.p)( ([gt,Ye,yt]) => !!gt && !!Ye && !!yt), (0,
                    _t.p)(pt), (0,
                    _t.p)( ([,gt,Ye]) => !Ae.isEqual(this.prevSkyConfiguration, gt) || !Ae.isEqual(this.prevLocation, Ye)), (0,
                    Xe.B)(1)).subscribe(function() {
                        var gt = (0,
                        Ut.A)(function*([Ye,yt,ht]) {
                            var mo;
                            const no = !(null === (mo = Ie.prevSkyConfiguration) || void 0 === mo || !mo.language) && Ie.prevSkyConfiguration.language !== yt.language;
                            if (Ie.prevSkyConfiguration = (0,
                            Ae.cloneDeep)(yt),
                            Ie.prevLocation = (0,
                            Ae.cloneDeep)(ht),
                            !Ie.isD3Initialized) {
                                let Co = () => {
                                    console.log("RESOLVER NOT READY")
                                }
                                ;
                                const Lt = new Promise(Ft => {
                                    Co = Ft
                                }
                                );
                                yield Ie.initializeStars(Ye, yt, ht, Co),
                                yield Lt,
                                Ie.isD3Initialized = !0
                            }
                            setTimeout( () => {
                                if (no ? Ie.getCelestial(Ye.id).reload(Tt(Ye, yt)) : Ie.getCelestial(Ye.id).apply(Tt(Ye, yt)),
                                Ie.previousLatitude !== ht.lat || Ie.previousLongitude !== ht.lng || Ie.previousTimestamp !== ht.UTCTimestamp) {
                                    const Co = Ce(new Date).utcOffset() - ht.timezone
                                      , Lt = ht.UTCTimestamp - 60 * Co * 1e3;
                                    Ie.getCelestial(Ye.id).skyview({
                                        date: new Date(Lt),
                                        location: [ht.lat, ht.lng]
                                    }),
                                    Ie.previousLatitude = ht.lat,
                                    Ie.previousLongitude = ht.lng,
                                    Ie.previousTimestamp = ht.UTCTimestamp
                                }
                            }
                            )
                        });
                        return function(Ye) {
                            return gt.apply(this, arguments)
                        }
                    }())
                }
                initializeStars(Ie, gt, Ye, yt) {
                    var ht = this;
                    return (0,
                    Ut.A)(function*() {
                        try {
                            console.log("Initialization try: ".concat(Ie.id, ", ").concat(ht.initializationTryCounter)),
                            ht.getCelestial(Ie.id).display(( (ze, ye) => {
                                const Ie = Tt(ze, ye);
                                return {
                                    adaptable: !1,
                                    width: Ie.width,
                                    container: ze.containerId,
                                    projection: "airy",
                                    transform: "equatorial",
                                    timezoneid: "5FOMB9OXYO0J",
                                    geopos: null,
                                    lang: Ie.language,
                                    center: [0, 0],
                                    follow: "zenith",
                                    controls: !1,
                                    interactive: !1,
                                    form: !1,
                                    formFields: {
                                        download: !0
                                    },
                                    datapath: "/assets/pp-posters/stars/celestial-data/",
                                    stars: {
                                        show: Ie.stars.show,
                                        limit: ze.starLimit,
                                        limitForSVG: 6.2,
                                        colors: !1,
                                        style: Ie.stars.style,
                                        designation: !1,
                                        propername: !1,
                                        size: ze.starSize,
                                        exponent: ze.isJewelry ? -.01 : -.27,
                                        data: ze.isJewelry ? "stars.jewelry.json" : "stars.6.json"
                                    },
                                    dsos: {
                                        show: !1
                                    },
                                    planets: {
                                        show: Ie.planets.show,
                                        which: ["sol", "mer", "ven", "ter", "lun", "mar", "jup", "sat", "ura", "nep"],
                                        symbols: Ie.planets.symbols,
                                        symbolStyle: {
                                            fill: "#00ccff",
                                            font: 'bold 20px "Lucida Sans Unicode", Consolas, sans-serif',
                                            align: "center",
                                            baseline: "middle"
                                        },
                                        symbolType: "disk",
                                        names: Ie.planets.names,
                                        nameStyle: Ie.planets.nameStyle
                                    },
                                    constellations: {
                                        namesType: "iau",
                                        ...Ie.constellations
                                    },
                                    mw: Ie.mw,
                                    lines: Ie.lines,
                                    background: {
                                        fill: "transparent",
                                        opacity: 1,
                                        stroke: "#000000",
                                        width: 0
                                    },
                                    horizon: {
                                        show: !1
                                    },
                                    daylight: {
                                        show: !1
                                    }
                                }
                            }
                            )(Ie, gt)),
                            yt(ht.initializationTryCounter)
                        } catch (mo) {
                            console.log(mo),
                            ht.initializationTryCounter++,
                            ht.timerRef = setTimeout( () => {
                                ht.initializeStars(Ie, gt, Ye, yt)
                            }
                            , 100 * ht.initializationTryCounter)
                        }
                    })()
                }
                ngOnDestroy() {
                    this.ngUnsubscribe.next(!0),
                    this.ngUnsubscribe.complete(),
                    this.timerRef && "number" == typeof this.timerRef && clearTimeout(this.timerRef),
                    this.d3parent.nativeElement.remove()
                }
                exportSvg(Ie) {
                    var gt = this;
                    return (0,
                    Ut.A)(function*() {
                        const Ye = gt.getCelestial(Ie).exportSVG()
                          , yt = yield new Promise(mo => {
                            Ye.then(no => {
                                mo(no)
                            }
                            )
                        }
                        )
                          , ht = yield gt.httpClient.post("/api/stars/d3-celestial/svg", {
                            svg: yt
                        }).toPromise();
                        return null == ht ? void 0 : ht.uuid
                    })()
                }
                getCelestial(Ie) {
                    return 1 === Ie ? Celestial : 2 === Ie ? Celestial2nd : 3 === Ie ? Celestial3rd : void console.log("ID IS NOT SUPPORTED")
                }
            }
            return (ze = ye).\u0275fac = function(Ie) {
                return new (Ie || ze)(it.rXU(jt.Qq))
            }
            ,
            ze.\u0275cmp = it.VBU({
                type: ze,
                selectors: [["pp-poster-stars-area"]],
                viewQuery: function(Ie, gt) {
                    if (1 & Ie && it.GBs(et, 5),
                    2 & Ie) {
                        let Ye;
                        it.mGM(Ye = it.lsd()) && (gt.d3parent = Ye.first)
                    }
                },
                inputs: {
                    appConfiguration: "appConfiguration",
                    skyConfiguration: "skyConfiguration",
                    location: "location"
                },
                decls: 4,
                vars: 3,
                consts: [["d3parent", ""], [1, "stars-wrapper"], [3, "id", 4, "ngIf"], [3, "id"]],
                template: function(Ie, gt) {
                    1 & Ie && (it.j41(0, "div", 1, 0),
                    it.DNE(2, re, 1, 1, "div", 2),
                    it.nI1(3, "async"),
                    it.k0s()),
                    2 & Ie && (it.R7$(2),
                    it.Y8G("ngIf", it.bMT(3, 1, gt.appConfiguration$)))
                },
                dependencies: [r.MD, r.bT, r.Jj, jt.q1],
                styles: ["[_nghost-%COMP%]{width:100%;height:100%;display:block}[_nghost-%COMP%]   .stars-wrapper[_ngcontent-%COMP%]{width:100%;height:100%}[_nghost-%COMP%]   .stars-wrapper[_ngcontent-%COMP%]   #celestial-map[_ngcontent-%COMP%], [_nghost-%COMP%]   .stars-wrapper[_ngcontent-%COMP%]   #celestial-map-jewelry[_ngcontent-%COMP%], [_nghost-%COMP%]   .stars-wrapper[_ngcontent-%COMP%]   #celestial-map-1[_ngcontent-%COMP%], [_nghost-%COMP%]   .stars-wrapper[_ngcontent-%COMP%]   #celestial-map-2[_ngcontent-%COMP%], [_nghost-%COMP%]   .stars-wrapper[_ngcontent-%COMP%]   #celestial-map-3[_ngcontent-%COMP%]{width:100%!important;height:100%!important}[_nghost-%COMP%]   .stars-wrapper[_ngcontent-%COMP%]   #celestial-map[_ngcontent-%COMP%]     canvas, [_nghost-%COMP%]   .stars-wrapper[_ngcontent-%COMP%]   #celestial-map-jewelry[_ngcontent-%COMP%]     canvas, [_nghost-%COMP%]   .stars-wrapper[_ngcontent-%COMP%]   #celestial-map-1[_ngcontent-%COMP%]     canvas, [_nghost-%COMP%]   .stars-wrapper[_ngcontent-%COMP%]   #celestial-map-2[_ngcontent-%COMP%]     canvas, [_nghost-%COMP%]   .stars-wrapper[_ngcontent-%COMP%]   #celestial-map-3[_ngcontent-%COMP%]     canvas{width:100%!important;height:100%!important}"]
            }),
            ye
        }
        )()
    }
    ,
    29865: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            V: () => re
        });
        var Ut = $(10467)
          , r = $(7494)
          , Mt = $(9566)
          , s = $(13620)
          , so = $(61762)
          , Wt = $(69847)
          , _t = $(60177)
          , Ae = $(27617)
          , Me = $(78606)
          , ct = $(50552)
          , Tt = $(41046)
          , Qe = $(54438);
        const jt = ["svgContainer"]
          , Xe = pt => ({
            fill: pt
        });
        function Ce(pt, Be) {
            if (1 & pt && (Qe.j41(0, "div", 11)(1, "div"),
            Qe.nI1(2, "async"),
            Qe.nI1(3, "async"),
            Qe.nrm(4, "svg-icon", 8),
            Qe.nI1(5, "async"),
            Qe.k0s()()),
            2 & pt) {
                let ze, ye;
                const ge = Qe.XpG(2);
                Qe.R7$(),
                Qe.xc7("width", null == (ze = Qe.bMT(2, 6, ge.pretext$)) ? null : ze.width, "px")("margin-bottom", null == (ye = Qe.bMT(3, 8, ge.pretext$)) ? null : ye.marginBottom, "px"),
                Qe.R7$(3),
                Qe.Y8G("svgStyle", Qe.eq3(12, Xe, Qe.bMT(5, 10, ge.textColor$)))("src", "/assets/pp-posters/zodiac/symbol/" + ge.zodiac.selectedZodiac + ".svg")
            }
        }
        function it(pt, Be) {
            if (1 & pt && (Qe.j41(0, "pp-poster-printing-registration", 5)(1, "pp-poster-arrangement-wrapper")(2, "pp-poster-image-area")(3, "div", 6)(4, "div", 7, 1),
            Qe.nrm(6, "svg-icon", 8),
            Qe.k0s()()(),
            Qe.j41(7, "pp-poster-text-area", 9),
            Qe.nI1(8, "async"),
            Qe.nI1(9, "async"),
            Qe.nI1(10, "async"),
            Qe.nI1(11, "async"),
            Qe.nI1(12, "async"),
            Qe.nI1(13, "async"),
            Qe.nI1(14, "async"),
            Qe.DNE(15, Ce, 6, 14, "div", 10),
            Qe.k0s()()()),
            2 & pt) {
                const ze = Be.ngIf
                  , ye = Qe.XpG();
                Qe.Y8G("poster", ze),
                Qe.R7$(3),
                Qe.xc7("margin-top", ye.zodiac.margin, "px")("width", ye.zodiac.width, "px")("height", ye.zodiac.width, "px")("padding", .046 * ye.zodiac.width, "px"),
                Qe.R7$(),
                Qe.xc7("background", ye.zodiac.circleBackground),
                Qe.AVh("circle-background-spiritual", ye.zodiac.zodiacStyle === ye.ZodiacLayoutEnum.SPIRITUAL),
                Qe.R7$(2),
                Qe.Y8G("svgStyle", Qe.eq3(37, Xe, ye.zodiac.color))("src", "/assets/pp-posters/zodiac/sign/" + ye.zodiac.zodiacStyle + "/" + ye.zodiac.selectedZodiac + ".svg"),
                Qe.R7$(),
                Qe.Y8G("poster", Qe.bMT(8, 23, ye.poster$))("color", Qe.bMT(9, 25, ye.textColor$))("textArea", Qe.bMT(10, 27, ye.textArea$))("title", Qe.bMT(11, 29, ye.title$))("subtitle", Qe.bMT(12, 31, ye.subtitle$))("footer", Qe.bMT(13, 33, ye.footer$))("date", Qe.bMT(14, 35, ye.date$)),
                Qe.R7$(8),
                Qe.Y8G("ngIf", ye.zodiac.zodiacSymbol)
            }
        }
        function et(pt, Be) {
            1 & pt && Qe.nrm(0, "pp-poster-loaded-element")
        }
        let re = ( () => {
            var pt;
            class Be extends ct.C {
                constructor(ye, ge, Ie) {
                    super(ye, ge),
                    this.host = ye,
                    this.zone = ge,
                    this.cdr = Ie,
                    this.zodiac = {
                        margin: 0,
                        width: 0,
                        background: "#FFF",
                        color: "#FFF",
                        zodiacSymbol: !1,
                        circleBackground: "transparent",
                        selectedZodiac: Ae.p2u.ARIES,
                        zodiacStyle: Ae.sqx.MODERN
                    },
                    this.ZodiacLayoutEnum = Ae.sqx,
                    this.careAboutSvgVisibility()
                }
                setAllTextSettings(ye) {
                    const ge = {
                        text: ye.customMessage ? ye.title : "",
                        isDefaultFont: !ye.titleFontScript
                    };
                    this.setText(ge, this.title$, {
                        font: null != ge && ge.isDefaultFont ? Ae.n3q.MACHO : Ae.n3q.LUXUS_BRUT,
                        portrait: {
                            sizeFactor: null != ge && ge.isDefaultFont ? .04 : .06,
                            bottomFactor: .0125,
                            topFactor: 0,
                            isBold: !0
                        },
                        horizontal: {
                            sizeFactor: null != ge && ge.isDefaultFont ? .04 : .06,
                            bottomFactor: .008,
                            topFactor: 0,
                            isBold: !0
                        }
                    });
                    const Ie = {
                        text: ye.customMessage ? ye.subtitle : "",
                        isDefaultFont: !ye.subtitleFontScript
                    };
                    this.setText(Ie, this.subtitle$, {
                        font: null != Ie && Ie.isDefaultFont ? Ae.n3q.CAPSUULA : Ae.n3q.LUXUS_BRUT,
                        portrait: {
                            sizeFactor: null != Ie && Ie.isDefaultFont ? .03 : .045,
                            bottomFactor: .0325,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: null != Ie && Ie.isDefaultFont ? .03 : .045,
                            bottomFactor: .0208,
                            topFactor: 0
                        }
                    }),
                    this.setText({
                        text: ye.customMessage ? ye.footer : "",
                        isDefaultFont: !0
                    }, this.footer$, {
                        font: Ae.n3q.CAPSUULA,
                        portrait: {
                            sizeFactor: .025,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: .016,
                            bottomFactor: 0,
                            topFactor: 0
                        }
                    }),
                    this.setText({
                        text: ye.customMessage ? ye.dateField : "",
                        isDefaultFont: !0
                    }, this.date$, {
                        font: Ae.n3q.CAPSUULA,
                        portrait: {
                            sizeFactor: .025,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: .016,
                            bottomFactor: 0,
                            topFactor: 0
                        }
                    })
                }
                setTextArea(ye) {
                    this.textArea$.next({
                        bottomFactor: ye.isPortrait ? .08 : .06,
                        marginFactor: ye.isPortrait ? .07 : .04
                    }),
                    this.setPretext(ye)
                }
                setDesign(ye, ge) {
                    var Ie = this;
                    return (0,
                    Ut.A)(function*() {
                        Ie.zodiac.margin = ye.isPortrait ? .04 * ye.size.width : .02 * ye.size.width,
                        Ie.zodiac.width = ye.isPortrait ? .9 * ye.size.width : .69 * ye.size.height,
                        Ie.zodiac.background = Ie.zodiacBackground(ge.colorScheme, ge.customColors, Ie.isFinalPoster),
                        Ie.zodiac.color = Ie.zodiacColor(ge.colorScheme, ge.customColors),
                        Ie.zodiac.circleBackground = Ie.circleColor(ge.colorScheme, ge.zodiacSign, Ie.isFinalPoster),
                        Ie.zodiac.selectedZodiac = ge.zodiacSign,
                        Ie.zodiac.zodiacStyle = ge.layout,
                        Ie.zodiac.zodiacSymbol = ge.zodiacSymbol,
                        Ie.textColor$.next(Ie.getTextColor(ge.colorScheme, ge.customColors))
                    })()
                }
                setPretext(ye) {
                    this.pretext$.next({
                        width: ye.isPortrait ? .045 * ye.size.width : .035 * ye.size.height,
                        marginBottom: ye.isPortrait ? .02 * ye.size.width : .015 * ye.size.height
                    })
                }
                careAboutSvgVisibility() {
                    var ye;
                    const ge = null === (ye = this.svgContainer) || void 0 === ye || null === (ye = ye.nativeElement) || void 0 === ye ? void 0 : ye.querySelector("svg");
                    ge && ge.clientWidth > 0 ? this.onImageLoad() : setTimeout( () => {
                        this.careAboutSvgVisibility()
                    }
                    , 100)
                }
                onImageLoad() {
                    this.load++,
                    1 === this.load && (this.initiateRender(),
                    this.cdr.detectChanges())
                }
                getTextColor(ye, ge) {
                    switch (ye) {
                    case Ae.Q86.PURPLE_GALAXY:
                    case Ae.Q86.EMERALD:
                    case Ae.Q86.SKY:
                    default:
                        return "#FFF";
                    case Ae.Q86.DEEP_SPACE_BLUE:
                        return "#f6E5CE";
                    case Ae.Q86.AURA:
                    case Ae.Q86.COSMIC_LATTE:
                    case Ae.Q86.SIMPLE:
                        return "#0f1721";
                    case Ae.Q86.CUSTOM:
                        return "#".concat(ge.zodiac)
                    }
                }
                prodPath(ye) {
                    return ye ? "_HQ_/" : ""
                }
                zodiacBackground(ye, ge, Ie) {
                    switch (ye) {
                    case Ae.Q86.SKY:
                        return "url('/assets/pp-posters/zodiac/".concat(this.prodPath(Ie), "background/SKY.jpg') center/cover no-repeat border-box");
                    case Ae.Q86.PURPLE_GALAXY:
                        return "url('/assets/pp-posters/zodiac/".concat(this.prodPath(Ie), "background/PURPLE_GALAXY.jpg') center/cover no-repeat border-box");
                    case Ae.Q86.EMERALD:
                        return "url('/assets/pp-posters/zodiac/".concat(this.prodPath(Ie), "background/EMERALD.jpg') center/cover no-repeat border-box");
                    case Ae.Q86.COSMIC_LATTE:
                    case Ae.Q86.AURA:
                        return "#f6E5CE";
                    case Ae.Q86.DEEP_SPACE_BLUE:
                        return "#0f1721";
                    case Ae.Q86.SIMPLE:
                        return "#FFF";
                    case Ae.Q86.CUSTOM:
                        return "#".concat(ge.background)
                    }
                }
                zodiacColor(ye, ge) {
                    switch (ye) {
                    case Ae.Q86.PURPLE_GALAXY:
                    case Ae.Q86.EMERALD:
                    case Ae.Q86.SIMPLE:
                    case Ae.Q86.AURA:
                    case Ae.Q86.SKY:
                        return "#FFF";
                    case Ae.Q86.COSMIC_LATTE:
                        return "#f6E5CE";
                    case Ae.Q86.DEEP_SPACE_BLUE:
                        return "#0f1721";
                    case Ae.Q86.CUSTOM:
                        return "#".concat(ge.zodiac)
                    }
                }
                circleColor(ye, ge, Ie) {
                    switch (ye) {
                    case Ae.Q86.PURPLE_GALAXY:
                    case Ae.Q86.EMERALD:
                    case Ae.Q86.SKY:
                    case Ae.Q86.CUSTOM:
                        return "transparent";
                    case Ae.Q86.SIMPLE:
                        return "#0e1111";
                    case Ae.Q86.DEEP_SPACE_BLUE:
                        return "#f6E5CE";
                    case Ae.Q86.COSMIC_LATTE:
                        return "#0f1721";
                    case Ae.Q86.AURA:
                        return "url(/assets/pp-posters/zodiac/".concat(this.prodPath(Ie), "auraCircle/").concat(ge, ".png) center/cover no-repeat border-box")
                    }
                }
            }
            return (pt = Be).\u0275fac = function(ye) {
                return new (ye || pt)(Qe.rXU(Qe.aKT),Qe.rXU(Qe.SKi),Qe.rXU(Qe.gRc))
            }
            ,
            pt.\u0275cmp = Qe.VBU({
                type: pt,
                selectors: [["pp-poster-zodiac"]],
                viewQuery: function(ye, ge) {
                    if (1 & ye && Qe.GBs(jt, 5),
                    2 & ye) {
                        let Ie;
                        Qe.mGM(Ie = Qe.lsd()) && (ge.svgContainer = Ie.first)
                    }
                },
                features: [Qe.Vt3],
                decls: 5,
                vars: 5,
                consts: [["posterWrapper", ""], ["svgContainer", ""], [3, "background"], [3, "poster", 4, "ngIf"], [4, "ngIf"], [3, "poster"], [1, "zodiac-instance"], [1, "circle-background"], [3, "svgStyle", "src"], [3, "poster", "color", "textArea", "title", "subtitle", "footer", "date"], ["class", "sign", "pretext", "", 4, "ngIf"], ["pretext", "", 1, "sign"]],
                template: function(ye, ge) {
                    1 & ye && (Qe.j41(0, "pp-poster-background", 2, 0),
                    Qe.DNE(2, it, 16, 39, "pp-poster-printing-registration", 3),
                    Qe.nI1(3, "async"),
                    Qe.k0s(),
                    Qe.DNE(4, et, 1, 0, "pp-poster-loaded-element", 4)),
                    2 & ye && (Qe.Y8G("background", ge.zodiac.background),
                    Qe.R7$(2),
                    Qe.Y8G("ngIf", Qe.bMT(3, 3, ge.poster$)),
                    Qe.R7$(2),
                    Qe.Y8G("ngIf", ge.isImageRendered))
                },
                dependencies: [_t.MD, _t.bT, _t.Jj, r.Z, Mt.R, Wt.c, s.y, so.W, Me.iu, Me.DM, Tt.C],
                styles: ["[_nghost-%COMP%]{width:100%;height:100%;display:block}[_nghost-%COMP%]   .zodiac-instance[_ngcontent-%COMP%]{box-sizing:border-box}[_nghost-%COMP%]   .zodiac-instance[_ngcontent-%COMP%]   .circle-background[_ngcontent-%COMP%]{width:100%;height:100%;border-radius:50%;box-sizing:border-box}[_nghost-%COMP%]   .sign[_ngcontent-%COMP%]{display:flex;width:100%;justify-content:center}"]
            }),
            Be
        }
        )()
    }
    ,
    32055: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            i: () => re
        });
        var Ut = $(10467)
          , r = $(7494)
          , Mt = $(9566)
          , s = $(13620)
          , so = $(61762)
          , Wt = $(69847)
          , _t = $(60177)
          , Ae = $(27617)
          , Me = $(74412)
          , ct = $(15996)
          , Tt = $(50552)
          , Qe = $(41046)
          , jt = $(93967)
          , Xe = $(66985)
          , Ce = $(54438);
        function it(pt, Be) {
            if (1 & pt) {
                const ze = Ce.RV6();
                Ce.j41(0, "pp-poster-printing-registration", 3)(1, "pp-poster-arrangement-wrapper")(2, "pp-poster-image-area", 4)(3, "img", 5),
                Ce.bIt("load", function() {
                    Ce.eBV(ze);
                    const ge = Ce.XpG();
                    return Ce.Njj(ge.onImageLoad())
                }),
                Ce.k0s(),
                Ce.nrm(4, "pp-poster-preview", 6),
                Ce.k0s(),
                Ce.nrm(5, "pp-poster-text-area", 7),
                Ce.nI1(6, "async"),
                Ce.nI1(7, "async"),
                Ce.nI1(8, "async"),
                Ce.nI1(9, "async"),
                Ce.nI1(10, "async"),
                Ce.k0s()()
            }
            if (2 & pt) {
                const ze = Be.ngIf
                  , ye = Ce.XpG();
                Ce.Y8G("poster", ze),
                Ce.R7$(2),
                Ce.Y8G("relative", !0),
                Ce.R7$(),
                Ce.xc7("margin-top", ye.moon.margin, "px")("width", ye.moon.width, "px")("height", ye.moon.width, "px")("transform", "rotate(" + ye.moon.rotation + "deg)"),
                Ce.Y8G("src", ye.moon.image, Ce.B4B),
                Ce.R7$(),
                Ce.Y8G("showPreview", !ye.isFinalPoster)("marginTop", !1)("previewType", "moon"),
                Ce.R7$(),
                Ce.Y8G("poster", ze)("color", Ce.bMT(6, 20, ye.textColor$))("textArea", Ce.bMT(7, 22, ye.textArea$))("title", Ce.bMT(8, 24, ye.title$))("subtitle", Ce.bMT(9, 26, ye.subtitle$))("footer", Ce.bMT(10, 28, ye.footer$))
            }
        }
        function et(pt, Be) {
            1 & pt && Ce.nrm(0, "pp-poster-loaded-element")
        }
        let re = ( () => {
            var pt;
            class Be extends Tt.C {
                constructor(ye, ge, Ie) {
                    super(ye, ge),
                    this.host = ye,
                    this.zone = ge,
                    this.cdr = Ie,
                    this.moon = {
                        margin: 0,
                        width: 0,
                        background: "#FFF",
                        image: "",
                        rotation: 0,
                        selectedByDate: !1
                    }
                }
                setAllTextSettings(ye) {
                    const ge = ye.moonConfig[0]
                      , Ie = {
                        text: ge.customMessage ? ge.title : "",
                        isDefaultFont: !ge.titleFontScript
                    };
                    this.setText(Ie, this.title$, {
                        font: null != Ie && Ie.isDefaultFont ? Ae.n3q.MACHO : Ae.n3q.LUXUS_BRUT,
                        portrait: {
                            sizeFactor: null != Ie && Ie.isDefaultFont ? .04 : .06,
                            bottomFactor: .0125,
                            topFactor: 0,
                            isBold: !0
                        },
                        horizontal: {
                            sizeFactor: null != Ie && Ie.isDefaultFont ? .04 : .06,
                            bottomFactor: .008,
                            topFactor: 0,
                            isBold: !0
                        }
                    });
                    const gt = {
                        text: ge.customMessage ? ge.subtitle : "",
                        isDefaultFont: !ge.subtitleFontScript
                    };
                    this.setText(gt, this.subtitle$, {
                        font: null != gt && gt.isDefaultFont ? Ae.n3q.MACHO : Ae.n3q.LUXUS_BRUT,
                        portrait: {
                            sizeFactor: null != gt && gt.isDefaultFont ? .03 : .045,
                            bottomFactor: .0325,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: null != gt && gt.isDefaultFont ? .03 : .045,
                            bottomFactor: .0208,
                            topFactor: 0
                        }
                    }),
                    this.setText({
                        text: ge.customMessage ? ge.footer : "",
                        isDefaultFont: !0
                    }, this.footer$, {
                        font: Ae.n3q.MACHO,
                        portrait: {
                            sizeFactor: .025,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: .016,
                            bottomFactor: 0,
                            topFactor: 0
                        }
                    })
                }
                setTextArea(ye) {
                    this.textArea$.next({
                        bottomFactor: ye.isPortrait ? .08 : .06,
                        marginFactor: ye.isPortrait ? .07 : .04
                    })
                }
                setDesign(ye, ge) {
                    var Ie = this;
                    return (0,
                    Ut.A)(function*() {
                        const gt = ge.moonConfig[0];
                        var Ye;
                        Ie.moon.margin = ye.isPortrait ? .04 * ye.size.width : .02 * ye.size.width,
                        Ie.moon.width = ye.isPortrait ? .9 * ye.size.width : .74 * ye.size.height,
                        Ie.moon.background = (0,
                        Me.G)(ge.style, Ie.isFinalPoster, ge.customBackground, (0,
                        jt.v)(ye)),
                        gt.selectedByDate ? (Ie.moon.image = "/assets/pp-posters/moon/".concat(Ie.isFinalPoster ? "_HQ_/" : "", "moon_").concat(ge.shadowMoon ? "shadow" : "transparent", "/").concat(gt.moon, ".png"),
                        Ie.moon.rotation = gt.moonRotation) : (Ie.moon.image = "/assets/pp-posters/moon/".concat(Ie.isFinalPoster ? "_HQ_/" : "", "moon_selected_").concat(ge.shadowMoon ? "shadow" : "transparent", "/").concat(gt.selectPhase, ".png"),
                        null !== (Ye = gt.place) && void 0 !== Ye && null !== (Ye = Ye.center) && void 0 !== Ye && Ye.latitude && (Ie.moon.rotation = gt.place.center.latitude > 0 ? 0 : 180)),
                        Ie.textColor$.next(Ie.getTextColor(ge.style, ge.customBackground))
                    })()
                }
                getTextColor(ye, ge) {
                    return ye === Ae.O8Z.CUSTOM ? (0,
                    ct.V)(ge) ? "#FFF" : "#000" : ye === Ae.O8Z.MARSHMALLOW ? "#666666" : [Ae.O8Z.WHITE, Ae.O8Z.CREAM].includes(ye) ? "#000" : "#FFF"
                }
                onImageLoad() {
                    this.load++,
                    1 === this.load && (this.initiateRender(),
                    this.cdr.detectChanges())
                }
            }
            return (pt = Be).\u0275fac = function(ye) {
                return new (ye || pt)(Ce.rXU(Ce.aKT),Ce.rXU(Ce.SKi),Ce.rXU(Ce.gRc))
            }
            ,
            pt.\u0275cmp = Ce.VBU({
                type: pt,
                selectors: [["pp-poster-moon"]],
                features: [Ce.Vt3],
                decls: 4,
                vars: 5,
                consts: [[3, "background"], [3, "poster", 4, "ngIf"], [4, "ngIf"], [3, "poster"], [3, "relative"], [1, "moon-instance", 3, "load", "src"], [3, "showPreview", "marginTop", "previewType"], [3, "poster", "color", "textArea", "title", "subtitle", "footer"]],
                template: function(ye, ge) {
                    1 & ye && (Ce.j41(0, "pp-poster-background", 0),
                    Ce.DNE(1, it, 11, 30, "pp-poster-printing-registration", 1),
                    Ce.nI1(2, "async"),
                    Ce.k0s(),
                    Ce.DNE(3, et, 1, 0, "pp-poster-loaded-element", 2)),
                    2 & ye && (Ce.Y8G("background", ge.moon.background),
                    Ce.R7$(),
                    Ce.Y8G("ngIf", Ce.bMT(2, 3, ge.poster$)),
                    Ce.R7$(2),
                    Ce.Y8G("ngIf", ge.isImageRendered))
                },
                dependencies: [r.Z, Mt.R, Wt.c, s.y, so.W, _t.MD, _t.bT, _t.Jj, Qe.C, Xe.P],
                styles: ["[_nghost-%COMP%]{width:100%;height:100%;display:block}[_nghost-%COMP%]   img.moon-instance[_ngcontent-%COMP%]{width:100%;height:100%}"]
            }),
            Be
        }
        )()
    }
    ,
    32077: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            t: () => ye
        });
        var Ut = $(10467)
          , r = $(54438)
          , Mt = $(9566)
          , s = $(60177)
          , so = $(27617)
          , Wt = $(78606)
          , _t = $(28105)
          , Ae = $(84412)
          , Me = $(7430)
          , ct = $(54843)
          , Tt = $(96354)
          , Qe = $(76675)
          , jt = $(63597)
          , Xe = $(5116)
          , Ce = $(66985)
          , it = $(21626)
          , et = $(345);
        const re = ge => ({
            fill: ge,
            stroke: "transparent"
        });
        function pt(ge, Ie) {
            if (1 & ge && (r.nrm(0, "pp-poster-stars-area", 10),
            r.nI1(1, "async"),
            r.nI1(2, "async"),
            r.nI1(3, "async")),
            2 & ge) {
                const gt = r.XpG();
                r.Y8G("appConfiguration", r.bMT(1, 3, gt.appConfigurationJewelry$))("location", r.bMT(2, 5, gt.location$))("skyConfiguration", r.bMT(3, 7, gt.skyConfiguration$))
            }
        }
        function Be(ge, Ie) {
            if (1 & ge && r.nrm(0, "div", 11, 0),
            2 & ge) {
                const gt = r.XpG();
                r.AVh("preview", !gt.isFinalPoster),
                r.Y8G("innerHTML", gt.stars.image, r.npT)
            }
        }
        let ye = ( () => {
            var ge;
            class Ie extends jt.l {
                constructor(Ye, yt, ht, mo, no) {
                    super(Ye, yt, ht, mo, no),
                    this.host = Ye,
                    this.zone = yt,
                    this.httpClient = ht,
                    this.domSanitizer = mo,
                    this.cdr = no,
                    this.hideSwitchers = !1,
                    this.showFrontOnInit = !0,
                    this.showAvers = new r.bkB(!1),
                    this.stars = {
                        uuid: void 0,
                        image: "",
                        text: ""
                    },
                    this.starsJewelry = {
                        starsUrl: "",
                        textUrl: "",
                        titleFontSize: "1px",
                        material: so.Xl7["14kgold"],
                        setup: so.Hyl.charm,
                        color: "transparent"
                    },
                    this.appConfigurationJewelry$ = new Ae.t(null),
                    this.skyConfiguration$ = new Ae.t(null),
                    this.location$ = new Ae.t(null)
                }
                setAllTextSettings(Ye) {
                    setTimeout( () => {
                        this.setMap(Ye)
                    }
                    , 200)
                }
                setDesign(Ye, yt) {
                    var ht = this;
                    return (0,
                    Ut.A)(function*() {
                        var mo;
                        if (ht.isSvgStars && (ht.stars.uuid = yt.starMapConfig[0].uuid),
                        ht.textColor$.next(ht.textColor(yt.colorScheme, yt.customColors)),
                        !ht.isSvgStars)
                            return;
                        const Co = yield ht.httpClient.get("/api/stars/d3-celestial/svg", {
                            params: {
                                uuid: null !== (mo = ht.stars.uuid) && void 0 !== mo ? mo : ""
                            },
                            responseType: "text"
                        }).toPromise();
                        if (!Co)
                            return;
                        let Ft = (new DOMParser).parseFromString(Co, "image/svg+xml");
                        Ft = (0,
                        Xe.t2)(Ft, !1),
                        Ft = (0,
                        Xe.Jr)(Ft),
                        ht.stars.image = ht.domSanitizer.bypassSecurityTrustHtml(Ft.documentElement.outerHTML),
                        setTimeout( () => {
                            (0,
                            Xe.Gj)(ht.starsSvg.nativeElement)
                        }
                        )
                    })()
                }
                setJewelry(Ye, yt) {
                    var ht = this;
                    return (0,
                    Ut.A)(function*() {
                        var mo;
                        ht.setMap(yt);
                        const no = yt.starMapConfig[0];
                        if (ht.starsJewelry.textUrl = yield(0,
                        ct._)(ht.httpClient.post("".concat(window.location.origin, "/api/stars/jewelry/text"), {
                            title: no.title,
                            titleFontScript: no.titleFont,
                            footer: "".concat(no.coordinates, "\n").concat(no.dateField)
                        }).pipe((0,
                        Tt.T)(co => (0,
                        Qe.ID)("image/svg+xml", co.image)))),
                        ht.starsJewelry.material = yt.material,
                        ht.starsJewelry.setup = yt.setup,
                        ht.starsJewelry.color = Qe.fd[yt.material],
                        !ht.isSvgStars)
                            return;
                        ht.stars.uuid = no.uuid;
                        const Co = yield(0,
                        ct._)(ht.httpClient.get("/api/stars/d3-celestial/svg", {
                            params: {
                                uuid: null !== (mo = ht.stars.uuid) && void 0 !== mo ? mo : "",
                                onlyCircle: !0
                            },
                            responseType: "text"
                        }));
                        if (!Co)
                            return;
                        let Ft = (new DOMParser).parseFromString(Co, "image/svg+xml");
                        Ft = (0,
                        Xe.t2)(Ft, !0, !0),
                        ht.stars.image = ht.domSanitizer.bypassSecurityTrustHtml(Ft.documentElement.outerHTML.replace(/<svg /, '<svg id="pp-element-loaded" '))
                    })()
                }
                setMap(Ye) {
                    var yt;
                    const ht = Ye.starMapConfig[0];
                    null != ht && ht.date && null != ht && null !== (yt = ht.place) && void 0 !== yt && yt.center && this.location$.next({
                        UTCTimestamp: ht.date,
                        timezone: ht.timezone,
                        lat: ht.place.center.latitude,
                        lng: ht.place.center.longitude
                    }),
                    this.skyConfiguration$.next({
                        ecliptic: Ye.ecliptic,
                        constellations: Ye.constellations,
                        constellationsName: Ye.constellationsName,
                        planets: Ye.planets,
                        planetNames: Ye.planetNames,
                        milkyWay: Ye.milkyWay,
                        grid: Ye.grid,
                        moon: Ye.moon,
                        colorScheme: Ye.colorScheme,
                        shape: Ye.shape,
                        jewelryColors: Qe.fd[Ye.material],
                        jewelryBackground: Qe.x_[Ye.material],
                        language: "ja" === Ye.lang ? "en" : Ye.lang,
                        ...Ye.customColors
                    }),
                    this.appConfigurationJewelry$.next({
                        size: 450,
                        id: 2,
                        starLimit: 14,
                        starSize: 2,
                        lineWidth: 1.5,
                        isJewelry: !0,
                        containerId: "celestial-map-jewelry"
                    })
                }
            }
            return (ge = Ie).\u0275fac = function(Ye) {
                return new (Ye || ge)(r.rXU(r.aKT),r.rXU(r.SKi),r.rXU(it.Qq),r.rXU(et.up),r.rXU(r.gRc))
            }
            ,
            ge.\u0275cmp = r.VBU({
                type: ge,
                selectors: [["pp-jewelry-stars"]],
                inputs: {
                    hideSwitchers: "hideSwitchers",
                    showFrontOnInit: "showFrontOnInit"
                },
                outputs: {
                    showAvers: "showAvers"
                },
                features: [r.Vt3],
                decls: 10,
                vars: 18,
                consts: [["starsSvg", ""], [3, "background"], [3, "showAvers", "material", "setup", "hideSwitchers", "showFront"], ["slot", "front"], [3, "appConfiguration", "location", "skyConfiguration", 4, "ngIf"], ["class", "stars-svg", 3, "preview", "innerHTML", 4, "ngIf"], [3, "showPreview", "marginTop", "maxWidth", "previewType"], ["slot", "back"], [1, "back-center"], [3, "src", "svgStyle"], [3, "appConfiguration", "location", "skyConfiguration"], [1, "stars-svg", 3, "innerHTML"]],
                template: function(Ye, yt) {
                    1 & Ye && (r.j41(0, "pp-poster-background", 1)(1, "pp-poster-jewelry-area", 2),
                    r.bIt("showAvers", function(mo) {
                        return yt.showAvers.emit(mo)
                    }),
                    r.j41(2, "div", 3)(3, "div"),
                    r.DNE(4, pt, 4, 9, "pp-poster-stars-area", 4)(5, Be, 2, 3, "div", 5),
                    r.nrm(6, "pp-poster-preview", 6),
                    r.k0s()(),
                    r.j41(7, "div", 7)(8, "div", 8),
                    r.nrm(9, "svg-icon", 9),
                    r.k0s()()()()),
                    2 & Ye && (r.Y8G("background", "transparent"),
                    r.R7$(),
                    r.Y8G("material", yt.starsJewelry.material)("setup", yt.starsJewelry.setup)("hideSwitchers", yt.hideSwitchers)("showFront", yt.showFrontOnInit),
                    r.R7$(2),
                    r.ZvI("front-center front-center-", yt.starsJewelry.setup, ""),
                    r.R7$(),
                    r.Y8G("ngIf", !yt.isSvgStars),
                    r.R7$(),
                    r.Y8G("ngIf", yt.isSvgStars),
                    r.R7$(),
                    r.Y8G("showPreview", !yt.isFinalPoster)("marginTop", !1)("maxWidth", 100)("previewType", "jewelry"),
                    r.R7$(3),
                    r.Y8G("src", yt.starsJewelry.textUrl)("svgStyle", r.eq3(16, re, yt.starsJewelry.color)))
                },
                dependencies: [s.MD, s.bT, s.Jj, Mt.R, _t.Y, Wt.iu, Wt.DM, Me.R, Ce.P],
                styles: ["[_nghost-%COMP%]{width:100%;height:100%;display:block}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]{box-sizing:border-box;position:relative;overflow:hidden}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .background-area[_ngcontent-%COMP%]{width:100%;height:100%;box-sizing:border-box;margin:auto}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .background-area[_ngcontent-%COMP%]   .circle-background[_ngcontent-%COMP%]{width:100%;height:100%;border-radius:50%;box-sizing:border-box}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .stars-area[_ngcontent-%COMP%]{margin:auto;position:absolute;top:0;right:0;bottom:0;left:0}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]{position:absolute;top:0;right:0;bottom:0;left:0}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .shield-border[_ngcontent-%COMP%]{position:absolute;top:1px;right:1px;bottom:1px;left:1px;border-style:solid;border-radius:100%}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .shield-image[_ngcontent-%COMP%]{position:absolute;top:0;right:0;bottom:0;left:0}[_nghost-%COMP%]   .sign[_ngcontent-%COMP%]{display:flex;width:100%;justify-content:center;color:red}[_nghost-%COMP%]   .front-center-charm[_ngcontent-%COMP%]{width:85.5%!important;margin-left:7.5%!important;margin-top:15.5%!important}[_nghost-%COMP%]   .front-center-charm-with-chain[_ngcontent-%COMP%]{width:74.8%!important;margin-left:12.6%!important;margin-top:24.9%!important}[_nghost-%COMP%]   .front-center-black-cord-bracelet[_ngcontent-%COMP%], [_nghost-%COMP%]   .front-center-silver-bracelet[_ngcontent-%COMP%]{width:67.4%!important;margin-left:16.9%!important;margin-top:20.1%!important}.stars-svg[_ngcontent-%COMP%]{width:100%;height:100%;box-sizing:border-box}.stars-svg[_ngcontent-%COMP%]     svg{width:100%;height:100%}.stars-svg[_ngcontent-%COMP%]     svg g#planesecliptic path{stroke-width:2.2222220833px;vector-effect:non-scaling-stroke!important;stroke-dasharray:66 61.2500000005}.stars-svg[_ngcontent-%COMP%]     svg g#constLines path{stroke-width:2.2222220833px;vector-effect:non-scaling-stroke!important}.stars-svg[_ngcontent-%COMP%]     svg g#gridLines path{stroke-width:1.1104166667px;vector-effect:non-scaling-stroke!important}.stars-svg.preview[_ngcontent-%COMP%]     svg g#constLines path, .stars-svg.preview[_ngcontent-%COMP%]     svg g#planesecliptic path{stroke-width:.5333333px}.stars-svg.preview[_ngcontent-%COMP%]     svg g#gridLines path{stroke-width:.2665px}"]
            }),
            Ie
        }
        )()
    }
    ,
    37187: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            $T: () => Wt.$,
            DE: () => Ce.D,
            F5: () => Mt.F,
            Gr: () => Qe.G,
            JZ: () => so.J,
            Jx: () => Be.J,
            Lt: () => jt.L,
            Vr: () => Ut.V,
            Vt: () => ye.V,
            Zl: () => re.Z,
            Zx: () => Me.Z,
            _I: () => s._,
            ah: () => _t.a,
            bG: () => it.b,
            bq: () => ge.b,
            hz: () => Ie.h,
            i8: () => r.i,
            ik: () => ze.i,
            n9: () => Tt.n,
            op: () => Ae.o,
            qu: () => ct.q,
            ti: () => pt.t,
            tu: () => Xe.t
        });
        var Ut = $(29865)
          , r = $(32055)
          , Mt = $(5829)
          , s = $(94917)
          , so = $(46341)
          , Wt = $(2227)
          , _t = $(92237)
          , Ae = $(84457)
          , Me = $(69307)
          , ct = $(78981)
          , Tt = $(80673)
          , Qe = $(80069)
          , jt = $(71683)
          , Xe = $(92034)
          , Ce = $(14308)
          , it = $(57761)
          , re = ($(87745),
        $(76881))
          , pt = $(32077)
          , Be = $(71121)
          , ze = $(72901)
          , ye = $(60333)
          , ge = $(1501)
          , Ie = $(8427)
    }
    ,
    46341: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            J: () => He
        });
        var Ut = $(10467)
          , r = $(54438)
          , Mt = $(7494)
          , s = $(9566)
          , so = $(69847)
          , Wt = $(60177)
          , _t = $(84412)
          , Ae = $(84572)
          , Me = $(56977)
          , ct = $(27617)
          , Tt = $(78606)
          , Qe = $(50552)
          , jt = $(70152)
          , Xe = $(49427)
          , Ce = $(61762)
          , it = $(96354)
          , et = $(76675)
          , re = $(21626);
        const pt = oe => ({
            "max-width": "100%",
            "max-height": "100%",
            width: "100%",
            height: "100%",
            fill: oe
        });
        function Be(oe, ue) {
            if (1 & oe && (r.j41(0, "div", 5),
            r.EFF(1),
            r.k0s()),
            2 & oe) {
                const J = r.XpG(2);
                r.xc7("font-size", J.custom.fontSize, "px")("height", J.custom.textHeight, "px")("font-family", J.custom.fontFamily)("color", "#" + J.color),
                r.R7$(),
                r.SpI(" ", J.custom.text, " ")
            }
        }
        function ze(oe, ue) {
            if (1 & oe && r.nrm(0, "svg-icon", 4),
            2 & oe) {
                const J = r.XpG(3);
                r.Y8G("svgStyle", r.eq3(2, pt, "#" + J.color))("src", J.themeUrl)
            }
        }
        function ye(oe, ue) {
            if (1 & oe && r.DNE(0, ze, 1, 4, "svg-icon", 6),
            2 & oe) {
                const J = r.XpG(2);
                r.Y8G("ngIf", J.enabled && J.themeUrl)
            }
        }
        function ge(oe, ue) {
            if (1 & oe && (r.j41(0, "div", 1)(1, "div", 2),
            r.DNE(2, Be, 2, 9, "div", 3)(3, ye, 1, 1, "svg-icon", 4),
            r.k0s()()),
            2 & oe) {
                const J = r.XpG();
                r.xc7("height", J.wrapperHeight, "px"),
                r.R7$(),
                r.xc7("justify-content", J.position === J.PhotoThemePosition.TOP ? "flex-start" : J.position === J.PhotoThemePosition.BOTTOM ? "flex-end" : "center"),
                r.AVh("svg-position-custom", J.custom.enabled),
                r.R7$(),
                r.vxM(J.custom.enabled ? 2 : 3)
            }
        }
        let gt = ( () => {
            var oe;
            class ue {
                set themeId(q) {
                    q !== this.lastThemeId && q && (this.lastThemeId = q,
                    this.httpClient.get((oe => "".concat(window.location.origin, "/api/files-management/").concat(oe, "/").concat(ct.Iwg.primary, "?editor=").concat(ct.hb4.photo))(q)).pipe((0,
                    it.T)(le => (0,
                    et.ID)("image/svg+xml", le.image))).subscribe(le => {
                        this.themeUrl = le
                    }
                    ))
                }
                constructor(q) {
                    this.httpClient = q,
                    this.lastThemeId = "",
                    this.themeUrl = "",
                    this.PhotoThemePosition = ct.FD
                }
            }
            return (oe = ue).\u0275fac = function(q) {
                return new (q || oe)(r.rXU(re.Qq))
            }
            ,
            oe.\u0275cmp = r.VBU({
                type: oe,
                selectors: [["pp-poster-svg-text"]],
                inputs: {
                    wrapperHeight: "wrapperHeight",
                    enabled: "enabled",
                    position: "position",
                    color: "color",
                    custom: "custom",
                    themeId: "themeId"
                },
                decls: 1,
                vars: 1,
                consts: [["class", "svg-wrapper", 3, "height", 4, "ngIf"], [1, "svg-wrapper"], [1, "svg-position"], [1, "custom-text-area", 3, "fontSize", "height", "fontFamily", "color"], [3, "svgStyle", "src"], [1, "custom-text-area"], [3, "svgStyle", "src", 4, "ngIf"]],
                template: function(q, le) {
                    1 & q && r.DNE(0, ge, 4, 7, "div", 0),
                    2 & q && r.Y8G("ngIf", le.enabled)
                },
                dependencies: [Wt.MD, Wt.bT, Tt.iu, Tt.DM],
                styles: [".svg-wrapper[_ngcontent-%COMP%]{top:0;position:absolute;width:100%;height:100%;display:flex;flex-direction:column;pointer-events:none}.svg-wrapper[_ngcontent-%COMP%]   .svg-position[_ngcontent-%COMP%]{position:absolute;display:flex;flex-direction:column;right:1%;bottom:1%;top:1%;left:1%}.svg-wrapper[_ngcontent-%COMP%]   .svg-position.svg-position-custom[_ngcontent-%COMP%]   .custom-text-area[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center;text-wrap-mode:nowrap}"]
            }),
            ue
        }
        )();
        var Ye = $(13620)
          , yt = $(41046)
          , ht = $(22063)
          , mo = $(73955);
        const no = () => [".jpeg", ".jpg", ".png", ".heic"];
        function Co(oe, ue) {
            if (1 & oe) {
                const J = r.RV6();
                r.j41(0, "img", 6),
                r.bIt("load", function() {
                    r.eBV(J);
                    const le = r.XpG(2);
                    return r.Njj(le.onImageLoad())
                })("click", function() {
                    r.eBV(J);
                    const le = r.XpG(2);
                    return r.Njj(le.selectClassicPhoto(0))
                }),
                r.k0s()
            }
            if (2 & oe) {
                const J = r.XpG(2);
                r.Y8G("src", J.finalImageUrl[0], r.B4B)
            }
        }
        function Lt(oe, ue) {
            if (1 & oe) {
                const J = r.RV6();
                r.j41(0, "pp-controls-file-uploader-photo", 7),
                r.nI1(1, "async"),
                r.nI1(2, "translate"),
                r.bIt("setFileUploadingProgress", function(le) {
                    r.eBV(J);
                    const Se = r.XpG(2);
                    return r.Njj(Se.setFileUploadingProgress.emit(le))
                }),
                r.k0s()
            }
            if (2 & oe) {
                const J = r.XpG(2);
                r.Y8G("photoFileGroup", J.photoFileGroup)("photoCropGroup", J.photoCropGroup)("photoId", J.photoId)("multiFile", J.multiFile)("isSubmitted", !1)("acceptable", r.lJ4(15, no))("isBase64Response", !0)("fullHeight", !0)("isBigPictureMode", !0)("isFileUploadingInProgress", !!J.isFileUploadingInProgress && r.bMT(1, 11, J.isFileUploadingInProgress(0)))("legalNote", r.bMT(2, 13, "soundwave.details.instruction"))
            }
        }
        function Ft(oe, ue) {
            if (1 & oe && (r.j41(0, "pp-poster-image-area")(1, "div", 2),
            r.DNE(2, Co, 1, 1, "img", 3)(3, Lt, 3, 16, "pp-controls-file-uploader-photo", 4),
            r.nrm(4, "pp-poster-svg-text", 5),
            r.k0s()()),
            2 & oe) {
                const J = r.XpG();
                r.R7$(),
                r.xc7("top", J.photoAreaMargin, "px")("bottom", J.photoAreaMargin, "px")("left", J.photoAreaMargin, "px")("right", J.photoAreaMargin, "px"),
                r.R7$(),
                r.Y8G("ngIf", J.finalImageUrl[0]),
                r.R7$(),
                r.Y8G("ngIf", !J.finalImageUrl[0]),
                r.R7$(),
                r.Y8G("themeId", J.svgText.id)("wrapperHeight", J.svgText.wrapperHeight)("enabled", J.svgText.enabled)("position", J.svgText.position)("color", J.svgText.color)("custom", J.svgText.custom)
            }
        }
        function co(oe, ue) {
            1 & oe && r.nrm(0, "pp-poster-loaded-element")
        }
        let Jt = ( () => {
            var oe;
            class ue extends ht.f {
                constructor() {
                    super(...arguments),
                    this.multiFile = !1,
                    this.photoId = 0,
                    this.setFileUploadingProgress = new r.bkB,
                    this.selectPhoto = new r.bkB,
                    this.textareaHeightCallback = new r.bkB
                }
                selectClassicPhoto(q) {
                    var le;
                    const Se = null !== (le = this.photoAreaMargin) && void 0 !== le ? le : 0;
                    this.selectPhoto.emit({
                        photoId: q,
                        imageInstanceSize: {
                            width: this.poster.size.width - 2 * Se,
                            height: this.poster.size.height - 2 * Se
                        }
                    })
                }
                onImageLoad() {
                    this.initiateRender()
                }
            }
            return (oe = ue).\u0275fac = ( () => {
                let J;
                return function(le) {
                    return (J || (J = r.xGo(oe)))(le || oe)
                }
            }
            )(),
            oe.\u0275cmp = r.VBU({
                type: oe,
                selectors: [["pp-poster-photo-classic"]],
                inputs: {
                    photoAreaMargin: "photoAreaMargin",
                    finalImageUrl: "finalImageUrl",
                    poster: "poster",
                    textColor: "textColor",
                    textBackground: "textBackground",
                    textArea: "textArea",
                    title: "title",
                    subtitle: "subtitle",
                    svgText: "svgText",
                    photoFileGroup: "photoFileGroup",
                    photoCropGroup: "photoCropGroup",
                    multiFile: "multiFile",
                    photoId: "photoId",
                    isFileUploadingInProgress: "isFileUploadingInProgress"
                },
                outputs: {
                    setFileUploadingProgress: "setFileUploadingProgress",
                    selectPhoto: "selectPhoto",
                    textareaHeightCallback: "textareaHeightCallback"
                },
                features: [r.Vt3],
                decls: 3,
                vars: 8,
                consts: [[4, "ngIf"], [3, "textareaHeightCallback", "poster", "color", "background", "textArea", "title", "subtitle"], [1, "image-instance"], [3, "src", "load", "click", 4, "ngIf"], [3, "photoFileGroup", "photoCropGroup", "photoId", "multiFile", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "isFileUploadingInProgress", "legalNote", "setFileUploadingProgress", 4, "ngIf"], [3, "themeId", "wrapperHeight", "enabled", "position", "color", "custom"], [3, "load", "click", "src"], [3, "setFileUploadingProgress", "photoFileGroup", "photoCropGroup", "photoId", "multiFile", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "isFileUploadingInProgress", "legalNote"]],
                template: function(q, le) {
                    1 & q && (r.DNE(0, Ft, 5, 16, "pp-poster-image-area", 0),
                    r.j41(1, "pp-poster-text-area", 1),
                    r.bIt("textareaHeightCallback", function(st) {
                        return le.textareaHeightCallback.emit(st)
                    }),
                    r.k0s(),
                    r.DNE(2, co, 1, 0, "pp-poster-loaded-element", 0)),
                    2 & q && (r.Y8G("ngIf", le.photoAreaMargin),
                    r.R7$(),
                    r.Y8G("poster", le.poster)("color", le.textColor)("background", le.textBackground)("textArea", le.textArea)("title", le.title)("subtitle", le.subtitle),
                    r.R7$(),
                    r.Y8G("ngIf", le.isImageRendered))
                },
                dependencies: [Wt.MD, Wt.bT, Wt.Jj, Tt.iu, Xe.ex, Ce.W, gt, Ye.y, yt.C, mo.h, mo.D9],
                styles: [".image-instance[_ngcontent-%COMP%]{position:absolute;background:#dedddd}.image-instance[_ngcontent-%COMP%]   pp-controls-file-uploader[_ngcontent-%COMP%]{position:absolute;top:0;left:0;right:0;bottom:0;z-index:1020}.image-instance[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:100%;height:100%;object-fit:cover;cursor:pointer}"]
            }),
            ue
        }
        )();
        class po {
            static getTextAreaConfig(ue) {
                return {
                    bottomFactor: ue.isPortrait ? .035 : .03,
                    marginFactor: ue.isPortrait ? .05 : .03
                }
            }
            static getTitleTextSettings(ue) {
                return {
                    font: null != ue && ue.isDefaultFont ? ct.n3q.MACHO : ct.n3q.LUXUS_BRUT,
                    portrait: {
                        sizeFactor: .058,
                        bottomFactor: 0,
                        topFactor: .032,
                        letterSpacingFactor: null != ue && ue.isDefaultFont ? 0 : .003
                    },
                    horizontal: {
                        sizeFactor: null != ue && ue.isDefaultFont ? .046 : .04,
                        bottomFactor: 0,
                        topFactor: .032,
                        letterSpacingFactor: null != ue && ue.isDefaultFont ? 0 : .003
                    }
                }
            }
            static getSubtitleTextSettings(ue) {
                return {
                    font: ct.n3q.MACHO,
                    portrait: {
                        sizeFactor: .024,
                        bottomFactor: 0,
                        topFactor: .015
                    },
                    horizontal: {
                        sizeFactor: .022,
                        bottomFactor: 0,
                        topFactor: .015
                    }
                }
            }
        }
        const Et = () => [".jpeg", ".jpg", ".png", ".heic"];
        function Kt(oe, ue) {
            if (1 & oe) {
                const J = r.RV6();
                r.j41(0, "img", 6),
                r.bIt("load", function() {
                    r.eBV(J);
                    const le = r.XpG().$index
                      , Se = r.XpG(2);
                    return r.Njj(Se.onImageLoad(le))
                })("click", function() {
                    r.eBV(J);
                    const le = r.XpG().$index
                      , Se = r.XpG(2);
                    return r.Njj(Se.selectClassicPhoto(le))
                }),
                r.k0s()
            }
            if (2 & oe) {
                const J = r.XpG().$index
                  , q = r.XpG(2);
                r.Y8G("src", q.finalImageUrl[J], r.B4B)
            }
        }
        function At(oe, ue) {
            if (1 & oe) {
                const J = r.RV6();
                r.j41(0, "pp-controls-file-uploader-photo", 7),
                r.nI1(1, "async"),
                r.nI1(2, "translate"),
                r.bIt("setFileUploadingProgress", function(le) {
                    r.eBV(J);
                    const Se = r.XpG(3);
                    return r.Njj(Se.setFileUploadingProgress.emit(le))
                }),
                r.k0s()
            }
            if (2 & oe) {
                const J = r.XpG().$index
                  , q = r.XpG(2);
                r.Y8G("photoFileGroup", q.photoFileGroup)("photoCropGroup", q.photoCropGroup)("onlySingleInput", !1)("photoId", J)("multiFile", q.multiFile)("fileId", J)("isSubmitted", !1)("acceptable", r.lJ4(17, Et))("isBase64Response", !0)("fullHeight", !0)("isBigPictureMode", !0)("isFileUploadingInProgress", !!q.isFileUploadingInProgress && r.bMT(1, 13, q.isFileUploadingInProgress(J)))("legalNote", r.bMT(2, 15, "soundwave.details.instruction"))
            }
        }
        function Re(oe, ue) {
            if (1 & oe && (r.j41(0, "div", 2),
            r.DNE(1, Kt, 1, 1, "img", 4)(2, At, 3, 18, "pp-controls-file-uploader-photo", 5),
            r.k0s()),
            2 & oe) {
                const J = ue.$index
                  , q = r.XpG(2);
                r.R7$(),
                r.Y8G("ngIf", q.finalImageUrl[J] && (q.isInteractive || q.load >= J)),
                r.R7$(),
                r.Y8G("ngIf", !q.finalImageUrl[J])
            }
        }
        function ve(oe, ue) {
            if (1 & oe && (r.j41(0, "pp-poster-image-area")(1, "div", 1),
            r.Z7z(2, Re, 3, 2, "div", 2, r.fX1),
            r.nrm(4, "pp-poster-svg-text", 3),
            r.k0s()()),
            2 & oe) {
                const J = r.XpG();
                r.R7$(),
                r.xc7("top", J.photoAreaMargin, "px")("bottom", J.photoAreaMargin, "px")("left", J.photoAreaMargin, "px")("right", J.photoAreaMargin, "px"),
                r.R7$(),
                r.Dyx(J.gridPhotosAmountArray),
                r.R7$(2),
                r.Y8G("themeId", J.svgText.id)("wrapperHeight", J.svgText.wrapperHeight)("enabled", J.svgText.enabled)("position", J.svgText.position)("color", J.svgText.color)("custom", J.svgText.custom)
            }
        }
        function ne(oe, ue) {
            1 & oe && r.nrm(0, "pp-poster-loaded-element")
        }
        let B = ( () => {
            var oe;
            class ue extends ht.f {
                constructor() {
                    super(...arguments),
                    this._gridPhotosAmount = 1,
                    this.gridPhotosAmountArray = [],
                    this.isInteractive = !1,
                    this.multiFile = !1,
                    this.setFileUploadingProgress = new r.bkB,
                    this.selectPhoto = new r.bkB,
                    this.textareaHeightCallback = new r.bkB,
                    this.loadedElements = []
                }
                set gridPhotosAmount(q) {
                    this._gridPhotosAmount = q,
                    this.gridPhotosAmountArray = Array.from({
                        length: q
                    }, (le, Se) => Se)
                }
                selectClassicPhoto(q) {
                    var le;
                    const Se = null !== (le = this.photoAreaMargin) && void 0 !== le ? le : 0;
                    this.selectPhoto.emit({
                        photoId: q,
                        imageInstanceSize: {
                            width: this.poster.size.width - 2 * Se,
                            height: this.poster.size.height - 2 * Se
                        }
                    })
                }
                onImageLoad(q) {
                    this.loadedElements.push(q),
                    this.load++,
                    4 === this.loadedElements.length && this.initiateRender()
                }
            }
            return (oe = ue).\u0275fac = ( () => {
                let J;
                return function(le) {
                    return (J || (J = r.xGo(oe)))(le || oe)
                }
            }
            )(),
            oe.\u0275cmp = r.VBU({
                type: oe,
                selectors: [["pp-poster-photo-4grid"]],
                inputs: {
                    photoAreaMargin: "photoAreaMargin",
                    finalImageUrl: "finalImageUrl",
                    poster: "poster",
                    textColor: "textColor",
                    textBackground: "textBackground",
                    textArea: "textArea",
                    title: "title",
                    subtitle: "subtitle",
                    gridPhotosAmount: "gridPhotosAmount",
                    svgText: "svgText",
                    isInteractive: "isInteractive",
                    photoFileGroup: "photoFileGroup",
                    photoCropGroup: "photoCropGroup",
                    multiFile: "multiFile",
                    isFileUploadingInProgress: "isFileUploadingInProgress"
                },
                outputs: {
                    setFileUploadingProgress: "setFileUploadingProgress",
                    selectPhoto: "selectPhoto",
                    textareaHeightCallback: "textareaHeightCallback"
                },
                features: [r.Vt3],
                decls: 2,
                vars: 2,
                consts: [[4, "ngIf"], [1, "image-instance"], [1, "single-slot"], [3, "themeId", "wrapperHeight", "enabled", "position", "color", "custom"], [3, "src", "load", "click", 4, "ngIf"], [3, "photoFileGroup", "photoCropGroup", "onlySingleInput", "photoId", "multiFile", "fileId", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "isFileUploadingInProgress", "legalNote", "setFileUploadingProgress", 4, "ngIf"], [3, "load", "click", "src"], [3, "setFileUploadingProgress", "photoFileGroup", "photoCropGroup", "onlySingleInput", "photoId", "multiFile", "fileId", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "isFileUploadingInProgress", "legalNote"]],
                template: function(q, le) {
                    1 & q && r.DNE(0, ve, 5, 14, "pp-poster-image-area", 0)(1, ne, 1, 0, "pp-poster-loaded-element", 0),
                    2 & q && (r.Y8G("ngIf", le.photoAreaMargin),
                    r.R7$(),
                    r.Y8G("ngIf", le.isImageRendered))
                },
                dependencies: [Wt.MD, Wt.bT, Wt.Jj, Tt.iu, Xe.ex, Ce.W, gt, yt.C, mo.h, mo.D9],
                styles: ['@font-face{font-family:Leander Script Pro;font-weight:700;src:url(/assets/pp-posters/fonts/leanderscriptpro-bold.otf) format("opentype")}@font-face{font-family:Leander Script Pro;src:url(/assets/pp-posters/fonts/leanderscriptpro-regular.otf) format("opentype")}@font-face{font-family:Madina Script;src:url(/assets/pp-posters/fonts/Madina-Script.otf) format("opentype")}@font-face{font-family:Proxima Nova;font-weight:700;src:url(/assets/pp-posters/fonts/proximanova-bold.otf) format("opentype")}@font-face{font-family:SourceCodePro-Regular;src:url(/assets/pp-posters/fonts/SourceCodePro-Regular.ttf) format("truetype")}@font-face{font-family:Proxima Nova;src:url(/assets/pp-posters/fonts/proximanova-regular.otf) format("opentype")}@font-face{font-family:Macho;font-weight:700;src:url(/assets/pp-posters/fonts/Macho-Medium.woff) format("opentype")}@font-face{font-family:Macho;src:url(/assets/pp-posters/fonts/Macho-Regular.woff) format("opentype")}@font-face{font-family:Capsuula;src:url(/assets/pp-posters/fonts/Capsuula.ttf) format("truetype")}@font-face{font-family:Capsuula Bold;src:url(/assets/pp-posters/fonts/Capsuula-bold.ttf) format("truetype")}@font-face{font-family:YesevaOne;src:url(/assets/pp-posters/fonts/YesevaOne-Regular.ttf)}@font-face{font-family:LuxusBrut;src:url(/assets/pp-posters/fonts/LuxusBrut.otf) format("opentype")}@font-face{font-family:PositivePrintsScript2;src:url(/assets/pp-posters/fonts/positive-prints-script-2.otf) format("opentype")}@font-face{font-family:PositivePrintsScript;src:url(/assets/pp-posters/fonts/PositivePrintsScript.ttf) format("opentype")}@font-face{font-family:Dejavu Sans;src:url(/assets/pp-posters/fonts/DejaVuSans.ttf) format("opentype")}@font-face{font-family:Roboto Thin;src:url(/assets/pp-posters/fonts/Roboto-Thin.ttf) format("opentype")}@font-face{font-family:roobert;font-weight:400;src:url(/assets/pp-posters/fonts/roobert-regular.otf) format("opentype")}@font-face{font-family:roobert;font-weight:700;src:url(/assets/pp-posters/fonts/roobert-bold.otf) format("opentype")}@font-face{font-family:Sophia Ronald;src:url(/assets/pp-posters/fonts/SophiaRonald.ttf) format("opentype")}@font-face{font-family:Hello October;src:url(/assets/pp-posters/fonts/Hello_October.otf) format("opentype")}@font-face{font-family:SignatureFont;src:url(/assets/pp-posters/fonts/SignatureFont.otf) format("opentype")}@font-face{font-family:EBGaramond-Bold;src:url(/assets/pp-posters/fonts/EBGaramond-Bold.ttf) format("opentype")}@font-face{font-family:EBGaramond-SemiBold;src:url(/assets/pp-posters/fonts/EBGaramond-SemiBold.ttf) format("opentype")}@font-face{font-family:EBGaramond-Regular;src:url(/assets/pp-posters/fonts/EBGaramond-Regular.ttf) format("opentype")}@font-face{font-family:Montserrat-ExtraBold;src:url(/assets/pp-posters/fonts/Montserrat-ExtraBold.ttf) format("opentype")}@font-face{font-family:Montserrat-Medium;src:url(/assets/pp-posters/fonts/Montserrat-Medium.ttf) format("opentype")}@font-face{font-family:Montserrat-Thin;src:url(/assets/pp-posters/fonts/Montserrat-Thin.ttf) format("opentype")}@font-face{font-family:Montserrat-Light;src:url(/assets/pp-posters/fonts/Montserrat-Light.ttf) format("opentype")}@font-face{font-family:Montserrat-ExtraBold;src:url(/assets/pp-posters/fonts/Montserrat-ExtraBold.ttf) format("opentype")}@font-face{font-family:Montserrat-Medium;src:url(/assets/pp-posters/fonts/Montserrat-Medium.ttf) format("opentype")}@font-face{font-family:Montserrat-Thin;src:url(/assets/pp-posters/fonts/Montserrat-Thin.ttf) format("opentype")}@font-face{font-family:AbrilFatface-Regular;src:url(/assets/pp-posters/fonts/AbrilFatface-Regular.ttf) format("opentype")}@font-face{font-family:MenloRegular;src:url(/assets/pp-posters/fonts/MenloRegular.ttf) format("opentype")}@font-face{font-family:MenloBoldItalic;src:url(/assets/pp-posters/fonts/MenloBoldItalic.ttf) format("opentype")}.image-instance[_ngcontent-%COMP%]{position:absolute;background:#fff}.image-instance[_ngcontent-%COMP%]   pp-controls-file-uploader[_ngcontent-%COMP%]{position:absolute;top:0;left:0;right:0;bottom:0;z-index:1020}.image-instance[_ngcontent-%COMP%]   .single-slot[_ngcontent-%COMP%]{width:50%;height:50%;float:left;box-sizing:border-box}.image-instance[_ngcontent-%COMP%]   .single-slot[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{cursor:pointer}.image-instance[_ngcontent-%COMP%]   .single-slot[_ngcontent-%COMP%]:nth-child(1){padding-right:1.5%;padding-bottom:1.5%}.image-instance[_ngcontent-%COMP%]   .single-slot[_ngcontent-%COMP%]:nth-child(2){padding-left:1.5%;padding-bottom:1.5%}.image-instance[_ngcontent-%COMP%]   .single-slot[_ngcontent-%COMP%]:nth-child(3){padding-right:1.5%;padding-top:1.5%}.image-instance[_ngcontent-%COMP%]   .single-slot[_ngcontent-%COMP%]:nth-child(4){padding-left:1.5%;padding-top:1.5%}.image-instance[_ngcontent-%COMP%]   .single-slot[_ngcontent-%COMP%]   pp-controls-file-uploader-photo[_ngcontent-%COMP%]{background:#dedddd;display:block;width:100%;height:100%}.image-instance[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:100%;height:100%;object-fit:cover}']
            }),
            ue
        }
        )();
        const de = () => [".jpeg", ".jpg", ".png", ".heic"];
        function lt(oe, ue) {
            if (1 & oe) {
                const J = r.RV6();
                r.j41(0, "img", 7),
                r.bIt("load", function() {
                    r.eBV(J);
                    const le = r.XpG(3);
                    return r.Njj(le.onImageLoad())
                })("click", function() {
                    r.eBV(J);
                    const le = r.XpG().$index
                      , Se = r.XpG(2);
                    return r.Njj(Se.selectClassicPhoto(le))
                }),
                r.k0s()
            }
            if (2 & oe) {
                const J = r.XpG().$index
                  , q = r.XpG(2);
                r.Y8G("src", q.finalImageUrl[J], r.B4B)
            }
        }
        function St(oe, ue) {
            if (1 & oe) {
                const J = r.RV6();
                r.j41(0, "pp-controls-file-uploader-photo", 8),
                r.nI1(1, "async"),
                r.nI1(2, "translate"),
                r.bIt("setFileUploadingProgress", function(le) {
                    r.eBV(J);
                    const Se = r.XpG(3);
                    return r.Njj(Se.setFileUploadingProgress.emit(le))
                }),
                r.k0s()
            }
            if (2 & oe) {
                const J = r.XpG().$index
                  , q = r.XpG(2);
                r.Y8G("photoFileGroup", q.photoFileGroup)("photoCropGroup", q.photoCropGroup)("photoId", q.photoId)("multiFile", q.multiFile)("fileId", J)("isSubmitted", !1)("acceptable", r.lJ4(16, de))("isBase64Response", !0)("fullHeight", !0)("isBigPictureMode", !0)("isFileUploadingInProgress", !!q.isFileUploadingInProgress && r.bMT(1, 12, q.isFileUploadingInProgress(J)))("legalNote", r.bMT(2, 14, "soundwave.details.instruction"))
            }
        }
        function tt(oe, ue) {
            if (1 & oe && (r.j41(0, "div"),
            r.DNE(1, lt, 1, 1, "img", 5)(2, St, 3, 17, "pp-controls-file-uploader-photo", 6),
            r.k0s()),
            2 & oe) {
                const J = ue.$index
                  , q = r.XpG(2);
                r.STu("grid-elements grid-elements-", q._definitionPhotosAmount, " grid-position-", J, ""),
                r.R7$(),
                r.Y8G("ngIf", q.finalImageUrl[J] && (q.isInteractive || q.load >= J)),
                r.R7$(),
                r.Y8G("ngIf", !q.finalImageUrl[J])
            }
        }
        function $t(oe, ue) {
            if (1 & oe && (r.j41(0, "pp-poster-image-area")(1, "div", 3),
            r.Z7z(2, tt, 3, 6, "div", 4, r.fX1),
            r.k0s()()),
            2 & oe) {
                const J = r.XpG();
                r.R7$(),
                r.xc7("top", J.photoAreaMargin, "px")("bottom", J.photoAreaBottom, "px")("left", J.photoAreaMargin, "px")("right", J.photoAreaMargin, "px"),
                r.R7$(),
                r.Dyx(J.definitionPhotosAmountArray)
            }
        }
        function Nt(oe, ue) {
            if (1 & oe && r.nrm(0, "div", 9),
            2 & oe) {
                const J = r.XpG();
                r.xc7("background", J.textColor)("height", null == J.delimiter ? null : J.delimiter.height, "px")
            }
        }
        function Vt(oe, ue) {
            1 & oe && r.nrm(0, "pp-poster-loaded-element")
        }
        let _o = ( () => {
            var oe;
            class ue extends ht.f {
                constructor() {
                    super(...arguments),
                    this.isInteractive = !1,
                    this._definitionPhotosAmount = 1,
                    this.definitionPhotosAmountArray = [],
                    this.multiFile = !1,
                    this.photoId = 0,
                    this.setFileUploadingProgress = new r.bkB,
                    this.selectPhoto = new r.bkB,
                    this.textareaHeightCallback = new r.bkB,
                    this.photoAreaBottom = this.photoAreaMargin
                }
                set definitionPhotosAmount(q) {
                    this._definitionPhotosAmount = q,
                    this.definitionPhotosAmountArray = Array.from({
                        length: q
                    }, (le, Se) => Se)
                }
                setNewImageHeight(q) {
                    var le, Se;
                    this.poster && (this.photoAreaBottom = (null !== (le = null === (Se = this.textArea) || void 0 === Se ? void 0 : Se.bottomFactor) && void 0 !== le ? le : 0) * (this.poster.isPortrait ? this.poster.size.width : this.poster.size.height) + q)
                }
                selectClassicPhoto(q) {
                    var le, Se;
                    const st = null !== (le = this.photoAreaMargin) && void 0 !== le ? le : 0
                      , Rt = {
                        width: this.poster.size.width - 2 * st,
                        height: this.poster.size.height - 2 * st - (null !== (Se = this.photoAreaBottom) && void 0 !== Se ? Se : 0)
                    };
                    this.selectPhoto.emit({
                        photoId: q,
                        imageInstanceSize: Rt
                    })
                }
                onImageLoad() {
                    this.load++,
                    this._definitionPhotosAmount === this.load && this.initiateRender()
                }
            }
            return (oe = ue).\u0275fac = ( () => {
                let J;
                return function(le) {
                    return (J || (J = r.xGo(oe)))(le || oe)
                }
            }
            )(),
            oe.\u0275cmp = r.VBU({
                type: oe,
                selectors: [["pp-poster-photo-definition"]],
                inputs: {
                    photoAreaMargin: "photoAreaMargin",
                    finalImageUrl: "finalImageUrl",
                    poster: "poster",
                    textColor: "textColor",
                    textBackground: "textBackground",
                    isInteractive: "isInteractive",
                    textArea: "textArea",
                    title: "title",
                    subtitle: "subtitle",
                    definition: "definition",
                    synonim: "synonim",
                    delimiter: "delimiter",
                    definitionPhotosAmount: "definitionPhotosAmount",
                    photoFileGroup: "photoFileGroup",
                    photoCropGroup: "photoCropGroup",
                    multiFile: "multiFile",
                    photoId: "photoId",
                    isFileUploadingInProgress: "isFileUploadingInProgress"
                },
                outputs: {
                    setFileUploadingProgress: "setFileUploadingProgress",
                    selectPhoto: "selectPhoto",
                    textareaHeightCallback: "textareaHeightCallback"
                },
                features: [r.Vt3],
                decls: 4,
                vars: 11,
                consts: [[4, "ngIf"], [3, "textareaHeightCallback", "poster", "color", "background", "textArea", "title", "subtitle", "footer", "date"], ["class", "delimiter", "afterSubtitle", "", 3, "background", "height", 4, "ngIf"], [1, "image-instance"], [3, "class"], [3, "src", "load", "click", 4, "ngIf"], [3, "photoFileGroup", "photoCropGroup", "photoId", "multiFile", "fileId", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "isFileUploadingInProgress", "legalNote", "setFileUploadingProgress", 4, "ngIf"], [3, "load", "click", "src"], [3, "setFileUploadingProgress", "photoFileGroup", "photoCropGroup", "photoId", "multiFile", "fileId", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "isFileUploadingInProgress", "legalNote"], ["afterSubtitle", "", 1, "delimiter"]],
                template: function(q, le) {
                    1 & q && (r.DNE(0, $t, 4, 8, "pp-poster-image-area", 0),
                    r.j41(1, "pp-poster-text-area", 1),
                    r.bIt("textareaHeightCallback", function(st) {
                        return le.setNewImageHeight(st),
                        le.textareaHeightCallback.emit(st)
                    }),
                    r.DNE(2, Nt, 1, 4, "div", 2),
                    r.k0s(),
                    r.DNE(3, Vt, 1, 0, "pp-poster-loaded-element", 0)),
                    2 & q && (r.Y8G("ngIf", le.photoAreaMargin),
                    r.R7$(),
                    r.Y8G("poster", le.poster)("color", le.textColor)("background", le.textBackground)("textArea", le.textArea)("title", le.title)("subtitle", le.subtitle)("footer", le.definition)("date", le.synonim),
                    r.R7$(),
                    r.Y8G("ngIf", (null == le.definition ? null : le.definition.text) || (null == le.synonim ? null : le.synonim.text)),
                    r.R7$(),
                    r.Y8G("ngIf", le.isImageRendered))
                },
                dependencies: [Wt.MD, Wt.bT, Wt.Jj, Tt.iu, Xe.ex, Ce.W, Ye.y, yt.C, mo.h, mo.D9],
                styles: [".image-instance[_ngcontent-%COMP%]{position:absolute;overflow:hidden}.image-instance[_ngcontent-%COMP%]   .grid-elements[_ngcontent-%COMP%]{position:absolute;display:block;background:#dedddd}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-1[_ngcontent-%COMP%]{width:100%;height:100%}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-4[_ngcontent-%COMP%]{width:49%;height:49%}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-4.grid-position-0[_ngcontent-%COMP%]{top:0;left:0}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-4.grid-position-1[_ngcontent-%COMP%]{top:0;right:0}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-4.grid-position-2[_ngcontent-%COMP%]{bottom:0;left:0}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-4.grid-position-3[_ngcontent-%COMP%]{bottom:0;right:0}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-9[_ngcontent-%COMP%]{width:32%;height:32%}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-9.grid-position-0[_ngcontent-%COMP%]{top:0;left:0}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-9.grid-position-1[_ngcontent-%COMP%]{top:0;left:34%}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-9.grid-position-2[_ngcontent-%COMP%]{top:0;right:0}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-9.grid-position-3[_ngcontent-%COMP%]{top:34%;left:0}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-9.grid-position-4[_ngcontent-%COMP%]{top:34%;left:34%}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-9.grid-position-5[_ngcontent-%COMP%]{top:34%;right:0}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-9.grid-position-6[_ngcontent-%COMP%]{bottom:0;left:0}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-9.grid-position-7[_ngcontent-%COMP%]{bottom:0;left:34%}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-9.grid-position-8[_ngcontent-%COMP%]{bottom:0;right:0}.image-instance[_ngcontent-%COMP%]   .grid-elements[_ngcontent-%COMP%]   pp-controls-file-uploader[_ngcontent-%COMP%]{position:absolute;top:0;left:0;right:0;bottom:0;z-index:1020}.image-instance[_ngcontent-%COMP%]   .grid-elements[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:100%;height:100%;object-fit:cover;cursor:pointer}.delimiter[_ngcontent-%COMP%]{order:11;display:block;width:100%}"]
            }),
            ue
        }
        )();
        class Lo {
            static getTextAreaConfig(ue) {
                return {
                    bottomFactor: ue.isPortrait ? .08 : .05,
                    marginFactor: ue.isPortrait ? .05 : .03,
                    paddingFactor: ue.isPortrait ? .01 : .02
                }
            }
            static getTitleTextSettings(ue, J) {
                return {
                    font: null != ue && ue.isDefaultFont ? ct.n3q.EB_GARAMOND_SEMIBOLD : ct.n3q.HELLO_OCTOBER,
                    textAlign: "left",
                    portrait: {
                        sizeFactor: .06,
                        bottomFactor: J.text ? 0 : .028,
                        topFactor: .032,
                        letterSpacingFactor: null != ue && ue.isDefaultFont ? 0 : .003
                    },
                    horizontal: {
                        sizeFactor: null != ue && ue.isDefaultFont ? .046 : .04,
                        bottomFactor: J.text ? 0 : .02,
                        topFactor: .032,
                        letterSpacingFactor: null != ue && ue.isDefaultFont ? 0 : .003
                    }
                }
            }
            static getSubtitleTextSettings(ue, J) {
                return {
                    font: ct.n3q.EB_GARAMOND,
                    textAlign: "left",
                    portrait: {
                        sizeFactor: .03,
                        bottomFactor: .028,
                        topFactor: ue.text ? 0 : .032
                    },
                    horizontal: {
                        sizeFactor: .022,
                        bottomFactor: .02,
                        topFactor: ue.text ? 0 : .015
                    }
                }
            }
            static getDefinitionTextSettings(ue) {
                return {
                    font: ct.n3q.EB_GARAMOND,
                    textAlign: "left",
                    portrait: {
                        sizeFactor: .029,
                        bottomFactor: 0,
                        topFactor: .008
                    },
                    horizontal: {
                        sizeFactor: .022,
                        bottomFactor: 0,
                        topFactor: .015
                    }
                }
            }
            static getSynonymTextSettings(ue) {
                return {
                    font: ct.n3q.EB_GARAMOND,
                    textAlign: "left",
                    portrait: {
                        sizeFactor: .029,
                        bottomFactor: 0,
                        topFactor: .038
                    },
                    horizontal: {
                        sizeFactor: .022,
                        bottomFactor: 0,
                        topFactor: .015
                    }
                }
            }
        }
        function ao(oe, ue, J) {
            const le = document.createElement("canvas").getContext("2d");
            return le ? (le.font = "".concat(ue, "px ").concat(J),
            le.measureText(oe).width) : 0
        }
        function bt(oe, ue, J, q, le=.1, Se=!1) {
            const st = document.createElement("span");
            st.style.position = "absolute",
            st.style.whiteSpace = "nowrap",
            st.style.visibility = "hidden",
            st.style.letterSpacing = "normal",
            st.style.fontFamily = J,
            document.body.appendChild(st);
            let Rt = 1
              , Qt = 0;
            for (; Qt < ue && Rt < q; )
                Se ? Qt = ao(oe, Rt, J) : (st.style.fontSize = "".concat(Rt, "px"),
                st.textContent = oe,
                Qt = st.offsetWidth),
                Qt < ue && (Rt += le);
            return document.body.removeChild(st),
            q && Rt - le > q ? q : Rt - le
        }
        var Do = $(21413);
        function Xt(oe, ue, J) {
            const le = document.createElement("canvas").getContext("2d");
            if (!le)
                return 0;
            le.font = "".concat(ue, "px ").concat(J);
            const Se = le.measureText(oe);
            return Se.actualBoundingBoxAscent + Se.actualBoundingBoxDescent
        }
        var we = $(88455);
        function Oe(oe, ue) {
            if (1 & oe && (r.j41(0, "div", 1),
            r.EFF(1),
            r.k0s()),
            2 & oe) {
                const J = ue.$implicit
                  , q = ue.$index
                  , le = r.XpG(2);
                r.xc7("height", le.letterHeight, "px")("margin-top", 0 === q ? le._padding : 0, "px")("margin-bottom", le._padding, "px"),
                r.R7$(),
                r.SpI("", J, " ")
            }
        }
        function ee(oe, ue) {
            if (1 & oe && r.Z7z(0, Oe, 2, 7, "div", 0, r.fX1),
            2 & oe) {
                const J = r.XpG();
                r.Dyx(J._text)
            }
        }
        function W(oe, ue) {
            if (1 & oe && r.EFF(0),
            2 & oe) {
                const J = r.XpG();
                r.SpI(" ", J._text.join(""), " ")
            }
        }
        let ae = ( () => {
            var oe;
            class ue {
                set padding(q) {
                    this._padding = q,
                    this.textConfig$.next({
                        text: this._text,
                        font: this._font,
                        minimumLength: this._minimumLength,
                        orientation: this._orientation,
                        padding: this._padding
                    })
                }
                set text(q) {
                    this._text = [...q],
                    this.textConfig$.next({
                        text: this._text,
                        font: this._font,
                        minimumLength: this._minimumLength,
                        orientation: this._orientation,
                        padding: this._padding
                    })
                }
                set font(q) {
                    this._font = q,
                    this.textConfig$.next({
                        text: this._text,
                        font: this._font,
                        minimumLength: this._minimumLength,
                        orientation: this._orientation,
                        padding: this._padding
                    })
                }
                set minimumLength(q) {
                    this._minimumLength = q,
                    this.textConfig$.next({
                        text: this._text,
                        font: this._font,
                        minimumLength: this._minimumLength,
                        orientation: this._orientation,
                        padding: this._padding
                    })
                }
                set orientation(q) {
                    this._orientation = q,
                    this.textConfig$.next({
                        text: this._text,
                        font: this._font,
                        minimumLength: this._minimumLength,
                        orientation: this._orientation,
                        padding: this._padding
                    })
                }
                constructor(q) {
                    this.host = q,
                    this._text = [],
                    this._font = ct.n3q.ROOBERT,
                    this._minimumLength = 5,
                    this._padding = 0,
                    this._orientation = "portrait",
                    this.fontSize = 0,
                    this.textShadow = "",
                    this.letterHeight = 0,
                    this.textConfig$ = new _t.t({
                        text: this._text,
                        font: this._font,
                        minimumLength: this._minimumLength,
                        orientation: this._orientation,
                        padding: 0
                    }),
                    this.color = "#FFF",
                    this.isFinalPoster = !1,
                    this.destroy$ = new Do.B
                }
                ngOnInit() {
                    this.generateText(),
                    this.resizeObserver = new ResizeObserver(q => {
                        for (const le of q)
                            le.target === this.host.nativeElement && this.onResize()
                    }
                    ),
                    this.resizeObserver.observe(this.host.nativeElement)
                }
                ngOnDestroy() {
                    this.resizeObserver.disconnect(),
                    this.destroy$.next(),
                    this.destroy$.complete()
                }
                generateText() {
                    var q = this;
                    this.textConfig$.pipe((0,
                    Me.Q)(this.destroy$), (0,
                    jt.B)(200)).subscribe(function() {
                        var le = (0,
                        Ut.A)(function*(Se) {
                            yield(0,
                            we.A)(Se.font);
                            const st = [...Se.text];
                            for (; st.length < Se.minimumLength; )
                                st.push("A");
                            if ("landscape" === Se.orientation) {
                                const Rt = q.host.nativeElement.offsetWidth - 2 * Se.padding;
                                q.fontSize = bt(st.join(""), Rt, Se.font, 1e5, q.isFinalPoster ? 1 : .1, !0)
                            } else {
                                const Rt = q.host.nativeElement.offsetHeight - Se.padding;
                                q.fontSize = function ie(oe, ue, J, q, le=.1, Se=0) {
                                    const st = document.createElement("div");
                                    st.style.position = "absolute",
                                    st.style.visibility = "hidden",
                                    st.style.fontFamily = J,
                                    st.style.lineHeight = "1",
                                    document.body.appendChild(st);
                                    let Rt = 1
                                      , Qt = 0;
                                    for (console.log("maxHeight", ue); Qt < ue && Rt < q; )
                                        st.style.fontSize = "".concat(Rt, "px"),
                                        st.innerHTML = oe.split("").join("<br>"),
                                        Qt = (Xt("A", Rt, J) + Se) * oe.length,
                                        Qt < ue && (Rt += le);
                                    return document.body.removeChild(st),
                                    q && Rt - le > q ? q : Rt - .1
                                }(st.join(""), Rt, Se.font, 1e5, q.isFinalPoster ? 1 : .1, Se.padding)
                            }
                            q.letterHeight = Xt("A", q.fontSize, Se.font),
                            q.textShadow = "".concat(q.letterHeight / 30, "px ").concat(q.letterHeight / 30, "px ").concat(q.letterHeight / 20, "px rgba(0, 0, 0, 0.6)")
                        });
                        return function(Se) {
                            return le.apply(this, arguments)
                        }
                    }())
                }
                onResize() {
                    this.textConfig$.next({
                        text: this._text,
                        font: this._font,
                        minimumLength: this._minimumLength,
                        orientation: this._orientation,
                        padding: this._padding
                    })
                }
            }
            return (oe = ue).\u0275fac = function(q) {
                return new (q || oe)(r.rXU(r.aKT))
            }
            ,
            oe.\u0275cmp = r.VBU({
                type: oe,
                selectors: [["pp-poster-text-fill"]],
                inputs: {
                    color: "color",
                    isFinalPoster: "isFinalPoster",
                    padding: "padding",
                    text: "text",
                    font: "font",
                    minimumLength: "minimumLength",
                    orientation: "orientation"
                },
                decls: 3,
                vars: 12,
                consts: [[1, "character", 3, "height", "margin-top", "margin-bottom"], [1, "character"]],
                template: function(q, le) {
                    1 & q && (r.j41(0, "div"),
                    r.DNE(1, ee, 2, 0)(2, W, 1, 1),
                    r.k0s()),
                    2 & q && (r.ZvI("text-fill text-fill--", le._orientation, ""),
                    r.xc7("font-family", le._font)("font-size", le.fontSize, "px")("text-shadow", le.textShadow)("color", le.color),
                    r.R7$(),
                    r.vxM("portrait" === le._orientation ? 1 : 2))
                },
                dependencies: [Wt.MD],
                styles: ["[_nghost-%COMP%]{width:100%;height:100%;-webkit-user-select:none;user-select:none;letter-spacing:normal;z-index:1;position:absolute;display:block}[_nghost-%COMP%]   .text-fill[_ngcontent-%COMP%]{width:100%;height:100%;display:flex;z-index:1}[_nghost-%COMP%]   .text-fill.text-fill--landscape[_ngcontent-%COMP%]{justify-content:center;align-items:center}[_nghost-%COMP%]   .text-fill.text-fill--portrait[_ngcontent-%COMP%]{flex-direction:column;justify-content:center;align-items:center}[_nghost-%COMP%]   .text-fill.text-fill--portrait[_ngcontent-%COMP%]   .character[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center}"]
            }),
            ue
        }
        )();
        var Ve = function(oe) {
            return oe.DBL_HEARTS = "dbl_hearts",
            oe.HEARTS = "hearts",
            oe.FLOWER = "flower",
            oe.WILD_FLOWERS = "wild_flowers",
            oe
        }(Ve || {});
        const fe = () => [".jpeg", ".jpg", ".png", ".heic"]
          , Pt = oe => ({
            fill: oe
        });
        function mt(oe, ue) {
            if (1 & oe) {
                const J = r.RV6();
                r.j41(0, "img", 7),
                r.bIt("load", function() {
                    r.eBV(J);
                    const le = r.XpG(3);
                    return r.Njj(le.onImageLoad())
                })("click", function() {
                    r.eBV(J);
                    const le = r.XpG().$index
                      , Se = r.XpG(2);
                    return r.Njj(Se.selectClassicPhoto(le))
                }),
                r.k0s()
            }
            if (2 & oe) {
                const J = r.XpG().$index
                  , q = r.XpG(2);
                r.Y8G("src", q.finalImageUrl[J], r.B4B)
            }
        }
        function xo(oe, ue) {
            if (1 & oe) {
                const J = r.RV6();
                r.j41(0, "pp-controls-file-uploader-photo", 8),
                r.nI1(1, "async"),
                r.nI1(2, "translate"),
                r.bIt("setFileUploadingProgress", function(le) {
                    r.eBV(J);
                    const Se = r.XpG(3);
                    return r.Njj(Se.setFileUploadingProgress.emit(le))
                }),
                r.k0s()
            }
            if (2 & oe) {
                const J = r.XpG().$index
                  , q = r.XpG(2);
                r.Y8G("photoFileGroup", q.photoFileGroup)("photoCropGroup", q.photoCropGroup)("onlySingleInput", !1)("photoId", J)("multiFile", q.multiFile)("fileId", J)("isSubmitted", !1)("acceptable", r.lJ4(17, fe))("isBase64Response", !0)("fullHeight", !0)("isBigPictureMode", !0)("isFileUploadingInProgress", !!q.isFileUploadingInProgress && r.bMT(1, 13, q.isFileUploadingInProgress(J)))("legalNote", r.bMT(2, 15, "soundwave.details.instruction"))
            }
        }
        function So(oe, ue) {
            if (1 & oe && (r.j41(0, "div"),
            r.DNE(1, mt, 1, 1, "img", 5)(2, xo, 3, 18, "pp-controls-file-uploader-photo", 6),
            r.k0s()),
            2 & oe) {
                const J = ue.$index
                  , q = r.XpG(2);
                r.STu("grid-elements grid-elements-", q._collagePhotosAmount, " grid-position-", J, ""),
                r.R7$(),
                r.Y8G("ngIf", q.finalImageUrl[J] && (q.isInteractive || q.load >= J)),
                r.R7$(),
                r.Y8G("ngIf", !q.finalImageUrl[J])
            }
        }
        function ro(oe, ue) {
            if (1 & oe && r.nrm(0, "pp-poster-text-fill", 4),
            2 & oe) {
                const J = r.XpG(2);
                r.Y8G("isFinalPoster", J.isFinalPoster)("text", J.collageText.text)("color", J.collageText.color)("font", J.collageText.fontFamily)("orientation", J.collageText.orientation)("minimumLength", 5)("padding", J.collageText.padding)
            }
        }
        function Vo(oe, ue) {
            1 & oe && r.nrm(0, "img", 11)(1, "img", 12)
        }
        function vo(oe, ue) {
            if (1 & oe && r.nrm(0, "svg-icon", 13),
            2 & oe) {
                const J = r.XpG(3);
                r.AVh("motif-flower-portrait", J.poster.isPortrait)("motif-flower-square", J.poster.isSquare)("motif-flower-landscape", J.poster.isLandscape),
                r.Y8G("svgStyle", r.eq3(7, Pt, J.motifColor))
            }
        }
        function ei(oe, ue) {
            if (1 & oe && r.nrm(0, "svg-icon", 14),
            2 & oe) {
                const J = r.XpG(3);
                r.AVh("motif-dbl-hearts-portrait", J.poster.isPortrait)("motif-dbl-hearts-square", J.poster.isSquare)("motif-dbl-hearts-landscape", J.poster.isLandscape),
                r.Y8G("svgStyle", r.eq3(7, Pt, J.motifColor))
            }
        }
        function Ti(oe, ue) {
            if (1 & oe && r.nrm(0, "svg-icon", 15)(1, "svg-icon", 16),
            2 & oe) {
                const J = r.XpG(3);
                r.AVh("motif-hearts-top-portrait", J.poster.isPortrait)("motif-hearts-top-square", J.poster.isSquare)("motif-hearts-top-landscape", J.poster.isLandscape),
                r.Y8G("svgStyle", r.eq3(14, Pt, J.motifColor)),
                r.R7$(),
                r.AVh("motif-hearts-bottom-portrait", J.poster.isPortrait)("motif-hearts-bottom-square", J.poster.isSquare)("motif-hearts-bottom-landscape", J.poster.isLandscape),
                r.Y8G("svgStyle", r.eq3(16, Pt, J.motifColor))
            }
        }
        function ci(oe, ue) {
            if (1 & oe && r.DNE(0, Vo, 2, 0)(1, vo, 1, 9, "svg-icon", 9)(2, ei, 1, 9, "svg-icon", 10)(3, Ti, 2, 18),
            2 & oe) {
                const J = r.XpG(2);
                r.vxM(J.motif === J.CollageMotifsEnum.WILD_FLOWERS ? 0 : J.motif === J.CollageMotifsEnum.FLOWER ? 1 : J.motif === J.CollageMotifsEnum.DBL_HEARTS ? 2 : J.motif === J.CollageMotifsEnum.HEARTS ? 3 : -1)
            }
        }
        function ji(oe, ue) {
            if (1 & oe && (r.j41(0, "pp-poster-image-area")(1, "div", 2),
            r.Z7z(2, So, 3, 6, "div", 3, r.fX1),
            r.DNE(4, ro, 1, 7, "pp-poster-text-fill", 4),
            r.EFF(5),
            r.DNE(6, ci, 4, 1),
            r.k0s()()),
            2 & oe) {
                const J = r.XpG();
                r.R7$(),
                r.xc7("top", J.photoAreaMargin, "px")("bottom", J.photoAreaBottom, "px")("left", J.photoAreaMargin, "px")("right", J.photoAreaMargin, "px"),
                r.R7$(),
                r.Dyx(J.collagePhotosAmountArray),
                r.R7$(2),
                r.vxM(J.collageText ? 4 : -1),
                r.R7$(),
                r.SpI(" ", J.motifColor, " "),
                r.R7$(),
                r.vxM(J.motif ? 6 : -1)
            }
        }
        function yn(oe, ue) {
            1 & oe && r.nrm(0, "pp-poster-loaded-element")
        }
        let Dr = ( () => {
            var oe;
            class ue extends ht.f {
                constructor() {
                    super(...arguments),
                    this.isInteractive = !1,
                    this.isFinalPoster = !1,
                    this.motif = null,
                    this.motifColor = null,
                    this.collageText = null,
                    this._collagePhotosAmount = 1,
                    this.collagePhotosAmountArray = [],
                    this.multiFile = !1,
                    this.setFileUploadingProgress = new r.bkB,
                    this.selectPhoto = new r.bkB,
                    this.textareaHeightCallback = new r.bkB,
                    this.photoAreaBottom = this.photoAreaMargin,
                    this.CollageMotifsEnum = Ve
                }
                set collagePhotosAmount(q) {
                    this._collagePhotosAmount = q,
                    this.collagePhotosAmountArray = Array.from({
                        length: q
                    }, (le, Se) => Se)
                }
                setNewImageHeight(q) {
                    var le, Se, Rt, Qt;
                    this.poster && (this.photoAreaBottom = null !== (le = this.title) && void 0 !== le && le.text || null !== (Se = this.subtitle) && void 0 !== Se && Se.text ? (null !== (Rt = null === (Qt = this.textArea) || void 0 === Qt ? void 0 : Qt.bottomFactor) && void 0 !== Rt ? Rt : 0) * (this.poster.isPortrait ? this.poster.size.width : this.poster.size.height) + q : this.photoAreaMargin)
                }
                selectClassicPhoto(q) {
                    var le, Se;
                    const st = null !== (le = this.photoAreaMargin) && void 0 !== le ? le : 0
                      , Rt = {
                        width: this.poster.size.width - 2 * st,
                        height: this.poster.size.height - 2 * st - (null !== (Se = this.photoAreaBottom) && void 0 !== Se ? Se : 0)
                    };
                    this.selectPhoto.emit({
                        photoId: q,
                        imageInstanceSize: Rt
                    })
                }
                onImageLoad() {
                    this.load++,
                    this._collagePhotosAmount === this.load && this.initiateRender()
                }
            }
            return (oe = ue).\u0275fac = ( () => {
                let J;
                return function(le) {
                    return (J || (J = r.xGo(oe)))(le || oe)
                }
            }
            )(),
            oe.\u0275cmp = r.VBU({
                type: oe,
                selectors: [["pp-poster-photo-collage"]],
                inputs: {
                    photoAreaMargin: "photoAreaMargin",
                    finalImageUrl: "finalImageUrl",
                    poster: "poster",
                    textColor: "textColor",
                    textBackground: "textBackground",
                    isInteractive: "isInteractive",
                    isFinalPoster: "isFinalPoster",
                    textArea: "textArea",
                    title: "title",
                    subtitle: "subtitle",
                    motif: "motif",
                    motifColor: "motifColor",
                    collageText: "collageText",
                    collagePhotosAmount: "collagePhotosAmount",
                    photoFileGroup: "photoFileGroup",
                    photoCropGroup: "photoCropGroup",
                    multiFile: "multiFile",
                    isFileUploadingInProgress: "isFileUploadingInProgress"
                },
                outputs: {
                    setFileUploadingProgress: "setFileUploadingProgress",
                    selectPhoto: "selectPhoto",
                    textareaHeightCallback: "textareaHeightCallback"
                },
                features: [r.Vt3],
                decls: 3,
                vars: 8,
                consts: [[4, "ngIf"], [3, "textareaHeightCallback", "poster", "color", "background", "textArea", "title", "subtitle"], [1, "image-instance"], [3, "class"], [3, "isFinalPoster", "text", "color", "font", "orientation", "minimumLength", "padding"], [3, "src", "load", "click", 4, "ngIf"], [3, "photoFileGroup", "photoCropGroup", "onlySingleInput", "photoId", "multiFile", "fileId", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "isFileUploadingInProgress", "legalNote", "setFileUploadingProgress", 4, "ngIf"], [3, "load", "click", "src"], [3, "setFileUploadingProgress", "photoFileGroup", "photoCropGroup", "onlySingleInput", "photoId", "multiFile", "fileId", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "isFileUploadingInProgress", "legalNote"], ["src", "/assets/pp-posters/photo/motif/flower.svg", 1, "motif-flower", 3, "svgStyle", "motif-flower-portrait", "motif-flower-square", "motif-flower-landscape"], ["src", "/assets/pp-posters/photo/motif/dbl_hearts.svg", 1, "motif-dbl-hearts", 3, "svgStyle", "motif-dbl-hearts-portrait", "motif-dbl-hearts-square", "motif-dbl-hearts-landscape"], ["src", "/assets/pp-posters/photo/motif/wild_flowers_top.png", 1, "motif-wild-flowers", "motif-wild-flowers-top"], ["src", "/assets/pp-posters/photo/motif/wild_flowers_bottom.png", 1, "motif-wild-flowers", "motif-wild-flowers-bottom"], ["src", "/assets/pp-posters/photo/motif/flower.svg", 1, "motif-flower", 3, "svgStyle"], ["src", "/assets/pp-posters/photo/motif/dbl_hearts.svg", 1, "motif-dbl-hearts", 3, "svgStyle"], ["src", "/assets/pp-posters/photo/motif/hearts_top.svg", 1, "motif-hearts-top", 3, "svgStyle"], ["src", "/assets/pp-posters/photo/motif/hearts_bottom.svg", 1, "motif-hearts-bottom", 3, "svgStyle"]],
                template: function(q, le) {
                    1 & q && (r.DNE(0, ji, 7, 11, "pp-poster-image-area", 0),
                    r.j41(1, "pp-poster-text-area", 1),
                    r.bIt("textareaHeightCallback", function(st) {
                        return le.setNewImageHeight(st),
                        le.textareaHeightCallback.emit(st)
                    }),
                    r.k0s(),
                    r.DNE(2, yn, 1, 0, "pp-poster-loaded-element", 0)),
                    2 & q && (r.Y8G("ngIf", le.photoAreaMargin),
                    r.R7$(),
                    r.Y8G("poster", le.poster)("color", le.textColor)("background", le.textBackground)("textArea", le.textArea)("title", le.title)("subtitle", le.subtitle),
                    r.R7$(),
                    r.Y8G("ngIf", le.isImageRendered))
                },
                dependencies: [Wt.MD, Wt.bT, Wt.Jj, Tt.iu, Tt.DM, Xe.ex, Ce.W, Ye.y, yt.C, ae, mo.h, mo.D9],
                styles: [".image-instance[_ngcontent-%COMP%]{position:absolute}.image-instance[_ngcontent-%COMP%]   pp-poster-text-fill[_ngcontent-%COMP%]{pointer-events:none}.image-instance[_ngcontent-%COMP%]   img.motif-wild-flowers[_ngcontent-%COMP%]{width:25%;height:auto;position:absolute;pointer-events:none}.image-instance[_ngcontent-%COMP%]   img.motif-wild-flowers.motif-wild-flowers-top[_ngcontent-%COMP%]{top:0;left:0}.image-instance[_ngcontent-%COMP%]   img.motif-wild-flowers.motif-wild-flowers-bottom[_ngcontent-%COMP%]{bottom:0;right:0}.image-instance[_ngcontent-%COMP%]   svg-icon.motif-flower[_ngcontent-%COMP%]{pointer-events:none;position:absolute;display:flex;left:0;bottom:0}.image-instance[_ngcontent-%COMP%]   svg-icon.motif-flower.motif-flower-portrait[_ngcontent-%COMP%]{width:25%}.image-instance[_ngcontent-%COMP%]   svg-icon.motif-flower.motif-flower-square[_ngcontent-%COMP%]{width:17%}.image-instance[_ngcontent-%COMP%]   svg-icon.motif-flower.motif-flower-landscape[_ngcontent-%COMP%]{width:12%}.image-instance[_ngcontent-%COMP%]   svg-icon.motif-dbl-hearts[_ngcontent-%COMP%]{pointer-events:none;position:absolute;z-index:10}.image-instance[_ngcontent-%COMP%]   svg-icon.motif-dbl-hearts.motif-dbl-hearts-portrait[_ngcontent-%COMP%]{right:-3%;bottom:-3%;width:15%}.image-instance[_ngcontent-%COMP%]   svg-icon.motif-dbl-hearts.motif-dbl-hearts-square[_ngcontent-%COMP%]{right:-3%;bottom:-3%;width:17%}.image-instance[_ngcontent-%COMP%]   svg-icon.motif-dbl-hearts.motif-dbl-hearts-landscape[_ngcontent-%COMP%]{right:-1.5%;bottom:-3%;width:12%}.image-instance[_ngcontent-%COMP%]   svg-icon.motif-hearts-top[_ngcontent-%COMP%]{pointer-events:none;position:absolute;z-index:10}.image-instance[_ngcontent-%COMP%]   svg-icon.motif-hearts-top.motif-hearts-top-portrait[_ngcontent-%COMP%]{width:13%;top:2%;left:1%}.image-instance[_ngcontent-%COMP%]   svg-icon.motif-hearts-top.motif-hearts-top-square[_ngcontent-%COMP%]{width:11%;top:2%;left:1%}.image-instance[_ngcontent-%COMP%]   svg-icon.motif-hearts-top.motif-hearts-top-landscape[_ngcontent-%COMP%]{width:9%;top:2%;left:1%}.image-instance[_ngcontent-%COMP%]   svg-icon.motif-hearts-bottom[_ngcontent-%COMP%]{pointer-events:none;position:absolute;z-index:10;bottom:0}.image-instance[_ngcontent-%COMP%]   svg-icon.motif-hearts-bottom.motif-hearts-bottom-portrait[_ngcontent-%COMP%]{width:22%;right:-1%}.image-instance[_ngcontent-%COMP%]   svg-icon.motif-hearts-bottom.motif-hearts-bottom-square[_ngcontent-%COMP%]{width:20%;right:-1%}.image-instance[_ngcontent-%COMP%]   svg-icon.motif-hearts-bottom.motif-hearts-bottom-landscape[_ngcontent-%COMP%]{width:17%;right:-1.5%}.image-instance[_ngcontent-%COMP%]   .grid-elements[_ngcontent-%COMP%]{position:absolute;display:block;background:#dedddd}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-1[_ngcontent-%COMP%]{width:100%;height:100%}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-4[_ngcontent-%COMP%]{width:50%;height:50%}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-4.grid-position-0[_ngcontent-%COMP%]{top:0;left:0}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-4.grid-position-1[_ngcontent-%COMP%]{top:0;right:0}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-4.grid-position-2[_ngcontent-%COMP%]{bottom:0;left:0}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-4.grid-position-3[_ngcontent-%COMP%]{bottom:0;right:0}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-6[_ngcontent-%COMP%]{width:50%;height:34%}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-6.grid-position-0[_ngcontent-%COMP%]{top:0;left:0}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-6.grid-position-1[_ngcontent-%COMP%]{top:0;right:0}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-6.grid-position-2[_ngcontent-%COMP%]{top:33.33333%;left:0}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-6.grid-position-3[_ngcontent-%COMP%]{top:33.33333%;right:0}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-6.grid-position-4[_ngcontent-%COMP%]{height:33.3333%;bottom:0;left:0}.image-instance[_ngcontent-%COMP%]   .grid-elements.grid-elements-6.grid-position-5[_ngcontent-%COMP%]{height:33.3333%;bottom:0;right:0}.image-instance[_ngcontent-%COMP%]   .grid-elements[_ngcontent-%COMP%]   pp-controls-file-uploader[_ngcontent-%COMP%]{position:absolute;top:0;left:0;right:0;bottom:0;z-index:1020}.image-instance[_ngcontent-%COMP%]   .grid-elements[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:100%;height:100%;object-fit:cover;cursor:pointer}.delimiter[_ngcontent-%COMP%]{order:11;display:block;width:100%}"]
            }),
            ue
        }
        )();
        class Ln {
            static getTextAreaConfig(ue) {
                return {
                    bottomFactor: ue.isPortrait ? .035 : .03,
                    marginFactor: ue.isPortrait ? .05 : .03
                }
            }
            static getTitleTextSettings(ue) {
                return {
                    font: null != ue && ue.isDefaultFont ? ct.n3q.MONTSERRAT_MEDIUM : ct.n3q.HELLO_OCTOBER,
                    portrait: {
                        sizeFactor: null != ue && ue.isDefaultFont ? .05 : .088,
                        bottomFactor: null != ue && ue.isDefaultFont ? .0216 : .0243,
                        topFactor: null != ue && ue.isDefaultFont ? .06 : .03,
                        isBold: !1
                    },
                    horizontal: {
                        sizeFactor: null != ue && ue.isDefaultFont ? .05 : .08,
                        bottomFactor: null != ue && ue.isDefaultFont ? .034 : .018,
                        topFactor: null != ue && ue.isDefaultFont ? .04 : .03,
                        isBold: !1
                    }
                }
            }
            static getSubtitleTextSettings(ue) {
                return {
                    font: null != ue && ue.isDefaultFont ? ct.n3q.MONTSERRAT_THIN : ct.n3q.HELLO_OCTOBER,
                    portrait: {
                        sizeFactor: null != ue && ue.isDefaultFont ? .028 : .052,
                        bottomFactor: null != ue && ue.isDefaultFont ? .01 : 0,
                        topFactor: 0
                    },
                    horizontal: {
                        sizeFactor: null != ue && ue.isDefaultFont ? .03 : .052,
                        bottomFactor: null != ue && ue.isDefaultFont ? .02 : 0,
                        topFactor: 0
                    }
                }
            }
        }
        function Lr(oe, ue) {
            if (1 & oe) {
                const J = r.RV6();
                r.j41(0, "pp-poster-photo-classic", 8),
                r.nI1(1, "async"),
                r.nI1(2, "async"),
                r.nI1(3, "async"),
                r.nI1(4, "async"),
                r.nI1(5, "async"),
                r.nI1(6, "async"),
                r.nI1(7, "async"),
                r.bIt("setFileUploadingProgress", function(le) {
                    r.eBV(J);
                    const Se = r.XpG(2);
                    return r.Njj(Se.setFileUpploadingProgress.emit(le))
                })("selectPhoto", function(le) {
                    r.eBV(J);
                    const Se = r.XpG(2);
                    return r.Njj(Se.onPhotoSelect(le))
                })("textareaHeightCallback", function(le) {
                    r.eBV(J);
                    const Se = r.XpG(2);
                    return r.Njj(Se.newTextareaHeight(le))
                }),
                r.k0s()
            }
            if (2 & oe) {
                const J = r.XpG(2);
                r.Y8G("photoAreaMargin", r.bMT(1, 13, J.photoAreaMargin$))("finalImageUrl", J.finalImageUrl)("photoFileGroup", J.photoFileGroup)("photoCropGroup", J.photoCropGroup)("multiFile", J.multiFile)("isFileUploadingInProgress", J.isFileUploadingInProgress)("poster", r.bMT(2, 15, J.poster$))("textColor", r.bMT(3, 17, J.textColor$))("textBackground", r.bMT(4, 19, J.textBackground$))("textArea", r.bMT(5, 21, J.textArea$))("title", r.bMT(6, 23, J.title$))("subtitle", r.bMT(7, 25, J.subtitle$))("svgText", J.svgText)
            }
        }
        function xt(oe, ue) {
            if (1 & oe) {
                const J = r.RV6();
                r.j41(0, "pp-poster-photo-definition", 9),
                r.nI1(1, "async"),
                r.nI1(2, "async"),
                r.nI1(3, "async"),
                r.nI1(4, "async"),
                r.nI1(5, "async"),
                r.nI1(6, "async"),
                r.nI1(7, "async"),
                r.nI1(8, "async"),
                r.nI1(9, "async"),
                r.nI1(10, "async"),
                r.bIt("setFileUploadingProgress", function(le) {
                    r.eBV(J);
                    const Se = r.XpG(2);
                    return r.Njj(Se.setFileUpploadingProgress.emit(le))
                })("selectPhoto", function(le) {
                    r.eBV(J);
                    const Se = r.XpG(2);
                    return r.Njj(Se.onPhotoSelect(le))
                })("textareaHeightCallback", function(le) {
                    r.eBV(J);
                    const Se = r.XpG(2);
                    return r.Njj(Se.newTextareaHeight(le))
                }),
                r.k0s()
            }
            if (2 & oe) {
                const J = r.XpG(2);
                r.Y8G("photoAreaMargin", r.bMT(1, 17, J.photoAreaMargin$))("finalImageUrl", J.finalImageUrl)("photoFileGroup", J.photoFileGroup)("photoCropGroup", J.photoCropGroup)("multiFile", J.multiFile)("definitionPhotosAmount", J.photo.definitionPhotosAmount)("isFileUploadingInProgress", J.isFileUploadingInProgress)("poster", r.bMT(2, 19, J.poster$))("textColor", r.bMT(3, 21, J.textColor$))("textBackground", r.bMT(4, 23, J.textBackground$))("textArea", r.bMT(5, 25, J.textArea$))("title", r.bMT(6, 27, J.title$))("subtitle", r.bMT(7, 29, J.subtitle$))("definition", r.bMT(8, 31, J.footer$))("synonim", r.bMT(9, 33, J.date$))("delimiter", r.bMT(10, 35, J.delimiter$))("isInteractive", J.isInteractive)
            }
        }
        function Z(oe, ue) {
            if (1 & oe) {
                const J = r.RV6();
                r.j41(0, "pp-poster-photo-4grid", 10),
                r.nI1(1, "async"),
                r.nI1(2, "async"),
                r.bIt("setFileUploadingProgress", function(le) {
                    r.eBV(J);
                    const Se = r.XpG(2);
                    return r.Njj(Se.setFileUpploadingProgress.emit(le))
                })("selectPhoto", function(le) {
                    r.eBV(J);
                    const Se = r.XpG(2);
                    return r.Njj(Se.onPhotoSelect(le))
                })("textareaHeightCallback", function(le) {
                    r.eBV(J);
                    const Se = r.XpG(2);
                    return r.Njj(Se.newTextareaHeight(le))
                }),
                r.k0s()
            }
            if (2 & oe) {
                const J = r.XpG(2);
                r.Y8G("photoAreaMargin", r.bMT(1, 10, J.photoAreaMargin$))("gridPhotosAmount", J.photo.gridPhotosAmounts)("finalImageUrl", J.finalImageUrl)("photoFileGroup", J.photoFileGroup)("photoCropGroup", J.photoCropGroup)("multiFile", J.multiFile)("isFileUploadingInProgress", J.isFileUploadingInProgress)("poster", r.bMT(2, 12, J.poster$))("svgText", J.svgText)("isInteractive", J.isInteractive)
            }
        }
        function se(oe, ue) {
            if (1 & oe) {
                const J = r.RV6();
                r.j41(0, "pp-poster-photo-collage", 11),
                r.nI1(1, "async"),
                r.nI1(2, "async"),
                r.nI1(3, "async"),
                r.nI1(4, "async"),
                r.nI1(5, "async"),
                r.nI1(6, "async"),
                r.nI1(7, "async"),
                r.nI1(8, "async"),
                r.bIt("setFileUploadingProgress", function(le) {
                    r.eBV(J);
                    const Se = r.XpG(2);
                    return r.Njj(Se.setFileUpploadingProgress.emit(le))
                })("selectPhoto", function(le) {
                    r.eBV(J);
                    const Se = r.XpG(2);
                    return r.Njj(Se.onPhotoSelect(le))
                })("textareaHeightCallback", function(le) {
                    r.eBV(J);
                    const Se = r.XpG(2);
                    return r.Njj(Se.newTextareaHeight(le))
                }),
                r.k0s()
            }
            if (2 & oe) {
                const J = r.XpG(2);
                r.Y8G("photoAreaMargin", r.bMT(1, 18, J.photoAreaMargin$))("finalImageUrl", J.finalImageUrl)("isFinalPoster", J.isFinalPoster)("photoFileGroup", J.photoFileGroup)("photoCropGroup", J.photoCropGroup)("multiFile", J.multiFile)("collagePhotosAmount", J.photo.collagePhotosAmount)("isFileUploadingInProgress", J.isFileUploadingInProgress)("motif", J.collageMotif.motif)("motifColor", J.collageMotif.color)("poster", r.bMT(2, 20, J.poster$))("textColor", r.bMT(3, 22, J.textColor$))("textBackground", r.bMT(4, 24, J.textBackground$))("textArea", r.bMT(5, 26, J.textArea$))("title", r.bMT(6, 28, J.title$))("subtitle", r.bMT(7, 30, J.subtitle$))("collageText", r.bMT(8, 32, J.collageText$))("isInteractive", J.isInteractive)
            }
        }
        function Ee(oe, ue) {
            if (1 & oe && (r.j41(0, "pp-poster-printing-registration", 3)(1, "pp-poster-arrangement-wrapper"),
            r.DNE(2, Lr, 8, 27, "pp-poster-photo-classic", 4)(3, xt, 11, 37, "pp-poster-photo-definition", 5)(4, Z, 3, 14, "pp-poster-photo-4grid", 6)(5, se, 9, 34, "pp-poster-photo-collage", 7),
            r.k0s()()),
            2 & oe) {
                const J = ue.ngIf
                  , q = r.XpG();
                r.Y8G("poster", J),
                r.R7$(2),
                r.vxM(q.photo.layout === q.PhotoLayoutEnum.CLASSIC ? 2 : q.photo.layout === q.PhotoLayoutEnum.DEFINITION ? 3 : q.photo.layout === q.PhotoLayoutEnum.FOUR_GRID ? 4 : q.photo.layout === q.PhotoLayoutEnum.COLLAGE ? 5 : -1)
            }
        }
        let He = ( () => {
            var oe;
            class ue extends Qe.C {
                constructor(q, le) {
                    super(q, le),
                    this.host = q,
                    this.zone = le,
                    this.multiFile = !1,
                    this.setFileUpploadingProgress = new r.bkB,
                    this.photoSelect = new r.bkB,
                    this.photoAreaMargin$ = new _t.t(null),
                    this.textAreaHeight$ = new _t.t(null),
                    this.delimiter$ = new _t.t(null),
                    this.photo = {
                        background: "#FFFFFF",
                        layout: ct.KCj.CLASSIC,
                        definitionPhotosAmount: 1,
                        gridPhotosAmounts: 1,
                        collagePhotosAmount: 1
                    },
                    this.collageMotif = {
                        motif: null,
                        color: null
                    },
                    this.svgText = {
                        width: 0,
                        height: 0,
                        wrapperHeight: 0,
                        enabled: !1,
                        id: "",
                        custom: {
                            enabled: !1,
                            text: "",
                            fontSize: 0,
                            textHeight: 0,
                            fontFamily: ct.n3q.SIGNATURE_FONT
                        },
                        position: ct.FD.CENTER,
                        color: ct.jGw.BLACK
                    },
                    this.collageText$ = new _t.t({
                        text: "",
                        color: "#FFF",
                        fontFamily: ct.n3q.SIGNATURE_FONT,
                        orientation: "portrait",
                        padding: 0
                    }),
                    this.showAddPhoto = !0,
                    this.finalImageUrl = [],
                    this.PhotoLayoutEnum = ct.KCj
                }
                ngAfterViewInit() {
                    (0,
                    Ae.z)([this.poster$, this.textArea$, this.textAreaHeight$, this.photoAreaMargin$, this.posterConfiguration$]).pipe((0,
                    jt.B)(200), (0,
                    Me.Q)(this.ngUnsubscribe)).subscribe( ([q,le,Se,st,Rt]) => {
                        if (q && st)
                            if ((null == Rt ? void 0 : Rt.layout) !== ct.KCj.FOUR_GRID && Se) {
                                var Qt;
                                this.svgText.wrapperHeight = q.size.height - st - (null !== (Qt = null == le ? void 0 : le.bottomFactor) && void 0 !== Qt ? Qt : 0) * (q.isPortrait ? q.size.width : q.size.height) - (null != Se ? Se : 0)
                            } else
                                this.svgText.wrapperHeight = q.size.height - 2 * st
                    }
                    )
                }
                setAllTextSettings(q) {
                    if (q.layout === ct.KCj.CLASSIC) {
                        const le = {
                            text: q.customMessage ? q.title : "",
                            isDefaultFont: !q.alternativeFont
                        };
                        this.setText(le, this.title$, po.getTitleTextSettings(le));
                        const Se = {
                            text: q.customMessage ? q.text : "",
                            isDefaultFont: !0
                        };
                        this.setText(Se, this.subtitle$, po.getSubtitleTextSettings(Se))
                    } else if (q.layout === ct.KCj.COLLAGE) {
                        const le = {
                            text: q.customMessage ? q.title : "",
                            isDefaultFont: !q.alternativeFont
                        };
                        this.setText(le, this.title$, Ln.getTitleTextSettings(le));
                        const Se = {
                            text: q.customMessage ? q.text : "",
                            isDefaultFont: !q.subtitleAlternativeFont
                        };
                        this.setText(Se, this.subtitle$, Ln.getSubtitleTextSettings(Se))
                    } else if (q.layout === ct.KCj.DEFINITION) {
                        const le = {
                            text: q.customMessage ? q.definitionTitle : "",
                            isDefaultFont: !q.alternativeFont
                        }
                          , Se = {
                            text: q.customMessage ? q.subtitle : "",
                            isDefaultFont: !0
                        };
                        this.setText(le, this.title$, Lo.getTitleTextSettings(le, Se)),
                        this.setText(Se, this.subtitle$, Lo.getSubtitleTextSettings(le, Se));
                        const st = {
                            text: q.customMessage ? q.definition : "",
                            isDefaultFont: !0
                        };
                        this.setText(st, this.footer$, Lo.getDefinitionTextSettings(st));
                        const Rt = {
                            text: q.customMessage ? q.synonym : "",
                            isDefaultFont: !0
                        };
                        this.setText(Rt, this.date$, Lo.getSynonymTextSettings(Rt))
                    }
                }
                setTextArea(q, le) {
                    switch (le.layout) {
                    case ct.KCj.CLASSIC:
                    case ct.KCj.FOUR_GRID:
                        this.textArea$.next(po.getTextAreaConfig(q));
                        break;
                    case ct.KCj.DEFINITION:
                        this.textArea$.next(Lo.getTextAreaConfig(q)),
                        this.setDelimiter(q);
                        break;
                    case ct.KCj.COLLAGE:
                        this.textArea$.next(Ln.getTextAreaConfig(q))
                    }
                }
                setDelimiter(q) {
                    this.delimiter$.next({
                        height: q.isPortrait ? .002 * q.size.height : .003 * q.size.height
                    })
                }
                setDesign(q, le) {
                    var Se = this;
                    return (0,
                    Ut.A)(function*() {
                        const st = .055 * (q.isPortrait ? q.size.width : q.size.height);
                        Se.photoAreaMargin$.next(st),
                        Se.photo.layout = le.layout,
                        Se.photo.background = Se.getBackground(le),
                        Se.photo.definitionPhotosAmount = le.definitionPhotosAmount,
                        Se.photo.gridPhotosAmounts = le.gridPhotosAmounts,
                        Se.photo.collagePhotosAmount = le.collagePhotosAmount,
                        Se.textBackground$.next(Se.getBackground(le)),
                        Se.textColor$.next(Se.getTextColor(le)),
                        le.layout === ct.KCj.COLLAGE ? (Se.collageMotif.motif = le.collageColorScheme === ct.NWO.WILD_FLOWERS ? Ve.WILD_FLOWERS : le.collageColorScheme === ct.NWO.FLOWER ? Ve.FLOWER : le.collageColorScheme === ct.NWO.HEARTS ? Ve.HEARTS : le.collageColorScheme === ct.NWO.DBL_HEARTS ? Ve.DBL_HEARTS : null,
                        Se.collageMotif.color = "#".concat(le.customColors.motif)) : (Se.collageMotif.motif = null,
                        Se.collageMotif.color = null),
                        Se.collageText$.next({
                            text: le.collageText.toUpperCase(),
                            color: Se.getCollageTextColor(le),
                            fontFamily: le.collageAlternativeFont ? ct.n3q.ABRIL_FATFACE_REGULAR : ct.n3q.MONTSERRAT_EXTRABOLD,
                            orientation: q.isPortrait ? "portrait" : "landscape",
                            padding: .024 * q.size.width
                        }),
                        Se.svgText.width = q.size.width - 2 * st,
                        Se.svgText.height = Se.svgText.width / 4,
                        Se.svgText.enabled = le.themeEnabled,
                        Se.svgText.color = le.themeColor,
                        Se.svgText.position = le.themePosition,
                        Se.svgText.id = le.themeId,
                        Se.svgText.custom.enabled = "custom" === le.themeCategory,
                        Se.svgText.custom.enabled && (Se.svgText.custom.text = le.themeCustomText,
                        Se.svgText.custom.fontFamily = ct.n3q.SIGNATURE_FONT,
                        yield(0,
                        we.A)(ct.n3q.SIGNATURE_FONT),
                        Se.svgText.custom.fontSize = bt(Se.svgText.custom.text + "W", Se.svgText.width, Se.svgText.custom.fontFamily, .2 * Se.svgText.width),
                        Se.svgText.custom.textHeight = 1.8 * Se.svgText.custom.fontSize),
                        Se.showAddPhoto = !le.photoFiles[0].uuid,
                        Se.finalImageUrl = [];
                        for (let Rt = 0; Rt < le.photoFiles.length; Rt++)
                            Se.finalImageUrl.push(Se.getImageConfig(le, Rt))
                    })()
                }
                getImageConfig(q, le) {
                    return q.photoFiles[le].uuid ? "".concat(this.environmentPhotoApi, "/v2/").concat(this.isFinalPoster ? "photo" : "image", "/").concat(q.photoFiles[le].uuid, "?type=").concat(q.cropsData[le].filter, "&left=").concat(q.cropsData[le].cropData.x, "&top=").concat(q.cropsData[le].cropData.y, "&width=").concat(q.cropsData[le].cropData.width, "&height=").concat(q.cropsData[le].cropData.height, "&rotate=").concat(q.cropsData[le].rotate, "&flipped=").concat(q.cropsData[le].flip) : ""
                }
                newTextareaHeight(q) {
                    this.textAreaHeight$.next(q)
                }
                onPhotoSelectWithoutImageInstance(q) {
                    var le, Se, st, Rt;
                    switch (this.photo.layout) {
                    case ct.KCj.CLASSIC:
                        null === (le = this.ppPosterPhotoClassicComponent) || void 0 === le || le.selectClassicPhoto(q);
                        break;
                    case ct.KCj.DEFINITION:
                        null === (Se = this.ppPosterPhotoDefinitionComponent) || void 0 === Se || Se.selectClassicPhoto(q);
                        break;
                    case ct.KCj.FOUR_GRID:
                        null === (st = this.ppPosterPhoto4gridComponent) || void 0 === st || st.selectClassicPhoto(q);
                        break;
                    case ct.KCj.COLLAGE:
                        null === (Rt = this.ppPosterPhotoCollageComponent) || void 0 === Rt || Rt.selectClassicPhoto(q)
                    }
                }
                onPhotoSelect({photoId: q, imageInstanceSize: le}) {
                    this.photoSelect.emit([le.width, le.height, q])
                }
                getBackground(q) {
                    if (q.layout === ct.KCj.DEFINITION)
                        switch (q.definitionColorScheme) {
                        case ct.vG4.COSMIC_LATTE:
                            return "#F7E5CE";
                        case ct.vG4.DEEP_SPACE_BLUE:
                            return "#151D29";
                        case ct.vG4.SIMPLE:
                            return "#FFFFFF";
                        case ct.vG4.DARK:
                            return "#1D1D1B";
                        case ct.vG4.DUSTY_PINK:
                            return "#DEC2BA";
                        case ct.vG4.NAVY:
                            return "#384560";
                        case ct.vG4.SUNDUSK:
                            return "#393F4E";
                        case ct.vG4.VINTAGE:
                            return "#edeae3";
                        case ct.vG4.CUSTOM:
                            return "#".concat(q.customColors.background);
                        default:
                            return q.definitionColorScheme
                        }
                    else if (q.layout === ct.KCj.COLLAGE)
                        switch (q.collageColorScheme) {
                        case ct.NWO.COSMIC_LATTE:
                            return "#F7E5CE";
                        case ct.NWO.ROSE:
                            return "#F3EDE5";
                        case ct.NWO.DEEP_SPACE_BLUE:
                            return "#151D29";
                        case ct.NWO.FLOWER:
                        case ct.NWO.DBL_HEARTS:
                        case ct.NWO.HEARTS:
                        case ct.NWO.WILD_FLOWERS:
                        case ct.NWO.CUSTOM:
                            return "#".concat(q.customColors.background);
                        default:
                            return q.collageColorScheme
                        }
                    return "#FFFFFF"
                }
                getCollageTextColor(q) {
                    switch (q.collageColorScheme) {
                    case ct.NWO.COSMIC_LATTE:
                        return "#FFFFFF";
                    case ct.NWO.ROSE:
                        return "#DE254D";
                    case ct.NWO.DEEP_SPACE_BLUE:
                        return "#16212C";
                    case ct.NWO.FLOWER:
                    case ct.NWO.DBL_HEARTS:
                    case ct.NWO.HEARTS:
                    case ct.NWO.WILD_FLOWERS:
                    case ct.NWO.CUSTOM:
                        return "#".concat(q.customColors.collageText);
                    default:
                        return q.collageColorScheme
                    }
                }
                getTextColor(q) {
                    if (q.layout === ct.KCj.DEFINITION)
                        switch (q.definitionColorScheme) {
                        case ct.vG4.COSMIC_LATTE:
                            return "#151D29";
                        case ct.vG4.DEEP_SPACE_BLUE:
                            return "#F7E5CE";
                        case ct.vG4.SIMPLE:
                            return "#000000";
                        case ct.vG4.DARK:
                            return "#FFFFFF";
                        case ct.vG4.DUSTY_PINK:
                            return "#000000";
                        case ct.vG4.NAVY:
                            return "#FFFFFF";
                        case ct.vG4.SUNDUSK:
                            return "#FFCC66";
                        case ct.vG4.VINTAGE:
                            return "#ab7d64";
                        case ct.vG4.CUSTOM:
                            return "#".concat(q.customColors.text);
                        default:
                            return q.definitionColorScheme
                        }
                    else if (q.layout === ct.KCj.COLLAGE)
                        switch (q.collageColorScheme) {
                        case ct.NWO.COSMIC_LATTE:
                            return "#151D29";
                        case ct.NWO.ROSE:
                            return "#1D1C25";
                        case ct.NWO.DEEP_SPACE_BLUE:
                            return "#F7E5CE";
                        case ct.NWO.FLOWER:
                        case ct.NWO.DBL_HEARTS:
                        case ct.NWO.HEARTS:
                        case ct.NWO.WILD_FLOWERS:
                        case ct.NWO.CUSTOM:
                            return "#".concat(q.customColors.text);
                        default:
                            return q.collageColorScheme
                        }
                    return "#000000"
                }
            }
            return (oe = ue).\u0275fac = function(q) {
                return new (q || oe)(r.rXU(r.aKT),r.rXU(r.SKi))
            }
            ,
            oe.\u0275cmp = r.VBU({
                type: oe,
                selectors: [["pp-poster-photo"]],
                viewQuery: function(q, le) {
                    if (1 & q && (r.GBs(Jt, 5),
                    r.GBs(_o, 5),
                    r.GBs(B, 5),
                    r.GBs(Dr, 5)),
                    2 & q) {
                        let Se;
                        r.mGM(Se = r.lsd()) && (le.ppPosterPhotoClassicComponent = Se.first),
                        r.mGM(Se = r.lsd()) && (le.ppPosterPhotoDefinitionComponent = Se.first),
                        r.mGM(Se = r.lsd()) && (le.ppPosterPhoto4gridComponent = Se.first),
                        r.mGM(Se = r.lsd()) && (le.ppPosterPhotoCollageComponent = Se.first)
                    }
                },
                inputs: {
                    photoFileGroup: "photoFileGroup",
                    photoCropGroup: "photoCropGroup",
                    multiFile: "multiFile",
                    cropperConfig: "cropperConfig",
                    environmentPhotoApi: "environmentPhotoApi",
                    isFileUploadingInProgress: "isFileUploadingInProgress"
                },
                outputs: {
                    setFileUpploadingProgress: "setFileUpploadingProgress",
                    photoSelect: "photoSelect"
                },
                features: [r.Vt3],
                decls: 4,
                vars: 4,
                consts: [["posterWrapper", ""], [3, "background"], [3, "poster", 4, "ngIf"], [3, "poster"], [3, "photoAreaMargin", "finalImageUrl", "photoFileGroup", "photoCropGroup", "multiFile", "isFileUploadingInProgress", "poster", "textColor", "textBackground", "textArea", "title", "subtitle", "svgText"], [3, "photoAreaMargin", "finalImageUrl", "photoFileGroup", "photoCropGroup", "multiFile", "definitionPhotosAmount", "isFileUploadingInProgress", "poster", "textColor", "textBackground", "textArea", "title", "subtitle", "definition", "synonim", "delimiter", "isInteractive"], [3, "photoAreaMargin", "gridPhotosAmount", "finalImageUrl", "photoFileGroup", "photoCropGroup", "multiFile", "isFileUploadingInProgress", "poster", "svgText", "isInteractive"], [3, "photoAreaMargin", "finalImageUrl", "isFinalPoster", "photoFileGroup", "photoCropGroup", "multiFile", "collagePhotosAmount", "isFileUploadingInProgress", "motif", "motifColor", "poster", "textColor", "textBackground", "textArea", "title", "subtitle", "collageText", "isInteractive"], [3, "setFileUploadingProgress", "selectPhoto", "textareaHeightCallback", "photoAreaMargin", "finalImageUrl", "photoFileGroup", "photoCropGroup", "multiFile", "isFileUploadingInProgress", "poster", "textColor", "textBackground", "textArea", "title", "subtitle", "svgText"], [3, "setFileUploadingProgress", "selectPhoto", "textareaHeightCallback", "photoAreaMargin", "finalImageUrl", "photoFileGroup", "photoCropGroup", "multiFile", "definitionPhotosAmount", "isFileUploadingInProgress", "poster", "textColor", "textBackground", "textArea", "title", "subtitle", "definition", "synonim", "delimiter", "isInteractive"], [3, "setFileUploadingProgress", "selectPhoto", "textareaHeightCallback", "photoAreaMargin", "gridPhotosAmount", "finalImageUrl", "photoFileGroup", "photoCropGroup", "multiFile", "isFileUploadingInProgress", "poster", "svgText", "isInteractive"], [3, "setFileUploadingProgress", "selectPhoto", "textareaHeightCallback", "photoAreaMargin", "finalImageUrl", "isFinalPoster", "photoFileGroup", "photoCropGroup", "multiFile", "collagePhotosAmount", "isFileUploadingInProgress", "motif", "motifColor", "poster", "textColor", "textBackground", "textArea", "title", "subtitle", "collageText", "isInteractive"]],
                template: function(q, le) {
                    1 & q && (r.j41(0, "pp-poster-background", 1, 0),
                    r.DNE(2, Ee, 6, 2, "pp-poster-printing-registration", 2),
                    r.nI1(3, "async"),
                    r.k0s()),
                    2 & q && (r.Y8G("background", le.photo.background),
                    r.R7$(2),
                    r.Y8G("ngIf", r.bMT(3, 2, le.poster$)))
                },
                dependencies: [Wt.MD, Wt.bT, Wt.Jj, Mt.Z, s.R, so.c, Tt.iu, Jt, B, _o, Dr],
                styles: ["[_nghost-%COMP%]{width:100%;height:100%;display:block}"]
            }),
            ue
        }
        )()
    }
    ,
    57493: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            G: () => Tt,
            d: () => Qe
        });
        var Ut = $(10467)
          , r = $(60177)
          , Mt = $(27617)
          , s = $(50552)
          , so = $(54843)
          , Wt = $(16968)
          , _t = $(15996)
          , Ae = $(54438)
          , Me = $(21626)
          , ct = $(345);
        const Tt = {
            background: "#FFF",
            textBackground: "#FFF",
            passepartoutSize: 0,
            layout: Mt.U9G.SQUARE,
            shape: Mt.U9G.SQUARE,
            layoutBorderColor: "#FFF",
            svgCoverWidth: 0,
            sideCover: 0,
            blockMapUpdate: !1,
            viewPort: [[0, 0], [0, 0]],
            zoom: 11,
            style: void 0,
            markerByWidth: !0,
            customColor: {
                land: "#FFF",
                water: "#FFF",
                roads: "#FFF",
                background: "#FFFFFF"
            },
            showMarker: !1,
            markerPosition: [0, 0],
            markerType: Mt.sKi.HEART,
            markerColor: "#333",
            image: "",
            markerPrint: {
                html: "",
                width: 0,
                height: 0,
                left: 0,
                top: 0
            }
        };
        let Qe = ( () => {
            var jt;
            class Xe extends s.C {
                constructor(it, et, re, pt, Be, ze) {
                    super(it, et),
                    this.host = it,
                    this.zone = et,
                    this.httpClient = re,
                    this.domSanitizer = pt,
                    this.cdr = Be,
                    this.renderer2 = ze,
                    this.useImageMap = !1,
                    this.MapsLayoutsEnum = Mt.U9G
                }
                setAllTextSettings(it) {}
                setTextArea(it, et) {}
                setDesign(it, et) {
                    return new Promise(re => {
                        setTimeout(re, 10)
                    }
                    )
                }
                mathCeil(it) {
                    return Math.ceil(it)
                }
                getBackground(it, et) {
                    return it === Mt.c_T.CUSTOM ? "#".concat(et.background) : "#FFFFFF"
                }
                getText(it, et) {
                    return it === Mt.c_T.CUSTOM ? (0,
                    _t.V)(et.background) ? "#FFF" : "#0e1111" : "#000000"
                }
                getBorderColor(it, et, re) {
                    switch (it) {
                    case Mt.c_T.MINIMAL:
                    case Mt.c_T.BEACHGLASS:
                        return "#222";
                    case Mt.c_T.CARBON:
                    case Mt.c_T.BLACK:
                    case Mt.c_T.INTENSE:
                        return re ? "#222" : "#DDD";
                    case Mt.c_T.VINTAGE:
                        return "#D8B6A4";
                    case Mt.c_T.CUSTOM:
                        return "#".concat(et.roads);
                    case Mt.c_T.ANTIQUA:
                        return "#45453f";
                    case Mt.c_T.CLASSIC:
                        return "#56442a";
                    case Mt.c_T.WANDERLUST:
                        return "#d67373";
                    case Mt.c_T.COSY:
                        return "#b09e99";
                    case Mt.c_T.BEACHGLASS_CARBON:
                    case Mt.c_T.MINIMAL_WANDERLUST:
                        return "red"
                    }
                }
                get mapConfigs() {
                    return this.mapsForm.get("mapConfig")
                }
                exportSvg(it, et) {
                    var re = this;
                    return (0,
                    Ut.A)(function*() {
                        var pt;
                        const Be = null === (pt = re.mapWrappers.get(et)) || void 0 === pt ? void 0 : pt.generateSVG();
                        Be || console.log("LACK OF IMAGE");
                        const ze = yield(0,
                        so._)(re.httpClient.post("/api/map/mapbox/png", {
                            image: Be
                        }));
                        re.mapConfigs.at(it).controls.uuid.setValue(ze.uuid)
                    })()
                }
                updateMapConfig(it, et) {
                    const re = this.mapConfigs.at(et);
                    re.controls.zoom.setValue(it.userZoom, {
                        emitEvent: !1
                    }),
                    re.controls.map.setValue(it.map, {
                        emitEvent: !1
                    });
                    const pt = re.controls.place.value;
                    pt && (pt.center = {
                        latitude: it.center.lat,
                        longitude: it.center.lng
                    },
                    pt.viewPort = it.boundaries,
                    re.controls.place.setValue(pt, {
                        emitEvent: !1
                    }))
                }
                updateMarkerConfig(it, et) {
                    var re, pt, Be, ze;
                    const ye = this.mapConfigs.at(et);
                    ye.controls.markerSize.setValue(null !== (re = null === (pt = it.marker) || void 0 === pt ? void 0 : pt.size) && void 0 !== re ? re : {
                        width: 0,
                        height: 0
                    }, {
                        emitEvent: !1
                    }),
                    ye.controls.markerLocation.setValue(null !== (Be = null === (ze = it.marker) || void 0 === ze ? void 0 : ze.location) && void 0 !== Be ? Be : {
                        x: -100,
                        y: -100
                    }, {
                        emitEvent: !1
                    })
                }
            }
            return (jt = Xe).\u0275fac = function(it) {
                return new (it || jt)(Ae.rXU(Ae.aKT),Ae.rXU(Ae.SKi),Ae.rXU(Me.Qq),Ae.rXU(ct.up),Ae.rXU(Ae.gRc),Ae.rXU(Ae.sFG))
            }
            ,
            jt.\u0275cmp = Ae.VBU({
                type: jt,
                selectors: [["pp-poster-maps-common"]],
                viewQuery: function(it, et) {
                    if (1 & it && Ae.GBs(Wt.f, 5),
                    2 & it) {
                        let re;
                        Ae.mGM(re = Ae.lsd()) && (et.mapWrappers = re)
                    }
                },
                inputs: {
                    mapsForm: "mapsForm",
                    mapsEndpoint: "mapsEndpoint",
                    useImageMap: "useImageMap"
                },
                features: [Ae.Vt3],
                decls: 0,
                vars: 0,
                template: function(it, et) {},
                dependencies: [r.MD],
                encapsulation: 2
            }),
            Xe
        }
        )()
    }
    ,
    57761: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            b: () => Kt
        });
        var Ut = $(10467)
          , r = $(54438)
          , Mt = $(60177)
          , s = $(27617)
          , so = $(7494)
          , Wt = $(9566)
          , _t = $(13620)
          , Ae = $(61762)
          , Me = $(69847)
          , ct = $(78606)
          , Tt = $(50552)
          , Qe = $(84412)
          , jt = $(41046)
          , Xe = $(91054)
          , Ce = $(81836);
        const it = (At, Re) => {
            switch (At) {
            case s.STr.SIMPLE:
                return "#FFF";
            case s.STr.COSMIC_LATTE:
                return "#f6E5CE";
            case s.STr.DEEP_SPACE_BLUE:
                return "#0f1721";
            case s.STr.VINTAGE:
                return "#eceae2";
            case s.STr.STONE:
                return "#f1f1e9";
            case s.STr.ROSE:
                return "#f3ede5";
            case s.STr.CUSTOM:
                return "#".concat(Re);
            default:
                return At
            }
        }
          , et = (At, Re) => {
            switch (At) {
            case s.STr.SIMPLE:
                return "#000";
            case s.STr.COSMIC_LATTE:
                return "#0f1212";
            case s.STr.DEEP_SPACE_BLUE:
                return "#f6e5ce";
            case s.STr.VINTAGE:
                return "#ad7c61";
            case s.STr.STONE:
                return "#4b6f86";
            case s.STr.ROSE:
                return "#e13b5b";
            case s.STr.CUSTOM:
                return "#".concat(Re);
            default:
                return At
            }
        }
        ;
        var re = $(21626)
          , pt = $(345);
        const Be = ["charComponents"]
          , ze = (At, Re) => Re.trackBy;
        function ye(At, Re) {
            if (1 & At) {
                const ve = r.RV6();
                r.j41(0, "pp-poster-character", 12, 1),
                r.nI1(2, "async"),
                r.bIt("openAdvancedOptions", function(B) {
                    r.eBV(ve);
                    const de = r.XpG(3);
                    return r.Njj(de.openAdvancedOptions.emit(B))
                })("openErrorMsg", function(B) {
                    r.eBV(ve);
                    const de = r.XpG(3);
                    return r.Njj(de.openErrorMsg.emit(B))
                })("setFileUploadingProgress", function(B) {
                    r.eBV(ve);
                    const de = r.XpG(3);
                    return r.Njj(de.setFileUploadingProgress.emit(B))
                })("selectPhoto", function(B) {
                    r.eBV(ve);
                    const de = r.XpG(3);
                    return r.Njj(de.onPhotoSelect(B))
                })("photoLoaded", function() {
                    r.eBV(ve);
                    const B = r.XpG(3);
                    return r.Njj(B.onImageLoad())
                }),
                r.k0s()
            }
            if (2 & At) {
                const ve = r.XpG()
                  , ne = ve.$implicit
                  , B = ve.$index
                  , de = r.XpG(2);
                r.Y8G("isFinalPoster", de.isFinalPoster)("charId", B)("character", ne.char)("imageUrl", ne.image)("imageId", de.photoFileGroup ? de.photoAccess(B).controls.uuid.value : "")("photoFileGroup", de.photoFileGroup)("photoCropGroup", de.photoCropGroup)("onlySingleInput", !1)("isInteractive", de.isInteractive)("multiFile", de.multiFile)("isFileUploadingInProgress", !!de.isFileUploadingInProgress && r.bMT(2, 14, de.isFileUploadingInProgress(B)))("readyToLoad", de.isInteractive || de.load >= B)("svgCharFilesPath", "/assets/pp-posters/letter/characters/classic")("charactersDefinition", de.charactersDefinition)
            }
        }
        function ge(At, Re) {
            if (1 & At && (r.j41(0, "div", 10),
            r.DNE(1, ye, 3, 16, "pp-poster-character", 11),
            r.k0s()),
            2 & At) {
                const ve = Re.$implicit
                  , ne = r.XpG(2);
                r.xc7("height", ne.photoLetter.character.height, "px")("width", ve.width, "px")("margin-left", ve.marginLeft, "px"),
                r.R7$(),
                r.vxM(" " !== ve.char ? 1 : -1)
            }
        }
        function Ie(At, Re) {
            if (1 & At) {
                const ve = r.RV6();
                r.j41(0, "pp-poster-printing-registration", 5)(1, "pp-poster-arrangement-wrapper"),
                r.nrm(2, "pp-poster-text-area", 6),
                r.nI1(3, "async"),
                r.nI1(4, "async"),
                r.nI1(5, "async"),
                r.nI1(6, "async"),
                r.j41(7, "pp-poster-image-area")(8, "div", 7),
                r.Z7z(9, ge, 2, 7, "div", 8, ze),
                r.k0s()(),
                r.j41(11, "pp-poster-text-area", 9),
                r.nI1(12, "async"),
                r.nI1(13, "async"),
                r.nI1(14, "async"),
                r.nI1(15, "async"),
                r.bIt("textareaHeightCallback", function(B) {
                    r.eBV(ve);
                    const de = r.XpG();
                    return r.Njj(de.newTextareaHeight(B))
                }),
                r.k0s()()()
            }
            if (2 & At) {
                const ve = Re.ngIf
                  , ne = r.XpG();
                r.Y8G("poster", ve),
                r.R7$(2),
                r.Y8G("poster", r.bMT(3, 19, ne.poster$))("color", r.bMT(4, 21, ne.textColor$))("textArea", r.bMT(5, 23, ne.topTextArea$))("title", r.bMT(6, 25, ne.title$)),
                r.R7$(6),
                r.xc7("top", ne.photoLetter.textArea.top, "px")("width", ne.photoLetter.textArea.width, "px")("height", ne.photoLetter.textArea.height, "px")("margin-top", ne.photoLetter.textArea.marginTop, "px")("margin-left", ne.photoLetter.textArea.marginLeft, "px"),
                r.R7$(),
                r.Dyx(ne.photoLetter.chars),
                r.R7$(2),
                r.Y8G("poster", r.bMT(12, 27, ne.poster$))("color", r.bMT(13, 29, ne.textColor$))("textArea", r.bMT(14, 31, ne.textArea$))("subtitle", r.bMT(15, 33, ne.subtitle$))
            }
        }
        function gt(At, Re) {
            1 & At && r.nrm(0, "pp-poster-loaded-element")
        }
        let Ye = ( () => {
            var At;
            class Re extends Tt.C {
                constructor(ne, B, de, lt, St, tt) {
                    super(ne, B),
                    this.host = ne,
                    this.zone = B,
                    this.cdr = de,
                    this.httpClient = lt,
                    this.domSanitizer = St,
                    this.renderer2 = tt,
                    this.multiFile = !1,
                    this.photoSelect = new r.bkB,
                    this.setFileUploadingProgress = new r.bkB,
                    this.openErrorMsg = new r.bkB,
                    this.openAdvancedOptions = new r.bkB,
                    this.photoLetter = {
                        textArea: {
                            top: 0,
                            width: 0,
                            height: 0,
                            marginTop: 0,
                            marginLeft: 0
                        },
                        character: {
                            height: 0
                        },
                        background: "#fff",
                        chars: []
                    },
                    this.charactersDefinition = Ce.Uj,
                    this.textAreaHeight$ = new Qe.t(null),
                    this.topTextAreaHeight$ = new Qe.t(null)
                }
                onPhotoSelect({photoId: ne, imageInstanceSize: B}) {
                    this.photoSelect.emit([B.width, B.height, ne])
                }
                onPhotoSelectWithoutImageInstance(ne) {
                    var B;
                    null === (B = this.charComponents.toArray()) || void 0 === B || null === (B = B[ne]) || void 0 === B || B.selectLetter(ne)
                }
                setAllTextSettings(ne) {
                    const B = {
                        text: ne.title,
                        isDefaultFont: !ne.titleFont
                    };
                    this.setText(B, this.title$, {
                        font: null != B && B.isDefaultFont ? s.n3q.ROBOTO_THIN : s.n3q.POSITIVE_PRINTS_SCRIPT_2,
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: null != B && B.isDefaultFont ? .054 : .084,
                            bottomFactor: 0,
                            topFactor: 0,
                            maxLines: 1,
                            isBold: !1
                        }
                    });
                    const de = {
                        text: ne.subtitle,
                        isDefaultFont: !ne.subtitleFont
                    };
                    this.setText(de, this.subtitle$, {
                        font: null != de && de.isDefaultFont ? s.n3q.ROBOTO_THIN : s.n3q.HELLO_OCTOBER,
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: null != de && de.isDefaultFont ? .0265 : .066,
                            bottomFactor: 0,
                            topFactor: 0
                        }
                    })
                }
                setDesign(ne, B) {
                    return (0,
                    Ut.A)(function*() {})()
                }
                textLetterAreaHeight(ne, B, de, lt) {
                    return ne ? B ? .9 : .7 : .6
                }
                textLetterAreaMartinTop(ne, B, de, lt) {
                    return ne ? B ? -.15 : -.0525 : B || lt ? 0 : -.0525
                }
                setTextArea(ne, B) {
                    this.photoLetter.textArea.top = .2 * ne.size.height,
                    this.photoLetter.textArea.width = .96 * ne.size.width;
                    const de = [...B.text].length < 3
                      , lt = !B.title && !B.subtitle
                      , St = !B.title && !!B.subtitle
                      , tt = !!B.title && !B.subtitle;
                    this.photoLetter.textArea.height = ne.size.height * this.textLetterAreaHeight(de, lt, St, tt),
                    this.photoLetter.textArea.marginTop = ne.size.height * this.textLetterAreaMartinTop(de, lt, St, tt),
                    this.photoLetter.textArea.marginLeft = .02 * ne.size.width;
                    const Nt = this.photoLetter.textArea.height / Ce.Uj.E.height;
                    let Vt, _o = 0;
                    if (this.photoLetter.chars = [],
                    this.renderer2.setProperty(this.host.nativeElement, "style", "--character-outline-color: #".concat(B.customColors.outline)),
                    this.photoLetter.background = it(B.colorScheme, B.customColors.background),
                    this.textColor$.next(et(B.colorScheme, B.customColors.text)),
                    [...B.text].forEach( (ie, we) => {
                        ie = ie.toUpperCase();
                        const Oe = structuredClone(Ce.Uj[ie]);
                        if (!Oe)
                            return _o += Ce.Ur * Nt,
                            void this.photoLetter.chars.push({
                                char: " ",
                                marginLeft: 0,
                                width: Ce.Ur * Nt,
                                image: "",
                                trackBy: "space-".concat(we)
                            });
                        let ee = 0;
                        Vt && Oe.prevCharacter[Vt] && (ee = Oe.prevCharacter[Vt] * Nt),
                        _o += Oe.width * Nt,
                        this.photoLetter.chars.push({
                            char: ie,
                            marginLeft: ee,
                            width: Oe.width * Nt,
                            image: this.getImageConfig(B, we),
                            trackBy: "".concat(ie, "-").concat(we)
                        }),
                        Vt = ie
                    }
                    ),
                    _o > this.photoLetter.textArea.width) {
                        const ie = this.photoLetter.textArea.width / _o;
                        this.photoLetter.character.height = this.photoLetter.textArea.height * ie,
                        this.photoLetter.chars.forEach(we => {
                            we.width = we.width * ie,
                            Ce.Uj[we.char] && (we.marginLeft = we.marginLeft * ie)
                        }
                        )
                    } else
                        this.photoLetter.character.height = this.photoLetter.textArea.height;
                    const Lo = ne.size.height;
                    this.topTextArea$.next({
                        topFactor: (this.photoLetter.textArea.top - (B.titleFont ? .14 : .12) * Lo) / Lo,
                        marginFactor: ne.isPortrait ? .08 : .04,
                        fixedHeightFactor: (Lo - this.photoLetter.character.height) / 2 / Lo,
                        isFlex: !0,
                        isJustifyCenter: !0
                    }),
                    this.textArea$.next({
                        marginFactor: ne.isPortrait ? .07 : .04,
                        topFactor: (this.photoLetter.textArea.top + (this.photoLetter.textArea.height - this.photoLetter.character.height) / 2 + this.photoLetter.character.height + this.photoLetter.textArea.marginTop) / Lo
                    });
                    let Xt = 0;
                    for (const ie of this.photoLetter.chars) {
                        if (!(" " === ie.char || this.charactersDefinition[ie.char] && this.charactersDefinition[ie.char].withoutPhoto))
                            break;
                        Xt++
                    }
                    Xt > 0 && this.onImageLoad()
                }
                newTextareaHeight(ne) {
                    this.textAreaHeight$.next(ne)
                }
                newTopTextareaHeight(ne) {
                    this.topTextAreaHeight$.next(ne)
                }
                getImageConfig(ne, B) {
                    if (!ne.photoFiles[B].uuid)
                        return "";
                    const de = ne.cropsData[B]
                      , lt = ne.photoFiles[B]
                      , St = lt.weight
                      , Nt = (St * Ce.wS - St) / 2 / St * 100
                      , Vt = lt.size.height
                      , ao = (Vt * Ce.wS - Vt) / 2 / Vt * 100
                      , bt = lt.uuid
                      , Do = de.isInitialized ? de.filter : "normal"
                      , Xt = de.isInitialized ? de.cropData.x : Nt
                      , ie = de.isInitialized ? de.cropData.y : ao
                      , we = de.isInitialized ? de.cropData.width : 100 - 2 * Nt
                      , Oe = de.isInitialized ? de.cropData.height : 100 - 2 * ao
                      , ee = de.isInitialized ? de.rotate : 0
                      , W = !!de.isInitialized && de.flip;
                    return "".concat(this.environmentPhotoApi, "/v2/").concat(this.isFinalPoster ? "photo" : "image", "/").concat(bt, "?type=").concat(Do, "&left=").concat(Xt, "&top=").concat(ie, "&width=").concat(we, "&height=").concat(Oe, "&rotate=").concat(ee, "&flipped=").concat(W)
                }
                onImageLoad() {
                    for (this.load++; this.photoLetter.chars[this.load] && " " === this.photoLetter.chars[this.load].char; )
                        this.load++;
                    this.load >= this.photoLetter.chars.length && (this.initiateRender(),
                    this.cdr.detectChanges())
                }
                photoAccess(ne) {
                    return this.photoFileGroup.at(ne)
                }
            }
            return (At = Re).\u0275fac = function(ne) {
                return new (ne || At)(r.rXU(r.aKT),r.rXU(r.SKi),r.rXU(r.gRc),r.rXU(re.Qq),r.rXU(pt.up),r.rXU(r.sFG))
            }
            ,
            At.\u0275cmp = r.VBU({
                type: At,
                selectors: [["pp-poster-letter-classic"]],
                viewQuery: function(ne, B) {
                    if (1 & ne && r.GBs(Be, 5),
                    2 & ne) {
                        let de;
                        r.mGM(de = r.lsd()) && (B.charComponents = de)
                    }
                },
                inputs: {
                    environmentPhotoApi: "environmentPhotoApi",
                    isFileUploadingInProgress: "isFileUploadingInProgress",
                    photoFileGroup: "photoFileGroup",
                    photoCropGroup: "photoCropGroup",
                    multiFile: "multiFile"
                },
                outputs: {
                    photoSelect: "photoSelect",
                    setFileUploadingProgress: "setFileUploadingProgress",
                    openErrorMsg: "openErrorMsg",
                    openAdvancedOptions: "openAdvancedOptions"
                },
                features: [r.Vt3],
                decls: 5,
                vars: 5,
                consts: [["posterWrapper", ""], ["charComponents", ""], [3, "background"], [3, "poster", 4, "ngIf"], [4, "ngIf"], [3, "poster"], [3, "poster", "color", "textArea", "title"], [1, "letter-instance"], [1, "letter-character-area", 3, "height", "width", "marginLeft"], [3, "textareaHeightCallback", "poster", "color", "textArea", "subtitle"], [1, "letter-character-area"], [3, "isFinalPoster", "charId", "character", "imageUrl", "imageId", "photoFileGroup", "photoCropGroup", "onlySingleInput", "isInteractive", "multiFile", "isFileUploadingInProgress", "readyToLoad", "svgCharFilesPath", "charactersDefinition"], [3, "openAdvancedOptions", "openErrorMsg", "setFileUploadingProgress", "selectPhoto", "photoLoaded", "isFinalPoster", "charId", "character", "imageUrl", "imageId", "photoFileGroup", "photoCropGroup", "onlySingleInput", "isInteractive", "multiFile", "isFileUploadingInProgress", "readyToLoad", "svgCharFilesPath", "charactersDefinition"]],
                template: function(ne, B) {
                    1 & ne && (r.j41(0, "pp-poster-background", 2, 0),
                    r.DNE(2, Ie, 16, 35, "pp-poster-printing-registration", 3),
                    r.nI1(3, "async"),
                    r.k0s(),
                    r.DNE(4, gt, 1, 0, "pp-poster-loaded-element", 4)),
                    2 & ne && (r.Y8G("background", B.photoLetter.background),
                    r.R7$(2),
                    r.Y8G("ngIf", r.bMT(3, 3, B.poster$)),
                    r.R7$(2),
                    r.Y8G("ngIf", B.isImageRendered))
                },
                dependencies: [Mt.MD, Mt.bT, Mt.Jj, so.Z, Wt.R, Me.c, _t.y, Ae.W, ct.iu, jt.C, Xe.c],
                styles: ["[_nghost-%COMP%]{--character-outline-color: #000;width:100%;height:100%;display:block}[_nghost-%COMP%]   .letter-instance[_ngcontent-%COMP%]{box-sizing:border-box;display:flex;justify-content:center;align-items:center;position:absolute;left:0;right:0;margin:auto}[_nghost-%COMP%]   .letter-instance[_ngcontent-%COMP%]   .letter-character-area[_ngcontent-%COMP%]{position:relative}[_nghost-%COMP%]     svg   path.outline{fill:var(--character-outline-color)}"]
            }),
            Re
        }
        )();
        var yt = $(2745)
          , ht = $(23294);
        const mo = ["charComponents"]
          , no = (At, Re) => Re.trackBy;
        function Co(At, Re) {
            if (1 & At) {
                const ve = r.RV6();
                r.j41(0, "pp-poster-character", 14, 1),
                r.nI1(2, "async"),
                r.bIt("openAdvancedOptions", function(B) {
                    r.eBV(ve);
                    const de = r.XpG(3);
                    return r.Njj(de.openAdvancedOptions.emit(B))
                })("openErrorMsg", function(B) {
                    r.eBV(ve);
                    const de = r.XpG(3);
                    return r.Njj(de.openErrorMsg.emit(B))
                })("setFileUploadingProgress", function(B) {
                    r.eBV(ve);
                    const de = r.XpG(3);
                    return r.Njj(de.setFileUploadingProgress.emit(B))
                })("selectPhoto", function(B) {
                    r.eBV(ve);
                    const de = r.XpG(3);
                    return r.Njj(de.onPhotoSelect(B))
                })("photoLoaded", function() {
                    r.eBV(ve);
                    const B = r.XpG(3);
                    return r.Njj(B.onImageLoad())
                }),
                r.k0s()
            }
            if (2 & At) {
                const ve = r.XpG()
                  , ne = ve.$implicit
                  , B = ve.$index
                  , de = r.XpG(2);
                r.Y8G("charId", B)("character", ne.char)("imageUrl", ne.image)("imageId", de.photoFileGroup ? de.photoAccess(B).controls.uuid.value : "")("photoFileGroup", de.photoFileGroup)("photoCropGroup", de.photoCropGroup)("isFinalPoster", de.isFinalPoster)("isInteractive", de.isInteractive)("onlySingleInput", !1)("multiFile", de.multiFile)("isFileUploadingInProgress", !!de.isFileUploadingInProgress && r.bMT(2, 14, de.isFileUploadingInProgress(B)))("readyToLoad", de.isInteractive || de.load >= B)("svgCharFilesPath", "/assets/pp-posters/letter/characters/modern")("charactersDefinition", de.charactersDefinition)
            }
        }
        function Lt(At, Re) {
            if (1 & At && (r.j41(0, "div", 12),
            r.DNE(1, Co, 3, 16, "pp-poster-character", 13),
            r.k0s()),
            2 & At) {
                const ve = Re.$implicit
                  , ne = r.XpG(2);
                r.xc7("height", ne.photoLetterModern.character.height, "px")("width", ve.width, "px")("margin-left", ve.marginLeft, "px"),
                r.R7$(),
                r.vxM(" " !== ve.char ? 1 : -1)
            }
        }
        function Ft(At, Re) {
            if (1 & At) {
                const ve = r.RV6();
                r.j41(0, "pp-poster-printing-registration", 5)(1, "pp-poster-arrangement-wrapper")(2, "pp-poster-text-area", 6),
                r.nI1(3, "async"),
                r.nI1(4, "async"),
                r.nI1(5, "async"),
                r.nI1(6, "async"),
                r.bIt("titleHeightCallback", function(B) {
                    r.eBV(ve);
                    const de = r.XpG();
                    return r.Njj(de.newTitleHeight(B))
                }),
                r.k0s(),
                r.j41(7, "pp-poster-image-area")(8, "div", 7),
                r.Z7z(9, Lt, 2, 7, "div", 8, no),
                r.k0s()(),
                r.j41(11, "pp-poster-space-splitter", 9)(12, "pp-poster-text-area", 10),
                r.nI1(13, "async"),
                r.nI1(14, "async"),
                r.nI1(15, "async"),
                r.nI1(16, "async"),
                r.bIt("titleHeightCallback", function(B) {
                    r.eBV(ve);
                    const de = r.XpG();
                    return r.Njj(de.newTextareaHeight(B))
                }),
                r.k0s(),
                r.j41(17, "pp-poster-text-area", 11),
                r.nI1(18, "async"),
                r.nI1(19, "async"),
                r.nI1(20, "async"),
                r.nI1(21, "async"),
                r.bIt("subtitleHeightCallback", function(B) {
                    r.eBV(ve);
                    const de = r.XpG();
                    return r.Njj(de.newTextareaRightHeight(B))
                }),
                r.k0s()()()()
            }
            if (2 & At) {
                const ve = Re.ngIf
                  , ne = r.XpG();
                r.Y8G("poster", ve),
                r.R7$(2),
                r.Y8G("poster", r.bMT(3, 30, ne.poster$))("color", r.bMT(4, 32, ne.textColor$))("textArea", r.bMT(5, 34, ne.topTextArea$))("title", r.bMT(6, 36, ne.title$)),
                r.R7$(6),
                r.xc7("top", ne.photoLetterModern.textArea.top, "px")("width", ne.photoLetterModern.textArea.width, "px")("height", ne.photoLetterModern.textArea.height, "px")("margin-top", ne.photoLetterModern.textArea.marginTop, "px")("margin-left", ne.photoLetterModern.textArea.marginLeft, "px"),
                r.R7$(),
                r.Dyx(ne.photoLetterModern.chars),
                r.R7$(2),
                r.xc7("width", ne.photoLetterModern.bottomSplit.width, "px")("height", ne.photoLetterModern.bottomSplit.height, "px"),
                r.Y8G("spaceBetween", ne.photoLetterModern.bottomSplit.spaceBetween)("firstCustomWidth", 62)("secondCustomWidth", 38),
                r.R7$(),
                r.Y8G("poster", r.bMT(13, 38, ne.poster$))("color", r.bMT(14, 40, ne.textColor$))("textArea", r.bMT(15, 42, ne.textArea$))("title", r.bMT(16, 44, ne.subtitle$)),
                r.R7$(5),
                r.Y8G("poster", r.bMT(18, 46, ne.poster$))("color", r.bMT(19, 48, ne.textColor$))("textArea", r.bMT(20, 50, ne.textArea$))("subtitle", r.bMT(21, 52, ne.footer$))
            }
        }
        function co(At, Re) {
            1 & At && r.nrm(0, "pp-poster-loaded-element")
        }
        let Jt = ( () => {
            var At;
            class Re extends Tt.C {
                constructor(ne, B, de, lt, St, tt) {
                    super(ne, B),
                    this.host = ne,
                    this.zone = B,
                    this.cdr = de,
                    this.httpClient = lt,
                    this.domSanitizer = St,
                    this.renderer2 = tt,
                    this.multiFile = !1,
                    this.photoSelect = new r.bkB,
                    this.setFileUploadingProgress = new r.bkB,
                    this.openErrorMsg = new r.bkB,
                    this.openAdvancedOptions = new r.bkB,
                    this.photoLetterModern = {
                        textArea: {
                            top: 0,
                            width: 0,
                            height: 0,
                            marginTop: 0,
                            marginLeft: 0
                        },
                        character: {
                            height: 0
                        },
                        background: "#fff",
                        chars: [],
                        bottomSplit: {
                            width: 0,
                            height: 0,
                            spaceBetween: 0
                        }
                    },
                    this.charactersDefinition = Ce.PJ,
                    this.textAreaHeight$ = new Qe.t(null),
                    this.titleAreaHeight$ = new Qe.t(null),
                    this.textAreaRightHeight$ = new Qe.t(null)
                }
                ngOnInit() {
                    var ne = () => super.ngOnInit
                      , B = this;
                    return (0,
                    Ut.A)(function*() {
                        yield ne().call(B),
                        B.titleAreaHeight$.pipe((0,
                        ht.F)()).subscribe(de => {
                            const lt = B.poster$.getValue()
                              , St = B.posterConfiguration$.getValue();
                            null !== de && lt && St && B.setTextAreaWithSideEffects(lt, St)
                        }
                        ),
                        B.textAreaHeight$.pipe((0,
                        ht.F)()).subscribe(de => {
                            const lt = B.poster$.getValue()
                              , St = B.posterConfiguration$.getValue();
                            null !== de && lt && St && B.setTextAreaWithSideEffects(lt, St)
                        }
                        ),
                        B.textAreaRightHeight$.pipe((0,
                        ht.F)()).subscribe(de => {
                            const lt = B.poster$.getValue()
                              , St = B.posterConfiguration$.getValue();
                            null !== de && lt && St && B.setTextAreaWithSideEffects(lt, St)
                        }
                        )
                    })()
                }
                onPhotoSelect({photoId: ne, imageInstanceSize: B}) {
                    this.photoSelect.emit([B.width, B.height, ne])
                }
                onPhotoSelectWithoutImageInstance(ne) {
                    var B;
                    null === (B = this.charComponents.toArray()) || void 0 === B || null === (B = B[ne]) || void 0 === B || B.selectLetter(ne)
                }
                setAllTextSettings(ne) {
                    this.setText({
                        text: ne.title,
                        isDefaultFont: !0
                    }, this.title$, {
                        font: s.n3q.HELLO_OCTOBER,
                        textAlign: "left",
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: .105,
                            bottomFactor: 0,
                            topFactor: 0,
                            isBold: !1
                        }
                    }),
                    this.setText({
                        text: ne.subtitle,
                        isDefaultFont: !0
                    }, this.subtitle$, {
                        font: s.n3q.MONTSERRAT_MEDIUM,
                        textAlign: "justify",
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: .024,
                            bottomFactor: 0,
                            topFactor: 0
                        }
                    }),
                    this.setText({
                        text: ne.footnote,
                        isDefaultFont: !0
                    }, this.footer$, {
                        font: s.n3q.HELLO_OCTOBER,
                        textAlign: "right",
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: .085,
                            bottomFactor: 0,
                            topFactor: 0,
                            isBold: !1
                        }
                    })
                }
                setDesign(ne, B) {
                    return (0,
                    Ut.A)(function*() {})()
                }
                textLetterAreaHeight(ne, B, de, lt) {
                    return 1
                }
                textLetterAreaMartinTop(ne) {
                    var B, de, lt;
                    const St = null !== (B = this.textAreaHeight$.getValue()) && void 0 !== B ? B : 0
                      , tt = null !== (de = this.textAreaRightHeight$.getValue()) && void 0 !== de ? de : 0
                      , $t = ne.subtitle.length > 0 || ne.footnote.length > 0 ? St > tt ? St : tt : 0
                      , Nt = ne.title.length > 0 && null !== (lt = this.titleAreaHeight$.getValue()) && void 0 !== lt ? lt : 0;
                    return 0 === Nt && 0 === $t ? 0 : 0 === $t ? Nt / 2 : 0 === Nt ? -$t / 2 : (Nt - $t) / 2
                }
                setTextArea(ne, B) {
                    this.setTextAreaWithSideEffects(ne, B)
                }
                setTextAreaWithSideEffects(ne, B) {
                    this.photoLetterModern.textArea.top = 0 * ne.size.height,
                    this.photoLetterModern.textArea.width = .93 * ne.size.width,
                    this.photoLetterModern.textArea.marginLeft = .035 * ne.size.width,
                    this.photoLetterModern.textArea.marginTop = B.centerLayout ? this.textLetterAreaMartinTop(B) : 0;
                    const de = [...B.text].length < 3;
                    this.photoLetterModern.textArea.height = ne.size.height * this.textLetterAreaHeight(de, !B.title && !B.subtitle, !B.title && !!B.subtitle, !!B.title && !B.subtitle);
                    const Nt = this.photoLetterModern.textArea.height / Ce.PJ.E.height;
                    let Vt, _o = 0;
                    this.photoLetterModern.chars = [],
                    this.photoLetterModern.background = it(B.colorScheme, B.customColors.background);
                    const Lo = et(B.colorScheme, B.customColors.text);
                    this.textColor$.next(Lo),
                    this.renderer2.setProperty(this.host.nativeElement, "style", "--character-outline-color: #".concat(B.customColors.outline, "; --character-solid-fill: ").concat(Lo));
                    let ao = 0;
                    if ([...B.text].forEach( (ee, W) => {
                        ee = ee.toUpperCase();
                        const ae = structuredClone(Ce.PJ[ee])
                          , Ve = structuredClone(Ce.PJ[Vt]);
                        if (!ae)
                            return _o += Ce.R * Nt,
                            void this.photoLetterModern.chars.push({
                                char: " ",
                                marginLeft: 0,
                                width: Ce.R * Nt,
                                image: "",
                                trackBy: "space-".concat(W)
                            });
                        let fe = 0;
                        Vt && ae.prevCharacter[Vt] && (fe = ae.prevCharacter[Vt] * Nt),
                        null != Ve && Ve.marginRight && Vt !== ee && (fe += Ve.marginRight * Nt),
                        ae.marginLeft && Vt !== ee && (fe += ae.marginLeft * Nt),
                        _o += ae.width * Nt,
                        this.photoLetterModern.chars.push({
                            char: ee,
                            marginLeft: fe,
                            width: ae.width * Nt,
                            image: this.getImageConfig(B, W),
                            trackBy: "".concat(ee, "-").concat(W)
                        }),
                        ao += -1 * fe,
                        Vt = ee
                    }
                    ),
                    ao > 0 && (_o -= Math.abs(ao)),
                    _o > this.photoLetterModern.textArea.width) {
                        var bt;
                        const ee = this.photoLetterModern.textArea.width / _o
                          , W = null !== (bt = this.photoLetterModern.chars.find(Pt => " " !== Pt.char && Ce.PJ[Pt.char])) && void 0 !== bt ? bt : this.photoLetterModern.chars[0]
                          , ae = structuredClone(Ce.PJ[W.char])
                          , fe = this.calculateFinalSize(W.width, ee) / ae.width;
                        this.photoLetterModern.character.height = ae.height * fe,
                        this.photoLetterModern.chars.forEach(Pt => {
                            Pt.width = this.calculateFinalSize(Pt.width, ee),
                            Ce.PJ[Pt.char] && (Pt.marginLeft = Pt.marginLeft * ee)
                        }
                        )
                    } else
                        this.photoLetterModern.character.height = this.photoLetterModern.textArea.height;
                    const Do = ne.size.height
                      , Xt = ne.size.width;
                    this.photoLetterModern.bottomSplit.height = (Do - .6 * this.photoLetterModern.character.height) / 2 - .03 * Do,
                    this.photoLetterModern.bottomSplit.spaceBetween = .02 * ne.size.width;
                    const we = .04 * this.photoLetterModern.chars[0].width / Xt;
                    this.photoLetterModern.bottomSplit.width = ne.size.width * (.93 - 2 * we),
                    this.topTextArea$.next({
                        topFactor: this.photoLetterModern.textArea.marginTop / Do,
                        marginFactor: .035 + we,
                        fixedHeightFactor: this.photoLetterModern.bottomSplit.height / Do,
                        isFlex: !0,
                        isJustifyEnd: !0
                    }),
                    this.textArea$.next({
                        marginFactor: 0,
                        topFactor: this.photoLetterModern.textArea.marginTop / Do
                    });
                    let Oe = 0;
                    for (const ee of this.photoLetterModern.chars) {
                        if (!(" " === ee.char || this.charactersDefinition[ee.char] && this.charactersDefinition[ee.char].withoutPhoto))
                            break;
                        Oe++
                    }
                    Oe > 0 && this.onImageLoad()
                }
                newTextareaHeight(ne) {
                    this.textAreaHeight$.next(ne)
                }
                newTitleHeight(ne) {
                    this.titleAreaHeight$.next(ne)
                }
                newTextareaRightHeight(ne) {
                    this.textAreaRightHeight$.next(ne)
                }
                getImageConfig(ne, B) {
                    if (!ne.photoFiles[B].uuid)
                        return "";
                    const de = ne.cropsData[B]
                      , lt = ne.photoFiles[B]
                      , St = 2 * lt.weight * Ce.LC
                      , Nt = (St * Ce.wS - St) / 2 / St * 100
                      , Vt = 2 * lt.size.height * Ce.LC
                      , ao = (Vt * Ce.wS - Vt) / 2 / Vt * 100
                      , bt = lt.uuid
                      , Do = de.isInitialized ? de.filter : "normal"
                      , Xt = de.isInitialized ? de.cropData.x : Nt
                      , ie = de.isInitialized ? de.cropData.y : ao
                      , we = de.isInitialized ? de.cropData.width : 100 - 2 * Nt
                      , Oe = de.isInitialized ? de.cropData.height : 100 - 2 * ao
                      , ee = de.isInitialized ? de.rotate : 0
                      , W = !!de.isInitialized && de.flip;
                    return "".concat(this.environmentPhotoApi, "/v2/").concat(this.isFinalPoster ? "photo" : "image", "/").concat(bt, "?type=").concat(Do, "&left=").concat(Xt, "&top=").concat(ie, "&width=").concat(we, "&height=").concat(Oe, "&rotate=").concat(ee, "&flipped=").concat(W)
                }
                onImageLoad() {
                    for (this.load++; this.photoLetterModern.chars[this.load] && (" " === this.photoLetterModern.chars[this.load].char || this.charactersDefinition[this.photoLetterModern.chars[this.load].char].withoutPhoto); )
                        this.load++;
                    this.load >= this.photoLetterModern.chars.length && (this.initiateRender(),
                    this.cdr.detectChanges())
                }
                photoAccess(ne) {
                    return this.photoFileGroup.at(ne)
                }
                calculateFinalSize(ne, B) {
                    return ne * B
                }
            }
            return (At = Re).\u0275fac = function(ne) {
                return new (ne || At)(r.rXU(r.aKT),r.rXU(r.SKi),r.rXU(r.gRc),r.rXU(re.Qq),r.rXU(pt.up),r.rXU(r.sFG))
            }
            ,
            At.\u0275cmp = r.VBU({
                type: At,
                selectors: [["pp-poster-letter-modern"]],
                viewQuery: function(ne, B) {
                    if (1 & ne && r.GBs(mo, 5),
                    2 & ne) {
                        let de;
                        r.mGM(de = r.lsd()) && (B.charComponents = de)
                    }
                },
                inputs: {
                    environmentPhotoApi: "environmentPhotoApi",
                    isFileUploadingInProgress: "isFileUploadingInProgress",
                    photoFileGroup: "photoFileGroup",
                    photoCropGroup: "photoCropGroup",
                    multiFile: "multiFile"
                },
                outputs: {
                    photoSelect: "photoSelect",
                    setFileUploadingProgress: "setFileUploadingProgress",
                    openErrorMsg: "openErrorMsg",
                    openAdvancedOptions: "openAdvancedOptions"
                },
                features: [r.Vt3],
                decls: 5,
                vars: 5,
                consts: [["posterWrapper", ""], ["charComponents", ""], [3, "background"], [3, "poster", 4, "ngIf"], [4, "ngIf"], [3, "poster"], [3, "titleHeightCallback", "poster", "color", "textArea", "title"], [1, "letter-instance"], [1, "letter-character-area", 3, "height", "width", "marginLeft"], [3, "spaceBetween", "firstCustomWidth", "secondCustomWidth"], ["first", "", 3, "titleHeightCallback", "poster", "color", "textArea", "title"], ["second", "", 3, "subtitleHeightCallback", "poster", "color", "textArea", "subtitle"], [1, "letter-character-area"], [3, "charId", "character", "imageUrl", "imageId", "photoFileGroup", "photoCropGroup", "isFinalPoster", "isInteractive", "onlySingleInput", "multiFile", "isFileUploadingInProgress", "readyToLoad", "svgCharFilesPath", "charactersDefinition"], [3, "openAdvancedOptions", "openErrorMsg", "setFileUploadingProgress", "selectPhoto", "photoLoaded", "charId", "character", "imageUrl", "imageId", "photoFileGroup", "photoCropGroup", "isFinalPoster", "isInteractive", "onlySingleInput", "multiFile", "isFileUploadingInProgress", "readyToLoad", "svgCharFilesPath", "charactersDefinition"]],
                template: function(ne, B) {
                    1 & ne && (r.j41(0, "pp-poster-background", 2, 0),
                    r.DNE(2, Ft, 22, 54, "pp-poster-printing-registration", 3),
                    r.nI1(3, "async"),
                    r.k0s(),
                    r.DNE(4, co, 1, 0, "pp-poster-loaded-element", 4)),
                    2 & ne && (r.Y8G("background", B.photoLetterModern.background),
                    r.R7$(2),
                    r.Y8G("ngIf", r.bMT(3, 3, B.poster$)),
                    r.R7$(2),
                    r.Y8G("ngIf", B.isImageRendered))
                },
                dependencies: [Mt.MD, Mt.bT, Mt.Jj, so.Z, Wt.R, Me.c, _t.y, Ae.W, ct.iu, jt.C, Xe.c, yt.G],
                styles: ["[_nghost-%COMP%]{--character-outline-color: #000;--character-solid-fill: #000;width:100%;height:100%;display:block}[_nghost-%COMP%]   .letter-instance[_ngcontent-%COMP%]{box-sizing:border-box;display:flex;justify-content:center;align-items:center;position:absolute;left:0;right:0;margin:auto}[_nghost-%COMP%]   .letter-instance[_ngcontent-%COMP%]   .letter-character-area[_ngcontent-%COMP%]{position:relative}[_nghost-%COMP%]     svg   path.outline{fill:var(--character-outline-color)}[_nghost-%COMP%]     svg   path.solid{fill:var(--character-solid-fill);opacity:.6}"]
            }),
            Re
        }
        )();
        function po(At, Re) {
            if (1 & At) {
                const ve = r.RV6();
                r.j41(0, "pp-poster-letter-classic", 1),
                r.nI1(1, "async"),
                r.nI1(2, "async"),
                r.bIt("photoSelect", function(B) {
                    r.eBV(ve);
                    const de = r.XpG();
                    return r.Njj(de.photoSelect.emit(B))
                })("openAdvancedOptions", function(B) {
                    r.eBV(ve);
                    const de = r.XpG();
                    return r.Njj(de.openAdvancedOptions.emit(B))
                })("setFileUploadingProgress", function(B) {
                    r.eBV(ve);
                    const de = r.XpG();
                    return r.Njj(de.setFileUploadingProgress.emit(B))
                })("openErrorMsg", function(B) {
                    r.eBV(ve);
                    const de = r.XpG();
                    return r.Njj(de.openErrorMsg.emit(B))
                }),
                r.k0s()
            }
            if (2 & At) {
                const ve = r.XpG();
                r.Y8G("photoFileGroup", ve.photoFileGroup)("photoCropGroup", ve.photoCropGroup)("multiFile", ve.multiFile)("printingRegistration", r.bMT(1, 9, ve._printingRegistration$))("posterConfig", r.bMT(2, 11, ve.posterConfiguration$))("environmentPhotoApi", ve.environmentPhotoApi)("isFileUploadingInProgress", ve.isFileUploadingInProgress)("isFinalPoster", ve.isFinalPoster)("isInteractive", ve.isInteractive)
            }
        }
        function Et(At, Re) {
            if (1 & At) {
                const ve = r.RV6();
                r.j41(0, "pp-poster-letter-modern", 1),
                r.nI1(1, "async"),
                r.nI1(2, "async"),
                r.bIt("photoSelect", function(B) {
                    r.eBV(ve);
                    const de = r.XpG();
                    return r.Njj(de.photoSelect.emit(B))
                })("openAdvancedOptions", function(B) {
                    r.eBV(ve);
                    const de = r.XpG();
                    return r.Njj(de.openAdvancedOptions.emit(B))
                })("setFileUploadingProgress", function(B) {
                    r.eBV(ve);
                    const de = r.XpG();
                    return r.Njj(de.setFileUploadingProgress.emit(B))
                })("openErrorMsg", function(B) {
                    r.eBV(ve);
                    const de = r.XpG();
                    return r.Njj(de.openErrorMsg.emit(B))
                }),
                r.k0s()
            }
            if (2 & At) {
                const ve = r.XpG();
                r.Y8G("photoFileGroup", ve.photoFileGroup)("photoCropGroup", ve.photoCropGroup)("multiFile", ve.multiFile)("printingRegistration", r.bMT(1, 9, ve._printingRegistration$))("posterConfig", r.bMT(2, 11, ve.posterConfiguration$))("environmentPhotoApi", ve.environmentPhotoApi)("isFileUploadingInProgress", ve.isFileUploadingInProgress)("isFinalPoster", ve.isFinalPoster)("isInteractive", ve.isInteractive)
            }
        }
        let Kt = ( () => {
            var At;
            class Re extends Tt.C {
                constructor(ne, B, de, lt, St) {
                    super(ne, B),
                    this.host = ne,
                    this.zone = B,
                    this.cdr = de,
                    this.httpClient = lt,
                    this.domSanitizer = St,
                    this.LetterLayoutEnum = s.il1,
                    this.multiFile = !1,
                    this.photoSelect = new r.bkB,
                    this.setFileUploadingProgress = new r.bkB,
                    this.openErrorMsg = new r.bkB,
                    this.openAdvancedOptions = new r.bkB,
                    this.photoLetterLayout = s.il1.CLASSIC
                }
                onPhotoSelectWithoutImageInstance(ne) {
                    this.photoLetterLayout === s.il1.CLASSIC ? this.ppPosterLetterClassicComponent.onPhotoSelectWithoutImageInstance(ne) : this.photoLetterLayout === s.il1.MODERN && this.ppPosterLetterModernComponent.onPhotoSelectWithoutImageInstance(ne)
                }
                setAllTextSettings(ne) {}
                setDesign(ne, B) {
                    var de = this;
                    return (0,
                    Ut.A)(function*() {
                        de.photoLetterLayout = B.layout
                    })()
                }
                setTextArea(ne, B) {}
            }
            return (At = Re).\u0275fac = function(ne) {
                return new (ne || At)(r.rXU(r.aKT),r.rXU(r.SKi),r.rXU(r.gRc),r.rXU(re.Qq),r.rXU(pt.up))
            }
            ,
            At.\u0275cmp = r.VBU({
                type: At,
                selectors: [["pp-poster-letter"]],
                viewQuery: function(ne, B) {
                    if (1 & ne && (r.GBs(Ye, 5),
                    r.GBs(Jt, 5)),
                    2 & ne) {
                        let de;
                        r.mGM(de = r.lsd()) && (B.ppPosterLetterClassicComponent = de.first),
                        r.mGM(de = r.lsd()) && (B.ppPosterLetterModernComponent = de.first)
                    }
                },
                inputs: {
                    environmentPhotoApi: "environmentPhotoApi",
                    isFileUploadingInProgress: "isFileUploadingInProgress",
                    photoFileGroup: "photoFileGroup",
                    photoCropGroup: "photoCropGroup",
                    multiFile: "multiFile"
                },
                outputs: {
                    photoSelect: "photoSelect",
                    setFileUploadingProgress: "setFileUploadingProgress",
                    openErrorMsg: "openErrorMsg",
                    openAdvancedOptions: "openAdvancedOptions"
                },
                features: [r.Vt3],
                decls: 2,
                vars: 1,
                consts: [[3, "photoFileGroup", "photoCropGroup", "multiFile", "printingRegistration", "posterConfig", "environmentPhotoApi", "isFileUploadingInProgress", "isFinalPoster", "isInteractive"], [3, "photoSelect", "openAdvancedOptions", "setFileUploadingProgress", "openErrorMsg", "photoFileGroup", "photoCropGroup", "multiFile", "printingRegistration", "posterConfig", "environmentPhotoApi", "isFileUploadingInProgress", "isFinalPoster", "isInteractive"]],
                template: function(ne, B) {
                    1 & ne && r.DNE(0, po, 3, 13, "pp-poster-letter-classic", 0)(1, Et, 3, 13, "pp-poster-letter-modern", 0),
                    2 & ne && r.vxM(B.photoLetterLayout === B.LetterLayoutEnum.CLASSIC ? 0 : B.photoLetterLayout === B.LetterLayoutEnum.MODERN ? 1 : -1)
                },
                dependencies: [Mt.MD, Mt.Jj, Ye, Jt],
                styles: ["[_nghost-%COMP%]{--character-outline-color: #000;width:100%;height:100%;display:block}[_nghost-%COMP%]   .letter-instance[_ngcontent-%COMP%]{box-sizing:border-box;display:flex;justify-content:center;align-items:center;position:absolute;left:0;right:0;margin:auto}[_nghost-%COMP%]   .letter-instance[_ngcontent-%COMP%]   .letter-character-area[_ngcontent-%COMP%]{position:relative}[_nghost-%COMP%]     svg   path.outline{fill:var(--character-outline-color)}"]
            }),
            Re
        }
        )()
    }
    ,
    60333: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            V: () => Be
        });
        var Ut = $(10467)
          , r = $(54438)
          , Mt = $(9566)
          , s = $(60177)
          , so = $(27617)
          , Wt = $(78606)
          , _t = $(50552)
          , Ae = $(54843)
          , Me = $(96354)
          , ct = $(7430)
          , Tt = $(76675)
          , Qe = $(41046)
          , jt = $(21626);
        const Xe = ["svgContainer1"]
          , Ce = ["svgContainer2"]
          , it = ze => ({
            fill: ze,
            stroke: "transparent"
        });
        function et(ze, ye) {
            1 & ze && r.nrm(0, "pp-poster-loaded-element")
        }
        let Be = ( () => {
            var ze;
            class ye extends _t.C {
                constructor(Ie, gt, Ye, yt) {
                    super(Ie, gt),
                    this.host = Ie,
                    this.zone = gt,
                    this.httpClient = Ye,
                    this.cdr = yt,
                    this.exampleInformation = "",
                    this.hideSwitchers = !1,
                    this.showFrontOnInit = !0,
                    this.showAvers = new r.bkB(!1),
                    this.coordinatesJewelry = {
                        textURL: "",
                        coordinatesURL: "",
                        setup: so.Hyl.charm,
                        layout: 1,
                        material: so.Xl7.na,
                        color: "transparent"
                    }
                }
                setJewelry(Ie, gt) {
                    var Ye = this;
                    return (0,
                    Ut.A)(function*() {
                        var yt, ht;
                        Ye.coordinatesJewelry.textURL = null !== (yt = yield(0,
                        Ae._)(Ye.httpClient.post("".concat(window.location.origin, "/api/coordinates/jewelry/text"), {
                            title: gt.title,
                            titleFontScript: !1,
                            footer: gt.footer
                        }).pipe((0,
                        Me.T)(mo => (0,
                        Tt.ID)("image/svg+xml", mo.image))))) && void 0 !== yt ? yt : "",
                        Ye.coordinatesJewelry.coordinatesURL = null !== (ht = yield(0,
                        Ae._)(Ye.httpClient.post("".concat(window.location.origin, "/api/coordinates/jewelry/coordinates"), {
                            latitude: gt.latitude,
                            longitude: gt.longitude,
                            font: gt.layout === so.EYn.COORDINATES ? so.Ifl.PROXIMA_NOVA_BOLD : so.Ifl.YESEVAONE_REGULAR
                        }).pipe((0,
                        Me.T)(mo => (0,
                        Tt.ID)("image/svg+xml", mo.image))))) && void 0 !== ht ? ht : "",
                        Ye.coordinatesJewelry.material = gt.material,
                        Ye.coordinatesJewelry.setup = gt.setup,
                        Ye.coordinatesJewelry.color = Tt.fd[gt.material],
                        Ye.hideSwitchers && Ye.careAboutSvgVisibility(Ye.showFrontOnInit ? Ye.svgContainer1 : Ye.svgContainer2, Ye.onImageLoad.bind(Ye))
                    })()
                }
                setAllTextSettings(Ie, gt) {}
                setDesign(Ie, gt, Ye) {
                    return Promise.resolve(void 0)
                }
                setTextArea(Ie, gt) {}
                ngAfterViewInit() {}
                careAboutSvgVisibility(Ie, gt) {
                    var Ye;
                    const yt = null == Ie || null === (Ye = Ie.nativeElement) || void 0 === Ye ? void 0 : Ye.querySelector("svg");
                    yt && yt.clientWidth > 0 ? gt() : setTimeout( () => {
                        this.careAboutSvgVisibility(Ie, gt)
                    }
                    , 100)
                }
                onImageLoad() {
                    this.load++,
                    1 === this.load && (this.initiateRender(),
                    this.cdr.detectChanges())
                }
            }
            return (ze = ye).\u0275fac = function(Ie) {
                return new (Ie || ze)(r.rXU(r.aKT),r.rXU(r.SKi),r.rXU(jt.Qq),r.rXU(r.gRc))
            }
            ,
            ze.\u0275cmp = r.VBU({
                type: ze,
                selectors: [["pp-jewelry-coordinates"]],
                viewQuery: function(Ie, gt) {
                    if (1 & Ie && (r.GBs(Xe, 5),
                    r.GBs(Ce, 5)),
                    2 & Ie) {
                        let Ye;
                        r.mGM(Ye = r.lsd()) && (gt.svgContainer1 = Ye.first),
                        r.mGM(Ye = r.lsd()) && (gt.svgContainer2 = Ye.first)
                    }
                },
                inputs: {
                    exampleInformation: "exampleInformation",
                    hideSwitchers: "hideSwitchers",
                    showFrontOnInit: "showFrontOnInit"
                },
                outputs: {
                    showAvers: "showAvers"
                },
                features: [r.Vt3],
                decls: 11,
                vars: 14,
                consts: [["svgContainer1", ""], ["svgContainer2", ""], [3, "background"], [3, "showAvers", "material", "setup", "hideSwitchers", "showFront"], ["slot", "front"], [1, "front-center"], [3, "src", "svgStyle"], ["slot", "back"], [1, "back-center"], [4, "ngIf"]],
                template: function(Ie, gt) {
                    if (1 & Ie) {
                        const Ye = r.RV6();
                        r.j41(0, "pp-poster-background", 2)(1, "pp-poster-jewelry-area", 3),
                        r.bIt("showAvers", function(ht) {
                            return r.eBV(Ye),
                            r.Njj(gt.showAvers.emit(ht))
                        }),
                        r.j41(2, "div", 4)(3, "div", 5, 0),
                        r.nrm(5, "svg-icon", 6),
                        r.k0s()(),
                        r.j41(6, "div", 7)(7, "div", 8, 1),
                        r.nrm(9, "svg-icon", 6),
                        r.k0s()()()(),
                        r.DNE(10, et, 1, 0, "pp-poster-loaded-element", 9)
                    }
                    2 & Ie && (r.Y8G("background", "transparent"),
                    r.R7$(),
                    r.Y8G("material", gt.coordinatesJewelry.material)("setup", gt.coordinatesJewelry.setup)("hideSwitchers", gt.hideSwitchers)("showFront", gt.showFrontOnInit),
                    r.R7$(4),
                    r.Y8G("src", gt.coordinatesJewelry.coordinatesURL)("svgStyle", r.eq3(10, it, gt.coordinatesJewelry.color)),
                    r.R7$(4),
                    r.Y8G("src", gt.coordinatesJewelry.textURL)("svgStyle", r.eq3(12, it, gt.coordinatesJewelry.color)),
                    r.R7$(),
                    r.Y8G("ngIf", gt.isImageRendered))
                },
                dependencies: [s.MD, s.bT, Mt.R, Wt.iu, Wt.DM, ct.R, Qe.C],
                styles: ["[_nghost-%COMP%]{width:100%;height:100%;display:block}"]
            }),
            ye
        }
        )()
    }
    ,
    63597: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            l: () => Tt
        });
        var Ut = $(10467)
          , r = $(50552)
          , Mt = $(27617)
          , s = $(54438)
          , so = $(28105)
          , Wt = $(15996)
          , _t = $(60177)
          , Ae = $(21626)
          , Me = $(345);
        const ct = ["starsSvg"];
        let Tt = ( () => {
            var Qe;
            class jt extends r.C {
                constructor(Ce, it, et, re, pt) {
                    super(Ce, it),
                    this.host = Ce,
                    this.zone = it,
                    this.httpClient = et,
                    this.domSanitizer = re,
                    this.cdr = pt,
                    this.isSvgStars = !1,
                    this.starsSvgSavedCallback = new s.bkB,
                    this.StarsColorSchemeEnum = Mt.th1
                }
                setAllTextSettings(Ce) {}
                setTextArea(Ce, it) {}
                setDesign(Ce, it) {
                    return new Promise(et => {
                        setTimeout(et, 10)
                    }
                    )
                }
                exportSvg() {
                    var Ce = this;
                    return (0,
                    Ut.A)(function*() {
                        const it = Ce.starsForm.controls.starMapConfig
                          , et = [];
                        it.at(0) && et.push(Ce.starsWrapper.exportSvg(Ce.isJewelry ? 2 : 1)),
                        !it.at(1) || 2 !== Ce.starsForm.controls.starMaps.value && 3 !== Ce.starsForm.controls.starMaps.value || Ce.starsForm.controls.shape.value === Mt.nhL.CIRCLES_PHOTO || Ce.starsForm.controls.shape.value === Mt.nhL.CIRCLES_MOON || Ce.starsForm.controls.shape.value === Mt.nhL.HEARTS_PHOTO ? it.at(1) && et.push(new Promise(pt => pt(""))) : et.push(Ce.starsWrapper.exportSvg(2)),
                        it.at(2) && et.push(Ce.starsWrapper.exportSvg(3)),
                        (yield Promise.all(et)).forEach( (pt, Be) => {
                            it.at(Be).controls.uuid.setValue(null != pt ? pt : "")
                        }
                        ),
                        Ce.starsSvgSavedCallback.emit()
                    })()
                }
                isRasterBackground(Ce) {
                    return [Mt.th1.SKY, Mt.th1.EMERALD, Mt.th1.PURPLE_GALAXY].includes(Ce)
                }
                starsBackground(Ce, it, et, re) {
                    switch (Ce) {
                    case Mt.th1.NAVY:
                        return "#293952";
                    case Mt.th1.COSMIC_LATTE:
                        return "#f6E5CE";
                    case Mt.th1.DEEP_SPACE_BLUE:
                        return "#0f1721";
                    case Mt.th1.MIDNIGHT_BLUE:
                    case Mt.th1.COSMIC_LOVE:
                    case Mt.th1.SUPERNOVA:
                        return "#FFF";
                    case Mt.th1.BLACK_HOLE:
                        return "#0e1111";
                    case Mt.th1.CUSTOM:
                        return "#".concat(it.background);
                    case Mt.th1.SKY:
                    case Mt.th1.EMERALD:
                    case Mt.th1.PURPLE_GALAXY:
                        return "url('/assets/pp-posters/stars/".concat(et ? "_HQ_/" : "", "background/").concat(re, "/").concat(Ce, ".jpg') center/cover no-repeat border-box");
                    default:
                        return Ce
                    }
                }
                starsStroke(Ce, it) {
                    switch (Ce) {
                    case Mt.th1.NAVY:
                    case Mt.th1.BLACK_HOLE:
                        return "#FFF";
                    case Mt.th1.CUSTOM:
                        return "#".concat(it.starMapsElements);
                    case Mt.th1.COSMIC_LATTE:
                    case Mt.th1.DEEP_SPACE_BLUE:
                    case Mt.th1.MIDNIGHT_BLUE:
                    case Mt.th1.COSMIC_LOVE:
                    case Mt.th1.SUPERNOVA:
                    case Mt.th1.SKY:
                    case Mt.th1.EMERALD:
                    case Mt.th1.PURPLE_GALAXY:
                        return "transparent";
                    default:
                        return Ce
                    }
                }
                textColor(Ce, it) {
                    switch (Ce) {
                    case Mt.th1.NAVY:
                    case Mt.th1.BLACK_HOLE:
                    case Mt.th1.SKY:
                    case Mt.th1.EMERALD:
                    case Mt.th1.PURPLE_GALAXY:
                        return "#FFF";
                    case Mt.th1.COSMIC_LATTE:
                        return "#0f1212";
                    case Mt.th1.DEEP_SPACE_BLUE:
                        return "#f6e5ce";
                    case Mt.th1.MIDNIGHT_BLUE:
                    case Mt.th1.COSMIC_LOVE:
                    case Mt.th1.SUPERNOVA:
                        return "#0e1111";
                    case Mt.th1.CUSTOM:
                        return (0,
                        Wt.V)(it.background) ? "#FFF" : "#0e1111";
                    default:
                        return Ce
                    }
                }
                circleColor(Ce, it) {
                    switch (Ce) {
                    case Mt.th1.NAVY:
                        return "#293952";
                    case Mt.th1.COSMIC_LOVE:
                        return "#0f1212";
                    case Mt.th1.SUPERNOVA:
                    case Mt.th1.BLACK_HOLE:
                        return "#0e1111";
                    case Mt.th1.MIDNIGHT_BLUE:
                        return "#111e3f";
                    case Mt.th1.SKY:
                    case Mt.th1.EMERALD:
                    case Mt.th1.PURPLE_GALAXY:
                        return "transparent";
                    case Mt.th1.COSMIC_LATTE:
                        return "url('/assets/pp-posters/stars/circleBackground/".concat(Mt.th1.COSMIC_LATTE, ".svg') center/cover no-repeat border-box");
                    case Mt.th1.DEEP_SPACE_BLUE:
                        return "url('/assets/pp-posters/stars/circleBackground/".concat(Mt.th1.DEEP_SPACE_BLUE, ".svg') center/cover no-repeat border-box");
                    case Mt.th1.CUSTOM:
                        return "#".concat(it.shield);
                    default:
                        return Ce
                    }
                }
            }
            return (Qe = jt).\u0275fac = function(Ce) {
                return new (Ce || Qe)(s.rXU(s.aKT),s.rXU(s.SKi),s.rXU(Ae.Qq),s.rXU(Me.up),s.rXU(s.gRc))
            }
            ,
            Qe.\u0275cmp = s.VBU({
                type: Qe,
                selectors: [["pp-poster-stars-common"]],
                viewQuery: function(Ce, it) {
                    if (1 & Ce && (s.GBs(so.Y, 5),
                    s.GBs(ct, 5)),
                    2 & Ce) {
                        let et;
                        s.mGM(et = s.lsd()) && (it.starsWrapper = et.first),
                        s.mGM(et = s.lsd()) && (it.starsSvg = et.first)
                    }
                },
                inputs: {
                    starsForm: "starsForm",
                    isSvgStars: "isSvgStars"
                },
                outputs: {
                    starsSvgSavedCallback: "starsSvgSavedCallback"
                },
                features: [s.Vt3],
                decls: 0,
                vars: 0,
                template: function(Ce, it) {},
                dependencies: [_t.MD],
                encapsulation: 2
            }),
            jt
        }
        )()
    }
    ,
    66985: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            P: () => so
        });
        var Ut = $(60177)
          , r = $(78606)
          , Mt = $(54438);
        function s(Wt, _t) {
            if (1 & Wt && (Mt.j41(0, "div", 1),
            Mt.nrm(1, "svg-icon", 2),
            Mt.k0s()),
            2 & Wt) {
                const Ae = Mt.XpG();
                Mt.xc7("width", Ae.maxWidth, "%")("margin-left", (100 - Ae.maxWidth) / 2, "%"),
                Mt.AVh("margin-top", Ae.marginTop),
                Mt.R7$(),
                Mt.Y8G("src", "/assets/pp-posters/common/" + Ae.previewType + "-preview.svg")
            }
        }
        let so = ( () => {
            var Wt;
            class _t {
                constructor() {
                    this.showPreview = !1,
                    this.marginTop = !1,
                    this.maxWidth = 100
                }
            }
            return (Wt = _t).\u0275fac = function(Me) {
                return new (Me || Wt)
            }
            ,
            Wt.\u0275cmp = Mt.VBU({
                type: Wt,
                selectors: [["pp-poster-preview"]],
                inputs: {
                    showPreview: "showPreview",
                    marginTop: "marginTop",
                    maxWidth: "maxWidth",
                    previewType: "previewType"
                },
                decls: 1,
                vars: 1,
                consts: [[1, "poster-preview", 3, "margin-top", "width", "marginLeft"], [1, "poster-preview"], [3, "src"]],
                template: function(Me, ct) {
                    1 & Me && Mt.DNE(0, s, 2, 7, "div", 0),
                    2 & Me && Mt.vxM(ct.showPreview ? 0 : -1)
                },
                dependencies: [Ut.MD, r.DM],
                styles: ["[_nghost-%COMP%]{-webkit-user-select:none;user-select:none;pointer-events:none;letter-spacing:normal;width:100%;height:100%;display:flex;overflow:hidden;font-size:100px;position:absolute;top:0}[_nghost-%COMP%]   div[_ngcontent-%COMP%]{width:100%;height:100%;display:flex;overflow:hidden;font-size:100px;position:absolute;top:0}[_nghost-%COMP%]   div.margin-top[_ngcontent-%COMP%]   svg-icon[_ngcontent-%COMP%]{margin-top:10%}[_nghost-%COMP%]   div[_ngcontent-%COMP%]   svg-icon[_ngcontent-%COMP%]{width:100%;height:100%}[_nghost-%COMP%]   div[_ngcontent-%COMP%]   svg-icon[_ngcontent-%COMP%]     svg{width:100%;height:100%}"]
            }),
            _t
        }
        )()
    }
    ,
    69307: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            Z: () => Xt
        });
        var Ut = $(10467)
          , r = $(54438)
          , Mt = $(7494)
          , s = $(9566)
          , so = $(13620)
          , Wt = $(69847)
          , _t = $(60177)
          , Ae = $(27617)
          , Me = $(78606)
          , ct = $(28105)
          , Tt = $(61762)
          , Qe = $(84412)
          , jt = $(5116)
          , Xe = $(63597)
          , Ce = $(2745)
          , it = $(84572)
          , et = $(56977)
          , re = $(49427)
          , pt = $(76675)
          , Be = $(70152)
          , ze = $(41046)
          , ye = $(73955)
          , ge = $(66985)
          , Ie = $(21626)
          , gt = $(345);
        const Ye = (ie, we, Oe, ee, W, ae, Ve, fe) => ({
            appConfiguration$: ie,
            location$: we,
            title$: Oe,
            footer$: ee,
            date$: W,
            photo$: ae,
            starElement: Ve,
            moonElement: fe,
            elementId: 0
        })
          , yt = (ie, we, Oe, ee, W, ae, Ve, fe) => ({
            appConfiguration$: ie,
            location$: we,
            title$: Oe,
            footer$: ee,
            date$: W,
            photo$: ae,
            starElement: Ve,
            moonElement: fe,
            elementId: 1
        })
          , ht = (ie, we) => [ie, we]
          , mo = ie => [ie]
          , no = () => [".jpeg", ".jpg", ".png", ".heic"]
          , Co = (ie, we) => ({
            fill: ie,
            stroke: we,
            width: "100%",
            height: "100%"
        })
          , Lt = () => ({
            fill: "red",
            width: "100%",
            height: "100%"
        });
        function Ft(ie, we) {
            if (1 & ie && (r.j41(0, "pp-poster-space-splitter", 9),
            r.eu8(1, 10)(2, 11),
            r.k0s()),
            2 & ie) {
                const Oe = r.XpG().ngIf
                  , ee = r.XpG(2)
                  , W = r.sdS(5);
                r.xc7("width", Oe.width, "px")("height", Oe.height, "px")("margin-top", Oe.marginTop, "px"),
                r.Y8G("isRestricted", !ee.isMoonOrPhoto()),
                r.R7$(),
                r.Y8G("ngTemplateOutlet", W)("ngTemplateOutletContext", r.lV(11, Ye, ee.appConfiguration1$, ee.location1$, ee.title1$, ee.footer1$, ee.date1$, ee.photo1$, ee.starElement1, ee.moonElement1)),
                r.R7$(),
                r.Y8G("ngTemplateOutlet", W)("ngTemplateOutletContext", r.lV(20, yt, ee.appConfiguration2$, ee.location2$, ee.title2$, ee.footer2$, ee.date2$, ee.photo2$, ee.starElement2, ee.moonElement1))
            }
        }
        function co(ie, we) {
            if (1 & ie && (r.qex(0),
            r.DNE(1, Ft, 3, 29, "pp-poster-space-splitter", 8),
            r.bVm()),
            2 & ie) {
                const Oe = we.ngIf;
                r.R7$(),
                r.Y8G("ngIf", Oe.width && Oe.height)
            }
        }
        function Jt(ie, we) {
            if (1 & ie) {
                const Oe = r.RV6();
                r.j41(0, "pp-poster-printing-registration", 6)(1, "pp-poster-arrangement-wrapper")(2, "pp-poster-text-area", 7),
                r.nI1(3, "async"),
                r.nI1(4, "async"),
                r.nI1(5, "async"),
                r.nI1(6, "async"),
                r.nI1(7, "async"),
                r.bIt("textareaHeightCallback", function(W) {
                    r.eBV(Oe);
                    const ae = r.XpG();
                    return r.Njj(ae.newTopTextareaHeight(W))
                })("textareaWidthCallback", function(W) {
                    r.eBV(Oe);
                    const ae = r.XpG();
                    return r.Njj(ae.newTopTextareaWidth(W))
                }),
                r.k0s(),
                r.DNE(8, co, 2, 1, "ng-container", 5),
                r.nI1(9, "async"),
                r.k0s()()
            }
            if (2 & ie) {
                const Oe = we.ngIf
                  , ee = r.XpG();
                r.Y8G("poster", Oe),
                r.R7$(2),
                r.Y8G("poster", r.bMT(3, 7, ee.poster$))("color", r.bMT(4, 9, ee.textColor$))("textArea", r.bMT(5, 11, ee.topTextArea$))("title", r.bMT(6, 13, ee.title$))("subtitle", ee.isMoonOrPhoto() ? void 0 : r.bMT(7, 15, ee.subtitle$)),
                r.R7$(6),
                r.Y8G("ngIf", r.bMT(9, 17, ee.splitElementsSize$))
            }
        }
        function po(ie, we) {
            if (1 & ie && (r.j41(0, "div", 18),
            r.nrm(1, "div", 19),
            r.k0s()),
            2 & ie) {
                const Oe = r.XpG().elementId
                  , ee = r.r8f(0)
                  , W = r.XpG();
                r.xc7("padding", W.stars.padding, "px")("width", W.stars.height, "px")("height", W.stars.height, "px"),
                r.AVh("force-background-area", W.stars.shape === W.StarsShapesEnum.CIRCLES_PHOTO && 1 === Oe && W.getPhotoWithType(ee).showAddPhoto),
                r.R7$(),
                r.xc7("background", W.stars.circleBackground),
                r.AVh("special-sky", W.stars.colorScheme === W.StarsColorSchemeEnum.SKY)("special-emerald", W.stars.colorScheme === W.StarsColorSchemeEnum.EMERALD)("special-purple-galaxy", W.stars.colorScheme === W.StarsColorSchemeEnum.PURPLE_GALAXY)
            }
        }
        function Et(ie, we) {
            if (1 & ie) {
                const Oe = r.RV6();
                r.j41(0, "div", 21)(1, "img", 22),
                r.bIt("load", function() {
                    r.eBV(Oe);
                    const W = r.XpG(3);
                    return r.Njj(W.onImageLoad())
                }),
                r.k0s()(),
                r.nrm(2, "pp-poster-preview", 23)
            }
            if (2 & ie) {
                const Oe = r.XpG(2).moonElement
                  , ee = r.XpG();
                r.xc7("padding", ee.stars.height * (ee.isRasterBackground(ee.stars.colorScheme) ? .01 : 0), "px"),
                r.R7$(),
                r.xc7("transform", "rotate(" + Oe.rotation + "deg) scale(" + Oe.scale + ")"),
                r.Y8G("src", Oe.image, r.B4B),
                r.R7$(),
                r.Y8G("showPreview", !ee.isFinalPoster)("marginTop", !1)("previewType", "moon")
            }
        }
        function Kt(ie, we) {
            if (1 & ie && r.nrm(0, "div", 26, 2),
            2 & ie) {
                const Oe = r.XpG(3).starElement
                  , ee = r.XpG();
                r.AVh("preview", !ee.isFinalPoster),
                r.Y8G("innerHTML", Oe.image, r.npT)
            }
        }
        function At(ie, we) {
            if (1 & ie && (r.nrm(0, "pp-poster-stars-area", 25),
            r.nI1(1, "async"),
            r.nI1(2, "async"),
            r.nI1(3, "async")),
            2 & ie) {
                const Oe = r.XpG(3)
                  , ee = Oe.appConfiguration$
                  , W = Oe.location$
                  , ae = r.XpG();
                r.Y8G("appConfiguration", r.bMT(1, 3, ee))("location", r.bMT(2, 5, W))("skyConfiguration", r.bMT(3, 7, ae.skyConfiguration$))
            }
        }
        function Re(ie, we) {
            if (1 & ie && (r.DNE(0, Kt, 2, 3, "div", 24)(1, At, 4, 9, "pp-poster-stars-area", 25),
            r.nrm(2, "pp-poster-preview", 23)),
            2 & ie) {
                const Oe = r.XpG(3);
                r.vxM(Oe.isSvgStars ? 0 : 1),
                r.R7$(2),
                r.Y8G("showPreview", !Oe.isFinalPoster)("marginTop", Oe.stars.shape === Oe.StarsShapesEnum.HEARTS)("previewType", "star-dimmed")
            }
        }
        function ve(ie, we) {
            if (1 & ie) {
                const Oe = r.RV6();
                r.j41(0, "img", 29),
                r.bIt("load", function() {
                    r.eBV(Oe);
                    const W = r.XpG(4);
                    return r.Njj(W.onImageLoad())
                })("click", function() {
                    r.eBV(Oe);
                    const W = r.XpG(4);
                    return r.Njj(W.onPhotoSelect())
                }),
                r.k0s()
            }
            if (2 & ie) {
                const Oe = r.XpG(2).ngIf
                  , ee = r.XpG(2);
                r.Y8G("src", ee.getPhotoWithType(Oe).imageUrl, r.B4B)
            }
        }
        function ne(ie, we) {
            if (1 & ie) {
                const Oe = r.RV6();
                r.j41(0, "pp-controls-file-uploader-photo", 30),
                r.nI1(1, "translate"),
                r.bIt("setFileUploadingProgress", function(W) {
                    r.eBV(Oe);
                    const ae = r.XpG(4);
                    return r.Njj(ae.setFileUpploadingProgress.emit(W))
                }),
                r.k0s()
            }
            if (2 & ie) {
                const Oe = r.XpG(4);
                r.Y8G("photoFileGroup", Oe.photoFileGroup)("photoCropGroup", Oe.photoCropGroup)("photoId", Oe.photoId)("multiFile", Oe.multiFile)("isSubmitted", !1)("acceptable", r.lJ4(13, no))("isBase64Response", !0)("fullHeight", !0)("isBigPictureMode", !0)("isFileUploadingInProgress", Oe.isFileUploadingInProgress)("legalNote", r.bMT(1, 11, "soundwave.details.instruction"))
            }
        }
        function B(ie, we) {
            if (1 & ie && r.DNE(0, ve, 1, 1, "img", 27)(1, ne, 2, 14, "pp-controls-file-uploader-photo", 28),
            2 & ie) {
                const Oe = r.XpG().ngIf
                  , ee = r.XpG(2);
                r.vxM(ee.getPhotoWithType(Oe).showAddPhoto ? ee.photoFileGroup && ee.getPhotoWithType(Oe).showAddPhoto ? 1 : -1 : 0)
            }
        }
        function de(ie, we) {
            if (1 & ie && (r.j41(0, "div", 20),
            r.DNE(1, Et, 3, 8)(2, Re, 3, 4)(3, B, 2, 1),
            r.k0s()),
            2 & ie) {
                const Oe = we.ngIf
                  , ee = r.XpG().elementId
                  , W = r.XpG();
                r.xc7("width", W.stars.height, "px")("height", W.stars.height, "px"),
                r.AVh("special-punching-die", W.isRasterBackground(W.stars.colorScheme))("special-heart", W.stars.shape === W.StarsShapesEnum.HEARTS)("special-circle", r.eq3(19, mo, W.StarsShapesEnum.CIRCLES).includes(W.stars.shape) || W.stars.shape === W.StarsShapesEnum.CIRCLES_MOON && 0 === ee || W.stars.shape === W.StarsShapesEnum.CIRCLES_PHOTO && 0 === ee)("special-photo", r.eq3(21, mo, W.StarsShapesEnum.CIRCLES_PHOTO).includes(W.stars.shape) && 1 === ee)("special-sky", W.stars.colorScheme === W.StarsColorSchemeEnum.SKY)("special-emerald", W.stars.colorScheme === W.StarsColorSchemeEnum.EMERALD)("special-purple-galaxy", W.stars.colorScheme === W.StarsColorSchemeEnum.PURPLE_GALAXY),
                r.R7$(),
                r.vxM(W.stars.shape === W.StarsShapesEnum.CIRCLES_MOON && 1 === ee ? 1 : W.getPhotoWithType(Oe).isPhoto ? 3 : 2)
            }
        }
        function lt(ie, we) {
            if (1 & ie && (r.j41(0, "div", 33),
            r.nrm(1, "div", 34)(2, "div", 35)(3, "div", 36)(4, "div", 37),
            r.k0s()),
            2 & ie) {
                const Oe = r.XpG(4);
                r.R7$(),
                r.xc7("width", Oe.stars.punchingDieLineSize, "px")("background-color", Oe.stars.background),
                r.R7$(),
                r.xc7("height", Oe.stars.punchingDieLineSize, "px")("background-color", Oe.stars.background),
                r.R7$(),
                r.xc7("height", Oe.stars.punchingDieLineSize, "px")("background-color", Oe.stars.background),
                r.R7$(),
                r.xc7("width", Oe.stars.punchingDieLineSize, "px")("background-color", Oe.stars.background)
            }
        }
        function St(ie, we) {
            if (1 & ie && (r.nrm(0, "svg-icon", 32),
            r.DNE(1, lt, 5, 16, "div", 33)),
            2 & ie) {
                const Oe = r.XpG(3);
                r.Y8G("svgStyle", r.l_i(3, Co, Oe.stars.background, Oe.stars.stroke))("src", "/assets/pp-posters/stars/double-punching-die/shape-" + (Oe.stars.shape === Oe.StarsShapesEnum.HEARTS ? "heart" : "circle") + ".svg"),
                r.R7$(),
                r.vxM(Oe.stars.punchingDieLineSize ? 1 : -1)
            }
        }
        function tt(ie, we) {
            if (1 & ie && (r.j41(0, "div", 31),
            r.DNE(1, St, 2, 6),
            r.k0s()),
            2 & ie) {
                const Oe = r.XpG(2);
                r.xc7("padding", Oe.stars.punchingDiePadding, "px"),
                r.R7$(),
                r.vxM(Oe.isRasterBackground(Oe.stars.colorScheme) ? -1 : 1)
            }
        }
        function $t(ie, we) {
            if (1 & ie && (r.j41(0, "div", 39),
            r.nrm(1, "svg-icon", 40),
            r.k0s()),
            2 & ie) {
                const Oe = r.XpG(3);
                r.xc7("margin-top", Oe.Math.round(Oe.stars.specialShieldMarginTop), "px")("height", Oe.Math.round(Oe.stars.specialShieldHeight), "px"),
                r.R7$(),
                r.Y8G("svgStyle", r.lJ4(6, Lt))("src", "/assets/pp-posters/stars/shields/heart.svg")
            }
        }
        function Nt(ie, we) {
            if (1 & ie && (r.j41(0, "div", 39),
            r.nrm(1, "svg-icon", 40),
            r.k0s()),
            2 & ie) {
                const Oe = r.XpG(3);
                r.xc7("margin-top", Oe.Math.round(Oe.stars.specialShieldMarginTop), "px")("height", Oe.Math.round(Oe.stars.specialShieldHeight), "px"),
                r.R7$(),
                r.Y8G("svgStyle", r.lJ4(6, Lt))("src", "/assets/pp-posters/stars/shields/circle.svg")
            }
        }
        function Vt(ie, we) {
            if (1 & ie && r.DNE(0, $t, 2, 7, "div", 38)(1, Nt, 2, 7, "div", 38),
            2 & ie) {
                const Oe = r.XpG(2);
                r.vxM(Oe.stars.shape === Oe.StarsShapesEnum.HEARTS ? 0 : 1)
            }
        }
        function _o(ie, we) {
            if (1 & ie && (r.nrm(0, "pp-poster-text-area", 17),
            r.nI1(1, "async"),
            r.nI1(2, "async"),
            r.nI1(3, "async"),
            r.nI1(4, "async"),
            r.nI1(5, "async"),
            r.nI1(6, "async")),
            2 & ie) {
                const Oe = r.XpG()
                  , ee = Oe.title$
                  , W = Oe.footer$
                  , ae = Oe.date$
                  , Ve = r.XpG();
                r.Y8G("poster", r.bMT(1, 6, Ve.poster$))("color", r.bMT(2, 8, Ve.textColor$))("textArea", r.bMT(3, 10, Ve.textArea$))("title", r.bMT(4, 12, ee))("footer", r.bMT(5, 14, W))("date", r.bMT(6, 16, ae))
            }
        }
        function Lo(ie, we) {
            if (1 & ie && (r.nrm(0, "pp-poster-text-area", 17),
            r.nI1(1, "async"),
            r.nI1(2, "async"),
            r.nI1(3, "async"),
            r.nI1(4, "async"),
            r.nI1(5, "async"),
            r.nI1(6, "async")),
            2 & ie) {
                const Oe = r.XpG()
                  , ee = Oe.footer$
                  , W = Oe.date$
                  , ae = r.XpG();
                r.Y8G("poster", r.bMT(1, 6, ae.poster$))("color", r.bMT(2, 8, ae.textColor$))("textArea", r.bMT(3, 10, ae.textArea$))("title", r.bMT(4, 12, ae.subtitle$))("footer", r.bMT(5, 14, ee))("date", r.bMT(6, 16, W))
            }
        }
        function ao(ie, we) {
            if (1 & ie && (r.SS7(0),
            r.nI1(1, "async"),
            r.j41(2, "pp-poster-image-area", 12)(3, "div", 13),
            r.DNE(4, po, 2, 16, "div", 14)(5, de, 4, 23, "div", 15),
            r.nI1(6, "async"),
            r.DNE(7, tt, 2, 3, "div", 16),
            r.k0s(),
            r.DNE(8, Vt, 2, 1),
            r.k0s(),
            r.DNE(9, _o, 7, 18, "pp-poster-text-area", 17)(10, Lo, 7, 18, "pp-poster-text-area", 17)),
            2 & ie) {
                const Oe = we.photo$
                  , ee = we.elementId
                  , W = r.XpG();
                r.bH3(r.bMT(1, 12, Oe)),
                r.R7$(2),
                r.Y8G("relative", !0),
                r.R7$(),
                r.xc7("margin-top", W.stars.marginTop, "px")("width", W.stars.width, "px")("height", W.stars.height, "px"),
                r.R7$(),
                r.vxM(W.stars.shape !== W.StarsShapesEnum.CIRCLES_MOON || W.stars.shape === W.StarsShapesEnum.CIRCLES_MOON && 0 === ee ? 4 : -1),
                r.R7$(),
                r.Y8G("ngIf", r.bMT(6, 15, Oe)),
                r.R7$(2),
                r.vxM(W.stars.shape !== W.StarsShapesEnum.CIRCLES_MOON || W.stars.shape === W.StarsShapesEnum.CIRCLES_MOON && 0 === ee ? 7 : -1),
                r.R7$(),
                r.vxM(W.isRasterBackground(W.stars.colorScheme) && (r.l_i(17, ht, W.StarsShapesEnum.CIRCLES, W.StarsShapesEnum.HEARTS).includes(W.stars.shape) || W.isMoonOrPhoto() && 0 === ee) ? 8 : -1),
                r.R7$(),
                r.vxM(W.isMoonOrPhoto() ? 0 === ee ? 10 : -1 : 9)
            }
        }
        function bt(ie, we) {
            1 & ie && r.nrm(0, "pp-poster-loaded-element")
        }
        function Do(ie, we) {
            if (1 & ie && (r.SS7(0)(1),
            r.qSk(),
            r.j41(2, "svg", 41)(3, "defs")(4, "mask", 42),
            r.nrm(5, "circle", 43),
            r.k0s()()(),
            r.SS7(6)(7),
            r.j41(8, "svg", 41)(9, "defs")(10, "mask", 44),
            r.nrm(11, "circle", 43),
            r.k0s()()(),
            r.SS7(12)(13)(14)(15),
            r.j41(16, "svg", 45)(17, "defs")(18, "mask", 46),
            r.nrm(19, "path", 47),
            r.k0s()()()),
            2 & ie) {
                const Oe = r.XpG()
                  , ee = Oe.stars.width / 2
                  , W = ee * (Oe.isRasterAndClassic(Oe.stars.colorScheme, Oe.stars.shape) ? .83 : .917);
                r.R7$(2),
                r.BMQ("width", ee)("height", ee),
                r.R7$(3),
                r.BMQ("cx", ee)("cy", ee)("r", W);
                const ae = Oe.stars.width / 2
                  , Ve = .96 * ee;
                r.R7$(3),
                r.BMQ("width", ee)("height", ee),
                r.R7$(3),
                r.BMQ("cx", ae)("cy", ae)("r", Ve);
                const fe = .97 * Oe.stars.width
                  , Pt = fe / 1777
                  , mt = (Oe.stars.width - fe) / 2
                  , xo = 2 * -mt;
                r.R7$(5),
                r.BMQ("width", fe)("height", fe)("viewBox", "0 0 1777 1777"),
                r.R7$(3),
                r.BMQ("transform", "translate(" + mt + ", " + xo + ") scale(" + Pt + "," + Pt + ")")
            }
        }
        let Xt = ( () => {
            var ie;
            class we extends Xe.l {
                constructor(ee, W, ae, Ve, fe) {
                    super(ee, W, ae, Ve, fe),
                    this.host = ee,
                    this.zone = W,
                    this.httpClient = ae,
                    this.domSanitizer = Ve,
                    this.cdr = fe,
                    this.photoId = 0,
                    this.multiFile = !1,
                    this.photoSelect = new r.bkB,
                    this.setFileUpploadingProgress = new r.bkB,
                    this.isFileUploadingInProgress = !1,
                    this.title1$ = new Qe.t(null),
                    this.footer1$ = new Qe.t(null),
                    this.date1$ = new Qe.t(null),
                    this.title2$ = new Qe.t(null),
                    this.footer2$ = new Qe.t(null),
                    this.date2$ = new Qe.t(null),
                    this.stars = {
                        marginTop: 0,
                        width: 0,
                        height: 0,
                        padding: 0,
                        background: "#FFF",
                        stroke: "transparent",
                        circleBackground: "transparent",
                        colorScheme: Ae.th1.COSMIC_LOVE,
                        shape: Ae.nhL.CIRCLES,
                        punchingDiePadding: 0,
                        punchingDieLineSize: 0,
                        specialShieldMarginTop: 0,
                        specialShieldHeight: 0,
                        isPortrait: !1
                    },
                    this.starElement1 = {
                        uuid: void 0,
                        image: ""
                    },
                    this.starElement2 = {
                        uuid: void 0,
                        image: ""
                    },
                    this.moonElement1 = {
                        image: "",
                        rotation: 0,
                        scale: 1
                    },
                    this.appConfiguration1$ = new Qe.t(null),
                    this.appConfiguration2$ = new Qe.t(null),
                    this.skyConfiguration$ = new Qe.t(null),
                    this.location1$ = new Qe.t(null),
                    this.photo1$ = new Qe.t(null),
                    this.photo2$ = new Qe.t(null),
                    this.location2$ = new Qe.t(null),
                    this.topTextAreaHeight$ = new Qe.t(null),
                    this.topTextAreaWidth$ = new Qe.t(null),
                    this.splitElementsSize$ = new Qe.t({
                        width: 0,
                        height: 0,
                        marginTop: 0
                    }),
                    this.StarsShapesEnum = Ae.nhL,
                    this.Math = Math
                }
                ngAfterViewInit() {
                    (0,
                    it.z)([this.poster$, this.topTextArea$, this.topTextAreaHeight$, this.topTextAreaWidth$, this.posterConfiguration$]).pipe((0,
                    et.Q)(this.ngUnsubscribe), (0,
                    Be.B)(100)).subscribe( ([ee,W,ae,Ve,fe]) => {
                        var Pt, mt, xo;
                        ae || (ae = 0),
                        Ve || (Ve = 0),
                        W || (Ve = 0);
                        const So = null !== (Pt = ee.size.height) && void 0 !== Pt ? Pt : 0;
                        let ro = ee.size.height - (ae + (null !== (mt = W.topFactor) && void 0 !== mt ? mt : 0) * So)
                          , Vo = 0;
                        null != fe && fe.title || null == fe || !fe.subtitle ? null == fe || !fe.title || null != fe && fe.subtitle || !this.isMoonOrPhoto(null == fe ? void 0 : fe.shape) ? ((null == fe || !fe.title) && (null == fe || !fe.subtitle) || !fe.mainTextEnable) && (Vo = .044 * ee.size.height,
                        ro -= 2 * Vo) : ro -= .06 * ee.size.height : (Vo = .02 * ee.size.height,
                        ro -= 2 * Vo);
                        const vo = (null !== (xo = null == fe ? void 0 : fe.subtitle) && void 0 !== xo ? xo : "").indexOf("\n") > -1;
                        !this.isMoonOrPhoto(null == fe ? void 0 : fe.shape) && vo && (ro *= this.isRasterAndClassic(this.stars.colorScheme, this.stars.shape) ? 1.05 : 1.03);
                        let ei = null != Ve ? Ve : 0;
                        this.isMoonOrPhoto(null == fe ? void 0 : fe.shape) && (ei *= 1.055),
                        null != fe && fe.mainTextEnable && null != fe && fe.title && null != fe && fe.titleFont && (ro *= .995,
                        this.isMoonOrPhoto(null == fe ? void 0 : fe.shape) && (ro *= 1.02)),
                        null != fe && fe.mainTextEnable && null != fe && fe.subtitle && null != fe && fe.subtitleFont && (ro *= .99),
                        this.isWideRatio(ee, !0) && (ro *= 1.02),
                        this.isNarrowRatio(ee) && (ro *= .98),
                        this.splitElementsSize$.next({
                            width: ei,
                            height: ro,
                            marginTop: Vo
                        })
                    }
                    )
                }
                setAllTextSettings(ee) {
                    const W = ee.starMapConfig[0]
                      , ae = ee.starMapConfig[1]
                      , Ve = this.isMoonOrPhoto(ee.shape)
                      , fe = {
                        text: ee.mainTextEnable ? ee.title : "",
                        isDefaultFont: ee.titleFont
                    }
                      , Pt = {
                        text: ee.mainTextEnable ? ee.subtitle : "",
                        isDefaultFont: ee.subtitleFont
                    }
                      , mt = null != fe && fe.isDefaultFont ? .08 : .045;
                    this.setText(fe, this.title$, {
                        font: null != fe && fe.isDefaultFont ? Ae.n3q.POSITIVE_PRINTS_SCRIPT_2 : Ae.n3q.CAPSUULA_BOLD,
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: mt,
                            bottomFactor: 0,
                            lineHeightFactor: mt * (null != fe && fe.isDefaultFont ? 1.35 : 1.8),
                            topFactor: (Pt.text ? 0 : .015) + (null != fe && fe.isDefaultFont ? 0 : .01),
                            isBold: !1
                        }
                    });
                    const xo = Ve ? null != Pt && Pt.isDefaultFont ? .052 : .036 : .032;
                    this.setText(Pt, this.subtitle$, {
                        font: Ve && null != Pt && Pt.isDefaultFont ? Ae.n3q.POSITIVE_PRINTS_SCRIPT_2 : Ae.n3q.CAPSUULA,
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: xo,
                            bottomFactor: !Ve || null != Pt && Pt.isDefaultFont ? 0 : .02,
                            lineHeightFactor: xo * (Ve ? 1.34 : 1.25),
                            maxLines: 2,
                            heightLines: Ve ? 2 : void 0,
                            topFactor: Ve ? 0 : fe.text ? -.01 : .025,
                            isBold: !1
                        }
                    });
                    const So = {
                        text: W.title,
                        isDefaultFont: W.titleFont,
                        showEmptyLine: !0
                    }
                      , ro = {
                        text: ae.title,
                        isDefaultFont: ae.titleFont,
                        showEmptyLine: !0
                    }
                      , Vo = ci => ({
                        font: null != ci && ci.isDefaultFont ? Ae.n3q.POSITIVE_PRINTS_SCRIPT_2 : Ae.n3q.CAPSUULA_BOLD,
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: null != ci && ci.isDefaultFont ? .052 : .036,
                            bottomFactor: 0,
                            lineHeightFactor: .058 * 1.34,
                            topFactor: 0,
                            isBold: !1
                        }
                    });
                    this.setText(So, this.title1$, Vo(So)),
                    this.setText(ro, this.title2$, Vo(ro));
                    const ei = {
                        font: Ae.n3q.CAPSUULA,
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: .018,
                            bottomFactor: 0,
                            lineHeightFactor: .018 * 1.22,
                            topFactor: Ve ? 0 : .0268
                        }
                    };
                    this.setText({
                        text: W.coordinates,
                        isDefaultFont: !0,
                        showEmptyLine: !0
                    }, this.footer1$, ei),
                    this.setText({
                        text: ae.coordinates,
                        isDefaultFont: !0,
                        showEmptyLine: !0
                    }, this.footer2$, ei);
                    const Ti = {
                        ...ei,
                        horizontal: {
                            ...ei.horizontal,
                            topFactor: .00335
                        }
                    };
                    this.setText({
                        text: W.dateField,
                        isDefaultFont: !0,
                        showEmptyLine: !0
                    }, this.date1$, Ti),
                    this.setText({
                        text: ae.dateField,
                        isDefaultFont: !0,
                        showEmptyLine: !0
                    }, this.date2$, Ti)
                }
                setTextArea(ee, W) {
                    this.topTextArea$.next({
                        topFactor: this.isWideRatio(ee, !1) ? .04 : .07,
                        marginFactor: .09
                    });
                    let ae = .096;
                    W.mainTextEnable && W.title && (ae = W.titleFont ? .068 : .044),
                    this.isMoonOrPhoto(null == W ? void 0 : W.shape) && (ae *= .75),
                    this.textArea$.next({
                        bottomFactor: ae,
                        marginFactor: .013
                    })
                }
                isNarrowRatio(ee) {
                    return ee.size.height / ee.size.width >= .8
                }
                newTopTextareaHeight(ee) {
                    this.topTextAreaHeight$.next(ee)
                }
                newTopTextareaWidth(ee) {
                    this.topTextAreaWidth$.next(ee)
                }
                setDesign(ee, W) {
                    var ae = this;
                    return (0,
                    Ut.A)(function*() {
                        var Ve, fe, ro, Vo, vo;
                        Vo = ae.moonElement1,
                        (ro = W.starMapConfig[0]).selectedByDate ? (Vo.image = "/assets/pp-posters/moon/".concat(ae.isFinalPoster ? "_HQ_/" : "", "moon_shadow/").concat(ro.moon, ".png"),
                        Vo.rotation = ro.moonRotation) : (Vo.image = "/assets/pp-posters/moon/".concat(ae.isFinalPoster ? "_HQ_/" : "", "moon_selected_shadow/").concat(ro.selectPhase, ".png"),
                        null !== (vo = ro.place) && void 0 !== vo && null !== (vo = vo.center) && void 0 !== vo && vo.latitude && (Vo.rotation = ro.place.center.latitude > 0 ? 0 : 180)),
                        Vo.scale = 1.05,
                        ae.setMap(W);
                        const mt = W.starMapConfig[0]
                          , xo = W.starMapConfig[1];
                        if (ae.stars.colorScheme = W.colorScheme,
                        ae.stars.shape = W.shape,
                        ae.setSizes(ee, W),
                        ae.stars.background = ae.starsBackground(W.colorScheme, W.customColors, ae.isFinalPoster, "landscape"),
                        ae.stars.stroke = ae.starsStroke(W.colorScheme, W.customColors),
                        ae.stars.circleBackground = ae.circleColor(W.colorScheme, W.customColors),
                        ae.textColor$.next(ae.textColor(W.colorScheme, W.customColors)),
                        !ae.isSvgStars)
                            return;
                        ae.starElement1.uuid = mt.uuid,
                        ae.starElement2.uuid = xo.uuid;
                        const So = yield Promise.all([ae.httpClient.get("/api/stars/d3-celestial/svg", {
                            params: {
                                uuid: null !== (Ve = ae.starElement1.uuid) && void 0 !== Ve ? Ve : ""
                            },
                            responseType: "text"
                        }).toPromise(), ae.httpClient.get("/api/stars/d3-celestial/svg", {
                            params: {
                                uuid: null !== (fe = ae.starElement2.uuid) && void 0 !== fe ? fe : ""
                            },
                            responseType: "text"
                        }).toPromise()]);
                        !So || !So[0] || !So[1] || (ae.starElement1.image = ae.domSanitizer.bypassSecurityTrustHtml(ae.getImage(So[0])),
                        requestAnimationFrame(ae.onImageLoad.bind(ae)),
                        W.shape !== Ae.nhL.CIRCLES_PHOTO && (ae.starElement2.image = ae.domSanitizer.bypassSecurityTrustHtml(ae.getImage(So[1])),
                        requestAnimationFrame(ae.onImageLoad.bind(ae))))
                    })()
                }
                setMap(ee) {
                    var W, ae;
                    const Ve = ee.starMapConfig[0]
                      , fe = ee.starMapConfig[1];
                    null != Ve && Ve.date && null != Ve && null !== (W = Ve.place) && void 0 !== W && W.center && this.location1$.next({
                        UTCTimestamp: Ve.date,
                        timezone: Ve.timezone,
                        lat: Ve.place.center.latitude,
                        lng: Ve.place.center.longitude
                    }),
                    null != fe && fe.date && null != fe && null !== (ae = fe.place) && void 0 !== ae && ae.center && this.location2$.next({
                        UTCTimestamp: fe.date,
                        timezone: fe.timezone,
                        lat: fe.place.center.latitude,
                        lng: fe.place.center.longitude
                    }),
                    this.photo1$.next({
                        isPhoto: !1,
                        uuid: "",
                        imageUrl: "",
                        showAddPhoto: !1
                    }),
                    this.photo2$.next({
                        isPhoto: ee.shape === Ae.nhL.CIRCLES_PHOTO,
                        uuid: fe.photoFiles[0].uuid,
                        imageUrl: "".concat(this.environmentPhotoApi, "/v2/").concat(this.isFinalPoster ? "photo" : "image", "/").concat(fe.photoFiles[0].uuid, "?type=").concat(fe.cropsData[0].filter, "&left=").concat(fe.cropsData[0].cropData.x, "&top=").concat(fe.cropsData[0].cropData.y, "&width=").concat(fe.cropsData[0].cropData.width, "&height=").concat(fe.cropsData[0].cropData.height, "&rotate=").concat(fe.cropsData[0].rotate, "&flipped=").concat(fe.cropsData[0].flip),
                        showAddPhoto: !fe.photoFiles[0].uuid
                    }),
                    this.skyConfiguration$.next({
                        ecliptic: ee.ecliptic,
                        constellations: ee.constellations,
                        constellationsName: ee.constellationsName,
                        planets: ee.planets,
                        planetNames: ee.planetNames,
                        milkyWay: ee.milkyWay,
                        grid: ee.grid,
                        moon: ee.moon,
                        colorScheme: ee.colorScheme,
                        shape: ee.shape,
                        jewelryColors: pt.fd[ee.material],
                        jewelryBackground: pt.x_[ee.material],
                        language: ee.lang,
                        ...ee.customColors
                    });
                    const mt = {
                        size: 442,
                        starLimit: this.isMobile ? 5.2 : 5.4,
                        starSize: this.isMobile ? 3.825 : 5.0756,
                        lineWidth: .35,
                        isJewelry: !1
                    };
                    this.appConfiguration1$.next({
                        ...mt,
                        id: 1,
                        containerId: "celestial-map-1"
                    }),
                    this.appConfiguration2$.next({
                        ...mt,
                        id: 2,
                        containerId: "celestial-map-2"
                    })
                }
                getImage(ee) {
                    let ae = (new DOMParser).parseFromString(ee, "image/svg+xml");
                    return ae = (0,
                    jt.t2)(ae, !1),
                    ae = (0,
                    jt.Jr)(ae),
                    ae.documentElement.outerHTML
                }
                getPhotoWithType(ee) {
                    return ee
                }
                setSizes(ee, W) {
                    this.stars.isPortrait = ee.isPortrait,
                    this.stars.width = .82 * ee.size.width / 2,
                    this.stars.height = this.stars.width,
                    this.imageInstanceSize = {
                        width: this.stars.width,
                        height: this.stars.width
                    },
                    this.stars.padding = .01 * this.stars.width,
                    this.stars.marginTop = 0,
                    this.isMoonOrPhoto(W.shape) ? (this.stars.punchingDieLineSize = .015 * this.stars.width,
                    this.stars.punchingDiePadding = .005 * this.stars.width) : (this.stars.punchingDieLineSize = .059 * this.stars.width,
                    this.stars.punchingDiePadding = .055 * this.stars.width),
                    this.stars.shape === Ae.nhL.HEARTS ? (this.stars.specialShieldMarginTop = .0582 * ee.size.height,
                    this.stars.specialShieldHeight = .844 * this.stars.height) : (this.stars.specialShieldMarginTop = ee.size.height * (this.isRasterAndClassic(this.stars.colorScheme, this.stars.shape) ? .034 : .007),
                    this.stars.specialShieldHeight = this.stars.height * (this.isRasterAndClassic(this.stars.colorScheme, this.stars.shape) ? .882 : .975))
                }
                isMoonOrPhoto(ee=this.stars.shape) {
                    return [Ae.nhL.CIRCLES_PHOTO, Ae.nhL.CIRCLES_MOON].includes(ee)
                }
                isRasterAndClassic(ee, W) {
                    return this.isRasterBackground(ee) && !this.isMoonOrPhoto(W)
                }
                onPhotoSelect() {
                    this.photoSelect.emit([this.imageInstanceSize.width, this.imageInstanceSize.height])
                }
                onImageLoad() {
                    this.load++,
                    2 === this.load && (this.initiateRender(),
                    this.cdr.detectChanges())
                }
            }
            return (ie = we).\u0275fac = function(ee) {
                return new (ee || ie)(r.rXU(r.aKT),r.rXU(r.SKi),r.rXU(Ie.Qq),r.rXU(gt.up),r.rXU(r.gRc))
            }
            ,
            ie.\u0275cmp = r.VBU({
                type: ie,
                selectors: [["pp-poster-stars-double"]],
                inputs: {
                    photoFileGroup: "photoFileGroup",
                    photoCropGroup: "photoCropGroup",
                    photoId: "photoId",
                    multiFile: "multiFile",
                    environmentPhotoApi: "environmentPhotoApi",
                    isFileUploadingInProgress: "isFileUploadingInProgress"
                },
                outputs: {
                    photoSelect: "photoSelect",
                    setFileUpploadingProgress: "setFileUpploadingProgress"
                },
                features: [r.Vt3],
                decls: 9,
                vars: 8,
                consts: [["posterWrapper", ""], ["singleElement", ""], ["starsSvg", ""], [3, "background"], [3, "poster", 4, "ngIf"], [4, "ngIf"], [3, "poster"], [3, "textareaHeightCallback", "textareaWidthCallback", "poster", "color", "textArea", "title", "subtitle"], [3, "width", "height", "marginTop", "isRestricted", 4, "ngIf"], [3, "isRestricted"], ["first", "", 3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["second", "", 3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "relative"], [1, "stars-instance"], [1, "background-area", 3, "force-background-area", "padding", "width", "height"], ["class", "stars-area", 3, "special-punching-die", "special-heart", "special-circle", "special-photo", "special-sky", "special-emerald", "special-purple-galaxy", "width", "height", 4, "ngIf"], [1, "punching-die", 3, "padding"], [3, "poster", "color", "textArea", "title", "footer", "date"], [1, "background-area"], [1, "circle-background"], [1, "stars-area"], [1, "moon-area"], [3, "load", "src"], [3, "showPreview", "marginTop", "previewType"], [1, "stars-svg", 3, "preview", "innerHTML"], [3, "appConfiguration", "location", "skyConfiguration"], [1, "stars-svg", 3, "innerHTML"], [3, "src"], [3, "photoFileGroup", "photoCropGroup", "photoId", "multiFile", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "isFileUploadingInProgress", "legalNote"], [3, "load", "click", "src"], [3, "setFileUploadingProgress", "photoFileGroup", "photoCropGroup", "photoId", "multiFile", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "isFileUploadingInProgress", "legalNote"], [1, "punching-die"], [3, "svgStyle", "src"], [1, "punching-die-line"], [1, "punching-die-line-left"], [1, "punching-die-line-top"], [1, "punching-die-line-bottom"], [1, "punching-die-line-right"], [1, "special-shield", 3, "marginTop", "height"], [1, "special-shield"], [1, "special-shield-image-to-style", 3, "svgStyle", "src"], ["shape-rendering", "geometricPrecision", 2, "position", "absolute"], ["id", "circleClipPath"], ["fill", "white"], ["id", "photoClipPath", "clipPathUnits", "objectBoundingBox"], [2, "top", "0", "position", "absolute"], ["id", "heartClipPath"], ["fill", "white", "d", "M1666.1,954.9h0s-56.1,217.2-319.8,454c-238.8,214.4-457.8,325.9-457.8,325.9,0,0-219-111.5-457.8-325.9-263.6-236.7-319.8-454-319.8-454-89.7-290.5,54-462.9,54-462.9,0,0,136.4-188.9,368.9-188.9s354.6,209.8,354.6,209.8c0,0,122.1-209.8,354.6-209.8s368.9,188.9,368.9,188.9c0,0,143.7,172.4,54,462.9h.2Z"]],
                template: function(ee, W) {
                    if (1 & ee && (r.j41(0, "pp-poster-background", 3, 0),
                    r.DNE(2, Jt, 10, 19, "pp-poster-printing-registration", 4),
                    r.nI1(3, "async"),
                    r.k0s(),
                    r.DNE(4, ao, 11, 20, "ng-template", null, 1, r.C5r)(6, bt, 1, 0, "pp-poster-loaded-element", 5)(7, Do, 20, 14),
                    r.nI1(8, "async")),
                    2 & ee) {
                        let ae;
                        r.Y8G("background", W.stars.background),
                        r.R7$(2),
                        r.Y8G("ngIf", r.bMT(3, 4, W.poster$)),
                        r.R7$(4),
                        r.Y8G("ngIf", W.isImageRendered),
                        r.R7$(),
                        r.vxM((ae = r.bMT(8, 6, W.poster$)) ? 7 : -1, ae)
                    }
                },
                dependencies: [_t.MD, _t.bT, _t.T3, _t.Jj, Mt.Z, s.R, Wt.c, so.y, ct.Y, Me.iu, Me.DM, Tt.W, Ce.G, re.ex, ze.C, ye.h, ye.D9, ge.P],
                styles: ["[_nghost-%COMP%]{width:100%;height:100%;display:block}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]{box-sizing:border-box;position:relative;overflow:hidden}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .background-area[_ngcontent-%COMP%]{width:100%;height:100%;box-sizing:border-box;margin:auto}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .background-area[_ngcontent-%COMP%]   .circle-background[_ngcontent-%COMP%]{width:100%;height:100%;border-radius:50%;box-sizing:border-box}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .stars-area[_ngcontent-%COMP%]{margin:auto;position:absolute;top:0;right:0;bottom:0;left:0}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .stars-area[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:100%;height:100%;object-fit:cover;padding:1px;box-sizing:border-box;cursor:pointer}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]{position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]   .punching-die-line[_ngcontent-%COMP%]{position:absolute;top:0;left:0;right:0;bottom:0}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]   .punching-die-line[_ngcontent-%COMP%]   .punching-die-line-left[_ngcontent-%COMP%], [_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]   .punching-die-line[_ngcontent-%COMP%]   .punching-die-line-right[_ngcontent-%COMP%]{position:absolute;top:0;height:100%;background:#fff}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]   .punching-die-line[_ngcontent-%COMP%]   .punching-die-line-left[_ngcontent-%COMP%]{left:0}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]   .punching-die-line[_ngcontent-%COMP%]   .punching-die-line-right[_ngcontent-%COMP%]{right:0}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]   .punching-die-line[_ngcontent-%COMP%]   .punching-die-line-top[_ngcontent-%COMP%], [_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]   .punching-die-line[_ngcontent-%COMP%]   .punching-die-line-bottom[_ngcontent-%COMP%]{position:absolute;width:100%;background:#fff;left:0}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]   .punching-die-line[_ngcontent-%COMP%]   .punching-die-line-top[_ngcontent-%COMP%]{top:0}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]   .punching-die-line[_ngcontent-%COMP%]   .punching-die-line-bottom[_ngcontent-%COMP%]{bottom:0}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .shield-border[_ngcontent-%COMP%]{position:absolute;top:1px;right:1px;bottom:1px;left:1px;border-style:solid;border-radius:100%}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .shield-image[_ngcontent-%COMP%]{position:absolute;top:0;right:0;bottom:0;left:0}.stars-svg[_ngcontent-%COMP%]{width:100%;height:100%;box-sizing:border-box}.stars-svg[_ngcontent-%COMP%]     svg{width:100%;height:100%}.stars-svg[_ngcontent-%COMP%]     svg g#planesecliptic path{stroke-width:2.2222220833px;vector-effect:non-scaling-stroke!important;stroke-dasharray:66 61.2500000005}.stars-svg[_ngcontent-%COMP%]     svg g#constLines path{stroke-width:2.2222220833px;vector-effect:non-scaling-stroke!important}.stars-svg[_ngcontent-%COMP%]     svg g#gridLines path{stroke-width:1.1104166667px;vector-effect:non-scaling-stroke!important}.stars-svg.preview[_ngcontent-%COMP%]     svg g#constLines path, .stars-svg.preview[_ngcontent-%COMP%]     svg g#planesecliptic path{stroke-width:.5333333px}.stars-svg.preview[_ngcontent-%COMP%]     svg g#gridLines path{stroke-width:.2665px}.special-shield[_ngcontent-%COMP%]{position:absolute;top:0;left:0;right:0;bottom:0}.force-background-area[_ngcontent-%COMP%]   .circle-background.special-sky[_ngcontent-%COMP%]{background:#0c3159!important}.force-background-area[_ngcontent-%COMP%]   .circle-background.special-emerald[_ngcontent-%COMP%]{background:#123843!important}.force-background-area[_ngcontent-%COMP%]   .circle-background.special-purple-galaxy[_ngcontent-%COMP%]{background:#151d46!important}  .special-punching-die.special-sky pp-poster-stars-area canvas{background:#0c3159}  .special-punching-die.special-sky .stars-svg svg{background:#0c3159}  .special-punching-die.special-emerald pp-poster-stars-area canvas{background:#123843}  .special-punching-die.special-emerald .stars-svg svg{background:#123843}  .special-punching-die.special-purple-galaxy pp-poster-stars-area canvas{background:#151d46}  .special-punching-die.special-purple-galaxy .stars-svg svg{background:#151d46}  .special-punching-die.special-heart canvas,   .special-punching-die.special-heart svg{-webkit-mask:url(#heartClipPath);mask:url(#heartClipPath)}  .special-punching-die.special-circle canvas,   .special-punching-die.special-circle svg{-webkit-mask:url(#circleClipPath);mask:url(#circleClipPath)}  .special-punching-die.special-photo img{-webkit-mask:url(#photoClipPath);mask:url(#photoClipPath)}"]
            }),
            we
        }
        )()
    }
    ,
    71121: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            J: () => ze
        });
        var Ut = $(10467)
          , r = $(54438)
          , Mt = $(9566)
          , s = $(60177)
          , so = $(27617)
          , Wt = $(78606)
          , _t = $(50552)
          , Ae = $(96354)
          , Me = $(54843)
          , ct = $(7430)
          , Tt = $(76675)
          , Qe = $(41046)
          , jt = $(21626)
          , Xe = $(345);
        const Ce = ye => ({
            fill: "none",
            stroke: ye
        })
          , it = ye => ({
            fill: ye,
            stroke: "transparent"
        });
        function et(ye, ge) {
            if (1 & ye && r.nrm(0, "div", 9),
            2 & ye) {
                const Ie = r.XpG(2);
                r.xc7("color", Ie.lineArtJewelry.color),
                r.Y8G("innerHTML", Ie.lineArtJewelry.exampleInformation, r.npT)
            }
        }
        function re(ye, ge) {
            if (1 & ye && r.DNE(0, et, 1, 3, "div", 8),
            2 & ye) {
                const Ie = r.XpG();
                r.Y8G("ngIf", Ie.lineArtJewelry.exampleInformation)
            }
        }
        function pt(ye, ge) {
            1 & ye && r.nrm(0, "pp-poster-loaded-element")
        }
        let ze = ( () => {
            var ye;
            class ge extends _t.C {
                constructor(gt, Ye, yt, ht, mo) {
                    super(gt, Ye),
                    this.host = gt,
                    this.zone = Ye,
                    this.httpClient = yt,
                    this.cdr = ht,
                    this.domSanitizer = mo,
                    this.hideSwitchers = !1,
                    this.showFrontOnInit = !0,
                    this.showAvers = new r.bkB(!1),
                    this.lineArtJewelry = {
                        textURL: "",
                        titleFontSize: "1px",
                        material: so.Xl7.na,
                        color: "transparent",
                        graphic: so.UzR.ANNIVERSARY,
                        setup: so.Hyl.charm,
                        imageURL: "",
                        exampleInformation: "",
                        showExampleInformation: !0
                    }
                }
                setJewelry(gt, Ye) {
                    var yt = this;
                    return (0,
                    Ut.A)(function*() {
                        var ht, no;
                        yt.lineArtJewelry.textURL = null !== (ht = yield yt.httpClient.post("".concat(window.location.origin, "/api/line-art/jewelry/text"), {
                            title: Ye.customMessage ? Ye.title : "",
                            titleFontScript: Ye.titleFontScript,
                            footer: Ye.customMessage ? Ye.footer : ""
                        }).pipe((0,
                        Ae.T)(no => (0,
                        Tt.ID)("image/svg+xml", no.image))).toPromise()) && void 0 !== ht ? ht : "",
                        yt.lineArtJewelry.material = Ye.material,
                        yt.lineArtJewelry.color = Tt.fd[Ye.material],
                        yt.lineArtJewelry.graphic = Ye.graphic,
                        yt.lineArtJewelry.setup = Ye.setup,
                        yt.lineArtJewelry.imageURL = Ye.isSelectedIllustration ? yield(0,
                        Me._)(yt.httpClient.get((no = Ye.illustrationUuid,
                        "".concat(window.location.origin, "/api/files-management/").concat(no, "/").concat(so.Iwg.primary, "?editor=").concat(so.hb4.lineArt))).pipe((0,
                        Ae.T)(no => (0,
                        Tt.ID)("image/svg+xml", no.image)))) : "/assets/pp-posters/line-art/".concat(so.WTf.MINIMAL, "/").concat(yt.lineArtJewelry.graphic, ".svg"),
                        yt.lineArtJewelry.showExampleInformation = !Ye.isSelectedIllustration,
                        yt.lineArtJewelry.exampleInformation = yt.isFinalPoster ? "" : Ye.exampleMessage,
                        yt.onImageLoad()
                    })()
                }
                setAllTextSettings(gt, Ye) {}
                setDesign(gt, Ye, yt) {
                    return Promise.resolve(void 0)
                }
                setTextArea(gt, Ye) {}
                ngAfterViewInit() {}
                onImageLoad() {
                    this.load++,
                    1 === this.load && (this.initiateRender(),
                    this.cdr.detectChanges())
                }
            }
            return (ye = ge).\u0275fac = function(gt) {
                return new (gt || ye)(r.rXU(r.aKT),r.rXU(r.SKi),r.rXU(jt.Qq),r.rXU(r.gRc),r.rXU(Xe.up))
            }
            ,
            ye.\u0275cmp = r.VBU({
                type: ye,
                selectors: [["pp-jewelry-line-art"]],
                inputs: {
                    hideSwitchers: "hideSwitchers",
                    showFrontOnInit: "showFrontOnInit"
                },
                outputs: {
                    showAvers: "showAvers"
                },
                features: [r.Vt3],
                decls: 10,
                vars: 18,
                consts: [[3, "background"], [3, "showAvers", "material", "setup", "hideSwitchers", "showFront"], ["slot", "front"], [3, "src", "svgStyle"], [1, "example-information", 3, "innerHTML", "color"], ["slot", "back"], [1, "back-center"], [4, "ngIf"], ["class", "example-information", 3, "innerHTML", "color", 4, "ngIf"], [1, "example-information", 3, "innerHTML"]],
                template: function(gt, Ye) {
                    1 & gt && (r.j41(0, "pp-poster-background", 0)(1, "pp-poster-jewelry-area", 1),
                    r.bIt("showAvers", function(ht) {
                        return Ye.showAvers.emit(ht)
                    }),
                    r.j41(2, "div", 2)(3, "div"),
                    r.nrm(4, "svg-icon", 3),
                    r.DNE(5, re, 1, 1, "div", 4),
                    r.k0s()(),
                    r.j41(6, "div", 5)(7, "div", 6),
                    r.nrm(8, "svg-icon", 3),
                    r.k0s()()()(),
                    r.DNE(9, pt, 1, 0, "pp-poster-loaded-element", 7)),
                    2 & gt && (r.Y8G("background", "transparent"),
                    r.R7$(),
                    r.Y8G("material", Ye.lineArtJewelry.material)("setup", Ye.lineArtJewelry.setup)("hideSwitchers", Ye.hideSwitchers)("showFront", Ye.showFrontOnInit),
                    r.R7$(2),
                    r.ZvI("front-center front-center-", Ye.lineArtJewelry.setup, ""),
                    r.R7$(),
                    r.Y8G("src", Ye.lineArtJewelry.imageURL)("svgStyle", r.eq3(14, Ce, Ye.lineArtJewelry.color)),
                    r.R7$(),
                    r.vxM(Ye.lineArtJewelry.showExampleInformation ? 5 : -1),
                    r.R7$(3),
                    r.Y8G("src", Ye.lineArtJewelry.textURL)("svgStyle", r.eq3(16, it, Ye.lineArtJewelry.color)),
                    r.R7$(),
                    r.Y8G("ngIf", Ye.isImageRendered))
                },
                dependencies: [s.MD, s.bT, Mt.R, Wt.iu, Wt.DM, ct.R, Qe.C],
                styles: ["[_nghost-%COMP%]{width:100%;height:100%;display:block}[_nghost-%COMP%]   .front-center[_ngcontent-%COMP%], [_nghost-%COMP%]   .back-center[_ngcontent-%COMP%]{aspect-ratio:1/1;position:absolute;top:0;left:0}[_nghost-%COMP%]   .front-center-charm[_ngcontent-%COMP%]{width:52%!important;height:73%!important;margin-left:24.9%!important;margin-top:22.2%!important}[_nghost-%COMP%]   .front-center-charm-with-chain[_ngcontent-%COMP%]{width:46.3%!important;margin-left:28.6%!important;margin-top:29.9%!important}[_nghost-%COMP%]   .front-center-black-cord-bracelet[_ngcontent-%COMP%], [_nghost-%COMP%]   .front-center-silver-bracelet[_ngcontent-%COMP%]{width:41.4%!important;margin-left:30.9%!important;margin-top:25.1%!important}"]
            }),
            ge
        }
        )()
    }
    ,
    71683: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            L: () => Xt
        });
        var Ut = $(10467)
          , r = $(54438)
          , Mt = $(7494)
          , s = $(9566)
          , so = $(13620)
          , Wt = $(69847)
          , _t = $(60177)
          , Ae = $(27617)
          , Me = $(78606)
          , ct = $(84412)
          , Tt = $(84572)
          , Qe = $(56977)
          , jt = $(54843)
          , Xe = $(70152)
          , Ce = $(16968)
          , it = $(7335)
          , et = $(2745)
          , re = $(57493)
          , pt = $(67376)
          , ze = $(41046)
          , ye = $(49427)
          , ge = $(73955)
          , Ie = $(66985)
          , gt = $(21626)
          , Ye = $(345);
        const yt = ["mapWrapper"]
          , ht = (ie, we, Oe, ee, W) => ({
            title$: ie,
            subtitle$: we,
            map: Oe,
            photo$: ee,
            splitSize: W,
            mapIndex: 0
        })
          , mo = (ie, we, Oe, ee, W) => ({
            title$: ie,
            subtitle$: we,
            map: Oe,
            photo$: ee,
            splitSize: W,
            mapIndex: 1
        })
          , no = (ie, we, Oe, ee, W) => ({
            title$: ie,
            subtitle$: we,
            map: Oe,
            splitSize: ee,
            photo$: W,
            mapIndex: 2
        })
          , Co = (ie, we) => [ie, we]
          , Lt = (ie, we, Oe, ee, W) => [ie, we, Oe, ee, W]
          , Ft = () => [".jpeg", ".jpg", ".png", ".heic"];
        function co(ie, we) {
            if (1 & ie) {
                const Oe = r.RV6();
                r.j41(0, "button", 10),
                r.bIt("click", function() {
                    r.eBV(Oe);
                    const W = r.XpG(2);
                    return r.Njj(W.switchMapLock())
                }),
                r.nrm(1, "svg-icon", 11),
                r.k0s()
            }
            if (2 & ie) {
                const Oe = r.XpG(2);
                r.R7$(),
                r.Y8G("src", "/assets/pp-posters/maps/icons/padlock-" + (Oe.isLocked ? "closed" : "open") + ".svg")
            }
        }
        function Jt(ie, we) {
            if (1 & ie && (r.j41(0, "pp-poster-space-splitter", 13),
            r.eu8(1, 14)(2, 15)(3, 16),
            r.k0s()),
            2 & ie) {
                const Oe = r.XpG().ngIf
                  , ee = r.XpG(2)
                  , W = r.sdS(5);
                r.xc7("width", Oe.width, "px")("height", Oe.height, "px")("margin-top", Oe.marginTop, "px"),
                r.Y8G("isTriple", !0),
                r.R7$(),
                r.Y8G("ngTemplateOutlet", W)("ngTemplateOutletContext", r.s1E(13, ht, ee.title1$, ee.subtitle1$, ee.map1, ee.photo1$, Oe)),
                r.R7$(),
                r.Y8G("ngTemplateOutlet", W)("ngTemplateOutletContext", r.s1E(19, mo, ee.title2$, ee.subtitle2$, ee.map2, ee.photo2$, Oe)),
                r.R7$(),
                r.Y8G("ngTemplateOutlet", W)("ngTemplateOutletContext", r.s1E(25, no, ee.title3$, ee.subtitle3$, ee.map3, Oe, ee.photo3$))
            }
        }
        function po(ie, we) {
            if (1 & ie && (r.qex(0),
            r.DNE(1, Jt, 4, 31, "pp-poster-space-splitter", 12),
            r.bVm()),
            2 & ie) {
                const Oe = we.ngIf;
                r.R7$(),
                r.Y8G("ngIf", Oe.width && Oe.height)
            }
        }
        function Et(ie, we) {
            if (1 & ie && (r.j41(0, "pp-poster-printing-registration", 6)(1, "pp-poster-arrangement-wrapper", 7),
            r.DNE(2, co, 2, 1, "button", 8),
            r.nrm(3, "pp-poster-text-area", 9),
            r.nI1(4, "async"),
            r.nI1(5, "async"),
            r.nI1(6, "async"),
            r.nI1(7, "async"),
            r.DNE(8, po, 2, 1, "ng-container", 5),
            r.nI1(9, "async"),
            r.k0s()()),
            2 & ie) {
                const Oe = we.ngIf
                  , ee = r.XpG();
                r.Y8G("poster", Oe)("withPassepartout", ee.map1.passepartoutSize > 0),
                r.R7$(),
                r.Y8G("internalBorderColor", ee.map1.background),
                r.R7$(),
                r.vxM(ee.isMobile ? 2 : -1),
                r.R7$(),
                r.Y8G("poster", r.bMT(4, 9, ee.poster$))("color", r.bMT(5, 11, ee.textColor$))("textArea", r.bMT(6, 13, ee.topTextArea$))("title", r.bMT(7, 15, ee.title$)),
                r.R7$(5),
                r.Y8G("ngIf", r.bMT(9, 17, ee.splitElementsSize$))
            }
        }
        function Kt(ie, we) {
            if (1 & ie && r.nrm(0, "div", 24),
            2 & ie) {
                const Oe = r.XpG(3).map;
                r.xc7("left", Oe.markerPrint.left, "%")("top", Oe.markerPrint.top, "%")("height", Oe.markerPrint.height, "%")("width", Oe.markerPrint.width, "%"),
                r.Y8G("innerHTML", Oe.markerPrint.html, r.npT)
            }
        }
        function At(ie, we) {
            if (1 & ie) {
                const Oe = r.RV6();
                r.j41(0, "img", 22),
                r.bIt("load", function() {
                    r.eBV(Oe);
                    const W = r.XpG(3);
                    return r.Njj(W.onImageLoad())
                }),
                r.k0s(),
                r.DNE(1, Kt, 1, 9, "div", 23)
            }
            if (2 & ie) {
                const Oe = r.XpG(2)
                  , ee = Oe.splitSize
                  , W = Oe.map;
                r.xc7("width", ee.width / 3, "px")("height", ee.width / 3, "px"),
                r.Y8G("src", W.image, r.B4B),
                r.R7$(),
                r.Y8G("ngIf", W.showMarker)
            }
        }
        function Re(ie, we) {
            if (1 & ie) {
                const Oe = r.RV6();
                r.j41(0, "pp-poster-map-wrapper", 25, 2),
                r.bIt("updateMapConfig", function(W) {
                    r.eBV(Oe);
                    const ae = r.XpG(2).mapIndex
                      , Ve = r.XpG();
                    return r.Njj(Ve.updateMapConfig(W, ae))
                })("updateMarkerConfig", function(W) {
                    r.eBV(Oe);
                    const ae = r.XpG(2).mapIndex
                      , Ve = r.XpG();
                    return r.Njj(Ve.updateMarkerConfig(W, ae))
                }),
                r.k0s()
            }
            if (2 & ie) {
                const Oe = r.XpG(2)
                  , ee = Oe.mapIndex
                  , W = Oe.map
                  , ae = r.XpG();
                r.Aen(W.style),
                r.Y8G("mapsEndpoint", ae.mapsEndpoint)("mapboxAccessToken", ae.mapboxAccessToken)("mode", 3)("idx", ee)("isLocked", ae.isLocked)("hideNativeLock", !0)("viewPort", W.viewPort)("zoom", W.zoom)("markerByWidth", W.markerByWidth)("isInteractive", ae.isInteractive)("isActiveMap", ae.isInteractive)("isMobile", ae.isMobile)("land", W.customColor.land)("water", W.customColor.water)("roads", W.customColor.roads)("showMarker", W.showMarker)("markerType", W.markerType)("markerColor", W.markerColor)("markerPosition", W.markerPosition)
            }
        }
        function ve(ie, we) {
            if (1 & ie && r.DNE(0, At, 2, 6)(1, Re, 2, 21, "pp-poster-map-wrapper", 21),
            2 & ie) {
                const Oe = r.XpG().map
                  , ee = r.XpG();
                r.vxM(ee.useImageMap ? 0 : Oe.style ? 1 : -1)
            }
        }
        function ne(ie, we) {}
        function B(ie, we) {
            if (1 & ie && r.nrm(0, "svg-icon", 11),
            2 & ie) {
                const Oe = r.XpG(2).map;
                r.xc7("--border-color", Oe.layoutBorderColor),
                r.Y8G("src", "/assets/pp-posters/maps/shape/shape-" + Oe.layout + ".svg")
            }
        }
        function de(ie, we) {
            if (1 & ie && r.nrm(0, "svg-icon", 11),
            2 & ie) {
                const Oe = r.XpG(2).map
                  , ee = r.XpG();
                r.xc7("--border-color", Oe.layoutBorderColor),
                r.Y8G("src", "/assets/pp-posters/maps/shape/shape-" + Oe.layout + (Oe.shape === ee.MapsLayoutsEnum.CIRCLE_HEART_HOUSE ? "_3" : "") + ".svg")
            }
        }
        function lt(ie, we) {
            if (1 & ie && r.nrm(0, "svg-icon", 11),
            2 & ie) {
                const Oe = r.XpG(2).map
                  , ee = r.XpG();
                r.xc7("--border-color", Oe.layoutBorderColor),
                r.Y8G("src", "/assets/pp-posters/maps/shape/shape-" + Oe.layout + (Oe.shape === ee.MapsLayoutsEnum.CIRCLE_HEART_HOUSE ? "_3" : "") + ".svg")
            }
        }
        function St(ie, we) {
            if (1 & ie && r.nrm(0, "svg-icon", 11),
            2 & ie) {
                const Oe = r.XpG(2).map
                  , ee = r.XpG();
                r.xc7("--border-color", Oe.layoutBorderColor),
                r.Y8G("src", "/assets/pp-posters/maps/shape/shape-" + Oe.layout + (Oe.shape === ee.MapsLayoutsEnum.CIRCLE_HEART_HOUSE ? "_3" : "") + ".svg")
            }
        }
        function tt(ie, we) {
            if (1 & ie && r.nrm(0, "svg-icon", 11),
            2 & ie) {
                const Oe = r.XpG(2).map;
                r.xc7("--border-color", Oe.layoutBorderColor),
                r.Y8G("src", "/assets/pp-posters/maps/shape/shape-" + Oe.layout + ".svg")
            }
        }
        function $t(ie, we) {
            if (1 & ie && (r.j41(0, "div", 26)(1, "div", 27)(2, "div", 28),
            r.DNE(3, B, 1, 3, "svg-icon", 29)(4, de, 1, 3, "svg-icon", 29)(5, lt, 1, 3, "svg-icon", 29)(6, St, 1, 3, "svg-icon", 29)(7, tt, 1, 3, "svg-icon", 29),
            r.k0s()(),
            r.nrm(8, "div", 30),
            r.k0s(),
            r.nrm(9, "div", 31)),
            2 & ie) {
                const Oe = r.XpG()
                  , ee = Oe.splitSize
                  , W = Oe.map
                  , ae = r.XpG();
                r.xc7("width", ee.width / 3, "px")("height", ee.width / 3, "px"),
                r.R7$(2),
                r.xc7("width", ee.width / 3, "px")("height", ee.width / 3, "px"),
                r.R7$(),
                r.Y8G("ngIf", W.layout === ae.MapsLayoutsEnum.SQUARE),
                r.R7$(),
                r.Y8G("ngIf", W.layout === ae.MapsLayoutsEnum.HEART),
                r.R7$(),
                r.Y8G("ngIf", W.layout === ae.MapsLayoutsEnum.CIRCLE),
                r.R7$(),
                r.Y8G("ngIf", W.layout === ae.MapsLayoutsEnum.HOUSE),
                r.R7$(),
                r.Y8G("ngIf", W.layout === ae.MapsLayoutsEnum.PUZZLE + "A" || W.layout === ae.MapsLayoutsEnum.PUZZLE + "B" || W.layout === ae.MapsLayoutsEnum.PUZZLE + "C"),
                r.R7$(2),
                r.xc7("border-color", ae.map1.background)("width", ae.mathCeil(ee.width / 3 + ee.width / 3 * .01), "px")("height", ae.mathCeil(ee.width / 3 + ee.width / 3 * .01), "px")("border-width", ae.mathCeil(ee.width / 3 * .01), "px")("margin-left", -ae.mathCeil(ee.width / 3 * .005), "px")("margin-top", -ae.mathCeil(ee.width / 3 * .005), "px")
            }
        }
        function Nt(ie, we) {
            if (1 & ie) {
                const Oe = r.RV6();
                r.j41(0, "img", 36),
                r.bIt("load", function() {
                    r.eBV(Oe);
                    const W = r.XpG(4);
                    return r.Njj(W.onImageLoad())
                })("click", function() {
                    r.eBV(Oe);
                    const W = r.XpG(4);
                    return r.Njj(W.onPhotoSelect())
                }),
                r.k0s()
            }
            if (2 & ie) {
                const Oe = r.XpG().ngIf;
                r.XpG();
                const ee = r.r8f(1)
                  , W = r.r8f(2)
                  , ae = r.r8f(3)
                  , Ve = r.XpG(2);
                r.Y8G("src", Ve.getPhotoWithType(Oe).imageUrl, r.B4B),
                r.BMQ("transform", "translate(" + W + ", " + ae + ") scale(" + ee + "," + ee + ")")
            }
        }
        function Vt(ie, we) {
            if (1 & ie) {
                const Oe = r.RV6();
                r.j41(0, "pp-controls-file-uploader-photo", 37),
                r.nI1(1, "translate"),
                r.bIt("setFileUploadingProgress", function(W) {
                    r.eBV(Oe);
                    const ae = r.XpG(4);
                    return r.Njj(ae.setFileUpploadingProgress.emit(W))
                }),
                r.k0s()
            }
            if (2 & ie) {
                const Oe = r.XpG(4);
                r.Y8G("photoFileGroup", Oe.photoFileGroup)("photoCropGroup", Oe.photoCropGroup)("photoId", Oe.photoId)("multiFile", Oe.multiFile)("isSubmitted", !1)("acceptable", r.lJ4(14, Ft))("isBase64Response", !0)("fullHeight", !0)("isBigPictureMode", !0)("withBackgroundGray", !0)("isFileUploadingInProgress", Oe.isFileUploadingInProgress)("legalNote", r.bMT(1, 12, "soundwave.details.instruction"))
            }
        }
        function _o(ie, we) {
            if (1 & ie && (r.j41(0, "div", 33),
            r.DNE(1, Nt, 1, 2, "img", 34)(2, Vt, 2, 15, "pp-controls-file-uploader-photo", 35),
            r.k0s()),
            2 & ie) {
                const Oe = we.ngIf
                  , ee = r.XpG(2).splitSize
                  , W = r.XpG();
                r.xc7("width", ee.width / 3, "px")("height", ee.width / 3, "px")("margin-top", Oe.isHeart ? ee.width / 3 * -.08 : 0, "px"),
                r.AVh("special-circle", !Oe.isHeart)("special-heart", Oe.isHeart),
                r.R7$(),
                r.Y8G("ngIf", !W.getPhotoWithType(Oe).showAddPhoto),
                r.R7$(),
                r.Y8G("ngIf", W.photoFileGroup && W.getPhotoWithType(Oe).showAddPhoto)
            }
        }
        function Lo(ie, we) {
            if (1 & ie && (r.SS7(0)(1)(2)(3),
            r.DNE(4, _o, 3, 12, "div", 32),
            r.nI1(5, "async")),
            2 & ie) {
                const Oe = r.XpG()
                  , ee = Oe.splitSize
                  , W = Oe.photo$
                  , ae = ee.width / 3 * 1.1;
                r.R7$(),
                r.bH3(ae / 1777),
                r.R7$(),
                r.bH3((ee.width / 3 - ae) / 2),
                r.R7$(),
                r.bH3(-ee.width / 3 * .11),
                r.R7$(),
                r.Y8G("ngIf", r.bMT(5, 4, W))
            }
        }
        function ao(ie, we) {
            if (1 & ie && (r.j41(0, "div", 17),
            r.DNE(1, ve, 2, 1)(2, ne, 0, 0),
            r.nrm(3, "pp-poster-preview", 18),
            r.k0s(),
            r.DNE(4, $t, 10, 25)(5, Lo, 6, 6, "div", 19),
            r.nrm(6, "pp-poster-text-area", 20),
            r.nI1(7, "async"),
            r.nI1(8, "async"),
            r.nI1(9, "async"),
            r.nI1(10, "async"),
            r.nI1(11, "async")),
            2 & ie) {
                const Oe = we.mapIndex
                  , ee = we.splitSize
                  , W = we.map
                  , ae = we.title$
                  , Ve = we.subtitle$
                  , fe = r.XpG();
                r.xc7("width", ee.width / 3, "px")("height", ee.width / 3, "px"),
                r.R7$(),
                r.vxM(!r.l_i(26, Co, fe.MapsLayoutsEnum.CIRCLE_PHOTO_CIRCLE, fe.MapsLayoutsEnum.CIRCLE_PHOTO_HEART_CIRCLE).includes(W.layout) || r.l_i(29, Co, fe.MapsLayoutsEnum.CIRCLE_PHOTO_CIRCLE, fe.MapsLayoutsEnum.CIRCLE_PHOTO_HEART_CIRCLE).includes(W.layout) && 1 !== Oe ? 1 : 2),
                r.R7$(2),
                r.Y8G("showPreview", !fe.isFinalPoster)("marginTop", !1)("maxWidth", 45)("previewType", r.s1E(32, Lt, fe.MapsStyleEnum.BLACK, fe.MapsStyleEnum.CARBON, fe.MapsStyleEnum.INTENSE, fe.MapsStyleEnum.WANDERLUST, fe.MapsStyleEnum.COSY).includes(W.style) ? "map-reverse" : "map"),
                r.R7$(),
                r.vxM(!r.l_i(38, Co, fe.MapsLayoutsEnum.CIRCLE_PHOTO_CIRCLE, fe.MapsLayoutsEnum.CIRCLE_PHOTO_HEART_CIRCLE).includes(W.layout) || r.l_i(41, Co, fe.MapsLayoutsEnum.CIRCLE_PHOTO_CIRCLE, fe.MapsLayoutsEnum.CIRCLE_PHOTO_HEART_CIRCLE).includes(W.layout) && 1 !== Oe ? 4 : 5),
                r.R7$(2),
                r.Y8G("poster", r.bMT(7, 16, fe.poster$))("color", r.bMT(8, 18, fe.textColor$))("textArea", r.bMT(9, 20, fe.textArea$))("title", r.bMT(10, 22, ae))("subtitle", r.bMT(11, 24, Ve))("background", W.textBackground)
            }
        }
        function bt(ie, we) {
            1 & ie && r.nrm(0, "pp-poster-loaded-element")
        }
        function Do(ie, we) {
            if (1 & ie && (r.SS7(0)(1),
            r.qSk(),
            r.j41(2, "svg", 38)(3, "defs")(4, "mask", 39),
            r.nrm(5, "circle", 40),
            r.k0s()()(),
            r.SS7(6)(7),
            r.j41(8, "svg", 41)(9, "defs")(10, "mask", 42),
            r.nrm(11, "path", 43),
            r.k0s()()()),
            2 & ie) {
                const Oe = we
                  , ee = Oe.width / 3 / 2
                  , W = .99 * ee;
                r.R7$(2),
                r.BMQ("width", ee)("height", ee),
                r.R7$(3),
                r.BMQ("cx", ee)("cy", ee)("r", W);
                const ae = Oe.width / 3
                  , Ve = ae / 1777;
                r.R7$(3),
                r.BMQ("width", ae)("height", ae)("viewBox", "0 0 1777 1777"),
                r.R7$(3),
                r.BMQ("transform", "scale(" + Ve + "," + Ve + ")")
            }
        }
        let Xt = ( () => {
            var ie;
            class we extends re.d {
                constructor(ee, W, ae, Ve, fe, Pt) {
                    super(ee, W, ae, Ve, fe, Pt),
                    this.host = ee,
                    this.zone = W,
                    this.httpClient = ae,
                    this.domSanitizer = Ve,
                    this.cdr = fe,
                    this.renderer2 = Pt,
                    this.mapWrapper = Ce.f,
                    this.photoId = 0,
                    this.multiFile = !1,
                    this.isFileUploadingInProgress = !1,
                    this.setFileUpploadingProgress = new r.bkB,
                    this.photoSelect = new r.bkB,
                    this.map1 = (0,
                    pt.cloneDeep)(re.G),
                    this.map2 = (0,
                    pt.cloneDeep)(re.G),
                    this.map3 = (0,
                    pt.cloneDeep)(re.G),
                    this.isLocked = !0,
                    this.photo1$ = new ct.t(null),
                    this.photo2$ = new ct.t(null),
                    this.photo3$ = new ct.t(null),
                    this.title1$ = new ct.t(null),
                    this.title2$ = new ct.t(null),
                    this.title3$ = new ct.t(null),
                    this.subtitle1$ = new ct.t(null),
                    this.subtitle2$ = new ct.t(null),
                    this.subtitle3$ = new ct.t(null),
                    this.splitElementsSize$ = new ct.t({
                        width: 0,
                        height: 0,
                        marginTop: 0
                    }),
                    this.MapsStyleEnum = Ae.c_T
                }
                ngAfterViewInit() {
                    (0,
                    Tt.z)([this.poster$, this.topTextArea$, this.posterConfiguration$]).pipe((0,
                    Qe.Q)(this.ngUnsubscribe), (0,
                    Xe.B)(100)).subscribe( ([ee,W,ae]) => {
                        var Ve, fe, Pt, mt, xo;
                        if (!ae || !ee)
                            return;
                        const So = null !== (Ve = ee.size.height) && void 0 !== Ve ? Ve : 0;
                        let ro = .13 * So;
                        ae.mainTextEnable && ae.title && (ro = .26 * So);
                        const Vo = .9 * ee.size.width;
                        this.imageInstanceSize = {
                            width: null !== (fe = null === (Pt = this.mapWrapper) || void 0 === Pt || null === (Pt = Pt.elementRef) || void 0 === Pt || null === (Pt = Pt.nativeElement) || void 0 === Pt ? void 0 : Pt.offsetWidth) && void 0 !== fe ? fe : 0,
                            height: null !== (mt = null === (xo = this.mapWrapper) || void 0 === xo || null === (xo = xo.elementRef) || void 0 === xo || null === (xo = xo.nativeElement) || void 0 === xo ? void 0 : xo.offsetHeight) && void 0 !== mt ? mt : 0
                        },
                        this.splitElementsSize$.next({
                            width: Vo,
                            height: So - ro,
                            marginTop: ro
                        })
                    }
                    )
                }
                setAllTextSettings(ee) {
                    const W = ee.mapConfig[0]
                      , ae = ee.mapConfig[1]
                      , Ve = ee.mapConfig[2]
                      , fe = {
                        text: ee.mainTextEnable ? ee.title : "",
                        isDefaultFont: !ee.titleFont
                    };
                    this.setText(fe, this.title$, {
                        font: null != fe && fe.isDefaultFont ? Ae.n3q.POSITIVE_PRINTS_SCRIPT_2 : Ae.n3q.LUXUS_BRUT,
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: .08,
                            bottomFactor: 0,
                            lineHeightFactor: .1,
                            topFactor: .015,
                            isBold: !1
                        }
                    });
                    const mt = {
                        text: W.title,
                        isDefaultFont: !W.titleFont,
                        showEmptyLine: !0
                    }
                      , xo = {
                        text: ae.title,
                        isDefaultFont: !ae.titleFont,
                        showEmptyLine: !0
                    }
                      , So = {
                        text: Ve.title,
                        isDefaultFont: !Ve.titleFont,
                        showEmptyLine: !0
                    }
                      , ro = ji => {
                        const yn = null != ji && ji.isDefaultFont ? .054 : .058;
                        return {
                            font: null != ji && ji.isDefaultFont ? Ae.n3q.POSITIVE_PRINTS_SCRIPT_2 : Ae.n3q.LUXUS_BRUT,
                            portrait: {
                                sizeFactor: 0,
                                bottomFactor: 0,
                                topFactor: 0
                            },
                            horizontal: {
                                sizeFactor: yn,
                                bottomFactor: .072,
                                lineHeightFactor: 1.34 * yn,
                                topFactor: 0,
                                isBold: !1,
                                fixedPosition: !0
                            }
                        }
                    }
                    ;
                    this.setText(mt, this.title1$, ro(mt)),
                    this.setText(xo, this.title2$, ro(xo)),
                    this.setText(So, this.title3$, ro(So));
                    const ei = {
                        text: ee.shape === Ae.U9G.CIRCLE_PHOTO_HEART_CIRCLE || ee.shape === Ae.U9G.CIRCLE_PHOTO_CIRCLE ? ae.photoSubtitle : ae.subtitle,
                        isDefaultFont: !0,
                        showEmptyLine: !0
                    }
                      , Ti = {
                        text: Ve.subtitle,
                        isDefaultFont: !0,
                        showEmptyLine: !0
                    }
                      , ci = ji => {
                        const yn = ee.mainTextEnable ? .025 : .029;
                        return {
                            font: Ae.n3q.CAPSUULA,
                            portrait: {
                                sizeFactor: 0,
                                bottomFactor: 0,
                                topFactor: 0
                            },
                            horizontal: {
                                sizeFactor: yn,
                                bottomFactor: 0,
                                lineHeightFactor: yn,
                                topFactor: 0,
                                isBold: !1
                            }
                        }
                    }
                    ;
                    this.setText({
                        text: W.subtitle,
                        isDefaultFont: !0,
                        showEmptyLine: !0
                    }, this.subtitle1$, ci()),
                    this.setText(ei, this.subtitle2$, ci()),
                    this.setText(Ti, this.subtitle3$, ci())
                }
                setTextArea(ee, W) {
                    this.topTextArea$.next({
                        topFactor: this.isWideRatio(ee, !1) ? .04 : .07,
                        marginFactor: .09,
                        fixedHeightFactor: .21,
                        isFlex: !0,
                        isJustifyCenter: !W.title.includes("\n")
                    });
                    let ae = .16;
                    W.mainTextEnable && W.title && (ae = .096),
                    this.textArea$.next({
                        bottomFactor: ae,
                        marginFactor: .013
                    })
                }
                setDesign(ee, W) {
                    var ae = this;
                    return (0,
                    Ut.A)(function*() {
                        const Ve = function() {
                            var fe = (0,
                            Ut.A)(function*(Pt, mt, xo, So) {
                                var ro, Vo, vo;
                                if (Pt.viewPort = [[W.mapConfig[mt].place.viewPort.west, W.mapConfig[mt].place.viewPort.south], [W.mapConfig[mt].place.viewPort.east, W.mapConfig[mt].place.viewPort.north]],
                                Pt.zoom = W.mapConfig[mt].zoom,
                                Pt.style = ae.getColorScheme(W.colorScheme, mt),
                                Pt.customColor = W.customColors,
                                Pt.background = ae.getBackground(W.colorScheme, W.customColors),
                                Pt.textBackground = ae.getBackground(W.colorScheme, W.customColors),
                                ae.textColor$.next(ae.getText(W.colorScheme, W.customColors)),
                                ae.renderer2.setProperty(ae.host.nativeElement, "style", "--punching-die-color: ".concat(Pt.background)),
                                Pt.shape = W.shape,
                                Pt.layout = ae.getMapLayout(W.shape, mt),
                                Pt.layoutBorderColor = ae.getBorderColor(Pt.style, Pt.customColor, !1),
                                Pt.showMarker = !!W.mapConfig[mt].place.formattedAddress && W.mapConfig[mt].showMarker,
                                Pt.markerPosition = W.mapConfig[mt].markerSelectByGPS ? [W.mapConfig[mt].markerLngGPS, W.mapConfig[mt].markerLatGPS] : null !== (ro = W.mapConfig[mt].markerPlace) && void 0 !== ro && ro.center ? [W.mapConfig[mt].markerPlace.center.longitude, W.mapConfig[mt].markerPlace.center.latitude] : [0, 0],
                                Pt.markerType = W.mapConfig[mt].markerType,
                                Pt.markerColor = W.mapConfig[mt].markerColor,
                                xo.next({
                                    isPhoto: So,
                                    isHeart: W.shape === Ae.U9G.CIRCLE_PHOTO_HEART_CIRCLE,
                                    uuid: W.mapConfig[mt].photoFiles[0].uuid,
                                    imageUrl: "".concat(ae.environmentPhotoApi, "/v2/").concat(ae.isFinalPoster ? "photo" : "image", "/").concat(W.mapConfig[mt].photoFiles[0].uuid, "?type=").concat(W.mapConfig[mt].cropsData[0].filter, "&left=").concat(W.mapConfig[mt].cropsData[0].cropData.x, "&top=").concat(W.mapConfig[mt].cropsData[0].cropData.y, "&width=").concat(W.mapConfig[mt].cropsData[0].cropData.width, "&height=").concat(W.mapConfig[mt].cropsData[0].cropData.height, "&rotate=").concat(W.mapConfig[mt].cropsData[0].rotate, "&flipped=").concat(W.mapConfig[mt].cropsData[0].flip),
                                    showAddPhoto: !W.mapConfig[mt].photoFiles[0].uuid
                                }),
                                ae.useImageMap && !ae.mapFileDownloaded.has(null !== (Vo = W.mapConfig[mt].uuid) && void 0 !== Vo ? Vo : ""))
                                    if (ae.mapFileDownloaded.add(null !== (vo = W.mapConfig[mt].uuid) && void 0 !== vo ? vo : ""),
                                    ae.isFinalPoster) {
                                        var ei;
                                        const ci = yield(0,
                                        jt._)(ae.httpClient.get("/api/map/image", {
                                            params: {
                                                uuid: null !== (ei = W.mapConfig[mt].uuid) && void 0 !== ei ? ei : ""
                                            },
                                            responseType: "blob"
                                        }));
                                        Pt.image = URL.createObjectURL(ci)
                                    } else {
                                        var Ti;
                                        const ci = yield(0,
                                        jt._)(ae.httpClient.get("/api/map/mapbox/png", {
                                            params: {
                                                uuid: null !== (Ti = W.mapConfig[mt].uuid) && void 0 !== Ti ? Ti : ""
                                            },
                                            responseType: "text"
                                        }));
                                        Pt.image = ci
                                    }
                                if (ae.useImageMap) {
                                    let ci = (0,
                                    it.H)(Pt.markerType);
                                    const ji = "#".concat(Pt.markerColor);
                                    ci = ci.replace("// ___marker_color___", "\n                <style>\n                  path.marker-fill {\n                    fill: ".concat(ji, ";\n                  }\n                  path.marker-stroke {\n                    stroke: ").concat(ji, ";\n                  }\n                </style>\n                ")),
                                    Pt.markerPrint = {
                                        html: ae.domSanitizer.bypassSecurityTrustHtml(ci),
                                        width: W.mapConfig[mt].markerSize.width / W.mapConfig[mt].map.width * 100,
                                        height: W.mapConfig[mt].markerSize.height / W.mapConfig[mt].map.height * 100,
                                        left: W.mapConfig[mt].markerLocation.x / W.mapConfig[mt].map.width * 100,
                                        top: W.mapConfig[mt].markerLocation.y / W.mapConfig[mt].map.height * 100
                                    }
                                }
                            });
                            return function(mt, xo, So, ro) {
                                return fe.apply(this, arguments)
                            }
                        }();
                        yield Ve(ae.map1, 0, ae.photo1$, !1),
                        yield Ve(ae.map2, 1, ae.photo2$, [Ae.U9G.CIRCLE_PHOTO_CIRCLE, Ae.U9G.CIRCLE_PHOTO_HEART_CIRCLE].includes(W.shape)),
                        yield Ve(ae.map3, 2, ae.photo3$, !1)
                    })()
                }
                switchMapLock() {
                    this.isLocked = !this.isLocked
                }
                getPhotoWithType(ee) {
                    return ee
                }
                onPhotoSelect() {
                    this.photoSelect.emit([this.imageInstanceSize.width, this.imageInstanceSize.height, 1])
                }
                onImageLoad() {
                    this.load++,
                    3 === this.load && (this.initiateRender(),
                    this.cdr.detectChanges())
                }
                getMapLayout(ee, W) {
                    return ee === Ae.U9G.PUZZLE ? "".concat(Ae.U9G.PUZZLE).concat(0 === W ? "A" : 1 === W ? "B" : "C") : ee === Ae.U9G.CIRCLE_HEART_HOUSE ? 0 === W ? Ae.U9G.CIRCLE : 1 === W ? Ae.U9G.HEART : Ae.U9G.HOUSE : ((ee === Ae.U9G.CIRCLE_PHOTO_HEART_CIRCLE || ee === Ae.U9G.CIRCLE_PHOTO_CIRCLE) && 1 !== W && (ee = Ae.U9G.CIRCLE),
                    ee)
                }
                getColorScheme(ee, W) {
                    return ee
                }
            }
            return (ie = we).\u0275fac = function(ee) {
                return new (ee || ie)(r.rXU(r.aKT),r.rXU(r.SKi),r.rXU(gt.Qq),r.rXU(Ye.up),r.rXU(r.gRc),r.rXU(r.sFG))
            }
            ,
            ie.\u0275cmp = r.VBU({
                type: ie,
                selectors: [["pp-poster-map-triple"]],
                viewQuery: function(ee, W) {
                    if (1 & ee && r.GBs(yt, 5),
                    2 & ee) {
                        let ae;
                        r.mGM(ae = r.lsd()) && (W.mapWrapper = ae.first)
                    }
                },
                inputs: {
                    photoFileGroup: "photoFileGroup",
                    photoCropGroup: "photoCropGroup",
                    photoId: "photoId",
                    multiFile: "multiFile",
                    cropperConfig: "cropperConfig",
                    environmentPhotoApi: "environmentPhotoApi",
                    isFileUploadingInProgress: "isFileUploadingInProgress"
                },
                outputs: {
                    setFileUpploadingProgress: "setFileUpploadingProgress",
                    photoSelect: "photoSelect"
                },
                features: [r.Vt3],
                decls: 9,
                vars: 8,
                consts: [["posterWrapper", ""], ["singleElement", ""], ["mapWrapper", ""], [3, "background"], [3, "poster", "withPassepartout", 4, "ngIf"], [4, "ngIf"], [3, "poster", "withPassepartout"], [3, "internalBorderColor"], [1, "padlock"], [3, "poster", "color", "textArea", "title"], [1, "padlock", 3, "click"], [3, "src"], [3, "isTriple", "width", "height", "marginTop", 4, "ngIf"], [3, "isTriple"], ["first", "", 3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["second", "", 3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["third", "", 3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "map-wrapper"], [3, "showPreview", "marginTop", "maxWidth", "previewType"], [1, "photo-instance", 3, "width", "height", "marginTop", "special-circle", "special-heart"], [3, "poster", "color", "textArea", "title", "subtitle", "background"], [3, "mapsEndpoint", "mapboxAccessToken", "mode", "idx", "isLocked", "hideNativeLock", "viewPort", "zoom", "style", "markerByWidth", "isInteractive", "isActiveMap", "isMobile", "land", "water", "roads", "showMarker", "markerType", "markerColor", "markerPosition"], [3, "load", "src"], ["class", "marker", 3, "left", "top", "height", "width", "innerHTML", 4, "ngIf"], [1, "marker", 3, "innerHTML"], [3, "updateMapConfig", "updateMarkerConfig", "mapsEndpoint", "mapboxAccessToken", "mode", "idx", "isLocked", "hideNativeLock", "viewPort", "zoom", "markerByWidth", "isInteractive", "isActiveMap", "isMobile", "land", "water", "roads", "showMarker", "markerType", "markerColor", "markerPosition"], [1, "layout-wrapper"], [1, "cover"], [1, "svg-cover"], [3, "--border-color", "src", 4, "ngIf"], [1, "cover-area"], [1, "layout-wrapper-border"], ["class", "photo-instance", 3, "width", "height", "marginTop", "special-circle", "special-heart", 4, "ngIf"], [1, "photo-instance"], [3, "src", "load", "click", 4, "ngIf"], [3, "photoFileGroup", "photoCropGroup", "photoId", "multiFile", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "withBackgroundGray", "isFileUploadingInProgress", "legalNote", "setFileUploadingProgress", 4, "ngIf"], [3, "load", "click", "src"], [3, "setFileUploadingProgress", "photoFileGroup", "photoCropGroup", "photoId", "multiFile", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "withBackgroundGray", "isFileUploadingInProgress", "legalNote"], ["shape-rendering", "geometricPrecision", 2, "position", "absolute"], ["id", "circleClipPath"], ["fill", "white"], [2, "top", "0", "position", "absolute"], ["id", "heartClipPath"], ["fill", "white", "d", "M1666.1,954.9h0s-56.1,217.2-319.8,454c-238.8,214.4-457.8,325.9-457.8,325.9,0,0-219-111.5-457.8-325.9-263.6-236.7-319.8-454-319.8-454-89.7-290.5,54-462.9,54-462.9,0,0,136.4-188.9,368.9-188.9s354.6,209.8,354.6,209.8c0,0,122.1-209.8,354.6-209.8s368.9,188.9,368.9,188.9c0,0,143.7,172.4,54,462.9h.2Z"]],
                template: function(ee, W) {
                    if (1 & ee && (r.j41(0, "pp-poster-background", 3, 0),
                    r.DNE(2, Et, 10, 19, "pp-poster-printing-registration", 4),
                    r.nI1(3, "async"),
                    r.k0s(),
                    r.DNE(4, ao, 12, 44, "ng-template", null, 1, r.C5r)(6, bt, 1, 0, "pp-poster-loaded-element", 5)(7, Do, 12, 9),
                    r.nI1(8, "async")),
                    2 & ee) {
                        let ae;
                        r.Y8G("background", W.map1.background),
                        r.R7$(2),
                        r.Y8G("ngIf", r.bMT(3, 4, W.poster$)),
                        r.R7$(4),
                        r.Y8G("ngIf", W.isImageRendered),
                        r.R7$(),
                        r.vxM((ae = r.bMT(8, 6, W.splitElementsSize$)) ? 7 : -1, ae)
                    }
                },
                dependencies: [_t.MD, _t.bT, _t.T3, _t.Jj, Mt.Z, s.R, Wt.c, so.y, Me.iu, Me.DM, Ce.f, et.G, ze.C, ye.ex, ge.h, ge.D9, Ie.P],
                styles: ["[_nghost-%COMP%]{--border-color: #E53422;--punching-die-color: #000;width:100%;height:100%;display:block}[_nghost-%COMP%]   .map-wrapper[_ngcontent-%COMP%]{position:absolute;top:0;right:0;bottom:0;left:0;display:block;overflow:hidden}[_nghost-%COMP%]   .map-wrapper[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:100%;height:100%;object-fit:cover}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]{position:absolute;overflow:hidden;pointer-events:none;left:0;right:0;top:0;bottom:0;z-index:1}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]   .cover[_ngcontent-%COMP%]{width:100%;display:block;overflow:hidden}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]   .cover[_ngcontent-%COMP%]   .cover-left[_ngcontent-%COMP%]{float:left;display:block;background:#fff}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]   .cover[_ngcontent-%COMP%]   .cover-right[_ngcontent-%COMP%]{float:left;display:block;background:#fff}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]   .cover[_ngcontent-%COMP%]   .svg-cover[_ngcontent-%COMP%]{width:100%;display:block;margin:auto;float:left}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]     svg{display:block}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]     svg .contour{stroke:var(--border-color)}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]   .cover-area[_ngcontent-%COMP%]{width:100%;height:100%;background:#fff}[_nghost-%COMP%]   .layout-wrapper-border[_ngcontent-%COMP%]{position:absolute;box-sizing:border-box;border:0px solid white;z-index:2;pointer-events:none}[_nghost-%COMP%]   .map-pane[_ngcontent-%COMP%]{background-position:center;background-repeat:no-repeat;background-size:cover;box-sizing:border-box;background-clip:content-box}[_nghost-%COMP%]   .marker[_ngcontent-%COMP%]{position:absolute;z-index:1;transform:translate(-50%,-50%)}[_nghost-%COMP%]   .marker[_ngcontent-%COMP%]     svg{width:100%;height:100%;position:absolute;top:0;left:0}[_nghost-%COMP%]   .marker[_ngcontent-%COMP%]     svg path.marker-stroke{fill:none;stroke-width:3}[_nghost-%COMP%]   button.padlock[_ngcontent-%COMP%]{position:absolute;top:0;left:0;right:unset;width:30px;height:30px;background:#f77147;border:1px solid #f77147;color:#fff;padding:0 0 0 4px}[_nghost-%COMP%]   button.padlock[_ngcontent-%COMP%]:hover{opacity:1;background:#ea4714}[_nghost-%COMP%]   button.padlock[_ngcontent-%COMP%]:first-child{border-top-left-radius:0;border-top-right-radius:0}[_nghost-%COMP%]   button.padlock[_ngcontent-%COMP%]:last-child{border-top:unset;border-bottom-left-radius:0;border-bottom-right-radius:0}[_nghost-%COMP%]   button.padlock[_ngcontent-%COMP%]     svg{width:30px;display:block;height:30px;padding:6px;margin-left:-6px;margin-top:-2px;box-sizing:border-box}[_nghost-%COMP%]   button.padlock[_ngcontent-%COMP%]     svg path{fill:#fff}[_nghost-%COMP%]     svg   path.punching-die{fill:var(--punching-die-color)}[_nghost-%COMP%]     .splitter-second{z-index:2}[_nghost-%COMP%]     .splitter-third{z-index:1}[_nghost-%COMP%]     .photo-instance{scale:1.06}[_nghost-%COMP%]     .photo-instance img{width:100%;height:100%;object-fit:cover;box-sizing:border-box}[_nghost-%COMP%]     .photo-instance.special-heart{scale:1.1}[_nghost-%COMP%]     .photo-instance.special-heart canvas, [_nghost-%COMP%]     .photo-instance.special-heart img, [_nghost-%COMP%]     .photo-instance.special-heart pp-controls-file-uploader-photo{-webkit-mask:url(#heartClipPath);mask:url(#heartClipPath)}[_nghost-%COMP%]     .photo-instance.special-circle canvas, [_nghost-%COMP%]     .photo-instance.special-circle img, [_nghost-%COMP%]     .photo-instance.special-circle pp-controls-file-uploader-photo{-webkit-mask:url(#circleClipPath);mask:url(#circleClipPath)}"]
            }),
            we
        }
        )()
    }
    ,
    72901: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            i: () => ze
        });
        var Ut = $(10467)
          , r = $(54438)
          , Mt = $(9566)
          , s = $(60177)
          , so = $(27617)
          , Wt = $(78606)
          , _t = $(50552)
          , Ae = $(54843)
          , Me = $(96354)
          , ct = $(7430)
          , Tt = $(76675)
          , Qe = $(41046)
          , jt = $(21626);
        const Xe = ["svgContainer1"]
          , Ce = ["svgContainer2"]
          , it = (ye, ge) => ({
            fill: ye,
            stroke: ge
        })
          , et = ye => ({
            fill: ye,
            stroke: "transparent"
        });
        function re(ye, ge) {
            if (1 & ye && r.nrm(0, "div", 12),
            2 & ye) {
                const Ie = r.XpG();
                r.xc7("color", Ie.lineArtJewelry.color),
                r.Y8G("innerHTML", Ie.exampleInformation, r.npT)
            }
        }
        function pt(ye, ge) {
            1 & ye && r.nrm(0, "pp-poster-loaded-element")
        }
        let ze = ( () => {
            var ye;
            class ge extends _t.C {
                constructor(gt, Ye, yt, ht) {
                    super(gt, Ye),
                    this.host = gt,
                    this.zone = Ye,
                    this.httpClient = yt,
                    this.cdr = ht,
                    this.exampleInformation = "",
                    this.hideSwitchers = !1,
                    this.showFrontOnInit = !0,
                    this.showAvers = new r.bkB(!1),
                    this.lineArtJewelry = {
                        textURL: "",
                        titleFontSize: "1px",
                        material: so.Xl7.na,
                        setup: so.Hyl.charm,
                        color: "transparent",
                        selectedZodiac: so.p2u.ARIES,
                        zodiacStyle: so.sqx.MODERN,
                        zodiacURL: ""
                    }
                }
                setJewelry(gt, Ye) {
                    var yt = this;
                    return (0,
                    Ut.A)(function*() {
                        yt.lineArtJewelry.textURL = yield(0,
                        Ae._)(yt.httpClient.post("".concat(window.location.origin, "/api/zodiac/jewelry/text"), {
                            title: Ye.customMessage ? Ye.title : "",
                            titleFontScript: Ye.titleFontScript,
                            footer: Ye.customMessage ? "".concat(Ye.footerJewelry, "\n").concat(Ye.dateField) : ""
                        }).pipe((0,
                        Me.T)(ht => (0,
                        Tt.ID)("image/svg+xml", ht.image)))),
                        yt.lineArtJewelry.material = Ye.material,
                        yt.lineArtJewelry.color = Tt.fd[Ye.material],
                        yt.lineArtJewelry.setup = Ye.setup,
                        yt.lineArtJewelry.selectedZodiac = Ye.zodiacSign,
                        yt.lineArtJewelry.zodiacStyle = Ye.layout,
                        yt.lineArtJewelry.zodiacURL = "/assets/pp-posters/zodiac/sign/".concat(yt.lineArtJewelry.zodiacStyle, "/").concat(yt.lineArtJewelry.selectedZodiac, ".svg"),
                        yt.hideSwitchers && yt.careAboutSvgVisibility(yt.showFrontOnInit ? yt.svgContainer1 : yt.svgContainer2, yt.onImageLoad.bind(yt))
                    })()
                }
                setAllTextSettings(gt, Ye) {}
                setDesign(gt, Ye, yt) {
                    return Promise.resolve(void 0)
                }
                setTextArea(gt, Ye) {}
                ngAfterViewInit() {}
                careAboutSvgVisibility(gt, Ye) {
                    var yt;
                    const ht = null == gt || null === (yt = gt.nativeElement) || void 0 === yt ? void 0 : yt.querySelector("svg");
                    ht && ht.clientWidth > 0 ? Ye() : setTimeout( () => {
                        this.careAboutSvgVisibility(gt, Ye)
                    }
                    , 100)
                }
                onImageLoad() {
                    this.load++,
                    1 === this.load && (this.initiateRender(),
                    this.cdr.detectChanges())
                }
            }
            return (ye = ge).\u0275fac = function(gt) {
                return new (gt || ye)(r.rXU(r.aKT),r.rXU(r.SKi),r.rXU(jt.Qq),r.rXU(r.gRc))
            }
            ,
            ye.\u0275cmp = r.VBU({
                type: ye,
                selectors: [["pp-jewelry-zodiac"]],
                viewQuery: function(gt, Ye) {
                    if (1 & gt && (r.GBs(Xe, 5),
                    r.GBs(Ce, 5)),
                    2 & gt) {
                        let yt;
                        r.mGM(yt = r.lsd()) && (Ye.svgContainer1 = yt.first),
                        r.mGM(yt = r.lsd()) && (Ye.svgContainer2 = yt.first)
                    }
                },
                inputs: {
                    exampleInformation: "exampleInformation",
                    hideSwitchers: "hideSwitchers",
                    showFrontOnInit: "showFrontOnInit"
                },
                outputs: {
                    showAvers: "showAvers"
                },
                features: [r.Vt3],
                decls: 13,
                vars: 16,
                consts: [["svgContainer1", ""], ["svgJewelryContour", ""], ["svgContainer2", ""], [3, "background"], [3, "showAvers", "material", "setup", "hideSwitchers", "showFront"], ["slot", "front"], [1, "front-center"], [3, "src", "svgStyle"], ["class", "example-information", 3, "innerHTML", "color", 4, "ngIf"], ["slot", "back"], [1, "back-center"], [4, "ngIf"], [1, "example-information", 3, "innerHTML"]],
                template: function(gt, Ye) {
                    if (1 & gt) {
                        const yt = r.RV6();
                        r.j41(0, "pp-poster-background", 3)(1, "pp-poster-jewelry-area", 4),
                        r.bIt("showAvers", function(mo) {
                            return r.eBV(yt),
                            r.Njj(Ye.showAvers.emit(mo))
                        }),
                        r.j41(2, "div", 5)(3, "div", 6, 0),
                        r.nrm(5, "svg-icon", 7, 1),
                        r.DNE(7, re, 1, 3, "div", 8),
                        r.k0s()(),
                        r.j41(8, "div", 9)(9, "div", 10, 2),
                        r.nrm(11, "svg-icon", 7),
                        r.k0s()()()(),
                        r.DNE(12, pt, 1, 0, "pp-poster-loaded-element", 11)
                    }
                    2 & gt && (r.Y8G("background", "transparent"),
                    r.R7$(),
                    r.Y8G("material", Ye.lineArtJewelry.material)("setup", Ye.lineArtJewelry.setup)("hideSwitchers", Ye.hideSwitchers)("showFront", Ye.showFrontOnInit),
                    r.R7$(4),
                    r.Y8G("src", Ye.lineArtJewelry.zodiacURL)("svgStyle", r.l_i(11, it, Ye.lineArtJewelry.color, Ye.lineArtJewelry.color)),
                    r.R7$(2),
                    r.Y8G("ngIf", Ye.exampleInformation),
                    r.R7$(4),
                    r.Y8G("src", Ye.lineArtJewelry.textURL)("svgStyle", r.eq3(14, et, Ye.lineArtJewelry.color)),
                    r.R7$(),
                    r.Y8G("ngIf", Ye.isImageRendered))
                },
                dependencies: [s.MD, s.bT, Mt.R, Wt.iu, Wt.DM, ct.R, Qe.C],
                styles: ["[_nghost-%COMP%]{width:100%;height:100%;display:block}"]
            }),
            ge
        }
        )()
    }
    ,
    74023: (zi, Bo, $) => {
        function Ut(Xe) {
            this.mode = Mt.MODE_8BIT_BYTE,
            this.data = Xe,
            this.parsedData = [];
            for (var Ce = 0, it = this.data.length; Ce < it; Ce++) {
                var et = []
                  , re = this.data.charCodeAt(Ce);
                re > 65536 ? (et[0] = 240 | (1835008 & re) >>> 18,
                et[1] = 128 | (258048 & re) >>> 12,
                et[2] = 128 | (4032 & re) >>> 6,
                et[3] = 128 | 63 & re) : re > 2048 ? (et[0] = 224 | (61440 & re) >>> 12,
                et[1] = 128 | (4032 & re) >>> 6,
                et[2] = 128 | 63 & re) : re > 128 ? (et[0] = 192 | (1984 & re) >>> 6,
                et[1] = 128 | 63 & re) : et[0] = re,
                this.parsedData.push(et)
            }
            this.parsedData = Array.prototype.concat.apply([], this.parsedData),
            this.parsedData.length != this.data.length && (this.parsedData.unshift(191),
            this.parsedData.unshift(187),
            this.parsedData.unshift(239))
        }
        function r(Xe, Ce) {
            this.typeNumber = Xe,
            this.errorCorrectLevel = Ce,
            this.modules = null,
            this.moduleCount = 0,
            this.dataCache = null,
            this.dataList = []
        }
        Ut.prototype = {
            getLength: function(Xe) {
                return this.parsedData.length
            },
            write: function(Xe) {
                for (var Ce = 0, it = this.parsedData.length; Ce < it; Ce++)
                    Xe.put(this.parsedData[Ce], 8)
            }
        },
        r.prototype = {
            addData: function(Xe) {
                var Ce = new Ut(Xe);
                this.dataList.push(Ce),
                this.dataCache = null
            },
            isDark: function(Xe, Ce) {
                if (Xe < 0 || this.moduleCount <= Xe || Ce < 0 || this.moduleCount <= Ce)
                    throw new Error(Xe + "," + Ce);
                return this.modules[Xe][Ce]
            },
            getModuleCount: function() {
                return this.moduleCount
            },
            make: function() {
                this.makeImpl(!1, this.getBestMaskPattern())
            },
            makeImpl: function(Xe, Ce) {
                this.moduleCount = 4 * this.typeNumber + 17,
                this.modules = new Array(this.moduleCount);
                for (var it = 0; it < this.moduleCount; it++) {
                    this.modules[it] = new Array(this.moduleCount);
                    for (var et = 0; et < this.moduleCount; et++)
                        this.modules[it][et] = null
                }
                this.setupPositionProbePattern(0, 0),
                this.setupPositionProbePattern(this.moduleCount - 7, 0),
                this.setupPositionProbePattern(0, this.moduleCount - 7),
                this.setupPositionAdjustPattern(),
                this.setupTimingPattern(),
                this.setupTypeInfo(Xe, Ce),
                this.typeNumber >= 7 && this.setupTypeNumber(Xe),
                null == this.dataCache && (this.dataCache = r.createData(this.typeNumber, this.errorCorrectLevel, this.dataList)),
                this.mapData(this.dataCache, Ce)
            },
            setupPositionProbePattern: function(Xe, Ce) {
                for (var it = -1; it <= 7; it++)
                    if (!(Xe + it <= -1 || this.moduleCount <= Xe + it))
                        for (var et = -1; et <= 7; et++)
                            Ce + et <= -1 || this.moduleCount <= Ce + et || (this.modules[Xe + it][Ce + et] = 0 <= it && it <= 6 && (0 == et || 6 == et) || 0 <= et && et <= 6 && (0 == it || 6 == it) || 2 <= it && it <= 4 && 2 <= et && et <= 4)
            },
            getBestMaskPattern: function() {
                for (var Xe = 0, Ce = 0, it = 0; it < 8; it++) {
                    this.makeImpl(!0, it);
                    var et = Wt.getLostPoint(this);
                    (0 == it || Xe > et) && (Xe = et,
                    Ce = it)
                }
                return Ce
            },
            createMovieClip: function(Xe, Ce, it) {
                var et = Xe.createEmptyMovieClip(Ce, it);
                this.make();
                for (var pt = 0; pt < this.modules.length; pt++)
                    for (var Be = 1 * pt, ze = 0; ze < this.modules[pt].length; ze++) {
                        var ye = 1 * ze;
                        this.modules[pt][ze] && (et.beginFill(0, 100),
                        et.moveTo(ye, Be),
                        et.lineTo(ye + 1, Be),
                        et.lineTo(ye + 1, Be + 1),
                        et.lineTo(ye, Be + 1),
                        et.endFill())
                    }
                return et
            },
            setupTimingPattern: function() {
                for (var Xe = 8; Xe < this.moduleCount - 8; Xe++)
                    null == this.modules[Xe][6] && (this.modules[Xe][6] = Xe % 2 == 0);
                for (var Ce = 8; Ce < this.moduleCount - 8; Ce++)
                    null == this.modules[6][Ce] && (this.modules[6][Ce] = Ce % 2 == 0)
            },
            setupPositionAdjustPattern: function() {
                for (var Xe = Wt.getPatternPosition(this.typeNumber), Ce = 0; Ce < Xe.length; Ce++)
                    for (var it = 0; it < Xe.length; it++) {
                        var et = Xe[Ce]
                          , re = Xe[it];
                        if (null == this.modules[et][re])
                            for (var pt = -2; pt <= 2; pt++)
                                for (var Be = -2; Be <= 2; Be++)
                                    this.modules[et + pt][re + Be] = -2 == pt || 2 == pt || -2 == Be || 2 == Be || 0 == pt && 0 == Be
                    }
            },
            setupTypeNumber: function(Xe) {
                for (var Ce = Wt.getBCHTypeNumber(this.typeNumber), it = 0; it < 18; it++) {
                    var et = !Xe && 1 == (Ce >> it & 1);
                    this.modules[Math.floor(it / 3)][it % 3 + this.moduleCount - 8 - 3] = et
                }
                for (it = 0; it < 18; it++)
                    et = !Xe && 1 == (Ce >> it & 1),
                    this.modules[it % 3 + this.moduleCount - 8 - 3][Math.floor(it / 3)] = et
            },
            setupTypeInfo: function(Xe, Ce) {
                for (var et = Wt.getBCHTypeInfo(this.errorCorrectLevel << 3 | Ce), re = 0; re < 15; re++) {
                    var pt = !Xe && 1 == (et >> re & 1);
                    re < 6 ? this.modules[re][8] = pt : re < 8 ? this.modules[re + 1][8] = pt : this.modules[this.moduleCount - 15 + re][8] = pt
                }
                for (re = 0; re < 15; re++)
                    pt = !Xe && 1 == (et >> re & 1),
                    re < 8 ? this.modules[8][this.moduleCount - re - 1] = pt : re < 9 ? this.modules[8][15 - re - 1 + 1] = pt : this.modules[8][15 - re - 1] = pt;
                this.modules[this.moduleCount - 8][8] = !Xe
            },
            mapData: function(Xe, Ce) {
                for (var it = -1, et = this.moduleCount - 1, re = 7, pt = 0, Be = this.moduleCount - 1; Be > 0; Be -= 2)
                    for (6 == Be && Be--; ; ) {
                        for (var ze = 0; ze < 2; ze++)
                            if (null == this.modules[et][Be - ze]) {
                                var ye = !1;
                                pt < Xe.length && (ye = 1 == (Xe[pt] >>> re & 1)),
                                Wt.getMask(Ce, et, Be - ze) && (ye = !ye),
                                this.modules[et][Be - ze] = ye,
                                -1 == --re && (pt++,
                                re = 7)
                            }
                        if ((et += it) < 0 || this.moduleCount <= et) {
                            et -= it,
                            it = -it;
                            break
                        }
                    }
            }
        },
        r.PAD0 = 236,
        r.PAD1 = 17,
        r.createData = function(Xe, Ce, it) {
            for (var et = ct.getRSBlocks(Xe, Ce), re = new Tt, pt = 0; pt < it.length; pt++) {
                var Be = it[pt];
                re.put(Be.mode, 4),
                re.put(Be.getLength(), Wt.getLengthInBits(Be.mode, Xe)),
                Be.write(re)
            }
            var ze = 0;
            for (pt = 0; pt < et.length; pt++)
                ze += et[pt].dataCount;
            if (re.getLengthInBits() > 8 * ze)
                throw new Error("code length overflow. (" + re.getLengthInBits() + ">" + 8 * ze + ")");
            for (re.getLengthInBits() + 4 <= 8 * ze && re.put(0, 4); re.getLengthInBits() % 8 != 0; )
                re.putBit(!1);
            for (; !(re.getLengthInBits() >= 8 * ze || (re.put(r.PAD0, 8),
            re.getLengthInBits() >= 8 * ze)); )
                re.put(r.PAD1, 8);
            return r.createBytes(re, et)
        }
        ,
        r.createBytes = function(Xe, Ce) {
            for (var it = 0, et = 0, re = 0, pt = new Array(Ce.length), Be = new Array(Ce.length), ze = 0; ze < Ce.length; ze++) {
                var ye = Ce[ze].dataCount
                  , ge = Ce[ze].totalCount - ye;
                et = Math.max(et, ye),
                re = Math.max(re, ge),
                pt[ze] = new Array(ye);
                for (var Ie = 0; Ie < pt[ze].length; Ie++)
                    pt[ze][Ie] = 255 & Xe.buffer[Ie + it];
                it += ye;
                var gt = Wt.getErrorCorrectPolynomial(ge)
                  , yt = new Me(pt[ze],gt.getLength() - 1).mod(gt);
                for (Be[ze] = new Array(gt.getLength() - 1),
                Ie = 0; Ie < Be[ze].length; Ie++) {
                    var ht = Ie + yt.getLength() - Be[ze].length;
                    Be[ze][Ie] = ht >= 0 ? yt.get(ht) : 0
                }
            }
            var mo = 0;
            for (Ie = 0; Ie < Ce.length; Ie++)
                mo += Ce[Ie].totalCount;
            var no = new Array(mo)
              , Co = 0;
            for (Ie = 0; Ie < et; Ie++)
                for (ze = 0; ze < Ce.length; ze++)
                    Ie < pt[ze].length && (no[Co++] = pt[ze][Ie]);
            for (Ie = 0; Ie < re; Ie++)
                for (ze = 0; ze < Ce.length; ze++)
                    Ie < Be[ze].length && (no[Co++] = Be[ze][Ie]);
            return no
        }
        ;
        for (var Mt = {
            MODE_NUMBER: 1,
            MODE_ALPHA_NUM: 2,
            MODE_8BIT_BYTE: 4,
            MODE_KANJI: 8
        }, s = {
            L: 1,
            M: 0,
            Q: 3,
            H: 2
        }, so = {
            PATTERN000: 0,
            PATTERN001: 1,
            PATTERN010: 2,
            PATTERN011: 3,
            PATTERN100: 4,
            PATTERN101: 5,
            PATTERN110: 6,
            PATTERN111: 7
        }, Wt = {
            PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]],
            G15: 1335,
            G18: 7973,
            G15_MASK: 21522,
            getBCHTypeInfo: function(Xe) {
                for (var Ce = Xe << 10; Wt.getBCHDigit(Ce) - Wt.getBCHDigit(Wt.G15) >= 0; )
                    Ce ^= Wt.G15 << Wt.getBCHDigit(Ce) - Wt.getBCHDigit(Wt.G15);
                return (Xe << 10 | Ce) ^ Wt.G15_MASK
            },
            getBCHTypeNumber: function(Xe) {
                for (var Ce = Xe << 12; Wt.getBCHDigit(Ce) - Wt.getBCHDigit(Wt.G18) >= 0; )
                    Ce ^= Wt.G18 << Wt.getBCHDigit(Ce) - Wt.getBCHDigit(Wt.G18);
                return Xe << 12 | Ce
            },
            getBCHDigit: function(Xe) {
                for (var Ce = 0; 0 != Xe; )
                    Ce++,
                    Xe >>>= 1;
                return Ce
            },
            getPatternPosition: function(Xe) {
                return Wt.PATTERN_POSITION_TABLE[Xe - 1]
            },
            getMask: function(Xe, Ce, it) {
                switch (Xe) {
                case so.PATTERN000:
                    return (Ce + it) % 2 == 0;
                case so.PATTERN001:
                    return Ce % 2 == 0;
                case so.PATTERN010:
                    return it % 3 == 0;
                case so.PATTERN011:
                    return (Ce + it) % 3 == 0;
                case so.PATTERN100:
                    return (Math.floor(Ce / 2) + Math.floor(it / 3)) % 2 == 0;
                case so.PATTERN101:
                    return Ce * it % 2 + Ce * it % 3 == 0;
                case so.PATTERN110:
                    return (Ce * it % 2 + Ce * it % 3) % 2 == 0;
                case so.PATTERN111:
                    return (Ce * it % 3 + (Ce + it) % 2) % 2 == 0;
                default:
                    throw new Error("bad maskPattern:" + Xe)
                }
            },
            getErrorCorrectPolynomial: function(Xe) {
                for (var Ce = new Me([1],0), it = 0; it < Xe; it++)
                    Ce = Ce.multiply(new Me([1, _t.gexp(it)],0));
                return Ce
            },
            getLengthInBits: function(Xe, Ce) {
                if (1 <= Ce && Ce < 10)
                    switch (Xe) {
                    case Mt.MODE_NUMBER:
                        return 10;
                    case Mt.MODE_ALPHA_NUM:
                        return 9;
                    case Mt.MODE_8BIT_BYTE:
                    case Mt.MODE_KANJI:
                        return 8;
                    default:
                        throw new Error("mode:" + Xe)
                    }
                else if (Ce < 27)
                    switch (Xe) {
                    case Mt.MODE_NUMBER:
                        return 12;
                    case Mt.MODE_ALPHA_NUM:
                        return 11;
                    case Mt.MODE_8BIT_BYTE:
                        return 16;
                    case Mt.MODE_KANJI:
                        return 10;
                    default:
                        throw new Error("mode:" + Xe)
                    }
                else {
                    if (!(Ce < 41))
                        throw new Error("type:" + Ce);
                    switch (Xe) {
                    case Mt.MODE_NUMBER:
                        return 14;
                    case Mt.MODE_ALPHA_NUM:
                        return 13;
                    case Mt.MODE_8BIT_BYTE:
                        return 16;
                    case Mt.MODE_KANJI:
                        return 12;
                    default:
                        throw new Error("mode:" + Xe)
                    }
                }
            },
            getLostPoint: function(Xe) {
                for (var Ce = Xe.getModuleCount(), it = 0, et = 0; et < Ce; et++)
                    for (var re = 0; re < Ce; re++) {
                        for (var pt = 0, Be = Xe.isDark(et, re), ze = -1; ze <= 1; ze++)
                            if (!(et + ze < 0 || Ce <= et + ze))
                                for (var ye = -1; ye <= 1; ye++)
                                    re + ye < 0 || Ce <= re + ye || 0 == ze && 0 == ye || Be == Xe.isDark(et + ze, re + ye) && pt++;
                        pt > 5 && (it += 3 + pt - 5)
                    }
                for (et = 0; et < Ce - 1; et++)
                    for (re = 0; re < Ce - 1; re++) {
                        var ge = 0;
                        Xe.isDark(et, re) && ge++,
                        Xe.isDark(et + 1, re) && ge++,
                        Xe.isDark(et, re + 1) && ge++,
                        Xe.isDark(et + 1, re + 1) && ge++,
                        (0 == ge || 4 == ge) && (it += 3)
                    }
                for (et = 0; et < Ce; et++)
                    for (re = 0; re < Ce - 6; re++)
                        Xe.isDark(et, re) && !Xe.isDark(et, re + 1) && Xe.isDark(et, re + 2) && Xe.isDark(et, re + 3) && Xe.isDark(et, re + 4) && !Xe.isDark(et, re + 5) && Xe.isDark(et, re + 6) && (it += 40);
                for (re = 0; re < Ce; re++)
                    for (et = 0; et < Ce - 6; et++)
                        Xe.isDark(et, re) && !Xe.isDark(et + 1, re) && Xe.isDark(et + 2, re) && Xe.isDark(et + 3, re) && Xe.isDark(et + 4, re) && !Xe.isDark(et + 5, re) && Xe.isDark(et + 6, re) && (it += 40);
                var Ie = 0;
                for (re = 0; re < Ce; re++)
                    for (et = 0; et < Ce; et++)
                        Xe.isDark(et, re) && Ie++;
                return it + Math.abs(100 * Ie / Ce / Ce - 50) / 5 * 10
            }
        }, _t = {
            glog: function(Xe) {
                if (Xe < 1)
                    throw new Error("glog(" + Xe + ")");
                return _t.LOG_TABLE[Xe]
            },
            gexp: function(Xe) {
                for (; Xe < 0; )
                    Xe += 255;
                for (; Xe >= 256; )
                    Xe -= 255;
                return _t.EXP_TABLE[Xe]
            },
            EXP_TABLE: new Array(256),
            LOG_TABLE: new Array(256)
        }, Ae = 0; Ae < 8; Ae++)
            _t.EXP_TABLE[Ae] = 1 << Ae;
        for (Ae = 8; Ae < 256; Ae++)
            _t.EXP_TABLE[Ae] = _t.EXP_TABLE[Ae - 4] ^ _t.EXP_TABLE[Ae - 5] ^ _t.EXP_TABLE[Ae - 6] ^ _t.EXP_TABLE[Ae - 8];
        for (Ae = 0; Ae < 255; Ae++)
            _t.LOG_TABLE[_t.EXP_TABLE[Ae]] = Ae;
        function Me(Xe, Ce) {
            if (null == Xe.length)
                throw new Error(Xe.length + "/" + Ce);
            for (var it = 0; it < Xe.length && 0 == Xe[it]; )
                it++;
            this.num = new Array(Xe.length - it + Ce);
            for (var et = 0; et < Xe.length - it; et++)
                this.num[et] = Xe[et + it]
        }
        function ct(Xe, Ce) {
            this.totalCount = Xe,
            this.dataCount = Ce
        }
        function Tt() {
            this.buffer = [],
            this.length = 0
        }
        Me.prototype = {
            get: function(Xe) {
                return this.num[Xe]
            },
            getLength: function() {
                return this.num.length
            },
            multiply: function(Xe) {
                for (var Ce = new Array(this.getLength() + Xe.getLength() - 1), it = 0; it < this.getLength(); it++)
                    for (var et = 0; et < Xe.getLength(); et++)
                        Ce[it + et] ^= _t.gexp(_t.glog(this.get(it)) + _t.glog(Xe.get(et)));
                return new Me(Ce,0)
            },
            mod: function(Xe) {
                if (this.getLength() - Xe.getLength() < 0)
                    return this;
                for (var Ce = _t.glog(this.get(0)) - _t.glog(Xe.get(0)), it = new Array(this.getLength()), et = 0; et < this.getLength(); et++)
                    it[et] = this.get(et);
                for (et = 0; et < Xe.getLength(); et++)
                    it[et] ^= _t.gexp(_t.glog(Xe.get(et)) + Ce);
                return new Me(it,0).mod(Xe)
            }
        },
        ct.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]],
        ct.getRSBlocks = function(Xe, Ce) {
            var it = ct.getRsBlockTable(Xe, Ce);
            if (null == it)
                throw new Error("bad rs block @ typeNumber:" + Xe + "/errorCorrectLevel:" + Ce);
            for (var et = it.length / 3, re = [], pt = 0; pt < et; pt++)
                for (var Be = it[3 * pt + 0], ze = it[3 * pt + 1], ye = it[3 * pt + 2], ge = 0; ge < Be; ge++)
                    re.push(new ct(ze,ye));
            return re
        }
        ,
        ct.getRsBlockTable = function(Xe, Ce) {
            switch (Ce) {
            case s.L:
                return ct.RS_BLOCK_TABLE[4 * (Xe - 1) + 0];
            case s.M:
                return ct.RS_BLOCK_TABLE[4 * (Xe - 1) + 1];
            case s.Q:
                return ct.RS_BLOCK_TABLE[4 * (Xe - 1) + 2];
            case s.H:
                return ct.RS_BLOCK_TABLE[4 * (Xe - 1) + 3];
            default:
                return
            }
        }
        ,
        Tt.prototype = {
            get: function(Xe) {
                var Ce = Math.floor(Xe / 8);
                return 1 == (this.buffer[Ce] >>> 7 - Xe % 8 & 1)
            },
            put: function(Xe, Ce) {
                for (var it = 0; it < Ce; it++)
                    this.putBit(1 == (Xe >>> Ce - it - 1 & 1))
            },
            getLengthInBits: function() {
                return this.length
            },
            putBit: function(Xe) {
                var Ce = Math.floor(this.length / 8);
                this.buffer.length <= Ce && this.buffer.push(0),
                Xe && (this.buffer[Ce] |= 128 >>> this.length % 8),
                this.length++
            }
        };
        var Qe = [[17, 14, 11, 7], [32, 26, 20, 14], [53, 42, 32, 24], [78, 62, 46, 34], [106, 84, 60, 44], [134, 106, 74, 58], [154, 122, 86, 64], [192, 152, 108, 84], [230, 180, 130, 98], [271, 213, 151, 119], [321, 251, 177, 137], [367, 287, 203, 155], [425, 331, 241, 177], [458, 362, 258, 194], [520, 412, 292, 220], [586, 450, 322, 250], [644, 504, 364, 280], [718, 560, 394, 310], [792, 624, 442, 338], [858, 666, 482, 382], [929, 711, 509, 403], [1003, 779, 565, 439], [1091, 857, 611, 461], [1171, 911, 661, 511], [1273, 997, 715, 535], [1367, 1059, 751, 593], [1465, 1125, 805, 625], [1528, 1190, 868, 658], [1628, 1264, 908, 698], [1732, 1370, 982, 742], [1840, 1452, 1030, 790], [1952, 1538, 1112, 842], [2068, 1628, 1168, 898], [2188, 1722, 1228, 958], [2303, 1809, 1283, 983], [2431, 1911, 1351, 1051], [2563, 1989, 1423, 1093], [2699, 2099, 1499, 1139], [2809, 2213, 1579, 1219], [2953, 2331, 1663, 1273]];
        function jt(Xe) {
            if (this.options = {
                padding: 4,
                width: 256,
                height: 256,
                typeNumber: 4,
                color: "#000000",
                background: "#ffffff",
                ecl: "M"
            },
            "string" == typeof Xe && (Xe = {
                content: Xe
            }),
            Xe)
                for (var it in Xe)
                    this.options[it] = Xe[it];
            if ("string" != typeof this.options.content)
                throw new Error("Expected 'content' as string!");
            if (0 === this.options.content.length)
                throw new Error("Expected 'content' to be non-empty!");
            if (!(this.options.padding >= 0))
                throw new Error("Expected 'padding' value to be non-negative!");
            if (!(this.options.width > 0 && this.options.height > 0))
                throw new Error("Expected 'width' or 'height' value to be higher than zero!");
            var Be = this.options.content
              , ze = function re(ge, Ie) {
                for (var gt = function pt(ge) {
                    var Ie = encodeURI(ge).toString().replace(/\%[0-9a-fA-F]{2}/g, "a");
                    return Ie.length + (Ie.length != ge ? 3 : 0)
                }(ge), Ye = 1, yt = 0, ht = 0, mo = Qe.length; ht <= mo; ht++) {
                    var no = Qe[ht];
                    if (!no)
                        throw new Error("Content too long: expected " + yt + " but got " + gt);
                    switch (Ie) {
                    case "L":
                        yt = no[0];
                        break;
                    case "M":
                        yt = no[1];
                        break;
                    case "Q":
                        yt = no[2];
                        break;
                    case "H":
                        yt = no[3];
                        break;
                    default:
                        throw new Error("Unknwon error correction level: " + Ie)
                    }
                    if (gt <= yt)
                        break;
                    Ye++
                }
                if (Ye > Qe.length)
                    throw new Error("Content too long");
                return Ye
            }(Be, this.options.ecl)
              , ye = function et(ge) {
                switch (ge) {
                case "L":
                    return s.L;
                case "M":
                    return s.M;
                case "Q":
                    return s.Q;
                case "H":
                    return s.H;
                default:
                    throw new Error("Unknwon error correction level: " + ge)
                }
            }(this.options.ecl);
            this.qrcode = new r(ze,ye),
            this.qrcode.addData(Be),
            this.qrcode.make()
        }
        jt.prototype.svg = function(Xe) {
            var Ce = this.options || {}
              , it = this.qrcode.modules;
            typeof Xe > "u" && (Xe = {
                container: Ce.container || "svg"
            });
            for (var et = !(typeof Ce.pretty < "u" && !Ce.pretty), re = et ? "  " : "", pt = et ? "\r\n" : "", Be = Ce.width, ze = Ce.height, ye = it.length, ge = Be / (ye + 2 * Ce.padding), Ie = ze / (ye + 2 * Ce.padding), gt = typeof Ce.join < "u" && !!Ce.join, Ye = typeof Ce.swap < "u" && !!Ce.swap, yt = !(typeof Ce.xmlDeclaration < "u" && !Ce.xmlDeclaration), ht = typeof Ce.predefined < "u" && !!Ce.predefined, mo = ht ? re + '<defs><path id="qrmodule" d="M0 0 h' + Ie + " v" + ge + ' H0 z" style="fill:' + Ce.color + ';shape-rendering:crispEdges;" /></defs>' + pt : "", no = re + '<rect x="0" y="0" width="' + Be + '" height="' + ze + '" style="fill:' + Ce.background + ';shape-rendering:crispEdges;"/>' + pt, Co = "", Lt = "", Ft = 0; Ft < ye; Ft++)
                for (var co = 0; co < ye; co++)
                    if (it[co][Ft]) {
                        var po = co * ge + Ce.padding * ge
                          , Et = Ft * Ie + Ce.padding * Ie;
                        if (Ye) {
                            var Kt = po;
                            po = Et,
                            Et = Kt
                        }
                        if (gt) {
                            var At = ge + po
                              , Re = Ie + Et;
                            po = Number.isInteger(po) ? Number(po) : po.toFixed(2),
                            Et = Number.isInteger(Et) ? Number(Et) : Et.toFixed(2),
                            At = Number.isInteger(At) ? Number(At) : At.toFixed(2),
                            Lt += "M" + po + "," + Et + " V" + (Re = Number.isInteger(Re) ? Number(Re) : Re.toFixed(2)) + " H" + At + " V" + Et + " H" + po + " Z "
                        } else
                            Co += ht ? re + '<use x="' + po.toString() + '" y="' + Et.toString() + '" href="#qrmodule" />' + pt : re + '<rect x="' + po.toString() + '" y="' + Et.toString() + '" width="' + ge + '" height="' + Ie + '" style="fill:' + Ce.color + ';shape-rendering:crispEdges;"/>' + pt
                    }
            gt && (Co = re + '<path x="0" y="0" style="fill:' + Ce.color + ';shape-rendering:crispEdges;" d="' + Lt + '" />');
            var ve = "";
            switch (Xe.container) {
            case "svg":
                yt && (ve += '<?xml version="1.0" standalone="yes"?>' + pt),
                ve += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' + Be + '" height="' + ze + '">' + pt,
                ve += mo + no + Co,
                ve += "</svg>";
                break;
            case "svg-viewbox":
                yt && (ve += '<?xml version="1.0" standalone="yes"?>' + pt),
                ve += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ' + Be + " " + ze + '">' + pt,
                ve += mo + no + Co,
                ve += "</svg>";
                break;
            case "g":
                ve += '<g width="' + Be + '" height="' + ze + '">' + pt,
                ve += mo + no + Co,
                ve += "</g>";
                break;
            default:
                ve += (mo + no + Co).replace(/^\s+/, "")
            }
            return ve
        }
        ,
        jt.prototype.save = function(Xe, Ce) {
            var it = this.svg();
            "function" != typeof Ce && (Ce = function(re, pt) {}
            );
            try {
                $(Object(function() {
                    var pt = new Error("Cannot find module 'fs'");
                    throw pt.code = "MODULE_NOT_FOUND",
                    pt
                }())).writeFile(Xe, it, Ce)
            } catch (re) {
                Ce(re)
            }
        }
        ,
        zi.exports = jt
    }
    ,
    74412: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            G: () => r
        });
        var Ut = $(27617);
        const r = (Mt, s, so, Wt) => {
            switch (Mt) {
            case Ut.O8Z.CREAM:
                return "transparent radial-gradient(closest-side, #FAF8F3 0%, #F8F3EA 35%, #F5E8D4 90%, #F5E6D0 100%) 0% 0% no-repeat padding-box";
            case Ut.O8Z.BLACK:
                return "#231f20";
            case Ut.O8Z.SKY:
                return "url('/assets/pp-posters/moon/".concat(s ? "_HQ_/" : "", "background/").concat(Wt, "/4.jpg') center/cover no-repeat border-box");
            case Ut.O8Z.NAVY:
                return "#293952";
            case Ut.O8Z.EMERALD:
                return "url('/assets/pp-posters/moon/".concat(s ? "_HQ_/" : "", "background/").concat(Wt, "/6.jpg') center/cover no-repeat border-box");
            case Ut.O8Z.PURPLE_GALAXY:
                return "url('/assets/pp-posters/moon/".concat(s ? "_HQ_/" : "", "background/").concat(Wt, "/7.jpg') center/cover no-repeat border-box");
            case Ut.O8Z.MAGIC_STAR:
                return "url('/assets/pp-posters/moon/".concat(s ? "_HQ_/" : "", "background/").concat(Wt, "/8.jpg') center/cover no-repeat border-box");
            case Ut.O8Z.CUSTOM:
                return "#".concat(so);
            case Ut.O8Z.MARSHMALLOW:
                return "url('/assets/pp-posters/moon/".concat(s ? "_HQ_/" : "", "background/").concat(Wt, "/10.jpg') center/cover no-repeat border-box");
            default:
                return "#FFF"
            }
        }
    }
    ,
    76881: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            Z: () => it
        });
        var Ut = $(10467)
          , r = $(60177)
          , Mt = $(27617)
          , s = $(78606)
          , so = $(50552)
          , Wt = $(21626)
          , _t = $(73955)
          , Ae = $(69847)
          , Me = $(9566)
          , ct = $(7494)
          , Tt = $(13620)
          , Qe = $(41046)
          , jt = $(54438);
        function Xe(re, pt) {
            if (1 & re && (jt.j41(0, "pp-poster-printing-registration", 4)(1, "pp-poster-arrangement-wrapper"),
            jt.nrm(2, "pp-poster-text-area", 5),
            jt.nI1(3, "async"),
            jt.nI1(4, "async"),
            jt.nI1(5, "async"),
            jt.nI1(6, "async"),
            jt.nrm(7, "pp-poster-text-area", 6),
            jt.nI1(8, "async"),
            jt.nI1(9, "async"),
            jt.nI1(10, "async"),
            jt.nI1(11, "async"),
            jt.nI1(12, "async"),
            jt.k0s()()),
            2 & re) {
                const Be = pt.ngIf
                  , ze = jt.XpG();
                jt.Y8G("poster", Be),
                jt.R7$(2),
                jt.Y8G("color", jt.bMT(3, 10, ze.textColor$))("poster", jt.bMT(4, 12, ze.poster$))("textArea", jt.bMT(5, 14, ze.topTextArea$))("title", jt.bMT(6, 16, ze.title$)),
                jt.R7$(5),
                jt.Y8G("color", jt.bMT(8, 18, ze.textColor$))("footer", jt.bMT(9, 20, ze.footer$))("poster", jt.bMT(10, 22, ze.poster$))("subtitle", jt.bMT(11, 24, ze.subtitle$))("textArea", jt.bMT(12, 26, ze.textArea$))
            }
        }
        function Ce(re, pt) {
            1 & re && jt.nrm(0, "pp-poster-loaded-element")
        }
        let it = ( () => {
            var re;
            class pt extends so.C {
                constructor(ze, ye, ge) {
                    super(ze, ye),
                    this.host = ze,
                    this.zone = ye,
                    this.cdr = ge,
                    this.giftCard = {
                        background: "#FFF"
                    }
                }
                setAllTextSettings(ze) {
                    const ye = {
                        text: ze.giftCardEnabled ? ze.giftCardTop : "",
                        isDefaultFont: ze.giftCardTopFontScript
                    };
                    this.setText(ye, this.title$, {
                        font: null != ye && ye.isDefaultFont ? Mt.n3q.HELLO_OCTOBER : Mt.n3q.MENLO_BOLD_ITALIC,
                        portrait: {
                            sizeFactor: null != ye && ye.isDefaultFont ? .13 : .092,
                            bottomFactor: .0125,
                            topFactor: null != ye && ye.isDefaultFont ? -.03 : 0,
                            isBold: !1
                        },
                        horizontal: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        }
                    }),
                    this.setText({
                        text: ze.giftCardEnabled ? ze.giftCardMiddle : "",
                        isDefaultFont: !0
                    }, this.subtitle$, {
                        font: Mt.n3q.MENLO_REGULAR,
                        portrait: {
                            sizeFactor: .041,
                            bottomFactor: .066,
                            lineHeightFactor: .0492,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        }
                    }),
                    this.setText({
                        text: ze.giftCardEnabled ? ze.giftCardBottom : "",
                        isDefaultFont: !0
                    }, this.footer$, {
                        font: Mt.n3q.HELLO_OCTOBER,
                        portrait: {
                            sizeFactor: .095,
                            bottomFactor: .02,
                            topFactor: 0,
                            isBold: !1
                        },
                        horizontal: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        }
                    })
                }
                setTextArea(ze) {
                    this.topTextArea$.next({
                        topFactor: .098,
                        marginFactor: .04
                    }),
                    this.textArea$.next({
                        bottomFactor: .05,
                        marginFactor: .08
                    })
                }
                setDesign(ze, ye) {
                    var ge = this;
                    return (0,
                    Ut.A)(function*() {
                        ge.giftCard.background = et(ye.giftCardColorScheme),
                        ge.textColor$.next(ge.getTextColor(ye.giftCardColorScheme)),
                        setTimeout( () => ge.onImageLoad())
                    })()
                }
                onImageLoad() {
                    this.load++,
                    1 === this.load && (this.initiateRender(),
                    this.cdr.detectChanges())
                }
                getTextColor(ze) {
                    return [Mt.az$.COSMIC_LATTE].includes(ze) ? "#000" : "#FFF"
                }
            }
            return (re = pt).\u0275fac = function(ze) {
                return new (ze || re)(jt.rXU(jt.aKT),jt.rXU(jt.SKi),jt.rXU(jt.gRc))
            }
            ,
            re.\u0275cmp = jt.VBU({
                type: re,
                selectors: [["pp-poster-gift-card"]],
                features: [jt.Vt3],
                decls: 5,
                vars: 5,
                consts: [["posterWrapper", ""], [3, "background"], [3, "poster", 4, "ngIf"], [4, "ngIf"], [3, "poster"], [3, "color", "poster", "textArea", "title"], [3, "color", "footer", "poster", "subtitle", "textArea"]],
                template: function(ze, ye) {
                    1 & ze && (jt.j41(0, "pp-poster-background", 1, 0),
                    jt.DNE(2, Xe, 13, 28, "pp-poster-printing-registration", 2),
                    jt.nI1(3, "async"),
                    jt.k0s(),
                    jt.DNE(4, Ce, 1, 0, "pp-poster-loaded-element", 3)),
                    2 & ze && (jt.Y8G("background", ye.giftCard.background),
                    jt.R7$(2),
                    jt.Y8G("ngIf", jt.bMT(3, 3, ye.poster$)),
                    jt.R7$(2),
                    jt.Y8G("ngIf", ye.isImageRendered))
                },
                dependencies: [r.MD, r.bT, r.Jj, s.iu, Wt.q1, _t.h, Ae.c, Me.R, ct.Z, Tt.y, Qe.C],
                styles: ["[_nghost-%COMP%]{--character-outline-color: #000;width:100%;height:100%;display:block}"]
            }),
            pt
        }
        )();
        const et = re => {
            switch (re) {
            case Mt.az$.SKY:
                return "url('/assets/pp-posters/gift-card/background/1.jpg') center/cover no-repeat border-box";
            case Mt.az$.EMERALD:
                return "url('/assets/pp-posters/gift-card/background/3.jpg') center/cover no-repeat border-box";
            case Mt.az$.COSMIC_LATTE:
                return "url('/assets/pp-posters/gift-card/background/2.jpg') center/cover no-repeat border-box"
            }
        }
    }
    ,
    78981: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            q: () => ee
        });
        var Ut = $(10467)
          , r = $(54438)
          , Mt = $(7494)
          , s = $(9566)
          , so = $(13620)
          , Wt = $(69847)
          , _t = $(60177)
          , Ae = $(27617)
          , Me = $(78606)
          , ct = $(28105)
          , Tt = $(61762)
          , Qe = $(84412)
          , jt = $(5116)
          , Xe = $(63597)
          , Ce = $(2745)
          , it = $(84572)
          , et = $(56977)
          , re = $(70152)
          , pt = $(76675)
          , Be = $(41046)
          , ze = $(49427)
          , ye = $(73955)
          , ge = $(66985)
          , Ie = $(21626)
          , gt = $(345);
        const Ye = (W, ae, Ve, fe, Pt, mt, xo) => ({
            appConfiguration$: W,
            location$: ae,
            title$: Ve,
            footer$: fe,
            date$: Pt,
            photo$: mt,
            starElement: xo,
            elementId: 0
        })
          , yt = (W, ae, Ve, fe, Pt, mt, xo) => ({
            appConfiguration$: W,
            location$: ae,
            title$: Ve,
            footer$: fe,
            date$: Pt,
            photo$: mt,
            starElement: xo,
            elementId: 1
        })
          , ht = (W, ae, Ve, fe, Pt, mt, xo) => ({
            appConfiguration$: W,
            location$: ae,
            title$: Ve,
            footer$: fe,
            date$: Pt,
            photo$: mt,
            starElement: xo,
            elementId: 2
        })
          , mo = (W, ae) => [W, ae]
          , no = (W, ae, Ve, fe, Pt) => [W, ae, Ve, fe, Pt]
          , Co = W => [W]
          , Lt = (W, ae, Ve) => [W, ae, Ve]
          , Ft = () => [".jpeg", ".jpg", ".png", ".heic"]
          , co = (W, ae) => ({
            fill: W,
            stroke: ae,
            width: "100%",
            height: "100%"
        })
          , Jt = () => ({
            fill: "red",
            width: "100%",
            height: "100%"
        });
        function po(W, ae) {
            if (1 & W && (r.j41(0, "pp-poster-space-splitter", 9),
            r.eu8(1, 10)(2, 11)(3, 12),
            r.k0s()),
            2 & W) {
                const Ve = r.XpG().ngIf
                  , fe = r.XpG(2)
                  , Pt = r.sdS(5);
                r.xc7("width", Ve.width, "px")("height", Ve.height, "px")("margin-top", Ve.marginTop, "px"),
                r.Y8G("isTriple", !0),
                r.R7$(),
                r.Y8G("ngTemplateOutlet", Pt)("ngTemplateOutletContext", r.sGs(13, Ye, fe.appConfiguration1$, fe.location1$, fe.title1$, fe.footer1$, fe.date1$, fe.photo1$, fe.starElement1)),
                r.R7$(),
                r.Y8G("ngTemplateOutlet", Pt)("ngTemplateOutletContext", r.sGs(21, yt, fe.appConfiguration2$, fe.location2$, fe.title2$, fe.footer2$, fe.date2$, fe.photo2$, fe.starElement2)),
                r.R7$(),
                r.Y8G("ngTemplateOutlet", Pt)("ngTemplateOutletContext", r.sGs(29, ht, fe.appConfiguration3$, fe.location3$, fe.title3$, fe.footer3$, fe.date3$, fe.photo3$, fe.starElement3))
            }
        }
        function Et(W, ae) {
            if (1 & W && (r.qex(0),
            r.DNE(1, po, 4, 37, "pp-poster-space-splitter", 8),
            r.bVm()),
            2 & W) {
                const Ve = ae.ngIf;
                r.R7$(),
                r.Y8G("ngIf", Ve.width && Ve.height)
            }
        }
        function Kt(W, ae) {
            if (1 & W) {
                const Ve = r.RV6();
                r.j41(0, "pp-poster-printing-registration", 6)(1, "pp-poster-arrangement-wrapper")(2, "pp-poster-text-area", 7),
                r.nI1(3, "async"),
                r.nI1(4, "async"),
                r.nI1(5, "async"),
                r.nI1(6, "async"),
                r.nI1(7, "async"),
                r.bIt("textareaHeightCallback", function(Pt) {
                    r.eBV(Ve);
                    const mt = r.XpG();
                    return r.Njj(mt.newTopTextareaHeight(Pt))
                })("textareaWidthCallback", function(Pt) {
                    r.eBV(Ve);
                    const mt = r.XpG();
                    return r.Njj(mt.newTopTextareaWidth(Pt))
                }),
                r.k0s(),
                r.DNE(8, Et, 2, 1, "ng-container", 5),
                r.nI1(9, "async"),
                r.k0s()()
            }
            if (2 & W) {
                const Ve = ae.ngIf
                  , fe = r.XpG();
                r.Y8G("poster", Ve),
                r.R7$(2),
                r.Y8G("poster", r.bMT(3, 7, fe.poster$))("color", r.bMT(4, 9, fe.textColor$))("textArea", r.bMT(5, 11, fe.topTextArea$))("title", r.bMT(6, 13, fe.title$))("subtitle", r.bMT(7, 15, fe.subtitle$)),
                r.R7$(6),
                r.Y8G("ngIf", r.bMT(9, 17, fe.splitElementsSize$))
            }
        }
        function At(W, ae) {
            if (1 & W && r.nrm(0, "div", 19),
            2 & W) {
                const Ve = r.XpG().elementId
                  , fe = r.XpG();
                r.xc7("background", 1 === Ve && fe.stars.shape === fe.StarsShapesEnum.CIRCLES_PHOTO && r.l_i(8, mo, fe.StarsColorSchemeEnum.NAVY, fe.StarsColorSchemeEnum.BLACK_HOLE).includes(fe.stars.colorScheme) ? "#BBBDC1" : fe.stars.circleBackground),
                r.AVh("special-sky", fe.stars.colorScheme === fe.StarsColorSchemeEnum.SKY)("special-emerald", fe.stars.colorScheme === fe.StarsColorSchemeEnum.EMERALD)("special-purple-galaxy", fe.stars.colorScheme === fe.StarsColorSchemeEnum.PURPLE_GALAXY)
            }
        }
        function Re(W, ae) {
            if (1 & W && r.nrm(0, "div", 21),
            2 & W) {
                const Ve = r.XpG(3).elementId
                  , fe = r.XpG();
                r.xc7("margin-top", fe.stars.shape === fe.StarsShapesEnum.HEARTS_PHOTO || fe.stars.shape === fe.StarsShapesEnum.CIRCLES_PHOTO ? -.06 * fe.stars.width : 0, "px")("background", 1 === Ve && fe.stars.shape === fe.StarsShapesEnum.HEARTS_PHOTO && r.l_i(10, mo, fe.StarsColorSchemeEnum.NAVY, fe.StarsColorSchemeEnum.BLACK_HOLE).includes(fe.stars.colorScheme) ? "#BBBDC1" : fe.stars.circleBackground),
                r.AVh("special-sky", fe.stars.colorScheme === fe.StarsColorSchemeEnum.SKY)("special-emerald", fe.stars.colorScheme === fe.StarsColorSchemeEnum.EMERALD)("special-purple-galaxy", fe.stars.colorScheme === fe.StarsColorSchemeEnum.PURPLE_GALAXY)
            }
        }
        function ve(W, ae) {
            if (1 & W && r.DNE(0, Re, 1, 13, "div", 20),
            2 & W) {
                const Ve = r.XpG(3);
                r.vxM(Ve.getPhotoWithType(ae).showAddPhoto ? 0 : -1)
            }
        }
        function ne(W, ae) {
            if (1 & W && (r.DNE(0, ve, 1, 1),
            r.nI1(1, "async")),
            2 & W) {
                let Ve;
                const fe = r.XpG().photo$;
                r.vxM((Ve = r.bMT(1, 1, fe)) ? 0 : -1, Ve)
            }
        }
        function B(W, ae) {
            if (1 & W && (r.nrm(0, "pp-poster-stars-area", 27),
            r.nI1(1, "async"),
            r.nI1(2, "async"),
            r.nI1(3, "async")),
            2 & W) {
                const Ve = r.XpG(3)
                  , fe = Ve.appConfiguration$
                  , Pt = Ve.location$
                  , mt = r.XpG();
                r.Y8G("appConfiguration", r.bMT(1, 3, fe))("location", r.bMT(2, 5, Pt))("skyConfiguration", r.bMT(3, 7, mt.skyConfiguration$))
            }
        }
        function de(W, ae) {
            if (1 & W && r.nrm(0, "div", 28, 2),
            2 & W) {
                const Ve = r.XpG(3).starElement
                  , fe = r.XpG();
                r.AVh("preview", !fe.isFinalPoster),
                r.Y8G("innerHTML", Ve.image, r.npT)
            }
        }
        function lt(W, ae) {
            if (1 & W && (r.DNE(0, B, 4, 9, "pp-poster-stars-area", 24)(1, de, 2, 3, "div", 25),
            r.nrm(2, "pp-poster-preview", 26)),
            2 & W) {
                const Ve = r.XpG(3);
                r.Y8G("ngIf", !Ve.isSvgStars),
                r.R7$(),
                r.Y8G("ngIf", Ve.isSvgStars),
                r.R7$(),
                r.Y8G("showPreview", !Ve.isFinalPoster)("marginTop", Ve.stars.shape === Ve.StarsShapesEnum.HEARTS)("previewType", "star-dimmed")
            }
        }
        function St(W, ae) {
            if (1 & W) {
                const Ve = r.RV6();
                r.j41(0, "img", 32),
                r.bIt("load", function() {
                    r.eBV(Ve);
                    const Pt = r.XpG(4);
                    return r.Njj(Pt.onImageLoad())
                })("click", function() {
                    r.eBV(Ve);
                    const Pt = r.XpG(4);
                    return r.Njj(Pt.onPhotoSelect())
                }),
                r.k0s()
            }
            if (2 & W) {
                const Ve = r.XpG(2).ngIf
                  , fe = r.XpG(2);
                r.Y8G("src", fe.getPhotoWithType(Ve).imageUrl, r.B4B)
            }
        }
        function tt(W, ae) {
            if (1 & W) {
                const Ve = r.RV6();
                r.j41(0, "pp-controls-file-uploader-photo", 33),
                r.nI1(1, "translate"),
                r.bIt("setFileUploadingProgress", function(Pt) {
                    r.eBV(Ve);
                    const mt = r.XpG(4);
                    return r.Njj(mt.setFileUpploadingProgress.emit(Pt))
                }),
                r.k0s()
            }
            if (2 & W) {
                const Ve = r.XpG(4);
                r.Y8G("photoFileGroup", Ve.photoFileGroup)("photoCropGroup", Ve.photoCropGroup)("photoId", Ve.photoId)("multiFile", Ve.multiFile)("isSubmitted", !1)("acceptable", r.lJ4(13, Ft))("isBase64Response", !0)("fullHeight", !0)("isBigPictureMode", !0)("isFileUploadingInProgress", Ve.isFileUploadingInProgress)("legalNote", r.bMT(1, 11, "soundwave.details.instruction"))
            }
        }
        function $t(W, ae) {
            if (1 & W && (r.j41(0, "div", 29),
            r.DNE(1, St, 1, 1, "img", 30)(2, tt, 2, 14, "pp-controls-file-uploader-photo", 31),
            r.k0s()),
            2 & W) {
                const Ve = r.XpG().ngIf
                  , fe = r.XpG(2);
                r.xc7("margin-top", fe.stars.shape === fe.StarsShapesEnum.HEARTS_PHOTO ? -.06 * fe.stars.width : 0, "px"),
                r.AVh("special-heart", fe.stars.shape === fe.StarsShapesEnum.HEARTS_PHOTO)("special-circle", fe.stars.shape === fe.StarsShapesEnum.CIRCLES_PHOTO),
                r.R7$(),
                r.vxM(fe.getPhotoWithType(Ve).showAddPhoto ? fe.photoFileGroup && fe.getPhotoWithType(Ve).showAddPhoto ? 2 : -1 : 1)
            }
        }
        function Nt(W, ae) {
            if (1 & W && (r.j41(0, "div", 22),
            r.DNE(1, lt, 3, 5)(2, $t, 3, 7, "div", 23),
            r.k0s()),
            2 & W) {
                const Ve = ae.ngIf
                  , fe = r.XpG().elementId
                  , Pt = r.XpG();
                r.xc7("width", Pt.stars.height, "px")("height", Pt.stars.height, "px"),
                r.AVh("special-punching-die", Pt.isRasterBackground(Pt.stars.colorScheme) && !(1 === fe && r.l_i(17, mo, Pt.StarsShapesEnum.CIRCLES_PHOTO, Pt.StarsShapesEnum.HEARTS_PHOTO).includes(Pt.stars.shape)))("special-heart", Pt.stars.shape === Pt.StarsShapesEnum.HEARTS || Pt.stars.shape === Pt.StarsShapesEnum.CIRCLES_HEART && 1 === fe)("special-circle", r.eq3(20, Co, Pt.StarsShapesEnum.CIRCLES).includes(Pt.stars.shape) || r.sMw(22, Lt, Pt.StarsShapesEnum.CIRCLES_HEART, Pt.StarsShapesEnum.CIRCLES_PHOTO, Pt.StarsShapesEnum.HEARTS_PHOTO).includes(Pt.stars.shape) && 1 !== fe)("special-sky", Pt.stars.colorScheme === Pt.StarsColorSchemeEnum.SKY)("special-emerald", Pt.stars.colorScheme === Pt.StarsColorSchemeEnum.EMERALD)("special-purple-galaxy", Pt.stars.colorScheme === Pt.StarsColorSchemeEnum.PURPLE_GALAXY),
                r.R7$(),
                r.vxM(Pt.getPhotoWithType(Ve).isPhoto ? 2 : 1)
            }
        }
        function Vt(W, ae) {
            if (1 & W && (r.j41(0, "div", 35),
            r.nrm(1, "div", 36)(2, "div", 37)(3, "div", 38)(4, "div", 39),
            r.k0s()),
            2 & W) {
                const Ve = r.XpG(3);
                r.R7$(),
                r.xc7("width", Ve.stars.punchingDieLineSize, "px")("background-color", Ve.stars.background),
                r.R7$(),
                r.xc7("height", Ve.stars.punchingDieLineSize, "px")("background-color", Ve.stars.background),
                r.R7$(),
                r.xc7("height", Ve.stars.punchingDieLineSize, "px")("background-color", Ve.stars.background),
                r.R7$(),
                r.xc7("width", Ve.stars.punchingDieLineSize, "px")("background-color", Ve.stars.background)
            }
        }
        function _o(W, ae) {
            if (1 & W && (r.nrm(0, "svg-icon", 34),
            r.DNE(1, Vt, 5, 16, "div", 35)),
            2 & W) {
                const Ve = r.XpG().starElement
                  , fe = r.XpG();
                r.Y8G("svgStyle", r.l_i(3, co, fe.stars.background, fe.stars.stroke))("src", "/assets/pp-posters/stars/double-punching-die/shape-" + (Ve.shape === fe.StarsShapesEnum.CIRCLES ? "circle" : "heart") + ".svg"),
                r.R7$(),
                r.vxM(fe.stars.punchingDieLineSize ? 1 : -1)
            }
        }
        function Lo(W, ae) {
            if (1 & W && (r.j41(0, "div", 42),
            r.nrm(1, "svg-icon", 43),
            r.k0s()),
            2 & W) {
                const Ve = r.XpG(4);
                r.xc7("margin-top", Ve.Math.round(Ve.stars.specialShieldMiddleMarginTop), "px")("margin-left", Ve.Math.round(-.062 * Ve.stars.specialShieldMiddleHeight), "px")("height", Ve.Math.round(Ve.stars.specialShieldMiddleHeight), "px")("width", Ve.Math.round(1.1126213592 * Ve.stars.specialShieldMiddleHeight), "px"),
                r.R7$(),
                r.Y8G("svgStyle", r.lJ4(10, Jt))("src", "/assets/pp-posters/stars/shields/heart.svg")
            }
        }
        function ao(W, ae) {
            if (1 & W && (r.j41(0, "div", 42),
            r.nrm(1, "svg-icon", 43),
            r.k0s()),
            2 & W) {
                const Ve = r.XpG(4);
                r.xc7("margin-top", Ve.Math.round(Ve.stars.specialShieldMarginTop), "px")("height", Ve.Math.round(Ve.stars.specialShieldHeight), "px"),
                r.R7$(),
                r.Y8G("svgStyle", r.lJ4(6, Jt))("src", "/assets/pp-posters/stars/shields/heart.svg")
            }
        }
        function bt(W, ae) {
            if (1 & W && r.DNE(0, Lo, 2, 11, "div", 41)(1, ao, 2, 7, "div", 40),
            2 & W) {
                const Ve = r.XpG(3);
                r.vxM(Ve.stars.shape === Ve.StarsShapesEnum.CIRCLES_HEART ? 0 : 1)
            }
        }
        function Do(W, ae) {
            if (1 & W && (r.j41(0, "div", 42),
            r.nrm(1, "svg-icon", 43),
            r.k0s()),
            2 & W) {
                const Ve = r.XpG(3);
                r.xc7("margin-top", Ve.Math.round(Ve.stars.specialShieldMarginTop), "px")("height", Ve.Math.round(Ve.stars.specialShieldHeight), "px"),
                r.R7$(),
                r.Y8G("svgStyle", r.lJ4(6, Jt))("src", "/assets/pp-posters/stars/shields/circle.svg")
            }
        }
        function Xt(W, ae) {
            if (1 & W && r.DNE(0, bt, 2, 1)(1, Do, 2, 7, "div", 40),
            2 & W) {
                const Ve = r.XpG().elementId
                  , fe = r.XpG();
                r.vxM(fe.stars.shape === fe.StarsShapesEnum.HEARTS || fe.stars.shape === fe.StarsShapesEnum.CIRCLES_HEART && 1 === Ve ? 0 : r.l_i(1, mo, fe.StarsShapesEnum.CIRCLES_PHOTO, fe.StarsShapesEnum.HEARTS_PHOTO).includes(fe.stars.shape) && 1 === Ve ? -1 : 1)
            }
        }
        function ie(W, ae) {
            if (1 & W && (r.j41(0, "pp-poster-image-area")(1, "div", 13)(2, "div", 14),
            r.DNE(3, At, 1, 11, "div", 15)(4, ne, 2, 3),
            r.k0s(),
            r.DNE(5, Nt, 3, 26, "div", 16),
            r.nI1(6, "async"),
            r.j41(7, "div", 17),
            r.DNE(8, _o, 2, 6),
            r.k0s()(),
            r.DNE(9, Xt, 2, 4),
            r.k0s(),
            r.nrm(10, "pp-poster-text-area", 18),
            r.nI1(11, "async"),
            r.nI1(12, "async"),
            r.nI1(13, "async"),
            r.nI1(14, "async"),
            r.nI1(15, "async"),
            r.nI1(16, "async")),
            2 & W) {
                const Ve = ae.title$
                  , fe = ae.footer$
                  , Pt = ae.date$
                  , mt = ae.photo$
                  , xo = ae.starElement
                  , So = ae.elementId
                  , ro = r.XpG();
                r.R7$(),
                r.xc7("margin-top", ro.stars.marginTop + xo.additionalMargin, "px")("width", ro.stars.width, "px")("height", ro.stars.height, "px")("scale", xo.scale),
                r.R7$(),
                r.xc7("padding", ro.stars.padding, "px")("width", ro.stars.height, "px")("height", ro.stars.height, "px"),
                r.AVh("force-background-area", (ro.stars.shape === ro.StarsShapesEnum.HEARTS_PHOTO || ro.stars.shape === ro.StarsShapesEnum.CIRCLES_PHOTO) && 1 === So),
                r.R7$(),
                r.vxM(1 === So && ro.stars.shape === ro.StarsShapesEnum.HEARTS_PHOTO ? 4 : 3),
                r.R7$(2),
                r.Y8G("ngIf", r.bMT(6, 28, mt)),
                r.R7$(2),
                r.xc7("padding", ro.stars.punchingDiePadding, "px"),
                r.R7$(),
                r.vxM(ro.isRasterBackground(ro.stars.colorScheme) || 1 === So && r.l_i(42, mo, ro.StarsShapesEnum.CIRCLES_PHOTO, ro.StarsShapesEnum.HEARTS_PHOTO).includes(ro.stars.shape) ? -1 : 8),
                r.R7$(),
                r.vxM(ro.isRasterBackground(ro.stars.colorScheme) && r.s1E(45, no, ro.StarsShapesEnum.CIRCLES, ro.StarsShapesEnum.HEARTS, ro.StarsShapesEnum.CIRCLES_HEART, ro.StarsShapesEnum.CIRCLES_PHOTO, ro.StarsShapesEnum.HEARTS_PHOTO).includes(ro.stars.shape) ? 9 : -1),
                r.R7$(),
                r.Y8G("poster", r.bMT(11, 30, ro.poster$))("color", r.bMT(12, 32, ro.textColor$))("textArea", r.bMT(13, 34, ro.textArea$))("title", r.bMT(14, 36, Ve))("footer", r.bMT(15, 38, fe))("date", r.bMT(16, 40, Pt))
            }
        }
        function we(W, ae) {
            1 & W && r.nrm(0, "pp-poster-loaded-element")
        }
        function Oe(W, ae) {
            if (1 & W && (r.SS7(0)(1),
            r.qSk(),
            r.j41(2, "svg", 44)(3, "defs")(4, "mask", 45),
            r.nrm(5, "circle", 46),
            r.k0s()()(),
            r.SS7(6)(7),
            r.j41(8, "svg", 44)(9, "defs")(10, "mask", 47),
            r.nrm(11, "circle", 46),
            r.k0s()()(),
            r.SS7(12)(13)(14)(15),
            r.j41(16, "svg", 48)(17, "defs")(18, "mask", 49),
            r.nrm(19, "path", 50),
            r.k0s()()(),
            r.SS7(20)(21),
            r.j41(22, "svg", 48)(23, "defs")(24, "mask", 51),
            r.nrm(25, "path", 50),
            r.k0s()()()),
            2 & W) {
                const Ve = r.XpG()
                  , fe = Ve.stars.width / 2
                  , Pt = .85 * fe;
                r.R7$(2),
                r.BMQ("width", fe)("height", fe),
                r.R7$(3),
                r.BMQ("cx", fe)("cy", fe)("r", Pt);
                const mt = Ve.stars.width / 2
                  , xo = .99 * fe;
                r.R7$(3),
                r.BMQ("width", mt)("height", mt),
                r.R7$(3),
                r.BMQ("cx", mt)("cy", mt)("r", xo);
                const So = .97 * Ve.stars.width
                  , ro = So / 1777
                  , Vo = (Ve.stars.width - So) / 2
                  , vo = 2 * -Vo;
                r.R7$(5),
                r.BMQ("width", So)("height", So)("viewBox", "0 0 1777 1777"),
                r.R7$(3),
                r.BMQ("transform", "translate(" + Vo + ", " + vo + ") scale(" + ro + "," + ro + ")");
                const ei = Ve.stars.width
                  , Ti = ei / 1777;
                r.R7$(3),
                r.BMQ("width", ei)("height", ei)("viewBox", "0 0 1777 1777"),
                r.R7$(3),
                r.BMQ("transform", "scale(" + Ti + "," + Ti + ")")
            }
        }
        let ee = ( () => {
            var W;
            class ae extends Xe.l {
                constructor(fe, Pt, mt, xo, So) {
                    super(fe, Pt, mt, xo, So),
                    this.host = fe,
                    this.zone = Pt,
                    this.httpClient = mt,
                    this.domSanitizer = xo,
                    this.cdr = So,
                    this.photoId = 0,
                    this.multiFile = !1,
                    this.photoSelect = new r.bkB,
                    this.setFileUpploadingProgress = new r.bkB,
                    this.isFileUploadingInProgress = !1,
                    this.title1$ = new Qe.t(null),
                    this.footer1$ = new Qe.t(null),
                    this.date1$ = new Qe.t(null),
                    this.title2$ = new Qe.t(null),
                    this.footer2$ = new Qe.t(null),
                    this.date2$ = new Qe.t(null),
                    this.title3$ = new Qe.t(null),
                    this.footer3$ = new Qe.t(null),
                    this.date3$ = new Qe.t(null),
                    this.stars = {
                        marginTop: 0,
                        width: 0,
                        height: 0,
                        padding: 0,
                        background: "#FFF",
                        circleBackground: "transparent",
                        stroke: "transparent",
                        colorScheme: Ae.th1.COSMIC_LOVE,
                        shape: Ae.nhL.CIRCLES,
                        punchingDiePadding: 0,
                        punchingDieLineSize: 0,
                        specialShieldMarginTop: 0,
                        specialShieldHeight: 0,
                        specialShieldMiddleMarginTop: 0,
                        specialShieldMiddleHeight: 0,
                        isPortrait: !1
                    },
                    this.starElement1 = {
                        scale: 1,
                        shape: Ae.nhL.CIRCLES,
                        uuid: void 0,
                        image: "",
                        additionalMargin: 0
                    },
                    this.starElement2 = {
                        scale: 1,
                        shape: Ae.nhL.CIRCLES,
                        uuid: void 0,
                        image: "",
                        additionalMargin: 0
                    },
                    this.starElement3 = {
                        scale: 1,
                        shape: Ae.nhL.CIRCLES,
                        uuid: void 0,
                        image: "",
                        additionalMargin: 0
                    },
                    this.appConfiguration1$ = new Qe.t(null),
                    this.appConfiguration2$ = new Qe.t(null),
                    this.appConfiguration3$ = new Qe.t(null),
                    this.skyConfiguration$ = new Qe.t(null),
                    this.location1$ = new Qe.t(null),
                    this.photo1$ = new Qe.t(null),
                    this.location2$ = new Qe.t(null),
                    this.photo2$ = new Qe.t(null),
                    this.location3$ = new Qe.t(null),
                    this.photo3$ = new Qe.t(null),
                    this.topTextAreaHeight$ = new Qe.t(null),
                    this.topTextAreaWidth$ = new Qe.t(null),
                    this.splitElementsSize$ = new Qe.t({
                        width: 0,
                        height: 0,
                        marginTop: 0
                    }),
                    this.StarsShapesEnum = Ae.nhL,
                    this.Math = Math
                }
                ngAfterViewInit() {
                    (0,
                    it.z)([this.poster$, this.topTextArea$, this.topTextAreaHeight$, this.topTextAreaWidth$, this.posterConfiguration$]).pipe((0,
                    re.B)(200), (0,
                    et.Q)(this.ngUnsubscribe)).subscribe( ([fe,Pt,mt,xo,So]) => {
                        var ro, Vo;
                        mt || (mt = 0);
                        const vo = null !== (ro = fe.size.height) && void 0 !== ro ? ro : 0;
                        let ei = fe.size.height - (mt + (null !== (Vo = Pt.topFactor) && void 0 !== Vo ? Vo : 0) * vo)
                          , Ti = 0;
                        !(null != So && So.title) && null != So && So.subtitle && (Ti = .011 * fe.size.height,
                        ei -= 2 * Ti),
                        (!(null != So && So.title) && !(null != So && So.subtitle) || !(null != So && So.mainTextEnable)) && (Ti = .044 * fe.size.height,
                        ei -= 2 * Ti),
                        this.isNarrowRatio(fe) && (ei *= .97),
                        this.splitElementsSize$.next({
                            width: .98 * fe.size.width,
                            height: ei,
                            marginTop: Ti
                        })
                    }
                    )
                }
                setAllTextSettings(fe) {
                    const Pt = fe.starMapConfig[0]
                      , mt = fe.starMapConfig[1]
                      , xo = fe.starMapConfig[2]
                      , So = {
                        text: fe.mainTextEnable ? fe.title : "",
                        isDefaultFont: fe.titleFont
                    }
                      , ro = {
                        text: fe.mainTextEnable ? fe.subtitle : "",
                        isDefaultFont: !0
                    }
                      , Vo = null != So && So.isDefaultFont ? .08 : .06;
                    this.setText(So, this.title$, {
                        font: null != So && So.isDefaultFont ? Ae.n3q.POSITIVE_PRINTS_SCRIPT_2 : Ae.n3q.CAPSUULA_BOLD,
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: Vo,
                            bottomFactor: 0,
                            lineHeightFactor: Vo * (null != So && So.isDefaultFont ? 1.35 : 1.8),
                            topFactor: ro.text ? 0 : .015,
                            isBold: !1
                        }
                    }),
                    this.setText(ro, this.subtitle$, {
                        font: Ae.n3q.CAPSUULA,
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: .032,
                            bottomFactor: 0,
                            lineHeightFactor: .04,
                            maxLines: 2,
                            topFactor: So.text ? -.01 : .025
                        }
                    });
                    const ei = {
                        text: Pt.title,
                        isDefaultFont: Pt.titleFont,
                        showEmptyLine: !0
                    }
                      , Ti = {
                        text: mt.title,
                        isDefaultFont: mt.titleFont,
                        showEmptyLine: !0
                    }
                      , ci = {
                        text: xo.title,
                        isDefaultFont: xo.titleFont,
                        showEmptyLine: !0
                    }
                      , ji = xt => ({
                        font: null != xt && xt.isDefaultFont ? Ae.n3q.POSITIVE_PRINTS_SCRIPT_2 : Ae.n3q.CAPSUULA_BOLD,
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: null != xt && xt.isDefaultFont ? .052 : .036,
                            bottomFactor: 0,
                            lineHeightFactor: .058 * 1.34,
                            maxLines: 1,
                            topFactor: 0,
                            isBold: !1
                        }
                    });
                    this.setText(ei, this.title1$, ji(ei)),
                    this.setText(Ti, this.title2$, ji(Ti)),
                    this.setText(ci, this.title3$, ji(ci));
                    const yn = fe.shape === Ae.nhL.HEARTS_PHOTO || fe.shape === Ae.nhL.CIRCLES_PHOTO
                      , Ln = {
                        font: Ae.n3q.CAPSUULA,
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: .018,
                            bottomFactor: 0,
                            lineHeightFactor: .018 * 1.22,
                            topFactor: .0268
                        }
                    };
                    this.setText({
                        text: Pt.coordinates,
                        isDefaultFont: !0,
                        showEmptyLine: !0
                    }, this.footer1$, Ln),
                    this.setText({
                        text: yn ? mt.photoFootnote1 : mt.coordinates,
                        isDefaultFont: !0,
                        showEmptyLine: !0
                    }, this.footer2$, Ln),
                    this.setText({
                        text: xo.coordinates,
                        isDefaultFont: !0,
                        showEmptyLine: !0
                    }, this.footer3$, Ln);
                    const Lr = {
                        ...Ln,
                        horizontal: {
                            ...Ln.horizontal,
                            topFactor: .00335
                        }
                    };
                    this.setText({
                        text: Pt.dateField,
                        isDefaultFont: !0,
                        showEmptyLine: !0
                    }, this.date1$, Lr),
                    this.setText({
                        text: yn ? mt.photoFootnote2 : mt.dateField,
                        isDefaultFont: !0,
                        showEmptyLine: !0
                    }, this.date2$, Lr),
                    this.setText({
                        text: xo.dateField,
                        isDefaultFont: !0,
                        showEmptyLine: !0
                    }, this.date3$, Lr)
                }
                setTextArea(fe, Pt) {
                    this.topTextArea$.next({
                        topFactor: this.isWideRatio(fe, !1) ? .07 : .082,
                        marginFactor: .09
                    });
                    let mt = .12;
                    Pt.mainTextEnable && (Pt.title || Pt.subtitle) && (mt = Pt.titleFont ? .068 : Pt.subtitle && !Pt.title ? .12 : Pt.subtitle ? .07 : this.isWideRatio(fe, !1) ? .05 : .08),
                    this.textArea$.next({
                        bottomFactor: mt,
                        marginFactor: .01
                    })
                }
                newTopTextareaHeight(fe) {
                    this.topTextAreaHeight$.next(fe)
                }
                newTopTextareaWidth(fe) {
                    this.topTextAreaWidth$.next(fe)
                }
                setDesign(fe, Pt) {
                    var mt = this;
                    return (0,
                    Ut.A)(function*() {
                        var xo, So, ro;
                        mt.setMap(Pt);
                        const Vo = Pt.starMapConfig[0]
                          , vo = Pt.starMapConfig[1]
                          , ei = Pt.starMapConfig[2];
                        mt.stars.colorScheme = Pt.colorScheme,
                        mt.stars.shape = Pt.shape,
                        mt.starElement1.scale = [Ae.nhL.CIRCLES_HEART, Ae.nhL.HEARTS_PHOTO].includes(mt.stars.shape) ? .85 : 1,
                        mt.starElement1.shape = mt.stars.shape === Ae.nhL.HEARTS ? Ae.nhL.HEARTS : Ae.nhL.CIRCLES,
                        mt.starElement2.scale = [Ae.nhL.CIRCLES_HEART, Ae.nhL.HEARTS_PHOTO].includes(mt.stars.shape) ? 1.2 : [Ae.nhL.CIRCLES_PHOTO].includes(mt.stars.shape) ? 1.06 : 1,
                        mt.starElement2.shape = mt.stars.shape === Ae.nhL.CIRCLES ? Ae.nhL.CIRCLES : Ae.nhL.HEARTS,
                        mt.starElement3.scale = [Ae.nhL.CIRCLES_HEART, Ae.nhL.HEARTS_PHOTO].includes(mt.stars.shape) ? .85 : 1,
                        mt.starElement3.shape = mt.stars.shape === Ae.nhL.HEARTS ? Ae.nhL.HEARTS : Ae.nhL.CIRCLES;
                        const Ti = [Ae.nhL.CIRCLES_HEART, Ae.nhL.HEARTS_PHOTO].includes(mt.stars.shape) ? .035 * fe.size.height : 0;
                        if (mt.starElement1.additionalMargin = Ti,
                        mt.starElement3.additionalMargin = Ti,
                        mt.setSizes(fe),
                        mt.stars.background = mt.starsBackground(Pt.colorScheme, Pt.customColors, mt.isFinalPoster, "landscape"),
                        mt.stars.stroke = mt.starsStroke(Pt.colorScheme, Pt.customColors),
                        mt.stars.circleBackground = mt.circleColor(Pt.colorScheme, Pt.customColors),
                        mt.textColor$.next(mt.textColor(Pt.colorScheme, Pt.customColors)),
                        !mt.isSvgStars)
                            return;
                        mt.starElement1.uuid = Vo.uuid,
                        mt.starElement2.uuid = vo.uuid,
                        mt.starElement3.uuid = ei.uuid;
                        const ci = yield Promise.all([mt.httpClient.get("/api/stars/d3-celestial/svg", {
                            params: {
                                uuid: null !== (xo = mt.starElement1.uuid) && void 0 !== xo ? xo : ""
                            },
                            responseType: "text"
                        }).toPromise(), mt.httpClient.get("/api/stars/d3-celestial/svg", {
                            params: {
                                uuid: null !== (So = mt.starElement2.uuid) && void 0 !== So ? So : ""
                            },
                            responseType: "text"
                        }).toPromise(), mt.httpClient.get("/api/stars/d3-celestial/svg", {
                            params: {
                                uuid: null !== (ro = mt.starElement3.uuid) && void 0 !== ro ? ro : ""
                            },
                            responseType: "text"
                        }).toPromise()]);
                        !ci || !ci[0] || !ci[1] || !ci[2] || (mt.starElement1.uuid && (mt.starElement1.image = mt.domSanitizer.bypassSecurityTrustHtml(mt.getImage(ci[0])),
                        requestAnimationFrame(mt.onImageLoad.bind(mt))),
                        mt.starElement2.uuid && (mt.starElement2.image = mt.domSanitizer.bypassSecurityTrustHtml(mt.getImage(ci[1])),
                        requestAnimationFrame(mt.onImageLoad.bind(mt))),
                        mt.starElement3.uuid && (mt.starElement3.image = mt.domSanitizer.bypassSecurityTrustHtml(mt.getImage(ci[2])),
                        requestAnimationFrame(mt.onImageLoad.bind(mt))))
                    })()
                }
                isWideRatio(fe, Pt) {
                    return Pt ? fe.size.height / fe.size.width < .7 : fe.size.height / fe.size.width <= .7
                }
                isNarrowRatio(fe) {
                    return fe.size.height / fe.size.width >= .8
                }
                getPhotoWithType(fe) {
                    return fe
                }
                onPhotoSelect() {
                    this.photoSelect.emit([this.imageInstanceSize.width, this.imageInstanceSize.height])
                }
                setSizes(fe) {
                    this.stars.width = .98 * fe.size.width / 3,
                    this.stars.height = this.stars.width,
                    this.stars.marginTop = .09 * this.stars.height,
                    this.imageInstanceSize = {
                        width: this.stars.width,
                        height: this.stars.width
                    },
                    this.stars.padding = .01 * this.stars.width,
                    this.stars.punchingDiePadding = .055 * this.stars.width,
                    this.stars.punchingDieLineSize = .061 * this.stars.width,
                    this.stars.shape === Ae.nhL.HEARTS && this.isRasterBackground(this.stars.colorScheme) ? (this.stars.specialShieldMarginTop = .0855 * fe.size.height,
                    this.stars.specialShieldHeight = .845 * this.stars.height) : [Ae.nhL.CIRCLES_HEART, Ae.nhL.HEARTS_PHOTO].includes(this.stars.shape) && this.isRasterBackground(this.stars.colorScheme) ? (this.stars.specialShieldMarginTop = 3.18 * this.stars.marginTop,
                    this.stars.specialShieldHeight = .767 * this.stars.height,
                    this.stars.specialShieldMiddleMarginTop = .41 * this.stars.specialShieldMarginTop,
                    this.stars.specialShieldMiddleHeight = 1.32 * this.stars.specialShieldHeight) : (this.stars.specialShieldMarginTop = 1.55 * this.stars.marginTop,
                    this.stars.specialShieldHeight = .902 * this.stars.height)
                }
                onImageLoad() {
                    this.load++,
                    3 === this.load && (this.initiateRender(),
                    this.cdr.detectChanges())
                }
                setMap(fe) {
                    var Pt, mt, xo;
                    const So = fe.starMapConfig[0]
                      , ro = fe.starMapConfig[1]
                      , Vo = fe.starMapConfig[2];
                    null != So && So.date && null != So && null !== (Pt = So.place) && void 0 !== Pt && Pt.center && this.location1$.next({
                        UTCTimestamp: So.date,
                        timezone: So.timezone,
                        lat: So.place.center.latitude,
                        lng: So.place.center.longitude
                    }),
                    null != ro && ro.date && null != ro && null !== (mt = ro.place) && void 0 !== mt && mt.center && this.location2$.next({
                        UTCTimestamp: ro.date,
                        timezone: ro.timezone,
                        lat: ro.place.center.latitude,
                        lng: ro.place.center.longitude
                    }),
                    null != Vo && Vo.date && null != Vo && null !== (xo = Vo.place) && void 0 !== xo && xo.center && this.location3$.next({
                        UTCTimestamp: Vo.date,
                        timezone: Vo.timezone,
                        lat: Vo.place.center.latitude,
                        lng: Vo.place.center.longitude
                    }),
                    this.photo1$.next({
                        isPhoto: !1,
                        isHeart: !1,
                        uuid: "",
                        imageUrl: "",
                        showAddPhoto: !1
                    }),
                    this.photo2$.next({
                        isPhoto: fe.shape === Ae.nhL.CIRCLES_PHOTO || fe.shape === Ae.nhL.HEARTS_PHOTO,
                        isHeart: fe.shape === Ae.nhL.HEARTS_PHOTO,
                        uuid: ro.photoFiles[0].uuid,
                        imageUrl: "".concat(this.environmentPhotoApi, "/v2/").concat(this.isFinalPoster ? "photo" : "image", "/").concat(ro.photoFiles[0].uuid, "?type=").concat(ro.cropsData[0].filter, "&left=").concat(ro.cropsData[0].cropData.x, "&top=").concat(ro.cropsData[0].cropData.y, "&width=").concat(ro.cropsData[0].cropData.width, "&height=").concat(ro.cropsData[0].cropData.height, "&rotate=").concat(ro.cropsData[0].rotate, "&flipped=").concat(ro.cropsData[0].flip),
                        showAddPhoto: !ro.photoFiles[0].uuid
                    }),
                    this.photo3$.next({
                        isPhoto: !1,
                        isHeart: !1,
                        uuid: "",
                        imageUrl: "",
                        showAddPhoto: !1
                    }),
                    this.skyConfiguration$.next({
                        ecliptic: fe.ecliptic,
                        constellations: fe.constellations,
                        constellationsName: fe.constellationsName,
                        planets: fe.planets,
                        planetNames: fe.planetNames,
                        milkyWay: fe.milkyWay,
                        grid: fe.grid,
                        moon: fe.moon,
                        colorScheme: fe.colorScheme,
                        shape: fe.shape,
                        jewelryColors: pt.fd[fe.material],
                        jewelryBackground: pt.x_[fe.material],
                        language: fe.lang,
                        ...fe.customColors
                    });
                    const vo = {
                        size: 360,
                        starLimit: this.isMobile ? 4.5 : 5.1,
                        starSize: this.isMobile ? 3.15 : 4.5,
                        lineWidth: this.isMobile ? .3 : .4,
                        isJewelry: !1
                    };
                    this.appConfiguration1$.next({
                        ...vo,
                        id: 1,
                        containerId: "celestial-map-1"
                    }),
                    this.appConfiguration2$.next({
                        ...vo,
                        id: 2,
                        containerId: "celestial-map-2"
                    }),
                    this.appConfiguration3$.next({
                        ...vo,
                        id: 3,
                        containerId: "celestial-map-3"
                    })
                }
                getImage(fe) {
                    let mt = (new DOMParser).parseFromString(fe, "image/svg+xml");
                    return mt = (0,
                    jt.t2)(mt, !1),
                    mt = (0,
                    jt.Jr)(mt),
                    mt.documentElement.outerHTML
                }
            }
            return (W = ae).\u0275fac = function(fe) {
                return new (fe || W)(r.rXU(r.aKT),r.rXU(r.SKi),r.rXU(Ie.Qq),r.rXU(gt.up),r.rXU(r.gRc))
            }
            ,
            W.\u0275cmp = r.VBU({
                type: W,
                selectors: [["pp-poster-stars-triple"]],
                inputs: {
                    photoFileGroup: "photoFileGroup",
                    photoCropGroup: "photoCropGroup",
                    photoId: "photoId",
                    multiFile: "multiFile",
                    environmentPhotoApi: "environmentPhotoApi",
                    isFileUploadingInProgress: "isFileUploadingInProgress"
                },
                outputs: {
                    photoSelect: "photoSelect",
                    setFileUpploadingProgress: "setFileUpploadingProgress"
                },
                features: [r.Vt3],
                decls: 9,
                vars: 8,
                consts: [["posterWrapper", ""], ["singleElement", ""], ["starsSvg", ""], [3, "background"], [3, "poster", 4, "ngIf"], [4, "ngIf"], [3, "poster"], [3, "textareaHeightCallback", "textareaWidthCallback", "poster", "color", "textArea", "title", "subtitle"], [3, "isTriple", "width", "height", "marginTop", 4, "ngIf"], [3, "isTriple"], ["first", "", 3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["second", "", 3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["third", "", 3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "stars-instance"], [1, "background-area"], [1, "circle-background", 3, "background", "special-sky", "special-emerald", "special-purple-galaxy"], ["class", "stars-area", 3, "special-punching-die", "special-heart", "special-circle", "special-sky", "special-emerald", "special-purple-galaxy", "width", "height", 4, "ngIf"], [1, "punching-die"], [3, "poster", "color", "textArea", "title", "footer", "date"], [1, "circle-background"], [1, "photo-heart-background", 3, "marginTop", "special-sky", "special-emerald", "special-purple-galaxy", "background"], [1, "photo-heart-background"], [1, "stars-area"], [1, "photo-instance", 3, "marginTop", "special-heart", "special-circle"], [3, "appConfiguration", "location", "skyConfiguration", 4, "ngIf"], ["class", "stars-svg", 3, "preview", "innerHTML", 4, "ngIf"], [3, "showPreview", "marginTop", "previewType"], [3, "appConfiguration", "location", "skyConfiguration"], [1, "stars-svg", 3, "innerHTML"], [1, "photo-instance"], [3, "src"], [3, "photoFileGroup", "photoCropGroup", "photoId", "multiFile", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "isFileUploadingInProgress", "legalNote"], [3, "load", "click", "src"], [3, "setFileUploadingProgress", "photoFileGroup", "photoCropGroup", "photoId", "multiFile", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "isFileUploadingInProgress", "legalNote"], [3, "svgStyle", "src"], [1, "punching-die-line"], [1, "punching-die-line-left"], [1, "punching-die-line-top"], [1, "punching-die-line-bottom"], [1, "punching-die-line-right"], [1, "special-shield", 3, "marginTop", "height"], [1, "special-shield", 3, "marginTop", "marginLeft", "height", "width"], [1, "special-shield"], [1, "special-shield-image-to-style", 3, "svgStyle", "src"], ["shape-rendering", "geometricPrecision", 2, "position", "absolute"], ["id", "circleClipPath"], ["fill", "white"], ["id", "circlePhotoClipPath"], [2, "top", "0", "position", "absolute"], ["id", "heartClipPath"], ["fill", "white", "d", "M1666.1,954.9h0s-56.1,217.2-319.8,454c-238.8,214.4-457.8,325.9-457.8,325.9,0,0-219-111.5-457.8-325.9-263.6-236.7-319.8-454-319.8-454-89.7-290.5,54-462.9,54-462.9,0,0,136.4-188.9,368.9-188.9s354.6,209.8,354.6,209.8c0,0,122.1-209.8,354.6-209.8s368.9,188.9,368.9,188.9c0,0,143.7,172.4,54,462.9h.2Z"], ["id", "heartPhotoClipPath"]],
                template: function(fe, Pt) {
                    if (1 & fe && (r.j41(0, "pp-poster-background", 3, 0),
                    r.DNE(2, Kt, 10, 19, "pp-poster-printing-registration", 4),
                    r.nI1(3, "async"),
                    r.k0s(),
                    r.DNE(4, ie, 17, 51, "ng-template", null, 1, r.C5r)(6, we, 1, 0, "pp-poster-loaded-element", 5)(7, Oe, 26, 18),
                    r.nI1(8, "async")),
                    2 & fe) {
                        let mt;
                        r.Y8G("background", Pt.stars.background),
                        r.R7$(2),
                        r.Y8G("ngIf", r.bMT(3, 4, Pt.poster$)),
                        r.R7$(4),
                        r.Y8G("ngIf", Pt.isImageRendered),
                        r.R7$(),
                        r.vxM((mt = r.bMT(8, 6, Pt.poster$)) ? 7 : -1, mt)
                    }
                },
                dependencies: [_t.MD, _t.bT, _t.T3, _t.Jj, Mt.Z, s.R, Wt.c, so.y, ct.Y, Me.iu, Me.DM, Tt.W, Ce.G, Be.C, ze.ex, ye.h, ye.D9, ge.P],
                styles: ["[_nghost-%COMP%]{width:100%;height:100%;display:block}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]{box-sizing:border-box;position:relative;overflow:hidden}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .background-area[_ngcontent-%COMP%]{width:100%;height:100%;box-sizing:border-box;margin:auto}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .background-area[_ngcontent-%COMP%]   .circle-background[_ngcontent-%COMP%]{width:100%;height:100%;border-radius:50%;box-sizing:border-box}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .background-area[_ngcontent-%COMP%]   .photo-heart-background[_ngcontent-%COMP%]{width:100%;height:100%;box-sizing:border-box;-webkit-mask:url(#heartPhotoClipPath);mask:url(#heartPhotoClipPath)}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .stars-area[_ngcontent-%COMP%]{margin:auto;position:absolute;top:0;right:0;bottom:0;left:0}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]{position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]   .punching-die-line[_ngcontent-%COMP%]{position:absolute;top:0;left:0;right:0;bottom:0}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]   .punching-die-line[_ngcontent-%COMP%]   .punching-die-line-left[_ngcontent-%COMP%], [_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]   .punching-die-line[_ngcontent-%COMP%]   .punching-die-line-right[_ngcontent-%COMP%]{position:absolute;top:0;height:100%;background:#fff}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]   .punching-die-line[_ngcontent-%COMP%]   .punching-die-line-left[_ngcontent-%COMP%]{left:0}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]   .punching-die-line[_ngcontent-%COMP%]   .punching-die-line-right[_ngcontent-%COMP%]{right:0}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]   .punching-die-line[_ngcontent-%COMP%]   .punching-die-line-top[_ngcontent-%COMP%], [_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]   .punching-die-line[_ngcontent-%COMP%]   .punching-die-line-bottom[_ngcontent-%COMP%]{position:absolute;width:100%;background:#fff;left:0}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]   .punching-die-line[_ngcontent-%COMP%]   .punching-die-line-top[_ngcontent-%COMP%]{top:0}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]   .punching-die-line[_ngcontent-%COMP%]   .punching-die-line-bottom[_ngcontent-%COMP%]{bottom:0}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .shield-border[_ngcontent-%COMP%]{position:absolute;top:1px;right:1px;bottom:1px;left:1px;border-style:solid;border-radius:100%}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .shield-image[_ngcontent-%COMP%]{position:absolute;top:0;right:0;bottom:0;left:0}.stars-svg[_ngcontent-%COMP%]{width:100%;height:100%;box-sizing:border-box}.stars-svg[_ngcontent-%COMP%]     svg{width:100%;height:100%}.stars-svg[_ngcontent-%COMP%]     svg g#planesecliptic path{stroke-width:2.2222220833px;vector-effect:non-scaling-stroke!important;stroke-dasharray:66 61.2500000005}.stars-svg[_ngcontent-%COMP%]     svg g#constLines path{stroke-width:2.2222220833px;vector-effect:non-scaling-stroke!important}.stars-svg[_ngcontent-%COMP%]     svg g#gridLines path{stroke-width:1.1104166667px;vector-effect:non-scaling-stroke!important}.stars-svg.preview[_ngcontent-%COMP%]     svg g#constLines path, .stars-svg.preview[_ngcontent-%COMP%]     svg g#planesecliptic path{stroke-width:.5333333px}.stars-svg.preview[_ngcontent-%COMP%]     svg g#gridLines path{stroke-width:.2665px}.special-shield[_ngcontent-%COMP%]{position:absolute;top:0;left:0;right:0;bottom:0}.force-background-area[_ngcontent-%COMP%]   .circle-background.special-sky[_ngcontent-%COMP%], .force-background-area[_ngcontent-%COMP%]   .photo-heart-background.special-sky[_ngcontent-%COMP%]{background:#0c3159!important}.force-background-area[_ngcontent-%COMP%]   .circle-background.special-emerald[_ngcontent-%COMP%], .force-background-area[_ngcontent-%COMP%]   .photo-heart-background.special-emerald[_ngcontent-%COMP%]{background:#123843!important}.force-background-area[_ngcontent-%COMP%]   .circle-background.special-purple-galaxy[_ngcontent-%COMP%], .force-background-area[_ngcontent-%COMP%]   .photo-heart-background.special-purple-galaxy[_ngcontent-%COMP%]{background:#151d46!important}  .special-punching-die{font-size:1px}  .special-punching-die.special-sky pp-poster-stars-area canvas{background:#0c3159}  .special-punching-die.special-sky .stars-svg svg{background:#0c3159}  .special-punching-die.special-emerald pp-poster-stars-area canvas{background:#123843}  .special-punching-die.special-emerald .stars-svg svg{background:#123843}  .special-punching-die.special-purple-galaxy pp-poster-stars-area canvas{background:#151d46}  .special-punching-die.special-purple-galaxy .stars-svg svg{background:#151d46}  .special-punching-die.special-heart canvas,   .special-punching-die.special-heart svg,   .special-punching-die.special-heart img{-webkit-mask:url(#heartClipPath);mask:url(#heartClipPath)}  .special-punching-die.special-circle canvas,   .special-punching-die.special-circle svg,   .special-punching-die.special-circle img{-webkit-mask:url(#circleClipPath);mask:url(#circleClipPath)}    .splitter-second{z-index:2}    .splitter-third{z-index:1}    .photo-instance{width:100%;height:100%}    .photo-instance img{width:100%;height:100%;object-fit:cover;box-sizing:border-box}    .photo-instance.special-heart img,     .photo-instance.special-heart pp-controls-file-uploader-photo{-webkit-mask:url(#heartPhotoClipPath);mask:url(#heartPhotoClipPath)}    .photo-instance.special-circle img,     .photo-instance.special-circle pp-controls-file-uploader-photo{-webkit-mask:url(#circlePhotoClipPath);mask:url(#circlePhotoClipPath)}"]
            }),
            ae
        }
        )()
    }
    ,
    80069: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            G: () => ie
        });
        var Ut = $(10467)
          , r = $(54438)
          , Mt = $(7494)
          , s = $(9566)
          , so = $(13620)
          , Wt = $(69847)
          , _t = $(60177)
          , Ae = $(27617)
          , Me = $(78606)
          , ct = $(84412)
          , Tt = $(84572)
          , Qe = $(56977)
          , jt = $(54843)
          , Xe = $(70152)
          , Ce = $(16968)
          , it = $(7335)
          , et = $(2745)
          , re = $(57493)
          , pt = $(67376)
          , ze = $(49427)
          , ye = $(41046)
          , ge = $(73955)
          , Ie = $(66985)
          , gt = $(21626)
          , Ye = $(345);
        const yt = ["mapWrapper"]
          , ht = (we, Oe, ee, W, ae) => ({
            title$: we,
            subtitle$: Oe,
            map: ee,
            splitSize: W,
            mapIndex: 0,
            photo$: ae
        })
          , mo = (we, Oe, ee, W, ae) => ({
            title$: we,
            subtitle$: Oe,
            map: ee,
            splitSize: W,
            mapIndex: 1,
            photo$: ae
        })
          , no = () => [".jpeg", ".jpg", ".png", ".heic"]
          , Co = (we, Oe, ee, W) => [we, Oe, ee, W];
        function Lt(we, Oe) {
            if (1 & we) {
                const ee = r.RV6();
                r.j41(0, "button", 10),
                r.bIt("click", function() {
                    r.eBV(ee);
                    const ae = r.XpG(2);
                    return r.Njj(ae.switchMapLock())
                }),
                r.nrm(1, "svg-icon", 11),
                r.k0s()
            }
            if (2 & we) {
                const ee = r.XpG(2);
                r.R7$(),
                r.Y8G("src", "/assets/pp-posters/maps/icons/padlock-" + (ee.isLocked ? "closed" : "open") + ".svg")
            }
        }
        function Ft(we, Oe) {
            if (1 & we && (r.j41(0, "pp-poster-space-splitter"),
            r.eu8(1, 14)(2, 15),
            r.k0s()),
            2 & we) {
                const ee = r.XpG().ngIf
                  , W = r.XpG(2)
                  , ae = r.sdS(5);
                r.xc7("width", ee.width, "px")("height", ee.height, "px")("margin-top", ee.marginTop, "px"),
                r.R7$(),
                r.Y8G("ngTemplateOutlet", ae)("ngTemplateOutletContext", r.s1E(10, ht, W.title1$, W.subtitle1$, W.map1, ee, W.photo1$)),
                r.R7$(),
                r.Y8G("ngTemplateOutlet", ae)("ngTemplateOutletContext", r.s1E(16, mo, W.title2$, W.subtitle2$, W.map2, ee, W.photo2$))
            }
        }
        function co(we, Oe) {
            if (1 & we && (r.nrm(0, "pp-poster-text-area", 13),
            r.nI1(1, "async"),
            r.nI1(2, "async"),
            r.nI1(3, "async"),
            r.nI1(4, "async"),
            r.nI1(5, "async")),
            2 & we) {
                const ee = r.XpG(3);
                r.Y8G("poster", r.bMT(1, 6, ee.poster$))("color", r.bMT(2, 8, ee.textColor$))("textArea", r.bMT(3, 10, ee.textArea$))("title", r.bMT(4, 12, ee.subtitle$))("subtitle", r.bMT(5, 14, ee.subtitle2$))("background", ee.map1.textBackground)
            }
        }
        function Jt(we, Oe) {
            if (1 & we && (r.qex(0),
            r.DNE(1, Ft, 3, 22, "pp-poster-space-splitter", 12)(2, co, 6, 16, "pp-poster-text-area", 13),
            r.bVm()),
            2 & we) {
                const ee = Oe.ngIf
                  , W = r.XpG(2);
                r.R7$(),
                r.Y8G("ngIf", ee.width && ee.height),
                r.R7$(),
                r.vxM(W.map1.layout === W.MapsLayoutsEnum.SQUARE_PHOTO ? 2 : -1)
            }
        }
        function po(we, Oe) {
            if (1 & we && (r.j41(0, "pp-poster-printing-registration", 6)(1, "pp-poster-arrangement-wrapper", 7),
            r.DNE(2, Lt, 2, 1, "button", 8),
            r.nrm(3, "pp-poster-text-area", 9),
            r.nI1(4, "async"),
            r.nI1(5, "async"),
            r.nI1(6, "async"),
            r.nI1(7, "async"),
            r.DNE(8, Jt, 3, 2, "ng-container", 5),
            r.nI1(9, "async"),
            r.k0s()()),
            2 & we) {
                const ee = Oe.ngIf
                  , W = r.XpG();
                r.Y8G("poster", ee)("withPassepartout", W.map1.passepartoutSize > 0),
                r.R7$(),
                r.Y8G("internalBorderColor", W.map1.background),
                r.R7$(),
                r.vxM(W.isMobile ? 2 : -1),
                r.R7$(),
                r.Y8G("poster", r.bMT(4, 9, W.poster$))("color", r.bMT(5, 11, W.textColor$))("textArea", r.bMT(6, 13, W.topTextArea$))("title", r.bMT(7, 15, W.title$)),
                r.R7$(5),
                r.Y8G("ngIf", r.bMT(9, 17, W.splitElementsSize$))
            }
        }
        function Et(we, Oe) {
            if (1 & we) {
                const ee = r.RV6();
                r.j41(0, "img", 25),
                r.bIt("load", function() {
                    r.eBV(ee);
                    const ae = r.XpG(4);
                    return r.Njj(ae.onImageLoad())
                })("click", function() {
                    r.eBV(ee);
                    const ae = r.XpG(4);
                    return r.Njj(ae.onPhotoSelect())
                }),
                r.k0s()
            }
            if (2 & we) {
                const ee = r.XpG().ngIf
                  , W = r.XpG(3);
                r.Y8G("src", W.getPhotoWithType(ee).imageUrl, r.B4B)
            }
        }
        function Kt(we, Oe) {
            if (1 & we) {
                const ee = r.RV6();
                r.j41(0, "pp-controls-file-uploader-photo", 26),
                r.nI1(1, "translate"),
                r.bIt("setFileUploadingProgress", function(ae) {
                    r.eBV(ee);
                    const Ve = r.XpG(4);
                    return r.Njj(Ve.setFileUpploadingProgress.emit(ae))
                }),
                r.k0s()
            }
            if (2 & we) {
                const ee = r.XpG(4);
                r.Y8G("photoFileGroup", ee.photoFileGroup)("photoCropGroup", ee.photoCropGroup)("photoId", ee.photoId)("multiFile", ee.multiFile)("isSubmitted", !1)("acceptable", r.lJ4(14, no))("isBase64Response", !0)("fullHeight", !0)("isBigPictureMode", !0)("withBackgroundGray", !0)("isFileUploadingInProgress", ee.isFileUploadingInProgress)("legalNote", r.bMT(1, 12, "soundwave.details.instruction"))
            }
        }
        function At(we, Oe) {
            if (1 & we && (r.qex(0),
            r.DNE(1, Et, 1, 1, "img", 23)(2, Kt, 2, 15, "pp-controls-file-uploader-photo", 24),
            r.bVm()),
            2 & we) {
                const ee = Oe.ngIf
                  , W = r.XpG(3);
                r.R7$(),
                r.Y8G("ngIf", !W.getPhotoWithType(ee).showAddPhoto),
                r.R7$(),
                r.Y8G("ngIf", W.photoFileGroup && W.getPhotoWithType(ee).showAddPhoto)
            }
        }
        function Re(we, Oe) {
            if (1 & we && (r.DNE(0, At, 3, 2, "ng-container", 5),
            r.nI1(1, "async")),
            2 & we) {
                const ee = r.XpG().photo$;
                r.Y8G("ngIf", r.bMT(1, 1, ee))
            }
        }
        function ve(we, Oe) {
            if (1 & we && r.nrm(0, "div", 31),
            2 & we) {
                const ee = r.XpG(3).map;
                r.xc7("left", ee.markerPrint.left, "%")("top", ee.markerPrint.top, "%")("height", ee.markerPrint.height, "%")("width", ee.markerPrint.width, "%"),
                r.Y8G("innerHTML", ee.markerPrint.html, r.npT)
            }
        }
        function ne(we, Oe) {
            if (1 & we) {
                const ee = r.RV6();
                r.j41(0, "img", 29),
                r.bIt("load", function() {
                    r.eBV(ee);
                    const ae = r.XpG(3);
                    return r.Njj(ae.onImageLoad())
                }),
                r.k0s(),
                r.DNE(1, ve, 1, 9, "div", 30)
            }
            if (2 & we) {
                const ee = r.XpG(2).map;
                r.Y8G("src", ee.image, r.B4B),
                r.R7$(),
                r.Y8G("ngIf", ee.showMarker)
            }
        }
        function B(we, Oe) {
            if (1 & we) {
                const ee = r.RV6();
                r.j41(0, "pp-poster-map-wrapper", 32, 2),
                r.bIt("updateMapConfig", function(ae) {
                    r.eBV(ee);
                    const Ve = r.XpG(2).mapIndex
                      , fe = r.XpG();
                    return r.Njj(fe.updateMapConfig(ae, Ve))
                })("updateMarkerConfig", function(ae) {
                    r.eBV(ee);
                    const Ve = r.XpG(2).mapIndex
                      , fe = r.XpG();
                    return r.Njj(fe.updateMarkerConfig(ae, Ve))
                }),
                r.k0s()
            }
            if (2 & we) {
                const ee = r.XpG(2)
                  , W = ee.mapIndex
                  , ae = ee.map
                  , Ve = r.XpG();
                r.Aen(ae.style),
                r.Y8G("isSmaller", "6A" === ae.layout || "6B" === ae.layout)("mapsEndpoint", Ve.mapsEndpoint)("mapboxAccessToken", Ve.mapboxAccessToken)("mode", 2)("idx", W)("isLocked", Ve.isLocked)("hideNativeLock", !0)("navigationLeft", 0 === W)("viewPort", ae.viewPort)("zoom", ae.zoom)("markerByWidth", ae.markerByWidth)("isInteractive", Ve.isInteractive)("isMobile", Ve.isMobile)("isActiveMap", Ve.isInteractive)("land", ae.customColor.land)("water", ae.customColor.water)("roads", ae.customColor.roads)("showMarker", ae.showMarker)("markerType", ae.markerType)("markerColor", ae.markerColor)("markerPosition", ae.markerPosition)
            }
        }
        function de(we, Oe) {
            if (1 & we && (r.DNE(0, ne, 2, 2)(1, B, 2, 23, "pp-poster-map-wrapper", 27),
            r.nrm(2, "pp-poster-preview", 28)),
            2 & we) {
                const ee = r.XpG().map
                  , W = r.XpG();
                r.vxM(W.useImageMap ? 0 : ee.style ? 1 : -1),
                r.R7$(2),
                r.Y8G("showPreview", !W.isFinalPoster)("marginTop", !1)("maxWidth", 45)("previewType", r.ziG(5, Co, W.MapsStyleEnum.BLACK, W.MapsStyleEnum.CARBON, W.MapsStyleEnum.INTENSE, W.MapsStyleEnum.WANDERLUST).includes(ee.style) ? "map-reverse" : "map")
            }
        }
        function lt(we, Oe) {
            if (1 & we && r.nrm(0, "svg-icon", 11),
            2 & we) {
                const ee = r.XpG(2).map;
                r.xc7("--border-color", ee.layoutBorderColor),
                r.Y8G("src", "/assets/pp-posters/maps/shape/shape-" + ee.layout + "-dbl.svg")
            }
        }
        function St(we, Oe) {
            if (1 & we && r.nrm(0, "svg-icon", 11),
            2 & we) {
                const ee = r.XpG(2).map;
                r.xc7("--border-color", ee.layoutBorderColor),
                r.Y8G("src", "/assets/pp-posters/maps/shape/shape-" + ee.layout + "-dbl.svg")
            }
        }
        function tt(we, Oe) {
            if (1 & we && r.DNE(0, lt, 1, 3, "svg-icon", 20)(1, St, 1, 3, "svg-icon", 20),
            2 & we) {
                const ee = r.XpG().map
                  , W = r.XpG();
                r.Y8G("ngIf", ee.layout === W.MapsLayoutsEnum.SQUARE),
                r.R7$(),
                r.Y8G("ngIf", ee.layout === W.MapsLayoutsEnum.SQUARE_PHOTO)
            }
        }
        function $t(we, Oe) {
            if (1 & we && r.nrm(0, "svg-icon", 11),
            2 & we) {
                const ee = r.XpG(2).map;
                r.xc7("--border-color", ee.layoutBorderColor),
                r.Y8G("src", "/assets/pp-posters/maps/shape/shape-" + ee.layout + "-dbl-prev.svg")
            }
        }
        function Nt(we, Oe) {
            if (1 & we && r.nrm(0, "svg-icon", 11),
            2 & we) {
                const ee = r.XpG(2).map;
                r.xc7("--border-color", ee.layoutBorderColor),
                r.Y8G("src", "/assets/pp-posters/maps/shape/shape-" + ee.layout + "-dbl-prev.svg")
            }
        }
        function Vt(we, Oe) {
            if (1 & we && r.DNE(0, $t, 1, 3, "svg-icon", 20)(1, Nt, 1, 3, "svg-icon", 20),
            2 & we) {
                const ee = r.XpG().map
                  , W = r.XpG();
                r.Y8G("ngIf", ee.layout === W.MapsLayoutsEnum.SQUARE),
                r.R7$(),
                r.Y8G("ngIf", ee.layout === W.MapsLayoutsEnum.SQUARE_PHOTO)
            }
        }
        function _o(we, Oe) {
            if (1 & we && r.nrm(0, "svg-icon", 11),
            2 & we) {
                const ee = r.XpG().map;
                r.xc7("--border-color", ee.layoutBorderColor),
                r.Y8G("src", "/assets/pp-posters/maps/shape/shape-" + ee.layout + ".svg")
            }
        }
        function Lo(we, Oe) {
            if (1 & we && r.nrm(0, "svg-icon", 11),
            2 & we) {
                const ee = r.XpG().map;
                r.xc7("--border-color", ee.layoutBorderColor),
                r.Y8G("src", "/assets/pp-posters/maps/shape/shape-" + ee.layout + ".svg")
            }
        }
        function ao(we, Oe) {
            if (1 & we && r.nrm(0, "svg-icon", 11),
            2 & we) {
                const ee = r.XpG().map;
                r.xc7("--border-color", ee.layoutBorderColor),
                r.Y8G("src", "/assets/pp-posters/maps/shape/shape-" + ee.layout + ".svg")
            }
        }
        function bt(we, Oe) {
            if (1 & we && (r.nrm(0, "pp-poster-text-area", 13),
            r.nI1(1, "async"),
            r.nI1(2, "async"),
            r.nI1(3, "async"),
            r.nI1(4, "async"),
            r.nI1(5, "async")),
            2 & we) {
                const ee = r.XpG()
                  , W = ee.map
                  , ae = ee.title$
                  , Ve = ee.subtitle$
                  , fe = r.XpG();
                r.Y8G("poster", r.bMT(1, 6, fe.poster$))("color", r.bMT(2, 8, fe.textColor$))("textArea", r.bMT(3, 10, fe.textArea$))("title", r.bMT(4, 12, ae))("subtitle", r.bMT(5, 14, Ve))("background", W.textBackground)
            }
        }
        function Do(we, Oe) {
            if (1 & we && (r.j41(0, "div", 16),
            r.DNE(1, Re, 2, 3, "ng-container")(2, de, 3, 10),
            r.k0s(),
            r.j41(3, "div", 17)(4, "div", 18)(5, "div", 19),
            r.DNE(6, tt, 2, 2)(7, Vt, 2, 2)(8, _o, 1, 3, "svg-icon", 20)(9, Lo, 1, 3, "svg-icon", 20)(10, ao, 1, 3, "svg-icon", 20),
            r.k0s()(),
            r.nrm(11, "div", 21),
            r.k0s(),
            r.nrm(12, "div", 22),
            r.DNE(13, bt, 6, 16, "pp-poster-text-area", 13)),
            2 & we) {
                const ee = Oe.mapIndex
                  , W = Oe.splitSize
                  , ae = Oe.map
                  , Ve = r.XpG();
                r.xc7("width", W.mapWidth, "px")("margin-left", 0 === ee ? W.mapMargin : 0, "px")("height", W.width / 2, "px"),
                r.R7$(),
                r.vxM(0 === ee && 7 === ae.layout ? 1 : 2),
                r.R7$(2),
                r.xc7("width", W.width / 2, "px")("height", W.width / 2, "px"),
                r.R7$(2),
                r.xc7("width", W.width / 2, "px")("height", W.width / 2, "px"),
                r.R7$(),
                r.vxM(Ve.isFinalPoster ? 6 : 7),
                r.R7$(2),
                r.Y8G("ngIf", ae.layout === Ve.MapsLayoutsEnum.CIRCLE),
                r.R7$(),
                r.Y8G("ngIf", ae.layout === Ve.MapsLayoutsEnum.HEART),
                r.R7$(),
                r.Y8G("ngIf", ae.layout === Ve.MapsLayoutsEnum.HALVES_HEART + "A" || ae.layout === Ve.MapsLayoutsEnum.HALVES_HEART + "B"),
                r.R7$(2),
                r.xc7("border-color", Ve.map1.background)("width", Ve.mathCeil(W.width / 2 + .01 * W.mapWidth), "px")("height", Ve.mathCeil(W.width / 2 + .01 * W.mapWidth), "px")("border-width", Ve.mathCeil(.01 * W.mapWidth), "px")("margin-left", -Ve.mathCeil(.005 * W.mapWidth), "px")("margin-top", -Ve.mathCeil(.005 * W.mapWidth), "px"),
                r.R7$(),
                r.vxM(ae.layout !== Ve.MapsLayoutsEnum.SQUARE_PHOTO ? 13 : -1)
            }
        }
        function Xt(we, Oe) {
            1 & we && r.nrm(0, "pp-poster-loaded-element")
        }
        let ie = ( () => {
            var we;
            class Oe extends re.d {
                constructor(W, ae, Ve, fe, Pt, mt) {
                    super(W, ae, Ve, fe, Pt, mt),
                    this.host = W,
                    this.zone = ae,
                    this.httpClient = Ve,
                    this.domSanitizer = fe,
                    this.cdr = Pt,
                    this.renderer2 = mt,
                    this.mapWrapper = Ce.f,
                    this.photoId = 0,
                    this.multiFile = !1,
                    this.isFileUploadingInProgress = !1,
                    this.setFileUpploadingProgress = new r.bkB,
                    this.photoSelect = new r.bkB,
                    this.map1 = (0,
                    pt.cloneDeep)(re.G),
                    this.map2 = (0,
                    pt.cloneDeep)(re.G),
                    this.isLocked = !0,
                    this.photo1$ = new ct.t(null),
                    this.photo2$ = new ct.t(null),
                    this.title1$ = new ct.t(null),
                    this.title2$ = new ct.t(null),
                    this.subtitle1$ = new ct.t(null),
                    this.subtitle2$ = new ct.t(null),
                    this.squareProportion = 1.1669822972,
                    this.isSquareLayout = !1,
                    this.splitElementsSize$ = new ct.t({
                        width: 0,
                        mapWidth: 0,
                        mapMargin: 0,
                        height: 0,
                        marginTop: 0
                    }),
                    this.MapsStyleEnum = Ae.c_T
                }
                ngAfterViewInit() {
                    (0,
                    Tt.z)([this.poster$, this.topTextArea$, this.posterConfiguration$]).pipe((0,
                    Qe.Q)(this.ngUnsubscribe), (0,
                    Xe.B)(100)).subscribe( ([W,ae,Ve]) => {
                        var fe, Pt, mt, xo, So;
                        if (!Ve)
                            return;
                        const ro = null !== (fe = W.size.height) && void 0 !== fe ? fe : 0;
                        let Vo = .09 * ro;
                        Ve.mainTextEnable && Ve.title && (Vo = .24 * ro,
                        Ve.shape === Ae.U9G.HALVES_HEART && (Vo = .26 * ro)),
                        this.isSquare(Ve) && (Vo *= .75);
                        const vo = W.size.width * (this.isSquare(Ve) ? .9 : .8);
                        this.imageInstanceSize = {
                            width: null !== (Pt = null === (mt = this.mapWrapper) || void 0 === mt || null === (mt = mt.elementRef) || void 0 === mt || null === (mt = mt.nativeElement) || void 0 === mt ? void 0 : mt.offsetWidth) && void 0 !== Pt ? Pt : 0,
                            height: null !== (xo = null === (So = this.mapWrapper) || void 0 === So || null === (So = So.elementRef) || void 0 === So || null === (So = So.nativeElement) || void 0 === So ? void 0 : So.offsetHeight) && void 0 !== xo ? xo : 0
                        };
                        const ei = vo / (Ve.shape === Ae.U9G.HALVES_HEART ? 3 : 2);
                        this.splitElementsSize$.next({
                            width: vo,
                            mapMargin: Ve.shape === Ae.U9G.HALVES_HEART ? vo / 2 - ei : 0,
                            mapWidth: ei,
                            height: ro - Vo,
                            marginTop: Vo
                        })
                    }
                    )
                }
                setAllTextSettings(W) {
                    const ae = W.mapConfig[0]
                      , Ve = W.mapConfig[1]
                      , fe = {
                        text: W.mainTextEnable ? W.title : "",
                        isDefaultFont: !W.titleFont
                    }
                      , Pt = null != fe && fe.isDefaultFont ? .08 : .06;
                    this.setText(fe, this.title$, {
                        font: null != fe && fe.isDefaultFont ? Ae.n3q.POSITIVE_PRINTS_SCRIPT_2 : Ae.n3q.CAPSUULA_BOLD,
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: Pt,
                            bottomFactor: 0,
                            lineHeightFactor: 1.25 * Pt,
                            topFactor: .015,
                            isBold: !1
                        }
                    });
                    const mt = {
                        text: ae.title,
                        isDefaultFont: !ae.titleFont,
                        showEmptyLine: !0
                    }
                      , xo = {
                        text: Ve.title,
                        isDefaultFont: !Ve.titleFont,
                        showEmptyLine: !0
                    }
                      , So = {
                        text: W.mainTextEnable ? W.subtitle : "",
                        isDefaultFont: !W.subtitleFont,
                        showEmptyLine: !0
                    }
                      , ro = (Ti, ci) => {
                        const ji = null != Ti && Ti.isDefaultFont ? .054 : .036;
                        return {
                            font: null != Ti && Ti.isDefaultFont ? Ae.n3q.POSITIVE_PRINTS_SCRIPT_2 : ci ? Ae.n3q.CAPSUULA_BOLD : Ae.n3q.CAPSUULA,
                            portrait: {
                                sizeFactor: 0,
                                bottomFactor: 0,
                                topFactor: 0
                            },
                            horizontal: {
                                sizeFactor: ji,
                                bottomFactor: W.shape === Ae.U9G.HALVES_HEART ? W.mainTextEnable ? .038 : .072 : .042,
                                lineHeightFactor: 1.34 * ji,
                                topFactor: 0,
                                isBold: !1,
                                fixedPosition: !0
                            }
                        }
                    }
                    ;
                    this.setText(mt, this.title1$, ro(mt, !0)),
                    this.setText(xo, this.title2$, ro(xo, !0)),
                    this.setText(So, this.subtitle$, ro(So, !1));
                    const vo = {
                        text: Ve.subtitle,
                        isDefaultFont: !0,
                        showEmptyLine: !0
                    }
                      , ei = Ti => {
                        const ci = W.mainTextEnable ? .024 : .029;
                        return {
                            font: Ae.n3q.CAPSUULA,
                            portrait: {
                                sizeFactor: 0,
                                bottomFactor: 0,
                                topFactor: 0
                            },
                            horizontal: {
                                sizeFactor: ci,
                                bottomFactor: 0,
                                lineHeightFactor: ci,
                                topFactor: 0,
                                isBold: !1
                            }
                        }
                    }
                    ;
                    this.setText({
                        text: ae.subtitle,
                        isDefaultFont: !0,
                        showEmptyLine: !0
                    }, this.subtitle1$, ei()),
                    this.setText(vo, this.subtitle2$, ei())
                }
                setTextArea(W, ae) {
                    this.topTextArea$.next({
                        topFactor: this.isWideRatio(W, !1) ? .04 : .034,
                        marginFactor: .09,
                        fixedHeightFactor: .21,
                        isFlex: !0,
                        isJustifyCenter: !ae.title.includes("\n")
                    });
                    let Ve = .138;
                    ae.mainTextEnable && ae.title && (Ve = .08,
                    ae.shape === Ae.U9G.HALVES_HEART && (Ve = .1)),
                    this.textArea$.next({
                        bottomFactor: Ve,
                        marginFactor: .013
                    })
                }
                setDesign(W, ae) {
                    var Ve = this;
                    return (0,
                    Ut.A)(function*() {
                        const fe = function() {
                            var Pt = (0,
                            Ut.A)(function*(mt, xo, So, ro) {
                                var Vo, vo;
                                if (mt.viewPort = [[ae.mapConfig[xo].place.viewPort.west, ae.mapConfig[xo].place.viewPort.south], [ae.mapConfig[xo].place.viewPort.east, ae.mapConfig[xo].place.viewPort.north]],
                                mt.zoom = ae.mapConfig[xo].zoom,
                                mt.style = Ve.getColorScheme(ae.colorScheme, xo),
                                mt.customColor = ae.customColors,
                                mt.background = Ve.getBackground(ae.colorScheme, ae.customColors),
                                mt.textBackground = Ve.getBackground(ae.colorScheme, ae.customColors),
                                Ve.textColor$.next(Ve.getText(ae.colorScheme, ae.customColors)),
                                Ve.renderer2.setProperty(Ve.host.nativeElement, "style", "--punching-die-color: ".concat(mt.background)),
                                mt.layout = Ve.getMapLayout(ae.shape, xo),
                                mt.layoutBorderColor = Ve.getBorderColor(mt.style, mt.customColor, mt.layout === Ae.U9G.SQUARE_PHOTO && 1 === xo),
                                So.next({
                                    isPhoto: mt.layout === Ae.U9G.SQUARE_PHOTO,
                                    isHeart: !1,
                                    uuid: ae.mapConfig[xo].photoFiles[0].uuid,
                                    imageUrl: "".concat(Ve.environmentPhotoApi, "/v2/").concat(Ve.isFinalPoster ? "photo" : "image", "/").concat(ae.mapConfig[xo].photoFiles[0].uuid, "?type=").concat(ae.mapConfig[xo].cropsData[0].filter, "&left=").concat(ae.mapConfig[xo].cropsData[0].cropData.x, "&top=").concat(ae.mapConfig[xo].cropsData[0].cropData.y, "&width=").concat(ae.mapConfig[xo].cropsData[0].cropData.width, "&height=").concat(ae.mapConfig[xo].cropsData[0].cropData.height, "&rotate=").concat(ae.mapConfig[xo].cropsData[0].rotate, "&flipped=").concat(ae.mapConfig[xo].cropsData[0].flip),
                                    showAddPhoto: !ae.mapConfig[xo].photoFiles[0].uuid
                                }),
                                mt.showMarker = !!ae.mapConfig[xo].place.formattedAddress && ae.mapConfig[xo].showMarker,
                                mt.markerPosition = ae.mapConfig[xo].markerSelectByGPS ? [ae.mapConfig[xo].markerLngGPS, ae.mapConfig[xo].markerLatGPS] : null !== (Vo = ae.mapConfig[xo].markerPlace) && void 0 !== Vo && Vo.center ? [ae.mapConfig[xo].markerPlace.center.longitude, ae.mapConfig[xo].markerPlace.center.latitude] : [0, 0],
                                mt.markerType = ae.mapConfig[xo].markerType,
                                mt.markerColor = ae.mapConfig[xo].markerColor,
                                !ro) {
                                    var ei;
                                    if (Ve.useImageMap && !Ve.mapFileDownloaded.has(null !== (vo = ae.mapConfig[xo].uuid) && void 0 !== vo ? vo : ""))
                                        if (Ve.mapFileDownloaded.add(null !== (ei = ae.mapConfig[xo].uuid) && void 0 !== ei ? ei : ""),
                                        Ve.isFinalPoster) {
                                            var Ti;
                                            const ji = yield(0,
                                            jt._)(Ve.httpClient.get("/api/map/image", {
                                                params: {
                                                    uuid: null !== (Ti = ae.mapConfig[xo].uuid) && void 0 !== Ti ? Ti : ""
                                                },
                                                responseType: "blob"
                                            }));
                                            mt.image = URL.createObjectURL(ji)
                                        } else {
                                            var ci;
                                            const ji = yield(0,
                                            jt._)(Ve.httpClient.get("/api/map/mapbox/png", {
                                                params: {
                                                    uuid: null !== (ci = ae.mapConfig[xo].uuid) && void 0 !== ci ? ci : ""
                                                },
                                                responseType: "text"
                                            }));
                                            mt.image = ji
                                        }
                                    if (Ve.useImageMap) {
                                        let ji = (0,
                                        it.H)(mt.markerType);
                                        const yn = "#".concat(mt.markerColor);
                                        ji = ji.replace("// ___marker_color___", "\n                <style>\n                  path.marker-fill {\n                    fill: ".concat(yn, ";\n                  }\n                  path.marker-stroke {\n                    stroke: ").concat(yn, ";\n                  }\n                </style>\n                ")),
                                        mt.markerPrint = {
                                            html: Ve.domSanitizer.bypassSecurityTrustHtml(ji),
                                            width: ae.mapConfig[xo].markerSize.width / ae.mapConfig[xo].map.width * 100,
                                            height: ae.mapConfig[xo].markerSize.height / ae.mapConfig[xo].map.height * 100,
                                            left: ae.mapConfig[xo].markerLocation.x / ae.mapConfig[xo].map.width * 100,
                                            top: ae.mapConfig[xo].markerLocation.y / ae.mapConfig[xo].map.height * 100
                                        }
                                    }
                                }
                            });
                            return function(xo, So, ro, Vo) {
                                return Pt.apply(this, arguments)
                            }
                        }();
                        yield fe(Ve.map1, 0, Ve.photo1$, ae.shape === Ae.U9G.SQUARE_PHOTO),
                        yield fe(Ve.map2, 1, Ve.photo2$, !1),
                        Ve.isSquareLayout = Ve.isSquare(ae)
                    })()
                }
                switchMapLock() {
                    this.isLocked = !this.isLocked
                }
                getPhotoWithType(W) {
                    return W
                }
                onPhotoSelect() {
                    this.photoSelect.emit([this.imageInstanceSize.width, this.imageInstanceSize.height, 0])
                }
                getMapLayout(W, ae) {
                    return W === Ae.U9G.HALVES_HEART ? "".concat(Ae.U9G.HALVES_HEART).concat(0 === ae ? "A" : "B") : W
                }
                getColorScheme(W, ae) {
                    return W === Ae.c_T.MINIMAL_WANDERLUST ? 0 === ae ? Ae.c_T.MINIMAL : Ae.c_T.WANDERLUST : W === Ae.c_T.BEACHGLASS_CARBON ? 0 === ae ? Ae.c_T.BEACHGLASS : Ae.c_T.CARBON : W
                }
                isSquare(W) {
                    return W.shape === Ae.U9G.SQUARE || W.shape === Ae.U9G.SQUARE_PHOTO
                }
                onImageLoad() {
                    this.load++,
                    2 === this.load && (this.initiateRender(),
                    this.cdr.detectChanges())
                }
            }
            return (we = Oe).\u0275fac = function(W) {
                return new (W || we)(r.rXU(r.aKT),r.rXU(r.SKi),r.rXU(gt.Qq),r.rXU(Ye.up),r.rXU(r.gRc),r.rXU(r.sFG))
            }
            ,
            we.\u0275cmp = r.VBU({
                type: we,
                selectors: [["pp-poster-map-double"]],
                viewQuery: function(W, ae) {
                    if (1 & W && r.GBs(yt, 5),
                    2 & W) {
                        let Ve;
                        r.mGM(Ve = r.lsd()) && (ae.mapWrapper = Ve.first)
                    }
                },
                inputs: {
                    photoFileGroup: "photoFileGroup",
                    photoCropGroup: "photoCropGroup",
                    photoId: "photoId",
                    multiFile: "multiFile",
                    cropperConfig: "cropperConfig",
                    environmentPhotoApi: "environmentPhotoApi",
                    isFileUploadingInProgress: "isFileUploadingInProgress"
                },
                outputs: {
                    setFileUpploadingProgress: "setFileUpploadingProgress",
                    photoSelect: "photoSelect"
                },
                features: [r.Vt3],
                decls: 7,
                vars: 5,
                consts: [["posterWrapper", ""], ["singleElement", ""], ["mapWrapper", ""], [3, "background"], [3, "poster", "withPassepartout", 4, "ngIf"], [4, "ngIf"], [3, "poster", "withPassepartout"], [3, "internalBorderColor"], [1, "padlock"], [3, "poster", "color", "textArea", "title"], [1, "padlock", 3, "click"], [3, "src"], [3, "width", "height", "marginTop", 4, "ngIf"], [3, "poster", "color", "textArea", "title", "subtitle", "background"], ["first", "", 3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["second", "", 3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "map-wrapper"], [1, "layout-wrapper"], [1, "cover"], [1, "svg-cover"], [3, "--border-color", "src", 4, "ngIf"], [1, "cover-area"], [1, "layout-wrapper-border"], [3, "src", "load", "click", 4, "ngIf"], [3, "photoFileGroup", "photoCropGroup", "photoId", "multiFile", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "withBackgroundGray", "isFileUploadingInProgress", "legalNote", "setFileUploadingProgress", 4, "ngIf"], [3, "load", "click", "src"], [3, "setFileUploadingProgress", "photoFileGroup", "photoCropGroup", "photoId", "multiFile", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "withBackgroundGray", "isFileUploadingInProgress", "legalNote"], [3, "isSmaller", "mapsEndpoint", "mapboxAccessToken", "mode", "idx", "isLocked", "hideNativeLock", "navigationLeft", "viewPort", "zoom", "style", "markerByWidth", "isInteractive", "isMobile", "isActiveMap", "land", "water", "roads", "showMarker", "markerType", "markerColor", "markerPosition"], [3, "showPreview", "marginTop", "maxWidth", "previewType"], [3, "load", "src"], ["class", "marker", 3, "left", "top", "height", "width", "innerHTML", 4, "ngIf"], [1, "marker", 3, "innerHTML"], [3, "updateMapConfig", "updateMarkerConfig", "isSmaller", "mapsEndpoint", "mapboxAccessToken", "mode", "idx", "isLocked", "hideNativeLock", "navigationLeft", "viewPort", "zoom", "markerByWidth", "isInteractive", "isMobile", "isActiveMap", "land", "water", "roads", "showMarker", "markerType", "markerColor", "markerPosition"]],
                template: function(W, ae) {
                    1 & W && (r.j41(0, "pp-poster-background", 3, 0),
                    r.DNE(2, po, 10, 19, "pp-poster-printing-registration", 4),
                    r.nI1(3, "async"),
                    r.k0s(),
                    r.DNE(4, Do, 14, 32, "ng-template", null, 1, r.C5r)(6, Xt, 1, 0, "pp-poster-loaded-element", 5)),
                    2 & W && (r.Y8G("background", ae.map1.background),
                    r.R7$(2),
                    r.Y8G("ngIf", r.bMT(3, 3, ae.poster$)),
                    r.R7$(4),
                    r.Y8G("ngIf", ae.isImageRendered))
                },
                dependencies: [_t.MD, _t.bT, _t.T3, _t.Jj, Mt.Z, s.R, Wt.c, so.y, Me.iu, Me.DM, Ce.f, et.G, ze.ex, ye.C, ge.h, ge.D9, Ie.P],
                styles: ["[_nghost-%COMP%]{--border-color: #E53422;--punching-die-color: #000;width:100%;height:100%;display:block}[_nghost-%COMP%]   .map-wrapper[_ngcontent-%COMP%]{position:absolute;top:0;right:0;bottom:0;left:0;display:block;overflow:hidden}[_nghost-%COMP%]   .map-wrapper[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:100%;height:100%;object-fit:cover;cursor:pointer}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]{position:absolute;overflow:hidden;pointer-events:none;left:0;right:0;top:0;bottom:0;z-index:1}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]   .cover[_ngcontent-%COMP%]{width:100%;display:block;overflow:hidden}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]   .cover[_ngcontent-%COMP%]   .cover-left[_ngcontent-%COMP%]{float:left;display:block;background:#fff}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]   .cover[_ngcontent-%COMP%]   .cover-right[_ngcontent-%COMP%]{float:left;display:block;background:#fff}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]   .cover[_ngcontent-%COMP%]   .svg-cover[_ngcontent-%COMP%]{width:100%;display:block;margin:auto;float:left}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]   .cover[_ngcontent-%COMP%]   .svg-cover[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:100%;height:100%}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]     svg{display:block}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]     svg .contour{stroke:var(--border-color)}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]   .cover-area[_ngcontent-%COMP%]{width:100%;height:100%;background:#fff}[_nghost-%COMP%]   .layout-wrapper-border[_ngcontent-%COMP%]{position:absolute;box-sizing:border-box;border:0px solid white;z-index:2;pointer-events:none}[_nghost-%COMP%]   .marker[_ngcontent-%COMP%]{position:absolute;z-index:1;transform:translate(-50%,-50%)}[_nghost-%COMP%]   .marker[_ngcontent-%COMP%]     svg{width:100%;height:100%;position:absolute;top:0;left:0}[_nghost-%COMP%]   .marker[_ngcontent-%COMP%]     svg path.marker-stroke{fill:none;stroke-width:3}[_nghost-%COMP%]   button.padlock[_ngcontent-%COMP%]{position:absolute;top:0;left:0;right:unset;width:30px;height:30px;background:#f77147;border:1px solid #f77147;color:#fff;padding:0 0 0 4px}[_nghost-%COMP%]   button.padlock[_ngcontent-%COMP%]:hover{opacity:1;background:#ea4714}[_nghost-%COMP%]   button.padlock[_ngcontent-%COMP%]:first-child{border-top-left-radius:0;border-top-right-radius:0}[_nghost-%COMP%]   button.padlock[_ngcontent-%COMP%]:last-child{border-top:unset;border-bottom-left-radius:0;border-bottom-right-radius:0}[_nghost-%COMP%]   button.padlock[_ngcontent-%COMP%]     svg{width:30px;display:block;height:30px;padding:6px;margin-left:-6px;margin-top:-2px;box-sizing:border-box}[_nghost-%COMP%]   button.padlock[_ngcontent-%COMP%]     svg path{fill:#fff}[_nghost-%COMP%]     svg   path.punching-die{fill:var(--punching-die-color)}"]
            }),
            Oe
        }
        )()
    }
    ,
    80673: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            n: () => Et
        });
        var Ut = $(10467)
          , r = $(54438)
          , Mt = $(7494)
          , s = $(9566)
          , so = $(13620)
          , Wt = $(69847)
          , _t = $(60177)
          , Ae = $(27617)
          , Me = $(78606)
          , ct = $(84412)
          , Tt = $(84572)
          , Qe = $(56977)
          , jt = $(54843)
          , Xe = $(70152)
          , Ce = $(16968)
          , it = $(7335)
          , et = $(57493)
          , re = $(67376)
          , Be = $(41046)
          , ze = $(91054)
          , ye = $(81836)
          , ge = $(66985)
          , Ie = $(21626)
          , gt = $(345);
        const Ye = (Kt, At, Re, ve, ne) => [Kt, At, Re, ve, ne];
        function yt(Kt, At) {
            if (1 & Kt && r.nrm(0, "div", 14),
            2 & Kt) {
                const Re = r.XpG(3);
                r.xc7("left", Re.map.markerPrint.left, "%")("top", Re.map.markerPrint.top, "%")("height", Re.map.markerPrint.height, "%")("width", Re.map.markerPrint.width, "%"),
                r.Y8G("innerHTML", Re.map.markerPrint.html, r.npT)
            }
        }
        function ht(Kt, At) {
            if (1 & Kt) {
                const Re = r.RV6();
                r.j41(0, "img", 12),
                r.bIt("load", function() {
                    r.eBV(Re);
                    const ne = r.XpG(2);
                    return r.Njj(ne.onImageLoad())
                }),
                r.k0s(),
                r.DNE(1, yt, 1, 9, "div", 13)
            }
            if (2 & Kt) {
                const Re = r.XpG(2);
                r.Y8G("src", Re.map.image, r.B4B),
                r.R7$(),
                r.Y8G("ngIf", Re.map.showMarker)
            }
        }
        function mo(Kt, At) {
            if (1 & Kt) {
                const Re = r.RV6();
                r.j41(0, "pp-poster-map-wrapper", 15, 1),
                r.bIt("updateMapConfig", function(ne) {
                    r.eBV(Re);
                    const B = r.XpG(2);
                    return r.Njj(B.updateMapConfig(ne, 0))
                })("updateMarkerConfig", function(ne) {
                    r.eBV(Re);
                    const B = r.XpG(2);
                    return r.Njj(B.updateMarkerConfig(ne, 0))
                }),
                r.k0s()
            }
            if (2 & Kt) {
                const Re = r.XpG(2);
                r.Aen(Re.map.style),
                r.Y8G("mapsEndpoint", Re.mapsEndpoint)("mapboxAccessToken", Re.mapboxAccessToken)("mode", 1)("idx", 1)("isLocked", !0)("newZoom", !0)("viewPort", Re.map.viewPort)("zoom", Re.map.zoom)("markerByWidth", Re.map.markerByWidth)("isInteractive", Re.isInteractive)("isMobile", Re.isMobile)("isActiveMap", Re.isInteractive)("land", Re.map.customColor.land)("water", Re.map.customColor.water)("roads", Re.map.customColor.roads)("showMarker", Re.map.showMarker)("markerType", Re.map.markerType)("markerColor", Re.map.markerColor)("markerPosition", Re.map.markerPosition)("blockMapUpdate", Re.map.blockMapUpdate)
            }
        }
        function no(Kt, At) {
            if (1 & Kt && (r.j41(0, "div", 16)(1, "div", 17),
            r.nrm(2, "div", 18),
            r.j41(3, "div", 19),
            r.nrm(4, "svg-icon", 20),
            r.k0s(),
            r.nrm(5, "div", 21),
            r.k0s(),
            r.nrm(6, "div", 22),
            r.k0s(),
            r.nrm(7, "div", 23)),
            2 & Kt) {
                const Re = r.XpG(2);
                r.xc7("margin-top", Re.map.layout === Re.MapsLayoutsEnum.HOUSE ? Re.map.passepartoutSize : 0, "px"),
                r.R7$(2),
                r.xc7("background", Re.map.background)("width", Re.map.sideCover, "px")("height", Re.map.svgCoverWidth, "px"),
                r.R7$(),
                r.xc7("width", Re.map.svgCoverWidth, "px")("height", Re.map.svgCoverWidth, "px"),
                r.R7$(),
                r.xc7("--border-color", Re.map.layoutBorderColor),
                r.Y8G("src", "/assets/pp-posters/maps/shape/shape-" + Re.map.layout + ".svg"),
                r.R7$(),
                r.xc7("background", Re.map.background)("width", Re.map.sideCover, "px")("height", Re.map.svgCoverWidth, "px"),
                r.R7$(),
                r.xc7("background", Re.map.background),
                r.R7$(),
                r.xc7("border-color", Re.map.background)("width", Re.mathCeil(Re.map.svgCoverWidth + .01 * Re.map.svgCoverWidth), "px")("height", Re.mathCeil(Re.map.svgCoverWidth + .01 * Re.map.svgCoverWidth), "px")("border-width", Re.mathCeil(.01 * Re.map.svgCoverWidth), "px")("margin-left", -Re.mathCeil(.005 * Re.map.svgCoverWidth), "px")("margin-top", -Re.mathCeil(.005 * Re.map.svgCoverWidth) + (Re.map.layout === Re.MapsLayoutsEnum.HOUSE ? Re.mathCeil(Re.map.passepartoutSize) : 0), "px")
            }
        }
        function Co(Kt, At) {
            if (1 & Kt) {
                const Re = r.RV6();
                r.j41(0, "div", 28)(1, "pp-poster-character", 29, 2),
                r.bIt("setFileUploadingProgress", function(ne) {
                    r.eBV(Re);
                    const B = r.XpG(5);
                    return r.Njj(B.setFileUpploadingProgress.emit(ne))
                })("selectPhoto", function() {
                    r.eBV(Re);
                    const ne = r.XpG(5);
                    return r.Njj(ne.onPhotoSelect())
                })("photoLoaded", function() {
                    r.eBV(Re);
                    const ne = r.XpG(5);
                    return r.Njj(ne.onImageLoad())
                }),
                r.k0s()()
            }
            if (2 & Kt) {
                const Re = r.XpG(3)
                  , ve = r.XpG(2);
                r.xc7("width", ve.imageInstanceSize.width, "px")("height", ve.imageInstanceSize.height, "px"),
                r.R7$(),
                r.Y8G("isFinalPoster", ve.isFinalPoster)("fillWhite", !0)("showUploadInfoText", !0)("isInteractive", ve.isInteractive)("letterDefaultZoom", 1)("charId", 0)("character", ve.map.layout === ve.MapsLayoutsEnum.PHOTO ? "\u25cb" : "\u2661")("imageUrl", ve.getPhotoWithType(Re).uuid ? ve.getPhotoWithType(Re).imageUrl : "")("imageId", ve.getPhotoWithType(Re).uuid ? ve.getPhotoWithType(Re).uuid : "")("photoFileGroup", ve.photoFileGroup)("photoCropGroup", ve.photoCropGroup)("multiFile", ve.multiFile)("isFileUploadingInProgress", ve.isFileUploadingInProgress)("readyToLoad", !0)("svgCharFilesPath", "/assets/pp-posters/maps/characters")("charactersDefinition", ve.charactersDefinition)
            }
        }
        function Lt(Kt, At) {
            if (1 & Kt && (r.j41(0, "div", 26),
            r.nI1(1, "async"),
            r.DNE(2, Co, 3, 20, "div", 27),
            r.k0s()),
            2 & Kt) {
                const Re = r.XpG(3).ngIf
                  , ve = r.XpG();
                r.xc7("background", ve.map.layout === ve.MapsLayoutsEnum.PHOTO ? ve.map.background : "transparent")("bottom", r.bMT(1, 9, ve.photoBottom$), "px")("width", Re.size.width, "px")("height", ve.imageInstanceSize.wrapperHeight, "px"),
                r.R7$(2),
                r.vxM(ve.map.layout === ve.MapsLayoutsEnum.PHOTO || ve.map.layout === ve.MapsLayoutsEnum.HEART_PHOTO ? 2 : -1)
            }
        }
        function Ft(Kt, At) {
            if (1 & Kt && r.DNE(0, Lt, 3, 11, "div", 25),
            2 & Kt) {
                const Re = r.XpG(3);
                r.Y8G("ngIf", Re.imageInstanceSize)
            }
        }
        function co(Kt, At) {
            if (1 & Kt && r.DNE(0, Ft, 1, 1, "div", 24),
            2 & Kt) {
                const Re = r.XpG(2);
                r.vxM(Re.map.layout === Re.MapsLayoutsEnum.PHOTO || Re.map.layout === Re.MapsLayoutsEnum.HEART_PHOTO ? 0 : -1)
            }
        }
        function Jt(Kt, At) {
            if (1 & Kt) {
                const Re = r.RV6();
                r.j41(0, "pp-poster-printing-registration", 6)(1, "pp-poster-arrangement-wrapper", 7)(2, "div", 8),
                r.DNE(3, ht, 2, 2)(4, mo, 2, 22, "pp-poster-map-wrapper", 9),
                r.nrm(5, "pp-poster-preview", 10),
                r.k0s(),
                r.DNE(6, no, 8, 35)(7, co, 1, 1),
                r.nI1(8, "async"),
                r.j41(9, "pp-poster-text-area", 11),
                r.nI1(10, "async"),
                r.nI1(11, "async"),
                r.nI1(12, "async"),
                r.nI1(13, "async"),
                r.nI1(14, "async"),
                r.bIt("textareaHeightCallback", function(ne) {
                    r.eBV(Re);
                    const B = r.XpG();
                    return r.Njj(B.newTopTextareaHeight(ne))
                }),
                r.k0s()()()
            }
            if (2 & Kt) {
                let Re;
                const ve = At.ngIf
                  , ne = r.XpG();
                r.Y8G("poster", ve)("passepartoutColor", ne.map.background)("withPassepartout", ne.map.passepartoutSize > 0),
                r.R7$(),
                r.Y8G("passepartoutSize", ne.map.passepartoutSize)("internalBorderColor", ne.map.background),
                r.R7$(),
                r.xc7("background", ne.map.background)("margin-left", ne.map.passepartoutSize, "px")("margin-top", ne.map.passepartoutSize, "px")("margin-bottom", ne.map.passepartoutSize, "px")("margin-right", ne.map.passepartoutSize, "px"),
                r.R7$(),
                r.vxM(ne.useImageMap ? 3 : ne.map.style ? 4 : -1),
                r.R7$(2),
                r.Y8G("showPreview", !ne.isFinalPoster)("marginTop", !1)("maxWidth", 45)("previewType", r.s1E(40, Ye, ne.MapsStyleEnum.BLACK, ne.MapsStyleEnum.CARBON, ne.MapsStyleEnum.INTENSE, ne.MapsStyleEnum.WANDERLUST, ne.MapsStyleEnum.COSY).includes(ne.map.style) ? "map-reverse" : "map"),
                r.R7$(),
                r.vxM(ne.map.layout !== ne.MapsLayoutsEnum.SQUARE && ne.map.layout !== ne.MapsLayoutsEnum.PHOTO && ne.map.layout !== ne.MapsLayoutsEnum.HEART_PHOTO ? 6 : -1),
                r.R7$(),
                r.vxM((Re = r.bMT(8, 28, ne.photo1$)) ? 7 : -1, Re),
                r.R7$(2),
                r.Y8G("poster", r.bMT(10, 30, ne.poster$))("color", r.bMT(11, 32, ne.textColor$))("textArea", r.bMT(12, 34, ne.textArea$))("title", r.bMT(13, 36, ne.title$))("subtitle", r.bMT(14, 38, ne.subtitle$))("background", ne.map.textBackground)
            }
        }
        function po(Kt, At) {
            1 & Kt && r.nrm(0, "pp-poster-loaded-element")
        }
        let Et = ( () => {
            var Kt;
            class At extends et.d {
                constructor(ve, ne, B, de, lt, St) {
                    super(ve, ne, B, de, lt, St),
                    this.host = ve,
                    this.zone = ne,
                    this.httpClient = B,
                    this.domSanitizer = de,
                    this.cdr = lt,
                    this.renderer2 = St,
                    this.map = (0,
                    re.cloneDeep)(et.G),
                    this.photoId = 0,
                    this.multiFile = !1,
                    this.isFileUploadingInProgress = !1,
                    this.setFileUpploadingProgress = new r.bkB,
                    this.photoSelect = new r.bkB,
                    this.photo1$ = new ct.t(null),
                    this.photoBottom$ = new ct.t(0),
                    this.textHeight$ = new ct.t(0),
                    this.charactersDefinition = ye.rc,
                    this.StarsShapesEnum = Ae.nhL,
                    this.MapsStyleEnum = Ae.c_T
                }
                ngAfterViewInit() {
                    (0,
                    Tt.z)([this.poster$, this.posterConfiguration$]).pipe((0,
                    Xe.B)(200), (0,
                    Qe.Q)(this.ngUnsubscribe)).subscribe( ([ve,ne]) => {
                        ve && (this.map.svgCoverWidth = ve.isPortrait ? Math.floor(ve.size.width) : Math.floor(.8 * ve.size.height),
                        this.map.sideCover = ve.isPortrait ? 0 : Math.floor((ve.size.width - this.map.svgCoverWidth) / 2),
                        this.imageInstanceSize = (null == ne ? void 0 : ne.shape) === Ae.U9G.HEART_PHOTO ? {
                            wrapperHeight: .18 * this.map.svgCoverWidth,
                            width: .35 * this.map.svgCoverWidth * (203.55 / 185),
                            height: .35 * this.map.svgCoverWidth,
                            marginTop: 0
                        } : {
                            wrapperHeight: .19 * this.map.svgCoverWidth,
                            width: .35 * this.map.svgCoverWidth,
                            height: .35 * this.map.svgCoverWidth,
                            marginTop: .2 * -this.map.svgCoverWidth
                        })
                    }
                    ),
                    (0,
                    Tt.z)([this.posterConfiguration$, this.textHeight$]).pipe((0,
                    Xe.B)(200), (0,
                    Qe.Q)(this.ngUnsubscribe)).subscribe( ([ve,ne]) => {
                        const B = this.poster$.getValue()
                          , de = this.posterConfiguration$.getValue()
                          , lt = this.textArea$.getValue();
                        if (!B || !lt)
                            return;
                        const St = B.isPortrait ? B.size.width : B.size.height;
                        if ((null == de ? void 0 : de.shape) === Ae.U9G.HEART_PHOTO)
                            this.photoBottom$.next(ne + St * (B.isPortrait ? .04 : .03));
                        else {
                            var tt;
                            const $t = (null !== (tt = lt.bottomFactor) && void 0 !== tt ? tt : 0) * St * (B.isPortrait ? .5 : .9);
                            this.photoBottom$.next(ne + $t)
                        }
                    }
                    )
                }
                setAllTextSettings(ve) {
                    const ne = ve.mapConfig[0]
                      , B = {
                        text: ne.customMessage ? ne.title : "",
                        isDefaultFont: !ne.titleFont
                    }
                      , de = {
                        text: ne.customMessage ? ne.subtitle : "",
                        isDefaultFont: !0
                    };
                    this.setText(B, this.title$, {
                        font: null != B && B.isDefaultFont ? Ae.n3q.MACHO : Ae.n3q.LUXUS_BRUT,
                        portrait: {
                            sizeFactor: .058,
                            topFactor: .03,
                            bottomFactor: de.text ? 0 : .014,
                            letterSpacingFactor: null != B && B.isDefaultFont ? 0 : .004,
                            isBold: !(null == B || !B.isDefaultFont)
                        },
                        square: {
                            sizeFactor: null != B && B.isDefaultFont ? .046 : .041,
                            topFactor: .03,
                            bottomFactor: de.text ? 0 : .014,
                            letterSpacingFactor: null != B && B.isDefaultFont ? 0 : .004,
                            isBold: !(null == B || !B.isDefaultFont)
                        },
                        horizontal: {
                            sizeFactor: null != B && B.isDefaultFont ? .046 : .056,
                            topFactor: .03,
                            bottomFactor: de.text ? 0 : .014,
                            letterSpacingFactor: null != B && B.isDefaultFont ? 0 : .004,
                            isBold: !(null == B || !B.isDefaultFont)
                        }
                    }),
                    this.setText(de, this.subtitle$, {
                        font: Ae.n3q.MACHO,
                        portrait: {
                            sizeFactor: .024,
                            bottomFactor: 0,
                            topFactor: B.text ? .01 : .03
                        },
                        horizontal: {
                            sizeFactor: .024,
                            bottomFactor: 0,
                            topFactor: .02
                        }
                    })
                }
                setTextArea(ve, ne) {
                    this.textArea$.next({
                        bottomFactor: ve.isPortrait ? .04 : .03,
                        marginFactor: ve.isPortrait ? .03 : .02,
                        topFactor: 0
                    })
                }
                setDesign(ve, ne) {
                    var B = this;
                    return (0,
                    Ut.A)(function*() {
                        var de, lt, St;
                        if (B.map.passepartoutSize = .05 * (ve.isPortrait ? ve.size.width : ve.size.height),
                        B.map.blockMapUpdate = ne.mapConfig[0].blockMapUpdate,
                        B.map.viewPort = [[ne.mapConfig[0].place.viewPort.west, ne.mapConfig[0].place.viewPort.south], [ne.mapConfig[0].place.viewPort.east, ne.mapConfig[0].place.viewPort.north]],
                        B.map.zoom = ne.mapConfig[0].zoom,
                        B.map.style = ne.colorScheme,
                        B.map.markerByWidth = ve.isPortrait,
                        B.map.customColor = ne.customColors,
                        B.map.layout = ne.shape,
                        B.map.background = B.getBackground(ne.colorScheme, ne.customColors),
                        B.map.textBackground = B.getBackground(ne.colorScheme, ne.customColors),
                        B.textColor$.next(B.getText(ne.colorScheme, ne.customColors)),
                        B.renderer2.setProperty(B.host.nativeElement, "style", "--character-outline-color: ".concat(B.map.background, "; --punching-die-color: ").concat(B.map.background)),
                        B.map.layoutBorderColor = B.getBorderColor(ne.colorScheme, ne.customColors, !1),
                        B.map.showMarker = !!ne.mapConfig[0].place.formattedAddress && ne.mapConfig[0].showMarker,
                        B.map.markerPosition = ne.mapConfig[0].markerSelectByGPS ? [ne.mapConfig[0].markerLngGPS, ne.mapConfig[0].markerLatGPS] : null !== (de = ne.mapConfig[0].markerPlace) && void 0 !== de && de.center ? [ne.mapConfig[0].markerPlace.center.longitude, ne.mapConfig[0].markerPlace.center.latitude] : [0, 0],
                        B.map.markerType = ne.mapConfig[0].markerType,
                        B.map.markerColor = ne.mapConfig[0].markerColor,
                        B.photo1$.next({
                            isPhoto: B.map.layout === Ae.U9G.PHOTO || B.map.layout === Ae.U9G.HEART_PHOTO,
                            isHeart: !1,
                            uuid: ne.mapConfig[0].photoFiles[0].uuid,
                            imageUrl: "".concat(B.environmentPhotoApi, "/v2/").concat(B.isFinalPoster ? "photo" : "image", "/").concat(ne.mapConfig[0].photoFiles[0].uuid, "?type=").concat(ne.mapConfig[0].cropsData[0].filter, "&left=").concat(ne.mapConfig[0].cropsData[0].cropData.x, "&top=").concat(ne.mapConfig[0].cropsData[0].cropData.y, "&width=").concat(ne.mapConfig[0].cropsData[0].cropData.width, "&height=").concat(ne.mapConfig[0].cropsData[0].cropData.height, "&rotate=").concat(ne.mapConfig[0].cropsData[0].rotate, "&flipped=").concat(ne.mapConfig[0].cropsData[0].flip),
                            showAddPhoto: !ne.mapConfig[0].photoFiles[0].uuid
                        }),
                        B.useImageMap && !B.mapFileDownloaded.has(null !== (lt = ne.mapConfig[0].uuid) && void 0 !== lt ? lt : ""))
                            if (B.mapFileDownloaded.add(null !== (St = ne.mapConfig[0].uuid) && void 0 !== St ? St : ""),
                            B.isFinalPoster) {
                                var tt;
                                const Nt = yield(0,
                                jt._)(B.httpClient.get("/api/map/image", {
                                    params: {
                                        uuid: null !== (tt = ne.mapConfig[0].uuid) && void 0 !== tt ? tt : ""
                                    },
                                    responseType: "blob"
                                }));
                                B.map.image = URL.createObjectURL(Nt)
                            } else {
                                var $t;
                                B.map.image = yield(0,
                                jt._)(B.httpClient.get("/api/map/mapbox/png", {
                                    params: {
                                        uuid: null !== ($t = ne.mapConfig[0].uuid) && void 0 !== $t ? $t : ""
                                    },
                                    responseType: "text"
                                }))
                            }
                        if (B.useImageMap) {
                            let Nt = (0,
                            it.H)(B.map.markerType);
                            const Vt = "#".concat(B.map.markerColor);
                            Nt = Nt.replace("// ___marker_color___", "\n                <style>\n                  path.marker-fill {\n                    fill: ".concat(Vt, ";\n                  }\n                  path.marker-stroke {\n                    stroke: ").concat(Vt, ";\n                  }\n                </style>\n                ")),
                            B.map.markerPrint = {
                                html: B.domSanitizer.bypassSecurityTrustHtml(Nt),
                                width: ne.mapConfig[0].markerSize.width / ne.mapConfig[0].map.width * 100,
                                height: ne.mapConfig[0].markerSize.height / ne.mapConfig[0].map.height * 100,
                                left: ne.mapConfig[0].markerLocation.x / ne.mapConfig[0].map.width * 100,
                                top: ne.mapConfig[0].markerLocation.y / ne.mapConfig[0].map.height * 100
                            }
                        }
                    })()
                }
                getPhotoWithType(ve) {
                    return ve
                }
                newTopTextareaHeight(ve) {
                    this.poster$ && this.textHeight$.next(ve)
                }
                onPhotoSelect() {
                    this.photoSelect.emit([this.imageInstanceSize.width, this.imageInstanceSize.height, 0])
                }
                onImageLoad() {
                    this.load++,
                    this.load === this.loadCondition() && (this.initiateRender(),
                    this.cdr.detectChanges())
                }
                loadCondition() {
                    return this.map.layout === Ae.U9G.PHOTO || this.map.layout === Ae.U9G.HEART_PHOTO ? 2 : 1
                }
            }
            return (Kt = At).\u0275fac = function(ve) {
                return new (ve || Kt)(r.rXU(r.aKT),r.rXU(r.SKi),r.rXU(Ie.Qq),r.rXU(gt.up),r.rXU(r.gRc),r.rXU(r.sFG))
            }
            ,
            Kt.\u0275cmp = r.VBU({
                type: Kt,
                selectors: [["pp-poster-map"]],
                inputs: {
                    photoFileGroup: "photoFileGroup",
                    photoCropGroup: "photoCropGroup",
                    photoId: "photoId",
                    multiFile: "multiFile",
                    cropperConfig: "cropperConfig",
                    environmentPhotoApi: "environmentPhotoApi",
                    isFileUploadingInProgress: "isFileUploadingInProgress"
                },
                outputs: {
                    setFileUpploadingProgress: "setFileUpploadingProgress",
                    photoSelect: "photoSelect"
                },
                features: [r.Vt3],
                decls: 5,
                vars: 5,
                consts: [["posterWrapper", ""], ["mapWrapper", ""], ["charComponents", ""], [3, "background"], [3, "poster", "passepartoutColor", "withPassepartout", 4, "ngIf"], [4, "ngIf"], [3, "poster", "passepartoutColor", "withPassepartout"], [3, "passepartoutSize", "internalBorderColor"], [1, "map-wrapper"], [3, "mapsEndpoint", "mapboxAccessToken", "mode", "idx", "isLocked", "newZoom", "viewPort", "zoom", "style", "markerByWidth", "isInteractive", "isMobile", "isActiveMap", "land", "water", "roads", "showMarker", "markerType", "markerColor", "markerPosition", "blockMapUpdate"], [3, "showPreview", "marginTop", "maxWidth", "previewType"], [3, "textareaHeightCallback", "poster", "color", "textArea", "title", "subtitle", "background"], [3, "load", "src"], ["class", "marker", 3, "left", "top", "height", "width", "innerHTML", 4, "ngIf"], [1, "marker", 3, "innerHTML"], [3, "updateMapConfig", "updateMarkerConfig", "mapsEndpoint", "mapboxAccessToken", "mode", "idx", "isLocked", "newZoom", "viewPort", "zoom", "markerByWidth", "isInteractive", "isMobile", "isActiveMap", "land", "water", "roads", "showMarker", "markerType", "markerColor", "markerPosition", "blockMapUpdate"], [1, "layout-wrapper"], [1, "cover"], [1, "cover-left"], [1, "svg-cover"], [3, "src"], [1, "cover-right"], [1, "cover-area"], [1, "layout-wrapper-border"], [1, "image-area-wrapper", 3, "background", "bottom", "width", "height"], ["class", "image-area-wrapper", 3, "background", "bottom", "width", "height", 4, "ngIf"], [1, "image-area-wrapper"], [1, "heart-image-wrapper", 3, "width", "height"], [1, "heart-image-wrapper"], [3, "setFileUploadingProgress", "selectPhoto", "photoLoaded", "isFinalPoster", "fillWhite", "showUploadInfoText", "isInteractive", "letterDefaultZoom", "charId", "character", "imageUrl", "imageId", "photoFileGroup", "photoCropGroup", "multiFile", "isFileUploadingInProgress", "readyToLoad", "svgCharFilesPath", "charactersDefinition"]],
                template: function(ve, ne) {
                    1 & ve && (r.j41(0, "pp-poster-background", 3, 0),
                    r.DNE(2, Jt, 15, 46, "pp-poster-printing-registration", 4),
                    r.nI1(3, "async"),
                    r.k0s(),
                    r.DNE(4, po, 1, 0, "pp-poster-loaded-element", 5)),
                    2 & ve && (r.Y8G("background", ne.map.background),
                    r.R7$(2),
                    r.Y8G("ngIf", r.bMT(3, 3, ne.poster$)),
                    r.R7$(2),
                    r.Y8G("ngIf", ne.isImageRendered))
                },
                dependencies: [_t.MD, _t.bT, _t.Jj, Mt.Z, s.R, Wt.c, so.y, Me.iu, Me.DM, Ce.f, Be.C, ze.c, ge.P],
                styles: ["[_nghost-%COMP%]{--border-color: #E53422;--character-outline-color: #000;width:100%;height:100%;display:block}[_nghost-%COMP%]   .map-wrapper[_ngcontent-%COMP%]{position:absolute;top:0;right:0;bottom:0;left:0;display:block}[_nghost-%COMP%]   .map-wrapper[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:100%;height:100%;object-fit:cover}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]{position:absolute;overflow:hidden;pointer-events:none;left:0;right:0;top:0;bottom:0;z-index:1}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]   .cover[_ngcontent-%COMP%]{width:100%;display:flex;overflow:hidden}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]   .cover[_ngcontent-%COMP%]   .cover-left[_ngcontent-%COMP%]{float:left;display:block;background:#fff}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]   .cover[_ngcontent-%COMP%]   .cover-right[_ngcontent-%COMP%]{float:left;display:block;background:#fff}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]   .cover[_ngcontent-%COMP%]   .svg-cover[_ngcontent-%COMP%]{width:100%;display:block;margin:auto;float:left}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]     svg{display:block}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]     svg .contour{stroke:var(--border-color)}[_nghost-%COMP%]   .layout-wrapper[_ngcontent-%COMP%]   .cover-area[_ngcontent-%COMP%]{margin-top:-2px;width:100%;height:100%;background:#fff}[_nghost-%COMP%]   .layout-wrapper-border[_ngcontent-%COMP%]{position:absolute;box-sizing:border-box;border:0px solid white;z-index:2;pointer-events:none}[_nghost-%COMP%]   .image-area-wrapper[_ngcontent-%COMP%]{background:transparent;position:absolute;z-index:10}[_nghost-%COMP%]   .circle-image-wrapper[_ngcontent-%COMP%]{border-radius:50%;background:#fff;margin:auto;position:relative;cursor:pointer}[_nghost-%COMP%]   .circle-image-wrapper[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:100%;height:100%;object-fit:cover;border-radius:50%}[_nghost-%COMP%]   .heart-image-wrapper[_ngcontent-%COMP%]{position:absolute;left:0;right:0;bottom:0;margin:auto;cursor:pointer}[_nghost-%COMP%]   .marker[_ngcontent-%COMP%]{position:absolute;z-index:1;transform:translate(-50%,-50%)}[_nghost-%COMP%]   .marker[_ngcontent-%COMP%]     svg{width:100%;height:100%;position:absolute;top:0;left:0}[_nghost-%COMP%]   .marker[_ngcontent-%COMP%]     svg path.marker-stroke{fill:none;stroke-width:3}[_nghost-%COMP%]     svg   path.outline{fill:var(--character-outline-color)}[_nghost-%COMP%]     svg   path.punching-die{fill:var(--punching-die-color)}"]
            }),
            At
        }
        )()
    }
    ,
    81247: function(zi) {
        zi.exports = function() {
            "use strict";
            var Bo, $, Ut;
            function r(s, so) {
                if (Bo)
                    if ($) {
                        var Wt = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + Bo + ")(sharedChunk); (" + $ + ")(sharedChunk); self.onerror = null;"
                          , _t = {};
                        Bo(_t),
                        Ut = so(_t),
                        typeof window < "u" && window && window.URL && window.URL.createObjectURL && (Ut.workerUrl = window.URL.createObjectURL(new Blob([Wt],{
                            type: "text/javascript"
                        })))
                    } else
                        $ = so;
                else
                    Bo = so
            }
            return r(0, function(s) {
                function so(n) {
                    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
                }
                var Wt, _t = {}, Ae = {};
                function Me() {
                    if (Wt)
                        return Ae;
                    Wt = 1,
                    Object.defineProperty(Ae, "__esModule", {
                        value: !0
                    }),
                    Ae.setMatrixArrayType = function(u) {
                        Ae.ARRAY_TYPE = e = u
                    }
                    ,
                    Ae.toRadian = function(u) {
                        return u * a
                    }
                    ,
                    Ae.equals = function(u, l) {
                        return Math.abs(u - l) <= n * Math.max(1, Math.abs(u), Math.abs(l))
                    }
                    ,
                    Ae.RANDOM = Ae.ARRAY_TYPE = Ae.EPSILON = void 0;
                    var n = 1e-6;
                    Ae.EPSILON = n;
                    var e = typeof Float32Array < "u" ? Float32Array : Array;
                    Ae.ARRAY_TYPE = e;
                    var o = Math.random;
                    Ae.RANDOM = o;
                    var a = Math.PI / 180;
                    return Math.hypot || (Math.hypot = function() {
                        for (var u = 0, l = arguments.length; l--; )
                            u += arguments[l] * arguments[l];
                        return Math.sqrt(u)
                    }
                    ),
                    Ae
                }
                var ct, Tt = {};
                function Qe() {
                    if (ct)
                        return Tt;
                    function n(l) {
                        return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(p) {
                            return typeof p
                        }
                        : function(p) {
                            return p && "function" == typeof Symbol && p.constructor === Symbol && p !== Symbol.prototype ? "symbol" : typeof p
                        }
                        )(l)
                    }
                    ct = 1,
                    Object.defineProperty(Tt, "__esModule", {
                        value: !0
                    }),
                    Tt.create = function() {
                        var l = new e.ARRAY_TYPE(4);
                        return e.ARRAY_TYPE != Float32Array && (l[1] = 0,
                        l[2] = 0),
                        l[0] = 1,
                        l[3] = 1,
                        l
                    }
                    ,
                    Tt.clone = function(l) {
                        var p = new e.ARRAY_TYPE(4);
                        return p[0] = l[0],
                        p[1] = l[1],
                        p[2] = l[2],
                        p[3] = l[3],
                        p
                    }
                    ,
                    Tt.copy = function(l, p) {
                        return l[0] = p[0],
                        l[1] = p[1],
                        l[2] = p[2],
                        l[3] = p[3],
                        l
                    }
                    ,
                    Tt.identity = function(l) {
                        return l[0] = 1,
                        l[1] = 0,
                        l[2] = 0,
                        l[3] = 1,
                        l
                    }
                    ,
                    Tt.fromValues = function(l, p, g, x) {
                        var T = new e.ARRAY_TYPE(4);
                        return T[0] = l,
                        T[1] = p,
                        T[2] = g,
                        T[3] = x,
                        T
                    }
                    ,
                    Tt.set = function(l, p, g, x, T) {
                        return l[0] = p,
                        l[1] = g,
                        l[2] = x,
                        l[3] = T,
                        l
                    }
                    ,
                    Tt.transpose = function(l, p) {
                        if (l === p) {
                            var g = p[1];
                            l[1] = p[2],
                            l[2] = g
                        } else
                            l[0] = p[0],
                            l[1] = p[2],
                            l[2] = p[1],
                            l[3] = p[3];
                        return l
                    }
                    ,
                    Tt.invert = function(l, p) {
                        var g = p[0]
                          , x = p[1]
                          , T = p[2]
                          , f = p[3]
                          , b = g * f - T * x;
                        return b ? (l[0] = f * (b = 1 / b),
                        l[1] = -x * b,
                        l[2] = -T * b,
                        l[3] = g * b,
                        l) : null
                    }
                    ,
                    Tt.adjoint = function(l, p) {
                        var g = p[0];
                        return l[0] = p[3],
                        l[1] = -p[1],
                        l[2] = -p[2],
                        l[3] = g,
                        l
                    }
                    ,
                    Tt.determinant = function(l) {
                        return l[0] * l[3] - l[2] * l[1]
                    }
                    ,
                    Tt.multiply = a,
                    Tt.rotate = function(l, p, g) {
                        var x = p[0]
                          , T = p[1]
                          , f = p[2]
                          , b = p[3]
                          , P = Math.sin(g)
                          , v = Math.cos(g);
                        return l[0] = x * v + f * P,
                        l[1] = T * v + b * P,
                        l[2] = x * -P + f * v,
                        l[3] = T * -P + b * v,
                        l
                    }
                    ,
                    Tt.scale = function(l, p, g) {
                        var x = p[1]
                          , T = p[2]
                          , f = p[3]
                          , b = g[0]
                          , P = g[1];
                        return l[0] = p[0] * b,
                        l[1] = x * b,
                        l[2] = T * P,
                        l[3] = f * P,
                        l
                    }
                    ,
                    Tt.fromRotation = function(l, p) {
                        var g = Math.sin(p)
                          , x = Math.cos(p);
                        return l[0] = x,
                        l[1] = g,
                        l[2] = -g,
                        l[3] = x,
                        l
                    }
                    ,
                    Tt.fromScaling = function(l, p) {
                        return l[0] = p[0],
                        l[1] = 0,
                        l[2] = 0,
                        l[3] = p[1],
                        l
                    }
                    ,
                    Tt.str = function(l) {
                        return "mat2(" + l[0] + ", " + l[1] + ", " + l[2] + ", " + l[3] + ")"
                    }
                    ,
                    Tt.frob = function(l) {
                        return Math.hypot(l[0], l[1], l[2], l[3])
                    }
                    ,
                    Tt.LDU = function(l, p, g, x) {
                        return l[2] = x[2] / x[0],
                        g[0] = x[0],
                        g[1] = x[1],
                        g[3] = x[3] - l[2] * g[1],
                        [l, p, g]
                    }
                    ,
                    Tt.add = function(l, p, g) {
                        return l[0] = p[0] + g[0],
                        l[1] = p[1] + g[1],
                        l[2] = p[2] + g[2],
                        l[3] = p[3] + g[3],
                        l
                    }
                    ,
                    Tt.subtract = u,
                    Tt.exactEquals = function(l, p) {
                        return l[0] === p[0] && l[1] === p[1] && l[2] === p[2] && l[3] === p[3]
                    }
                    ,
                    Tt.equals = function(l, p) {
                        var g = l[0]
                          , x = l[1]
                          , T = l[2]
                          , f = l[3]
                          , b = p[0]
                          , P = p[1]
                          , v = p[2]
                          , w = p[3];
                        return Math.abs(g - b) <= e.EPSILON * Math.max(1, Math.abs(g), Math.abs(b)) && Math.abs(x - P) <= e.EPSILON * Math.max(1, Math.abs(x), Math.abs(P)) && Math.abs(T - v) <= e.EPSILON * Math.max(1, Math.abs(T), Math.abs(v)) && Math.abs(f - w) <= e.EPSILON * Math.max(1, Math.abs(f), Math.abs(w))
                    }
                    ,
                    Tt.multiplyScalar = function(l, p, g) {
                        return l[0] = p[0] * g,
                        l[1] = p[1] * g,
                        l[2] = p[2] * g,
                        l[3] = p[3] * g,
                        l
                    }
                    ,
                    Tt.multiplyScalarAndAdd = function(l, p, g, x) {
                        return l[0] = p[0] + g[0] * x,
                        l[1] = p[1] + g[1] * x,
                        l[2] = p[2] + g[2] * x,
                        l[3] = p[3] + g[3] * x,
                        l
                    }
                    ,
                    Tt.sub = Tt.mul = void 0;
                    var e = function(l) {
                        if (l && l.__esModule)
                            return l;
                        if (null === l || "object" !== n(l) && "function" != typeof l)
                            return {
                                default: l
                            };
                        var g = o(void 0);
                        if (g && g.has(l))
                            return g.get(l);
                        var x = {}
                          , T = Object.defineProperty && Object.getOwnPropertyDescriptor;
                        for (var f in l)
                            if ("default" !== f && Object.prototype.hasOwnProperty.call(l, f)) {
                                var b = T ? Object.getOwnPropertyDescriptor(l, f) : null;
                                b && (b.get || b.set) ? Object.defineProperty(x, f, b) : x[f] = l[f]
                            }
                        return x.default = l,
                        g && g.set(l, x),
                        x
                    }(Me());
                    function o(l) {
                        if ("function" != typeof WeakMap)
                            return null;
                        var p = new WeakMap
                          , g = new WeakMap;
                        return (o = function(x) {
                            return x ? g : p
                        }
                        )(l)
                    }
                    function a(l, p, g) {
                        var x = p[0]
                          , T = p[1]
                          , f = p[2]
                          , b = p[3]
                          , P = g[0]
                          , v = g[1]
                          , w = g[2]
                          , C = g[3];
                        return l[0] = x * P + f * v,
                        l[1] = T * P + b * v,
                        l[2] = x * w + f * C,
                        l[3] = T * w + b * C,
                        l
                    }
                    function u(l, p, g) {
                        return l[0] = p[0] - g[0],
                        l[1] = p[1] - g[1],
                        l[2] = p[2] - g[2],
                        l[3] = p[3] - g[3],
                        l
                    }
                    return Tt.mul = a,
                    Tt.sub = u,
                    Tt
                }
                var jt, Xe = {};
                function Ce() {
                    if (jt)
                        return Xe;
                    function n(l) {
                        return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(p) {
                            return typeof p
                        }
                        : function(p) {
                            return p && "function" == typeof Symbol && p.constructor === Symbol && p !== Symbol.prototype ? "symbol" : typeof p
                        }
                        )(l)
                    }
                    jt = 1,
                    Object.defineProperty(Xe, "__esModule", {
                        value: !0
                    }),
                    Xe.create = function() {
                        var l = new e.ARRAY_TYPE(6);
                        return e.ARRAY_TYPE != Float32Array && (l[1] = 0,
                        l[2] = 0,
                        l[4] = 0,
                        l[5] = 0),
                        l[0] = 1,
                        l[3] = 1,
                        l
                    }
                    ,
                    Xe.clone = function(l) {
                        var p = new e.ARRAY_TYPE(6);
                        return p[0] = l[0],
                        p[1] = l[1],
                        p[2] = l[2],
                        p[3] = l[3],
                        p[4] = l[4],
                        p[5] = l[5],
                        p
                    }
                    ,
                    Xe.copy = function(l, p) {
                        return l[0] = p[0],
                        l[1] = p[1],
                        l[2] = p[2],
                        l[3] = p[3],
                        l[4] = p[4],
                        l[5] = p[5],
                        l
                    }
                    ,
                    Xe.identity = function(l) {
                        return l[0] = 1,
                        l[1] = 0,
                        l[2] = 0,
                        l[3] = 1,
                        l[4] = 0,
                        l[5] = 0,
                        l
                    }
                    ,
                    Xe.fromValues = function(l, p, g, x, T, f) {
                        var b = new e.ARRAY_TYPE(6);
                        return b[0] = l,
                        b[1] = p,
                        b[2] = g,
                        b[3] = x,
                        b[4] = T,
                        b[5] = f,
                        b
                    }
                    ,
                    Xe.set = function(l, p, g, x, T, f, b) {
                        return l[0] = p,
                        l[1] = g,
                        l[2] = x,
                        l[3] = T,
                        l[4] = f,
                        l[5] = b,
                        l
                    }
                    ,
                    Xe.invert = function(l, p) {
                        var g = p[0]
                          , x = p[1]
                          , T = p[2]
                          , f = p[3]
                          , b = p[4]
                          , P = p[5]
                          , v = g * f - x * T;
                        return v ? (l[0] = f * (v = 1 / v),
                        l[1] = -x * v,
                        l[2] = -T * v,
                        l[3] = g * v,
                        l[4] = (T * P - f * b) * v,
                        l[5] = (x * b - g * P) * v,
                        l) : null
                    }
                    ,
                    Xe.determinant = function(l) {
                        return l[0] * l[3] - l[1] * l[2]
                    }
                    ,
                    Xe.multiply = a,
                    Xe.rotate = function(l, p, g) {
                        var x = p[0]
                          , T = p[1]
                          , f = p[2]
                          , b = p[3]
                          , P = p[4]
                          , v = p[5]
                          , w = Math.sin(g)
                          , C = Math.cos(g);
                        return l[0] = x * C + f * w,
                        l[1] = T * C + b * w,
                        l[2] = x * -w + f * C,
                        l[3] = T * -w + b * C,
                        l[4] = P,
                        l[5] = v,
                        l
                    }
                    ,
                    Xe.scale = function(l, p, g) {
                        var x = p[1]
                          , T = p[2]
                          , f = p[3]
                          , b = p[4]
                          , P = p[5]
                          , v = g[0]
                          , w = g[1];
                        return l[0] = p[0] * v,
                        l[1] = x * v,
                        l[2] = T * w,
                        l[3] = f * w,
                        l[4] = b,
                        l[5] = P,
                        l
                    }
                    ,
                    Xe.translate = function(l, p, g) {
                        var x = p[0]
                          , T = p[1]
                          , f = p[2]
                          , b = p[3]
                          , P = p[4]
                          , v = p[5]
                          , w = g[0]
                          , C = g[1];
                        return l[0] = x,
                        l[1] = T,
                        l[2] = f,
                        l[3] = b,
                        l[4] = x * w + f * C + P,
                        l[5] = T * w + b * C + v,
                        l
                    }
                    ,
                    Xe.fromRotation = function(l, p) {
                        var g = Math.sin(p)
                          , x = Math.cos(p);
                        return l[0] = x,
                        l[1] = g,
                        l[2] = -g,
                        l[3] = x,
                        l[4] = 0,
                        l[5] = 0,
                        l
                    }
                    ,
                    Xe.fromScaling = function(l, p) {
                        return l[0] = p[0],
                        l[1] = 0,
                        l[2] = 0,
                        l[3] = p[1],
                        l[4] = 0,
                        l[5] = 0,
                        l
                    }
                    ,
                    Xe.fromTranslation = function(l, p) {
                        return l[0] = 1,
                        l[1] = 0,
                        l[2] = 0,
                        l[3] = 1,
                        l[4] = p[0],
                        l[5] = p[1],
                        l
                    }
                    ,
                    Xe.str = function(l) {
                        return "mat2d(" + l[0] + ", " + l[1] + ", " + l[2] + ", " + l[3] + ", " + l[4] + ", " + l[5] + ")"
                    }
                    ,
                    Xe.frob = function(l) {
                        return Math.hypot(l[0], l[1], l[2], l[3], l[4], l[5], 1)
                    }
                    ,
                    Xe.add = function(l, p, g) {
                        return l[0] = p[0] + g[0],
                        l[1] = p[1] + g[1],
                        l[2] = p[2] + g[2],
                        l[3] = p[3] + g[3],
                        l[4] = p[4] + g[4],
                        l[5] = p[5] + g[5],
                        l
                    }
                    ,
                    Xe.subtract = u,
                    Xe.multiplyScalar = function(l, p, g) {
                        return l[0] = p[0] * g,
                        l[1] = p[1] * g,
                        l[2] = p[2] * g,
                        l[3] = p[3] * g,
                        l[4] = p[4] * g,
                        l[5] = p[5] * g,
                        l
                    }
                    ,
                    Xe.multiplyScalarAndAdd = function(l, p, g, x) {
                        return l[0] = p[0] + g[0] * x,
                        l[1] = p[1] + g[1] * x,
                        l[2] = p[2] + g[2] * x,
                        l[3] = p[3] + g[3] * x,
                        l[4] = p[4] + g[4] * x,
                        l[5] = p[5] + g[5] * x,
                        l
                    }
                    ,
                    Xe.exactEquals = function(l, p) {
                        return l[0] === p[0] && l[1] === p[1] && l[2] === p[2] && l[3] === p[3] && l[4] === p[4] && l[5] === p[5]
                    }
                    ,
                    Xe.equals = function(l, p) {
                        var g = l[0]
                          , x = l[1]
                          , T = l[2]
                          , f = l[3]
                          , b = l[4]
                          , P = l[5]
                          , v = p[0]
                          , w = p[1]
                          , C = p[2]
                          , A = p[3]
                          , O = p[4]
                          , F = p[5];
                        return Math.abs(g - v) <= e.EPSILON * Math.max(1, Math.abs(g), Math.abs(v)) && Math.abs(x - w) <= e.EPSILON * Math.max(1, Math.abs(x), Math.abs(w)) && Math.abs(T - C) <= e.EPSILON * Math.max(1, Math.abs(T), Math.abs(C)) && Math.abs(f - A) <= e.EPSILON * Math.max(1, Math.abs(f), Math.abs(A)) && Math.abs(b - O) <= e.EPSILON * Math.max(1, Math.abs(b), Math.abs(O)) && Math.abs(P - F) <= e.EPSILON * Math.max(1, Math.abs(P), Math.abs(F))
                    }
                    ,
                    Xe.sub = Xe.mul = void 0;
                    var e = function(l) {
                        if (l && l.__esModule)
                            return l;
                        if (null === l || "object" !== n(l) && "function" != typeof l)
                            return {
                                default: l
                            };
                        var g = o(void 0);
                        if (g && g.has(l))
                            return g.get(l);
                        var x = {}
                          , T = Object.defineProperty && Object.getOwnPropertyDescriptor;
                        for (var f in l)
                            if ("default" !== f && Object.prototype.hasOwnProperty.call(l, f)) {
                                var b = T ? Object.getOwnPropertyDescriptor(l, f) : null;
                                b && (b.get || b.set) ? Object.defineProperty(x, f, b) : x[f] = l[f]
                            }
                        return x.default = l,
                        g && g.set(l, x),
                        x
                    }(Me());
                    function o(l) {
                        if ("function" != typeof WeakMap)
                            return null;
                        var p = new WeakMap
                          , g = new WeakMap;
                        return (o = function(x) {
                            return x ? g : p
                        }
                        )(l)
                    }
                    function a(l, p, g) {
                        var x = p[0]
                          , T = p[1]
                          , f = p[2]
                          , b = p[3]
                          , P = p[4]
                          , v = p[5]
                          , w = g[0]
                          , C = g[1]
                          , A = g[2]
                          , O = g[3]
                          , F = g[4]
                          , z = g[5];
                        return l[0] = x * w + f * C,
                        l[1] = T * w + b * C,
                        l[2] = x * A + f * O,
                        l[3] = T * A + b * O,
                        l[4] = x * F + f * z + P,
                        l[5] = T * F + b * z + v,
                        l
                    }
                    function u(l, p, g) {
                        return l[0] = p[0] - g[0],
                        l[1] = p[1] - g[1],
                        l[2] = p[2] - g[2],
                        l[3] = p[3] - g[3],
                        l[4] = p[4] - g[4],
                        l[5] = p[5] - g[5],
                        l
                    }
                    return Xe.mul = a,
                    Xe.sub = u,
                    Xe
                }
                var it, et = {};
                function re() {
                    if (it)
                        return et;
                    function n(l) {
                        return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(p) {
                            return typeof p
                        }
                        : function(p) {
                            return p && "function" == typeof Symbol && p.constructor === Symbol && p !== Symbol.prototype ? "symbol" : typeof p
                        }
                        )(l)
                    }
                    it = 1,
                    Object.defineProperty(et, "__esModule", {
                        value: !0
                    }),
                    et.create = function() {
                        var l = new e.ARRAY_TYPE(9);
                        return e.ARRAY_TYPE != Float32Array && (l[1] = 0,
                        l[2] = 0,
                        l[3] = 0,
                        l[5] = 0,
                        l[6] = 0,
                        l[7] = 0),
                        l[0] = 1,
                        l[4] = 1,
                        l[8] = 1,
                        l
                    }
                    ,
                    et.fromMat4 = function(l, p) {
                        return l[0] = p[0],
                        l[1] = p[1],
                        l[2] = p[2],
                        l[3] = p[4],
                        l[4] = p[5],
                        l[5] = p[6],
                        l[6] = p[8],
                        l[7] = p[9],
                        l[8] = p[10],
                        l
                    }
                    ,
                    et.clone = function(l) {
                        var p = new e.ARRAY_TYPE(9);
                        return p[0] = l[0],
                        p[1] = l[1],
                        p[2] = l[2],
                        p[3] = l[3],
                        p[4] = l[4],
                        p[5] = l[5],
                        p[6] = l[6],
                        p[7] = l[7],
                        p[8] = l[8],
                        p
                    }
                    ,
                    et.copy = function(l, p) {
                        return l[0] = p[0],
                        l[1] = p[1],
                        l[2] = p[2],
                        l[3] = p[3],
                        l[4] = p[4],
                        l[5] = p[5],
                        l[6] = p[6],
                        l[7] = p[7],
                        l[8] = p[8],
                        l
                    }
                    ,
                    et.fromValues = function(l, p, g, x, T, f, b, P, v) {
                        var w = new e.ARRAY_TYPE(9);
                        return w[0] = l,
                        w[1] = p,
                        w[2] = g,
                        w[3] = x,
                        w[4] = T,
                        w[5] = f,
                        w[6] = b,
                        w[7] = P,
                        w[8] = v,
                        w
                    }
                    ,
                    et.set = function(l, p, g, x, T, f, b, P, v, w) {
                        return l[0] = p,
                        l[1] = g,
                        l[2] = x,
                        l[3] = T,
                        l[4] = f,
                        l[5] = b,
                        l[6] = P,
                        l[7] = v,
                        l[8] = w,
                        l
                    }
                    ,
                    et.identity = function(l) {
                        return l[0] = 1,
                        l[1] = 0,
                        l[2] = 0,
                        l[3] = 0,
                        l[4] = 1,
                        l[5] = 0,
                        l[6] = 0,
                        l[7] = 0,
                        l[8] = 1,
                        l
                    }
                    ,
                    et.transpose = function(l, p) {
                        if (l === p) {
                            var g = p[1]
                              , x = p[2]
                              , T = p[5];
                            l[1] = p[3],
                            l[2] = p[6],
                            l[3] = g,
                            l[5] = p[7],
                            l[6] = x,
                            l[7] = T
                        } else
                            l[0] = p[0],
                            l[1] = p[3],
                            l[2] = p[6],
                            l[3] = p[1],
                            l[4] = p[4],
                            l[5] = p[7],
                            l[6] = p[2],
                            l[7] = p[5],
                            l[8] = p[8];
                        return l
                    }
                    ,
                    et.invert = function(l, p) {
                        var g = p[0]
                          , x = p[1]
                          , T = p[2]
                          , f = p[3]
                          , b = p[4]
                          , P = p[5]
                          , v = p[6]
                          , w = p[7]
                          , C = p[8]
                          , A = C * b - P * w
                          , O = -C * f + P * v
                          , F = w * f - b * v
                          , z = g * A + x * O + T * F;
                        return z ? (l[0] = A * (z = 1 / z),
                        l[1] = (-C * x + T * w) * z,
                        l[2] = (P * x - T * b) * z,
                        l[3] = O * z,
                        l[4] = (C * g - T * v) * z,
                        l[5] = (-P * g + T * f) * z,
                        l[6] = F * z,
                        l[7] = (-w * g + x * v) * z,
                        l[8] = (b * g - x * f) * z,
                        l) : null
                    }
                    ,
                    et.adjoint = function(l, p) {
                        var g = p[0]
                          , x = p[1]
                          , T = p[2]
                          , f = p[3]
                          , b = p[4]
                          , P = p[5]
                          , v = p[6]
                          , w = p[7]
                          , C = p[8];
                        return l[0] = b * C - P * w,
                        l[1] = T * w - x * C,
                        l[2] = x * P - T * b,
                        l[3] = P * v - f * C,
                        l[4] = g * C - T * v,
                        l[5] = T * f - g * P,
                        l[6] = f * w - b * v,
                        l[7] = x * v - g * w,
                        l[8] = g * b - x * f,
                        l
                    }
                    ,
                    et.determinant = function(l) {
                        var p = l[3]
                          , g = l[4]
                          , x = l[5]
                          , T = l[6]
                          , f = l[7]
                          , b = l[8];
                        return l[0] * (b * g - x * f) + l[1] * (-b * p + x * T) + l[2] * (f * p - g * T)
                    }
                    ,
                    et.multiply = a,
                    et.translate = function(l, p, g) {
                        var x = p[0]
                          , T = p[1]
                          , f = p[2]
                          , b = p[3]
                          , P = p[4]
                          , v = p[5]
                          , w = p[6]
                          , C = p[7]
                          , A = p[8]
                          , O = g[0]
                          , F = g[1];
                        return l[0] = x,
                        l[1] = T,
                        l[2] = f,
                        l[3] = b,
                        l[4] = P,
                        l[5] = v,
                        l[6] = O * x + F * b + w,
                        l[7] = O * T + F * P + C,
                        l[8] = O * f + F * v + A,
                        l
                    }
                    ,
                    et.rotate = function(l, p, g) {
                        var x = p[0]
                          , T = p[1]
                          , f = p[2]
                          , b = p[3]
                          , P = p[4]
                          , v = p[5]
                          , w = p[6]
                          , C = p[7]
                          , A = p[8]
                          , O = Math.sin(g)
                          , F = Math.cos(g);
                        return l[0] = F * x + O * b,
                        l[1] = F * T + O * P,
                        l[2] = F * f + O * v,
                        l[3] = F * b - O * x,
                        l[4] = F * P - O * T,
                        l[5] = F * v - O * f,
                        l[6] = w,
                        l[7] = C,
                        l[8] = A,
                        l
                    }
                    ,
                    et.scale = function(l, p, g) {
                        var x = g[0]
                          , T = g[1];
                        return l[0] = x * p[0],
                        l[1] = x * p[1],
                        l[2] = x * p[2],
                        l[3] = T * p[3],
                        l[4] = T * p[4],
                        l[5] = T * p[5],
                        l[6] = p[6],
                        l[7] = p[7],
                        l[8] = p[8],
                        l
                    }
                    ,
                    et.fromTranslation = function(l, p) {
                        return l[0] = 1,
                        l[1] = 0,
                        l[2] = 0,
                        l[3] = 0,
                        l[4] = 1,
                        l[5] = 0,
                        l[6] = p[0],
                        l[7] = p[1],
                        l[8] = 1,
                        l
                    }
                    ,
                    et.fromRotation = function(l, p) {
                        var g = Math.sin(p)
                          , x = Math.cos(p);
                        return l[0] = x,
                        l[1] = g,
                        l[2] = 0,
                        l[3] = -g,
                        l[4] = x,
                        l[5] = 0,
                        l[6] = 0,
                        l[7] = 0,
                        l[8] = 1,
                        l
                    }
                    ,
                    et.fromScaling = function(l, p) {
                        return l[0] = p[0],
                        l[1] = 0,
                        l[2] = 0,
                        l[3] = 0,
                        l[4] = p[1],
                        l[5] = 0,
                        l[6] = 0,
                        l[7] = 0,
                        l[8] = 1,
                        l
                    }
                    ,
                    et.fromMat2d = function(l, p) {
                        return l[0] = p[0],
                        l[1] = p[1],
                        l[2] = 0,
                        l[3] = p[2],
                        l[4] = p[3],
                        l[5] = 0,
                        l[6] = p[4],
                        l[7] = p[5],
                        l[8] = 1,
                        l
                    }
                    ,
                    et.fromQuat = function(l, p) {
                        var g = p[0]
                          , x = p[1]
                          , T = p[2]
                          , f = p[3]
                          , b = g + g
                          , P = x + x
                          , v = T + T
                          , w = g * b
                          , C = x * b
                          , A = x * P
                          , O = T * b
                          , F = T * P
                          , z = T * v
                          , L = f * b
                          , N = f * P
                          , G = f * v;
                        return l[0] = 1 - A - z,
                        l[3] = C - G,
                        l[6] = O + N,
                        l[1] = C + G,
                        l[4] = 1 - w - z,
                        l[7] = F - L,
                        l[2] = O - N,
                        l[5] = F + L,
                        l[8] = 1 - w - A,
                        l
                    }
                    ,
                    et.normalFromMat4 = function(l, p) {
                        var g = p[0]
                          , x = p[1]
                          , T = p[2]
                          , f = p[3]
                          , b = p[4]
                          , P = p[5]
                          , v = p[6]
                          , w = p[7]
                          , C = p[8]
                          , A = p[9]
                          , O = p[10]
                          , F = p[11]
                          , z = p[12]
                          , L = p[13]
                          , N = p[14]
                          , G = p[15]
                          , X = g * P - x * b
                          , _e = g * v - T * b
                          , me = g * w - f * b
                          , pe = x * v - T * P
                          , Ne = x * w - f * P
                          , Pe = T * w - f * v
                          , $e = C * L - A * z
                          , We = C * N - O * z
                          , je = C * G - F * z
                          , Ke = A * N - O * L
                          , rt = A * G - F * L
                          , at = O * G - F * N
                          , ot = X * at - _e * rt + me * Ke + pe * je - Ne * We + Pe * $e;
                        return ot ? (l[0] = (P * at - v * rt + w * Ke) * (ot = 1 / ot),
                        l[1] = (v * je - b * at - w * We) * ot,
                        l[2] = (b * rt - P * je + w * $e) * ot,
                        l[3] = (T * rt - x * at - f * Ke) * ot,
                        l[4] = (g * at - T * je + f * We) * ot,
                        l[5] = (x * je - g * rt - f * $e) * ot,
                        l[6] = (L * Pe - N * Ne + G * pe) * ot,
                        l[7] = (N * me - z * Pe - G * _e) * ot,
                        l[8] = (z * Ne - L * me + G * X) * ot,
                        l) : null
                    }
                    ,
                    et.projection = function(l, p, g) {
                        return l[0] = 2 / p,
                        l[1] = 0,
                        l[2] = 0,
                        l[3] = 0,
                        l[4] = -2 / g,
                        l[5] = 0,
                        l[6] = -1,
                        l[7] = 1,
                        l[8] = 1,
                        l
                    }
                    ,
                    et.str = function(l) {
                        return "mat3(" + l[0] + ", " + l[1] + ", " + l[2] + ", " + l[3] + ", " + l[4] + ", " + l[5] + ", " + l[6] + ", " + l[7] + ", " + l[8] + ")"
                    }
                    ,
                    et.frob = function(l) {
                        return Math.hypot(l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7], l[8])
                    }
                    ,
                    et.add = function(l, p, g) {
                        return l[0] = p[0] + g[0],
                        l[1] = p[1] + g[1],
                        l[2] = p[2] + g[2],
                        l[3] = p[3] + g[3],
                        l[4] = p[4] + g[4],
                        l[5] = p[5] + g[5],
                        l[6] = p[6] + g[6],
                        l[7] = p[7] + g[7],
                        l[8] = p[8] + g[8],
                        l
                    }
                    ,
                    et.subtract = u,
                    et.multiplyScalar = function(l, p, g) {
                        return l[0] = p[0] * g,
                        l[1] = p[1] * g,
                        l[2] = p[2] * g,
                        l[3] = p[3] * g,
                        l[4] = p[4] * g,
                        l[5] = p[5] * g,
                        l[6] = p[6] * g,
                        l[7] = p[7] * g,
                        l[8] = p[8] * g,
                        l
                    }
                    ,
                    et.multiplyScalarAndAdd = function(l, p, g, x) {
                        return l[0] = p[0] + g[0] * x,
                        l[1] = p[1] + g[1] * x,
                        l[2] = p[2] + g[2] * x,
                        l[3] = p[3] + g[3] * x,
                        l[4] = p[4] + g[4] * x,
                        l[5] = p[5] + g[5] * x,
                        l[6] = p[6] + g[6] * x,
                        l[7] = p[7] + g[7] * x,
                        l[8] = p[8] + g[8] * x,
                        l
                    }
                    ,
                    et.exactEquals = function(l, p) {
                        return l[0] === p[0] && l[1] === p[1] && l[2] === p[2] && l[3] === p[3] && l[4] === p[4] && l[5] === p[5] && l[6] === p[6] && l[7] === p[7] && l[8] === p[8]
                    }
                    ,
                    et.equals = function(l, p) {
                        var g = l[0]
                          , x = l[1]
                          , T = l[2]
                          , f = l[3]
                          , b = l[4]
                          , P = l[5]
                          , v = l[6]
                          , w = l[7]
                          , C = l[8]
                          , A = p[0]
                          , O = p[1]
                          , F = p[2]
                          , z = p[3]
                          , L = p[4]
                          , N = p[5]
                          , G = p[6]
                          , X = p[7]
                          , _e = p[8];
                        return Math.abs(g - A) <= e.EPSILON * Math.max(1, Math.abs(g), Math.abs(A)) && Math.abs(x - O) <= e.EPSILON * Math.max(1, Math.abs(x), Math.abs(O)) && Math.abs(T - F) <= e.EPSILON * Math.max(1, Math.abs(T), Math.abs(F)) && Math.abs(f - z) <= e.EPSILON * Math.max(1, Math.abs(f), Math.abs(z)) && Math.abs(b - L) <= e.EPSILON * Math.max(1, Math.abs(b), Math.abs(L)) && Math.abs(P - N) <= e.EPSILON * Math.max(1, Math.abs(P), Math.abs(N)) && Math.abs(v - G) <= e.EPSILON * Math.max(1, Math.abs(v), Math.abs(G)) && Math.abs(w - X) <= e.EPSILON * Math.max(1, Math.abs(w), Math.abs(X)) && Math.abs(C - _e) <= e.EPSILON * Math.max(1, Math.abs(C), Math.abs(_e))
                    }
                    ,
                    et.sub = et.mul = void 0;
                    var e = function(l) {
                        if (l && l.__esModule)
                            return l;
                        if (null === l || "object" !== n(l) && "function" != typeof l)
                            return {
                                default: l
                            };
                        var g = o(void 0);
                        if (g && g.has(l))
                            return g.get(l);
                        var x = {}
                          , T = Object.defineProperty && Object.getOwnPropertyDescriptor;
                        for (var f in l)
                            if ("default" !== f && Object.prototype.hasOwnProperty.call(l, f)) {
                                var b = T ? Object.getOwnPropertyDescriptor(l, f) : null;
                                b && (b.get || b.set) ? Object.defineProperty(x, f, b) : x[f] = l[f]
                            }
                        return x.default = l,
                        g && g.set(l, x),
                        x
                    }(Me());
                    function o(l) {
                        if ("function" != typeof WeakMap)
                            return null;
                        var p = new WeakMap
                          , g = new WeakMap;
                        return (o = function(x) {
                            return x ? g : p
                        }
                        )(l)
                    }
                    function a(l, p, g) {
                        var x = p[0]
                          , T = p[1]
                          , f = p[2]
                          , b = p[3]
                          , P = p[4]
                          , v = p[5]
                          , w = p[6]
                          , C = p[7]
                          , A = p[8]
                          , O = g[0]
                          , F = g[1]
                          , z = g[2]
                          , L = g[3]
                          , N = g[4]
                          , G = g[5]
                          , X = g[6]
                          , _e = g[7]
                          , me = g[8];
                        return l[0] = O * x + F * b + z * w,
                        l[1] = O * T + F * P + z * C,
                        l[2] = O * f + F * v + z * A,
                        l[3] = L * x + N * b + G * w,
                        l[4] = L * T + N * P + G * C,
                        l[5] = L * f + N * v + G * A,
                        l[6] = X * x + _e * b + me * w,
                        l[7] = X * T + _e * P + me * C,
                        l[8] = X * f + _e * v + me * A,
                        l
                    }
                    function u(l, p, g) {
                        return l[0] = p[0] - g[0],
                        l[1] = p[1] - g[1],
                        l[2] = p[2] - g[2],
                        l[3] = p[3] - g[3],
                        l[4] = p[4] - g[4],
                        l[5] = p[5] - g[5],
                        l[6] = p[6] - g[6],
                        l[7] = p[7] - g[7],
                        l[8] = p[8] - g[8],
                        l
                    }
                    return et.mul = a,
                    et.sub = u,
                    et
                }
                var pt, Be = {};
                function ze() {
                    if (pt)
                        return Be;
                    function n(f) {
                        return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(b) {
                            return typeof b
                        }
                        : function(b) {
                            return b && "function" == typeof Symbol && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b
                        }
                        )(f)
                    }
                    pt = 1,
                    Object.defineProperty(Be, "__esModule", {
                        value: !0
                    }),
                    Be.create = function() {
                        var f = new e.ARRAY_TYPE(16);
                        return e.ARRAY_TYPE != Float32Array && (f[1] = 0,
                        f[2] = 0,
                        f[3] = 0,
                        f[4] = 0,
                        f[6] = 0,
                        f[7] = 0,
                        f[8] = 0,
                        f[9] = 0,
                        f[11] = 0,
                        f[12] = 0,
                        f[13] = 0,
                        f[14] = 0),
                        f[0] = 1,
                        f[5] = 1,
                        f[10] = 1,
                        f[15] = 1,
                        f
                    }
                    ,
                    Be.clone = function(f) {
                        var b = new e.ARRAY_TYPE(16);
                        return b[0] = f[0],
                        b[1] = f[1],
                        b[2] = f[2],
                        b[3] = f[3],
                        b[4] = f[4],
                        b[5] = f[5],
                        b[6] = f[6],
                        b[7] = f[7],
                        b[8] = f[8],
                        b[9] = f[9],
                        b[10] = f[10],
                        b[11] = f[11],
                        b[12] = f[12],
                        b[13] = f[13],
                        b[14] = f[14],
                        b[15] = f[15],
                        b
                    }
                    ,
                    Be.copy = function(f, b) {
                        return f[0] = b[0],
                        f[1] = b[1],
                        f[2] = b[2],
                        f[3] = b[3],
                        f[4] = b[4],
                        f[5] = b[5],
                        f[6] = b[6],
                        f[7] = b[7],
                        f[8] = b[8],
                        f[9] = b[9],
                        f[10] = b[10],
                        f[11] = b[11],
                        f[12] = b[12],
                        f[13] = b[13],
                        f[14] = b[14],
                        f[15] = b[15],
                        f
                    }
                    ,
                    Be.fromValues = function(f, b, P, v, w, C, A, O, F, z, L, N, G, X, _e, me) {
                        var pe = new e.ARRAY_TYPE(16);
                        return pe[0] = f,
                        pe[1] = b,
                        pe[2] = P,
                        pe[3] = v,
                        pe[4] = w,
                        pe[5] = C,
                        pe[6] = A,
                        pe[7] = O,
                        pe[8] = F,
                        pe[9] = z,
                        pe[10] = L,
                        pe[11] = N,
                        pe[12] = G,
                        pe[13] = X,
                        pe[14] = _e,
                        pe[15] = me,
                        pe
                    }
                    ,
                    Be.set = function(f, b, P, v, w, C, A, O, F, z, L, N, G, X, _e, me, pe) {
                        return f[0] = b,
                        f[1] = P,
                        f[2] = v,
                        f[3] = w,
                        f[4] = C,
                        f[5] = A,
                        f[6] = O,
                        f[7] = F,
                        f[8] = z,
                        f[9] = L,
                        f[10] = N,
                        f[11] = G,
                        f[12] = X,
                        f[13] = _e,
                        f[14] = me,
                        f[15] = pe,
                        f
                    }
                    ,
                    Be.identity = a,
                    Be.transpose = function(f, b) {
                        if (f === b) {
                            var P = b[1]
                              , v = b[2]
                              , w = b[3]
                              , C = b[6]
                              , A = b[7]
                              , O = b[11];
                            f[1] = b[4],
                            f[2] = b[8],
                            f[3] = b[12],
                            f[4] = P,
                            f[6] = b[9],
                            f[7] = b[13],
                            f[8] = v,
                            f[9] = C,
                            f[11] = b[14],
                            f[12] = w,
                            f[13] = A,
                            f[14] = O
                        } else
                            f[0] = b[0],
                            f[1] = b[4],
                            f[2] = b[8],
                            f[3] = b[12],
                            f[4] = b[1],
                            f[5] = b[5],
                            f[6] = b[9],
                            f[7] = b[13],
                            f[8] = b[2],
                            f[9] = b[6],
                            f[10] = b[10],
                            f[11] = b[14],
                            f[12] = b[3],
                            f[13] = b[7],
                            f[14] = b[11],
                            f[15] = b[15];
                        return f
                    }
                    ,
                    Be.invert = function(f, b) {
                        var P = b[0]
                          , v = b[1]
                          , w = b[2]
                          , C = b[3]
                          , A = b[4]
                          , O = b[5]
                          , F = b[6]
                          , z = b[7]
                          , L = b[8]
                          , N = b[9]
                          , G = b[10]
                          , X = b[11]
                          , _e = b[12]
                          , me = b[13]
                          , pe = b[14]
                          , Ne = b[15]
                          , Pe = P * O - v * A
                          , $e = P * F - w * A
                          , We = P * z - C * A
                          , je = v * F - w * O
                          , Ke = v * z - C * O
                          , rt = w * z - C * F
                          , at = L * me - N * _e
                          , ot = L * pe - G * _e
                          , Ct = L * Ne - X * _e
                          , Zt = N * pe - G * me
                          , Ot = N * Ne - X * me
                          , lo = G * Ne - X * pe
                          , io = Pe * lo - $e * Ot + We * Zt + je * Ct - Ke * ot + rt * at;
                        return io ? (f[0] = (O * lo - F * Ot + z * Zt) * (io = 1 / io),
                        f[1] = (w * Ot - v * lo - C * Zt) * io,
                        f[2] = (me * rt - pe * Ke + Ne * je) * io,
                        f[3] = (G * Ke - N * rt - X * je) * io,
                        f[4] = (F * Ct - A * lo - z * ot) * io,
                        f[5] = (P * lo - w * Ct + C * ot) * io,
                        f[6] = (pe * We - _e * rt - Ne * $e) * io,
                        f[7] = (L * rt - G * We + X * $e) * io,
                        f[8] = (A * Ot - O * Ct + z * at) * io,
                        f[9] = (v * Ct - P * Ot - C * at) * io,
                        f[10] = (_e * Ke - me * We + Ne * Pe) * io,
                        f[11] = (N * We - L * Ke - X * Pe) * io,
                        f[12] = (O * ot - A * Zt - F * at) * io,
                        f[13] = (P * Zt - v * ot + w * at) * io,
                        f[14] = (me * $e - _e * je - pe * Pe) * io,
                        f[15] = (L * je - N * $e + G * Pe) * io,
                        f) : null
                    }
                    ,
                    Be.adjoint = function(f, b) {
                        var P = b[0]
                          , v = b[1]
                          , w = b[2]
                          , C = b[3]
                          , A = b[4]
                          , O = b[5]
                          , F = b[6]
                          , z = b[7]
                          , L = b[8]
                          , N = b[9]
                          , G = b[10]
                          , X = b[11]
                          , _e = b[12]
                          , me = b[13]
                          , pe = b[14]
                          , Ne = b[15];
                        return f[0] = O * (G * Ne - X * pe) - N * (F * Ne - z * pe) + me * (F * X - z * G),
                        f[1] = -(v * (G * Ne - X * pe) - N * (w * Ne - C * pe) + me * (w * X - C * G)),
                        f[2] = v * (F * Ne - z * pe) - O * (w * Ne - C * pe) + me * (w * z - C * F),
                        f[3] = -(v * (F * X - z * G) - O * (w * X - C * G) + N * (w * z - C * F)),
                        f[4] = -(A * (G * Ne - X * pe) - L * (F * Ne - z * pe) + _e * (F * X - z * G)),
                        f[5] = P * (G * Ne - X * pe) - L * (w * Ne - C * pe) + _e * (w * X - C * G),
                        f[6] = -(P * (F * Ne - z * pe) - A * (w * Ne - C * pe) + _e * (w * z - C * F)),
                        f[7] = P * (F * X - z * G) - A * (w * X - C * G) + L * (w * z - C * F),
                        f[8] = A * (N * Ne - X * me) - L * (O * Ne - z * me) + _e * (O * X - z * N),
                        f[9] = -(P * (N * Ne - X * me) - L * (v * Ne - C * me) + _e * (v * X - C * N)),
                        f[10] = P * (O * Ne - z * me) - A * (v * Ne - C * me) + _e * (v * z - C * O),
                        f[11] = -(P * (O * X - z * N) - A * (v * X - C * N) + L * (v * z - C * O)),
                        f[12] = -(A * (N * pe - G * me) - L * (O * pe - F * me) + _e * (O * G - F * N)),
                        f[13] = P * (N * pe - G * me) - L * (v * pe - w * me) + _e * (v * G - w * N),
                        f[14] = -(P * (O * pe - F * me) - A * (v * pe - w * me) + _e * (v * F - w * O)),
                        f[15] = P * (O * G - F * N) - A * (v * G - w * N) + L * (v * F - w * O),
                        f
                    }
                    ,
                    Be.determinant = function(f) {
                        var b = f[0]
                          , P = f[1]
                          , v = f[2]
                          , w = f[3]
                          , C = f[4]
                          , A = f[5]
                          , O = f[6]
                          , F = f[7]
                          , z = f[8]
                          , L = f[9]
                          , N = f[10]
                          , G = f[11]
                          , X = f[12]
                          , _e = f[13]
                          , me = f[14]
                          , pe = f[15];
                        return (b * A - P * C) * (N * pe - G * me) - (b * O - v * C) * (L * pe - G * _e) + (b * F - w * C) * (L * me - N * _e) + (P * O - v * A) * (z * pe - G * X) - (P * F - w * A) * (z * me - N * X) + (v * F - w * O) * (z * _e - L * X)
                    }
                    ,
                    Be.multiply = u,
                    Be.translate = function(f, b, P) {
                        var v, w, C, A, O, F, z, L, N, G, X, _e, me = P[0], pe = P[1], Ne = P[2];
                        return b === f ? (f[12] = b[0] * me + b[4] * pe + b[8] * Ne + b[12],
                        f[13] = b[1] * me + b[5] * pe + b[9] * Ne + b[13],
                        f[14] = b[2] * me + b[6] * pe + b[10] * Ne + b[14],
                        f[15] = b[3] * me + b[7] * pe + b[11] * Ne + b[15]) : (w = b[1],
                        C = b[2],
                        A = b[3],
                        O = b[4],
                        F = b[5],
                        z = b[6],
                        L = b[7],
                        N = b[8],
                        G = b[9],
                        X = b[10],
                        _e = b[11],
                        f[0] = v = b[0],
                        f[1] = w,
                        f[2] = C,
                        f[3] = A,
                        f[4] = O,
                        f[5] = F,
                        f[6] = z,
                        f[7] = L,
                        f[8] = N,
                        f[9] = G,
                        f[10] = X,
                        f[11] = _e,
                        f[12] = v * me + O * pe + N * Ne + b[12],
                        f[13] = w * me + F * pe + G * Ne + b[13],
                        f[14] = C * me + z * pe + X * Ne + b[14],
                        f[15] = A * me + L * pe + _e * Ne + b[15]),
                        f
                    }
                    ,
                    Be.scale = function(f, b, P) {
                        var v = P[0]
                          , w = P[1]
                          , C = P[2];
                        return f[0] = b[0] * v,
                        f[1] = b[1] * v,
                        f[2] = b[2] * v,
                        f[3] = b[3] * v,
                        f[4] = b[4] * w,
                        f[5] = b[5] * w,
                        f[6] = b[6] * w,
                        f[7] = b[7] * w,
                        f[8] = b[8] * C,
                        f[9] = b[9] * C,
                        f[10] = b[10] * C,
                        f[11] = b[11] * C,
                        f[12] = b[12],
                        f[13] = b[13],
                        f[14] = b[14],
                        f[15] = b[15],
                        f
                    }
                    ,
                    Be.rotate = function(f, b, P, v) {
                        var w, C, A, O, F, z, L, N, G, X, _e, me, pe, Ne, Pe, $e, We, je, Ke, rt, at, ot, Ct, Zt, Ot = v[0], lo = v[1], io = v[2], fo = Math.hypot(Ot, lo, io);
                        return fo < e.EPSILON ? null : (Ot *= fo = 1 / fo,
                        lo *= fo,
                        io *= fo,
                        w = Math.sin(P),
                        C = Math.cos(P),
                        F = b[1],
                        z = b[2],
                        L = b[3],
                        G = b[5],
                        X = b[6],
                        _e = b[7],
                        pe = b[9],
                        Ne = b[10],
                        Pe = b[11],
                        $e = Ot * Ot * (A = 1 - C) + C,
                        Ke = Ot * lo * A - io * w,
                        rt = lo * lo * A + C,
                        at = io * lo * A + Ot * w,
                        ot = Ot * io * A + lo * w,
                        Ct = lo * io * A - Ot * w,
                        Zt = io * io * A + C,
                        f[0] = (O = b[0]) * $e + (N = b[4]) * (We = lo * Ot * A + io * w) + (me = b[8]) * (je = io * Ot * A - lo * w),
                        f[1] = F * $e + G * We + pe * je,
                        f[2] = z * $e + X * We + Ne * je,
                        f[3] = L * $e + _e * We + Pe * je,
                        f[4] = O * Ke + N * rt + me * at,
                        f[5] = F * Ke + G * rt + pe * at,
                        f[6] = z * Ke + X * rt + Ne * at,
                        f[7] = L * Ke + _e * rt + Pe * at,
                        f[8] = O * ot + N * Ct + me * Zt,
                        f[9] = F * ot + G * Ct + pe * Zt,
                        f[10] = z * ot + X * Ct + Ne * Zt,
                        f[11] = L * ot + _e * Ct + Pe * Zt,
                        b !== f && (f[12] = b[12],
                        f[13] = b[13],
                        f[14] = b[14],
                        f[15] = b[15]),
                        f)
                    }
                    ,
                    Be.rotateX = function(f, b, P) {
                        var v = Math.sin(P)
                          , w = Math.cos(P)
                          , C = b[4]
                          , A = b[5]
                          , O = b[6]
                          , F = b[7]
                          , z = b[8]
                          , L = b[9]
                          , N = b[10]
                          , G = b[11];
                        return b !== f && (f[0] = b[0],
                        f[1] = b[1],
                        f[2] = b[2],
                        f[3] = b[3],
                        f[12] = b[12],
                        f[13] = b[13],
                        f[14] = b[14],
                        f[15] = b[15]),
                        f[4] = C * w + z * v,
                        f[5] = A * w + L * v,
                        f[6] = O * w + N * v,
                        f[7] = F * w + G * v,
                        f[8] = z * w - C * v,
                        f[9] = L * w - A * v,
                        f[10] = N * w - O * v,
                        f[11] = G * w - F * v,
                        f
                    }
                    ,
                    Be.rotateY = function(f, b, P) {
                        var v = Math.sin(P)
                          , w = Math.cos(P)
                          , C = b[0]
                          , A = b[1]
                          , O = b[2]
                          , F = b[3]
                          , z = b[8]
                          , L = b[9]
                          , N = b[10]
                          , G = b[11];
                        return b !== f && (f[4] = b[4],
                        f[5] = b[5],
                        f[6] = b[6],
                        f[7] = b[7],
                        f[12] = b[12],
                        f[13] = b[13],
                        f[14] = b[14],
                        f[15] = b[15]),
                        f[0] = C * w - z * v,
                        f[1] = A * w - L * v,
                        f[2] = O * w - N * v,
                        f[3] = F * w - G * v,
                        f[8] = C * v + z * w,
                        f[9] = A * v + L * w,
                        f[10] = O * v + N * w,
                        f[11] = F * v + G * w,
                        f
                    }
                    ,
                    Be.rotateZ = function(f, b, P) {
                        var v = Math.sin(P)
                          , w = Math.cos(P)
                          , C = b[0]
                          , A = b[1]
                          , O = b[2]
                          , F = b[3]
                          , z = b[4]
                          , L = b[5]
                          , N = b[6]
                          , G = b[7];
                        return b !== f && (f[8] = b[8],
                        f[9] = b[9],
                        f[10] = b[10],
                        f[11] = b[11],
                        f[12] = b[12],
                        f[13] = b[13],
                        f[14] = b[14],
                        f[15] = b[15]),
                        f[0] = C * w + z * v,
                        f[1] = A * w + L * v,
                        f[2] = O * w + N * v,
                        f[3] = F * w + G * v,
                        f[4] = z * w - C * v,
                        f[5] = L * w - A * v,
                        f[6] = N * w - O * v,
                        f[7] = G * w - F * v,
                        f
                    }
                    ,
                    Be.fromTranslation = function(f, b) {
                        return f[0] = 1,
                        f[1] = 0,
                        f[2] = 0,
                        f[3] = 0,
                        f[4] = 0,
                        f[5] = 1,
                        f[6] = 0,
                        f[7] = 0,
                        f[8] = 0,
                        f[9] = 0,
                        f[10] = 1,
                        f[11] = 0,
                        f[12] = b[0],
                        f[13] = b[1],
                        f[14] = b[2],
                        f[15] = 1,
                        f
                    }
                    ,
                    Be.fromScaling = function(f, b) {
                        return f[0] = b[0],
                        f[1] = 0,
                        f[2] = 0,
                        f[3] = 0,
                        f[4] = 0,
                        f[5] = b[1],
                        f[6] = 0,
                        f[7] = 0,
                        f[8] = 0,
                        f[9] = 0,
                        f[10] = b[2],
                        f[11] = 0,
                        f[12] = 0,
                        f[13] = 0,
                        f[14] = 0,
                        f[15] = 1,
                        f
                    }
                    ,
                    Be.fromRotation = function(f, b, P) {
                        var v, w, C, A = P[0], O = P[1], F = P[2], z = Math.hypot(A, O, F);
                        return z < e.EPSILON ? null : (A *= z = 1 / z,
                        O *= z,
                        F *= z,
                        v = Math.sin(b),
                        w = Math.cos(b),
                        f[0] = A * A * (C = 1 - w) + w,
                        f[1] = O * A * C + F * v,
                        f[2] = F * A * C - O * v,
                        f[3] = 0,
                        f[4] = A * O * C - F * v,
                        f[5] = O * O * C + w,
                        f[6] = F * O * C + A * v,
                        f[7] = 0,
                        f[8] = A * F * C + O * v,
                        f[9] = O * F * C - A * v,
                        f[10] = F * F * C + w,
                        f[11] = 0,
                        f[12] = 0,
                        f[13] = 0,
                        f[14] = 0,
                        f[15] = 1,
                        f)
                    }
                    ,
                    Be.fromXRotation = function(f, b) {
                        var P = Math.sin(b)
                          , v = Math.cos(b);
                        return f[0] = 1,
                        f[1] = 0,
                        f[2] = 0,
                        f[3] = 0,
                        f[4] = 0,
                        f[5] = v,
                        f[6] = P,
                        f[7] = 0,
                        f[8] = 0,
                        f[9] = -P,
                        f[10] = v,
                        f[11] = 0,
                        f[12] = 0,
                        f[13] = 0,
                        f[14] = 0,
                        f[15] = 1,
                        f
                    }
                    ,
                    Be.fromYRotation = function(f, b) {
                        var P = Math.sin(b)
                          , v = Math.cos(b);
                        return f[0] = v,
                        f[1] = 0,
                        f[2] = -P,
                        f[3] = 0,
                        f[4] = 0,
                        f[5] = 1,
                        f[6] = 0,
                        f[7] = 0,
                        f[8] = P,
                        f[9] = 0,
                        f[10] = v,
                        f[11] = 0,
                        f[12] = 0,
                        f[13] = 0,
                        f[14] = 0,
                        f[15] = 1,
                        f
                    }
                    ,
                    Be.fromZRotation = function(f, b) {
                        var P = Math.sin(b)
                          , v = Math.cos(b);
                        return f[0] = v,
                        f[1] = P,
                        f[2] = 0,
                        f[3] = 0,
                        f[4] = -P,
                        f[5] = v,
                        f[6] = 0,
                        f[7] = 0,
                        f[8] = 0,
                        f[9] = 0,
                        f[10] = 1,
                        f[11] = 0,
                        f[12] = 0,
                        f[13] = 0,
                        f[14] = 0,
                        f[15] = 1,
                        f
                    }
                    ,
                    Be.fromRotationTranslation = l,
                    Be.fromQuat2 = function(f, b) {
                        var P = new e.ARRAY_TYPE(3)
                          , v = -b[0]
                          , w = -b[1]
                          , C = -b[2]
                          , A = b[3]
                          , O = b[4]
                          , F = b[5]
                          , z = b[6]
                          , L = b[7]
                          , N = v * v + w * w + C * C + A * A;
                        return N > 0 ? (P[0] = 2 * (O * A + L * v + F * C - z * w) / N,
                        P[1] = 2 * (F * A + L * w + z * v - O * C) / N,
                        P[2] = 2 * (z * A + L * C + O * w - F * v) / N) : (P[0] = 2 * (O * A + L * v + F * C - z * w),
                        P[1] = 2 * (F * A + L * w + z * v - O * C),
                        P[2] = 2 * (z * A + L * C + O * w - F * v)),
                        l(f, b, P),
                        f
                    }
                    ,
                    Be.getTranslation = function(f, b) {
                        return f[0] = b[12],
                        f[1] = b[13],
                        f[2] = b[14],
                        f
                    }
                    ,
                    Be.getScaling = p,
                    Be.getRotation = function(f, b) {
                        var P = new e.ARRAY_TYPE(3);
                        p(P, b);
                        var v = 1 / P[0]
                          , w = 1 / P[1]
                          , C = 1 / P[2]
                          , A = b[0] * v
                          , O = b[1] * w
                          , F = b[2] * C
                          , z = b[4] * v
                          , L = b[5] * w
                          , N = b[6] * C
                          , G = b[8] * v
                          , X = b[9] * w
                          , _e = b[10] * C
                          , me = A + L + _e
                          , pe = 0;
                        return me > 0 ? (pe = 2 * Math.sqrt(me + 1),
                        f[3] = .25 * pe,
                        f[0] = (N - X) / pe,
                        f[1] = (G - F) / pe,
                        f[2] = (O - z) / pe) : A > L && A > _e ? (pe = 2 * Math.sqrt(1 + A - L - _e),
                        f[3] = (N - X) / pe,
                        f[0] = .25 * pe,
                        f[1] = (O + z) / pe,
                        f[2] = (G + F) / pe) : L > _e ? (pe = 2 * Math.sqrt(1 + L - A - _e),
                        f[3] = (G - F) / pe,
                        f[0] = (O + z) / pe,
                        f[1] = .25 * pe,
                        f[2] = (N + X) / pe) : (pe = 2 * Math.sqrt(1 + _e - A - L),
                        f[3] = (O - z) / pe,
                        f[0] = (G + F) / pe,
                        f[1] = (N + X) / pe,
                        f[2] = .25 * pe),
                        f
                    }
                    ,
                    Be.fromRotationTranslationScale = function(f, b, P, v) {
                        var w = b[0]
                          , C = b[1]
                          , A = b[2]
                          , O = b[3]
                          , F = w + w
                          , z = C + C
                          , L = A + A
                          , N = w * F
                          , G = w * z
                          , X = w * L
                          , _e = C * z
                          , me = C * L
                          , pe = A * L
                          , Ne = O * F
                          , Pe = O * z
                          , $e = O * L
                          , We = v[0]
                          , je = v[1]
                          , Ke = v[2];
                        return f[0] = (1 - (_e + pe)) * We,
                        f[1] = (G + $e) * We,
                        f[2] = (X - Pe) * We,
                        f[3] = 0,
                        f[4] = (G - $e) * je,
                        f[5] = (1 - (N + pe)) * je,
                        f[6] = (me + Ne) * je,
                        f[7] = 0,
                        f[8] = (X + Pe) * Ke,
                        f[9] = (me - Ne) * Ke,
                        f[10] = (1 - (N + _e)) * Ke,
                        f[11] = 0,
                        f[12] = P[0],
                        f[13] = P[1],
                        f[14] = P[2],
                        f[15] = 1,
                        f
                    }
                    ,
                    Be.fromRotationTranslationScaleOrigin = function(f, b, P, v, w) {
                        var C = b[0]
                          , A = b[1]
                          , O = b[2]
                          , F = b[3]
                          , z = C + C
                          , L = A + A
                          , N = O + O
                          , G = C * z
                          , X = C * L
                          , _e = C * N
                          , me = A * L
                          , pe = A * N
                          , Ne = O * N
                          , Pe = F * z
                          , $e = F * L
                          , We = F * N
                          , je = v[0]
                          , Ke = v[1]
                          , rt = v[2]
                          , at = w[0]
                          , ot = w[1]
                          , Ct = w[2]
                          , Zt = (1 - (me + Ne)) * je
                          , Ot = (X + We) * je
                          , lo = (_e - $e) * je
                          , io = (X - We) * Ke
                          , fo = (1 - (G + Ne)) * Ke
                          , Bt = (pe + Pe) * Ke
                          , Ro = (_e + $e) * rt
                          , ho = (pe - Pe) * rt
                          , Ao = (1 - (G + me)) * rt;
                        return f[0] = Zt,
                        f[1] = Ot,
                        f[2] = lo,
                        f[3] = 0,
                        f[4] = io,
                        f[5] = fo,
                        f[6] = Bt,
                        f[7] = 0,
                        f[8] = Ro,
                        f[9] = ho,
                        f[10] = Ao,
                        f[11] = 0,
                        f[12] = P[0] + at - (Zt * at + io * ot + Ro * Ct),
                        f[13] = P[1] + ot - (Ot * at + fo * ot + ho * Ct),
                        f[14] = P[2] + Ct - (lo * at + Bt * ot + Ao * Ct),
                        f[15] = 1,
                        f
                    }
                    ,
                    Be.fromQuat = function(f, b) {
                        var P = b[0]
                          , v = b[1]
                          , w = b[2]
                          , C = b[3]
                          , A = P + P
                          , O = v + v
                          , F = w + w
                          , z = P * A
                          , L = v * A
                          , N = v * O
                          , G = w * A
                          , X = w * O
                          , _e = w * F
                          , me = C * A
                          , pe = C * O
                          , Ne = C * F;
                        return f[0] = 1 - N - _e,
                        f[1] = L + Ne,
                        f[2] = G - pe,
                        f[3] = 0,
                        f[4] = L - Ne,
                        f[5] = 1 - z - _e,
                        f[6] = X + me,
                        f[7] = 0,
                        f[8] = G + pe,
                        f[9] = X - me,
                        f[10] = 1 - z - N,
                        f[11] = 0,
                        f[12] = 0,
                        f[13] = 0,
                        f[14] = 0,
                        f[15] = 1,
                        f
                    }
                    ,
                    Be.frustum = function(f, b, P, v, w, C, A) {
                        var O = 1 / (P - b)
                          , F = 1 / (w - v)
                          , z = 1 / (C - A);
                        return f[0] = 2 * C * O,
                        f[1] = 0,
                        f[2] = 0,
                        f[3] = 0,
                        f[4] = 0,
                        f[5] = 2 * C * F,
                        f[6] = 0,
                        f[7] = 0,
                        f[8] = (P + b) * O,
                        f[9] = (w + v) * F,
                        f[10] = (A + C) * z,
                        f[11] = -1,
                        f[12] = 0,
                        f[13] = 0,
                        f[14] = A * C * 2 * z,
                        f[15] = 0,
                        f
                    }
                    ,
                    Be.perspectiveNO = g,
                    Be.perspectiveZO = function(f, b, P, v, w) {
                        var C, A = 1 / Math.tan(b / 2);
                        return f[0] = A / P,
                        f[1] = 0,
                        f[2] = 0,
                        f[3] = 0,
                        f[4] = 0,
                        f[5] = A,
                        f[6] = 0,
                        f[7] = 0,
                        f[8] = 0,
                        f[9] = 0,
                        f[11] = -1,
                        f[12] = 0,
                        f[13] = 0,
                        f[15] = 0,
                        null != w && w !== 1 / 0 ? (f[10] = w * (C = 1 / (v - w)),
                        f[14] = w * v * C) : (f[10] = -1,
                        f[14] = -v),
                        f
                    }
                    ,
                    Be.perspectiveFromFieldOfView = function(f, b, P, v) {
                        var w = Math.tan(b.upDegrees * Math.PI / 180)
                          , C = Math.tan(b.downDegrees * Math.PI / 180)
                          , A = Math.tan(b.leftDegrees * Math.PI / 180)
                          , O = Math.tan(b.rightDegrees * Math.PI / 180)
                          , F = 2 / (A + O)
                          , z = 2 / (w + C);
                        return f[0] = F,
                        f[1] = 0,
                        f[2] = 0,
                        f[3] = 0,
                        f[4] = 0,
                        f[5] = z,
                        f[6] = 0,
                        f[7] = 0,
                        f[8] = -(A - O) * F * .5,
                        f[9] = (w - C) * z * .5,
                        f[10] = v / (P - v),
                        f[11] = -1,
                        f[12] = 0,
                        f[13] = 0,
                        f[14] = v * P / (P - v),
                        f[15] = 0,
                        f
                    }
                    ,
                    Be.orthoNO = x,
                    Be.orthoZO = function(f, b, P, v, w, C, A) {
                        var O = 1 / (b - P)
                          , F = 1 / (v - w)
                          , z = 1 / (C - A);
                        return f[0] = -2 * O,
                        f[1] = 0,
                        f[2] = 0,
                        f[3] = 0,
                        f[4] = 0,
                        f[5] = -2 * F,
                        f[6] = 0,
                        f[7] = 0,
                        f[8] = 0,
                        f[9] = 0,
                        f[10] = z,
                        f[11] = 0,
                        f[12] = (b + P) * O,
                        f[13] = (w + v) * F,
                        f[14] = C * z,
                        f[15] = 1,
                        f
                    }
                    ,
                    Be.lookAt = function(f, b, P, v) {
                        var w, C, A, O, F, z, L, N, G, X, _e = b[0], me = b[1], pe = b[2], Ne = v[0], Pe = v[1], $e = v[2], We = P[0], je = P[1], Ke = P[2];
                        return Math.abs(_e - We) < e.EPSILON && Math.abs(me - je) < e.EPSILON && Math.abs(pe - Ke) < e.EPSILON ? a(f) : (L = _e - We,
                        N = me - je,
                        G = pe - Ke,
                        w = Pe * (G *= X = 1 / Math.hypot(L, N, G)) - $e * (N *= X),
                        C = $e * (L *= X) - Ne * G,
                        A = Ne * N - Pe * L,
                        (X = Math.hypot(w, C, A)) ? (w *= X = 1 / X,
                        C *= X,
                        A *= X) : (w = 0,
                        C = 0,
                        A = 0),
                        O = N * A - G * C,
                        F = G * w - L * A,
                        z = L * C - N * w,
                        (X = Math.hypot(O, F, z)) ? (O *= X = 1 / X,
                        F *= X,
                        z *= X) : (O = 0,
                        F = 0,
                        z = 0),
                        f[0] = w,
                        f[1] = O,
                        f[2] = L,
                        f[3] = 0,
                        f[4] = C,
                        f[5] = F,
                        f[6] = N,
                        f[7] = 0,
                        f[8] = A,
                        f[9] = z,
                        f[10] = G,
                        f[11] = 0,
                        f[12] = -(w * _e + C * me + A * pe),
                        f[13] = -(O * _e + F * me + z * pe),
                        f[14] = -(L * _e + N * me + G * pe),
                        f[15] = 1,
                        f)
                    }
                    ,
                    Be.targetTo = function(f, b, P, v) {
                        var w = b[0]
                          , C = b[1]
                          , A = b[2]
                          , O = v[0]
                          , F = v[1]
                          , z = v[2]
                          , L = w - P[0]
                          , N = C - P[1]
                          , G = A - P[2]
                          , X = L * L + N * N + G * G;
                        X > 0 && (L *= X = 1 / Math.sqrt(X),
                        N *= X,
                        G *= X);
                        var _e = F * G - z * N
                          , me = z * L - O * G
                          , pe = O * N - F * L;
                        return (X = _e * _e + me * me + pe * pe) > 0 && (_e *= X = 1 / Math.sqrt(X),
                        me *= X,
                        pe *= X),
                        f[0] = _e,
                        f[1] = me,
                        f[2] = pe,
                        f[3] = 0,
                        f[4] = N * pe - G * me,
                        f[5] = G * _e - L * pe,
                        f[6] = L * me - N * _e,
                        f[7] = 0,
                        f[8] = L,
                        f[9] = N,
                        f[10] = G,
                        f[11] = 0,
                        f[12] = w,
                        f[13] = C,
                        f[14] = A,
                        f[15] = 1,
                        f
                    }
                    ,
                    Be.str = function(f) {
                        return "mat4(" + f[0] + ", " + f[1] + ", " + f[2] + ", " + f[3] + ", " + f[4] + ", " + f[5] + ", " + f[6] + ", " + f[7] + ", " + f[8] + ", " + f[9] + ", " + f[10] + ", " + f[11] + ", " + f[12] + ", " + f[13] + ", " + f[14] + ", " + f[15] + ")"
                    }
                    ,
                    Be.frob = function(f) {
                        return Math.hypot(f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8], f[9], f[10], f[11], f[12], f[13], f[14], f[15])
                    }
                    ,
                    Be.add = function(f, b, P) {
                        return f[0] = b[0] + P[0],
                        f[1] = b[1] + P[1],
                        f[2] = b[2] + P[2],
                        f[3] = b[3] + P[3],
                        f[4] = b[4] + P[4],
                        f[5] = b[5] + P[5],
                        f[6] = b[6] + P[6],
                        f[7] = b[7] + P[7],
                        f[8] = b[8] + P[8],
                        f[9] = b[9] + P[9],
                        f[10] = b[10] + P[10],
                        f[11] = b[11] + P[11],
                        f[12] = b[12] + P[12],
                        f[13] = b[13] + P[13],
                        f[14] = b[14] + P[14],
                        f[15] = b[15] + P[15],
                        f
                    }
                    ,
                    Be.subtract = T,
                    Be.multiplyScalar = function(f, b, P) {
                        return f[0] = b[0] * P,
                        f[1] = b[1] * P,
                        f[2] = b[2] * P,
                        f[3] = b[3] * P,
                        f[4] = b[4] * P,
                        f[5] = b[5] * P,
                        f[6] = b[6] * P,
                        f[7] = b[7] * P,
                        f[8] = b[8] * P,
                        f[9] = b[9] * P,
                        f[10] = b[10] * P,
                        f[11] = b[11] * P,
                        f[12] = b[12] * P,
                        f[13] = b[13] * P,
                        f[14] = b[14] * P,
                        f[15] = b[15] * P,
                        f
                    }
                    ,
                    Be.multiplyScalarAndAdd = function(f, b, P, v) {
                        return f[0] = b[0] + P[0] * v,
                        f[1] = b[1] + P[1] * v,
                        f[2] = b[2] + P[2] * v,
                        f[3] = b[3] + P[3] * v,
                        f[4] = b[4] + P[4] * v,
                        f[5] = b[5] + P[5] * v,
                        f[6] = b[6] + P[6] * v,
                        f[7] = b[7] + P[7] * v,
                        f[8] = b[8] + P[8] * v,
                        f[9] = b[9] + P[9] * v,
                        f[10] = b[10] + P[10] * v,
                        f[11] = b[11] + P[11] * v,
                        f[12] = b[12] + P[12] * v,
                        f[13] = b[13] + P[13] * v,
                        f[14] = b[14] + P[14] * v,
                        f[15] = b[15] + P[15] * v,
                        f
                    }
                    ,
                    Be.exactEquals = function(f, b) {
                        return f[0] === b[0] && f[1] === b[1] && f[2] === b[2] && f[3] === b[3] && f[4] === b[4] && f[5] === b[5] && f[6] === b[6] && f[7] === b[7] && f[8] === b[8] && f[9] === b[9] && f[10] === b[10] && f[11] === b[11] && f[12] === b[12] && f[13] === b[13] && f[14] === b[14] && f[15] === b[15]
                    }
                    ,
                    Be.equals = function(f, b) {
                        var P = f[0]
                          , v = f[1]
                          , w = f[2]
                          , C = f[3]
                          , A = f[4]
                          , O = f[5]
                          , F = f[6]
                          , z = f[7]
                          , L = f[8]
                          , N = f[9]
                          , G = f[10]
                          , X = f[11]
                          , _e = f[12]
                          , me = f[13]
                          , pe = f[14]
                          , Ne = f[15]
                          , Pe = b[0]
                          , $e = b[1]
                          , We = b[2]
                          , je = b[3]
                          , Ke = b[4]
                          , rt = b[5]
                          , at = b[6]
                          , ot = b[7]
                          , Ct = b[8]
                          , Zt = b[9]
                          , Ot = b[10]
                          , lo = b[11]
                          , io = b[12]
                          , fo = b[13]
                          , Bt = b[14]
                          , Ro = b[15];
                        return Math.abs(P - Pe) <= e.EPSILON * Math.max(1, Math.abs(P), Math.abs(Pe)) && Math.abs(v - $e) <= e.EPSILON * Math.max(1, Math.abs(v), Math.abs($e)) && Math.abs(w - We) <= e.EPSILON * Math.max(1, Math.abs(w), Math.abs(We)) && Math.abs(C - je) <= e.EPSILON * Math.max(1, Math.abs(C), Math.abs(je)) && Math.abs(A - Ke) <= e.EPSILON * Math.max(1, Math.abs(A), Math.abs(Ke)) && Math.abs(O - rt) <= e.EPSILON * Math.max(1, Math.abs(O), Math.abs(rt)) && Math.abs(F - at) <= e.EPSILON * Math.max(1, Math.abs(F), Math.abs(at)) && Math.abs(z - ot) <= e.EPSILON * Math.max(1, Math.abs(z), Math.abs(ot)) && Math.abs(L - Ct) <= e.EPSILON * Math.max(1, Math.abs(L), Math.abs(Ct)) && Math.abs(N - Zt) <= e.EPSILON * Math.max(1, Math.abs(N), Math.abs(Zt)) && Math.abs(G - Ot) <= e.EPSILON * Math.max(1, Math.abs(G), Math.abs(Ot)) && Math.abs(X - lo) <= e.EPSILON * Math.max(1, Math.abs(X), Math.abs(lo)) && Math.abs(_e - io) <= e.EPSILON * Math.max(1, Math.abs(_e), Math.abs(io)) && Math.abs(me - fo) <= e.EPSILON * Math.max(1, Math.abs(me), Math.abs(fo)) && Math.abs(pe - Bt) <= e.EPSILON * Math.max(1, Math.abs(pe), Math.abs(Bt)) && Math.abs(Ne - Ro) <= e.EPSILON * Math.max(1, Math.abs(Ne), Math.abs(Ro))
                    }
                    ,
                    Be.sub = Be.mul = Be.ortho = Be.perspective = void 0;
                    var e = function(f) {
                        if (f && f.__esModule)
                            return f;
                        if (null === f || "object" !== n(f) && "function" != typeof f)
                            return {
                                default: f
                            };
                        var P = o(void 0);
                        if (P && P.has(f))
                            return P.get(f);
                        var v = {}
                          , w = Object.defineProperty && Object.getOwnPropertyDescriptor;
                        for (var C in f)
                            if ("default" !== C && Object.prototype.hasOwnProperty.call(f, C)) {
                                var A = w ? Object.getOwnPropertyDescriptor(f, C) : null;
                                A && (A.get || A.set) ? Object.defineProperty(v, C, A) : v[C] = f[C]
                            }
                        return v.default = f,
                        P && P.set(f, v),
                        v
                    }(Me());
                    function o(f) {
                        if ("function" != typeof WeakMap)
                            return null;
                        var b = new WeakMap
                          , P = new WeakMap;
                        return (o = function(v) {
                            return v ? P : b
                        }
                        )(f)
                    }
                    function a(f) {
                        return f[0] = 1,
                        f[1] = 0,
                        f[2] = 0,
                        f[3] = 0,
                        f[4] = 0,
                        f[5] = 1,
                        f[6] = 0,
                        f[7] = 0,
                        f[8] = 0,
                        f[9] = 0,
                        f[10] = 1,
                        f[11] = 0,
                        f[12] = 0,
                        f[13] = 0,
                        f[14] = 0,
                        f[15] = 1,
                        f
                    }
                    function u(f, b, P) {
                        var v = b[0]
                          , w = b[1]
                          , C = b[2]
                          , A = b[3]
                          , O = b[4]
                          , F = b[5]
                          , z = b[6]
                          , L = b[7]
                          , N = b[8]
                          , G = b[9]
                          , X = b[10]
                          , _e = b[11]
                          , me = b[12]
                          , pe = b[13]
                          , Ne = b[14]
                          , Pe = b[15]
                          , $e = P[0]
                          , We = P[1]
                          , je = P[2]
                          , Ke = P[3];
                        return f[0] = $e * v + We * O + je * N + Ke * me,
                        f[1] = $e * w + We * F + je * G + Ke * pe,
                        f[2] = $e * C + We * z + je * X + Ke * Ne,
                        f[3] = $e * A + We * L + je * _e + Ke * Pe,
                        f[4] = ($e = P[4]) * v + (We = P[5]) * O + (je = P[6]) * N + (Ke = P[7]) * me,
                        f[5] = $e * w + We * F + je * G + Ke * pe,
                        f[6] = $e * C + We * z + je * X + Ke * Ne,
                        f[7] = $e * A + We * L + je * _e + Ke * Pe,
                        f[8] = ($e = P[8]) * v + (We = P[9]) * O + (je = P[10]) * N + (Ke = P[11]) * me,
                        f[9] = $e * w + We * F + je * G + Ke * pe,
                        f[10] = $e * C + We * z + je * X + Ke * Ne,
                        f[11] = $e * A + We * L + je * _e + Ke * Pe,
                        f[12] = ($e = P[12]) * v + (We = P[13]) * O + (je = P[14]) * N + (Ke = P[15]) * me,
                        f[13] = $e * w + We * F + je * G + Ke * pe,
                        f[14] = $e * C + We * z + je * X + Ke * Ne,
                        f[15] = $e * A + We * L + je * _e + Ke * Pe,
                        f
                    }
                    function l(f, b, P) {
                        var v = b[0]
                          , w = b[1]
                          , C = b[2]
                          , A = b[3]
                          , O = v + v
                          , F = w + w
                          , z = C + C
                          , L = v * O
                          , N = v * F
                          , G = v * z
                          , X = w * F
                          , _e = w * z
                          , me = C * z
                          , pe = A * O
                          , Ne = A * F
                          , Pe = A * z;
                        return f[0] = 1 - (X + me),
                        f[1] = N + Pe,
                        f[2] = G - Ne,
                        f[3] = 0,
                        f[4] = N - Pe,
                        f[5] = 1 - (L + me),
                        f[6] = _e + pe,
                        f[7] = 0,
                        f[8] = G + Ne,
                        f[9] = _e - pe,
                        f[10] = 1 - (L + X),
                        f[11] = 0,
                        f[12] = P[0],
                        f[13] = P[1],
                        f[14] = P[2],
                        f[15] = 1,
                        f
                    }
                    function p(f, b) {
                        var P = b[4]
                          , v = b[5]
                          , w = b[6]
                          , C = b[8]
                          , A = b[9]
                          , O = b[10];
                        return f[0] = Math.hypot(b[0], b[1], b[2]),
                        f[1] = Math.hypot(P, v, w),
                        f[2] = Math.hypot(C, A, O),
                        f
                    }
                    function g(f, b, P, v, w) {
                        var C, A = 1 / Math.tan(b / 2);
                        return f[0] = A / P,
                        f[1] = 0,
                        f[2] = 0,
                        f[3] = 0,
                        f[4] = 0,
                        f[5] = A,
                        f[6] = 0,
                        f[7] = 0,
                        f[8] = 0,
                        f[9] = 0,
                        f[11] = -1,
                        f[12] = 0,
                        f[13] = 0,
                        f[15] = 0,
                        null != w && w !== 1 / 0 ? (f[10] = (w + v) * (C = 1 / (v - w)),
                        f[14] = 2 * w * v * C) : (f[10] = -1,
                        f[14] = -2 * v),
                        f
                    }
                    function x(f, b, P, v, w, C, A) {
                        var O = 1 / (b - P)
                          , F = 1 / (v - w)
                          , z = 1 / (C - A);
                        return f[0] = -2 * O,
                        f[1] = 0,
                        f[2] = 0,
                        f[3] = 0,
                        f[4] = 0,
                        f[5] = -2 * F,
                        f[6] = 0,
                        f[7] = 0,
                        f[8] = 0,
                        f[9] = 0,
                        f[10] = 2 * z,
                        f[11] = 0,
                        f[12] = (b + P) * O,
                        f[13] = (w + v) * F,
                        f[14] = (A + C) * z,
                        f[15] = 1,
                        f
                    }
                    function T(f, b, P) {
                        return f[0] = b[0] - P[0],
                        f[1] = b[1] - P[1],
                        f[2] = b[2] - P[2],
                        f[3] = b[3] - P[3],
                        f[4] = b[4] - P[4],
                        f[5] = b[5] - P[5],
                        f[6] = b[6] - P[6],
                        f[7] = b[7] - P[7],
                        f[8] = b[8] - P[8],
                        f[9] = b[9] - P[9],
                        f[10] = b[10] - P[10],
                        f[11] = b[11] - P[11],
                        f[12] = b[12] - P[12],
                        f[13] = b[13] - P[13],
                        f[14] = b[14] - P[14],
                        f[15] = b[15] - P[15],
                        f
                    }
                    return Be.perspective = g,
                    Be.ortho = x,
                    Be.mul = u,
                    Be.sub = T,
                    Be
                }
                var ye, ge = {}, Ie = {};
                function gt() {
                    if (ye)
                        return Ie;
                    function n(w) {
                        return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(C) {
                            return typeof C
                        }
                        : function(C) {
                            return C && "function" == typeof Symbol && C.constructor === Symbol && C !== Symbol.prototype ? "symbol" : typeof C
                        }
                        )(w)
                    }
                    ye = 1,
                    Object.defineProperty(Ie, "__esModule", {
                        value: !0
                    }),
                    Ie.create = a,
                    Ie.clone = function(w) {
                        var C = new e.ARRAY_TYPE(3);
                        return C[0] = w[0],
                        C[1] = w[1],
                        C[2] = w[2],
                        C
                    }
                    ,
                    Ie.length = u,
                    Ie.fromValues = function(w, C, A) {
                        var O = new e.ARRAY_TYPE(3);
                        return O[0] = w,
                        O[1] = C,
                        O[2] = A,
                        O
                    }
                    ,
                    Ie.copy = function(w, C) {
                        return w[0] = C[0],
                        w[1] = C[1],
                        w[2] = C[2],
                        w
                    }
                    ,
                    Ie.set = function(w, C, A, O) {
                        return w[0] = C,
                        w[1] = A,
                        w[2] = O,
                        w
                    }
                    ,
                    Ie.add = function(w, C, A) {
                        return w[0] = C[0] + A[0],
                        w[1] = C[1] + A[1],
                        w[2] = C[2] + A[2],
                        w
                    }
                    ,
                    Ie.subtract = l,
                    Ie.multiply = p,
                    Ie.divide = g,
                    Ie.ceil = function(w, C) {
                        return w[0] = Math.ceil(C[0]),
                        w[1] = Math.ceil(C[1]),
                        w[2] = Math.ceil(C[2]),
                        w
                    }
                    ,
                    Ie.floor = function(w, C) {
                        return w[0] = Math.floor(C[0]),
                        w[1] = Math.floor(C[1]),
                        w[2] = Math.floor(C[2]),
                        w
                    }
                    ,
                    Ie.min = function(w, C, A) {
                        return w[0] = Math.min(C[0], A[0]),
                        w[1] = Math.min(C[1], A[1]),
                        w[2] = Math.min(C[2], A[2]),
                        w
                    }
                    ,
                    Ie.max = function(w, C, A) {
                        return w[0] = Math.max(C[0], A[0]),
                        w[1] = Math.max(C[1], A[1]),
                        w[2] = Math.max(C[2], A[2]),
                        w
                    }
                    ,
                    Ie.round = function(w, C) {
                        return w[0] = Math.round(C[0]),
                        w[1] = Math.round(C[1]),
                        w[2] = Math.round(C[2]),
                        w
                    }
                    ,
                    Ie.scale = function(w, C, A) {
                        return w[0] = C[0] * A,
                        w[1] = C[1] * A,
                        w[2] = C[2] * A,
                        w
                    }
                    ,
                    Ie.scaleAndAdd = function(w, C, A, O) {
                        return w[0] = C[0] + A[0] * O,
                        w[1] = C[1] + A[1] * O,
                        w[2] = C[2] + A[2] * O,
                        w
                    }
                    ,
                    Ie.distance = x,
                    Ie.squaredDistance = T,
                    Ie.squaredLength = f,
                    Ie.negate = function(w, C) {
                        return w[0] = -C[0],
                        w[1] = -C[1],
                        w[2] = -C[2],
                        w
                    }
                    ,
                    Ie.inverse = function(w, C) {
                        return w[0] = 1 / C[0],
                        w[1] = 1 / C[1],
                        w[2] = 1 / C[2],
                        w
                    }
                    ,
                    Ie.normalize = function(w, C) {
                        var A = C[0]
                          , O = C[1]
                          , F = C[2]
                          , z = A * A + O * O + F * F;
                        return z > 0 && (z = 1 / Math.sqrt(z)),
                        w[0] = C[0] * z,
                        w[1] = C[1] * z,
                        w[2] = C[2] * z,
                        w
                    }
                    ,
                    Ie.dot = b,
                    Ie.cross = function(w, C, A) {
                        var O = C[0]
                          , F = C[1]
                          , z = C[2]
                          , L = A[0]
                          , N = A[1]
                          , G = A[2];
                        return w[0] = F * G - z * N,
                        w[1] = z * L - O * G,
                        w[2] = O * N - F * L,
                        w
                    }
                    ,
                    Ie.lerp = function(w, C, A, O) {
                        var F = C[0]
                          , z = C[1]
                          , L = C[2];
                        return w[0] = F + O * (A[0] - F),
                        w[1] = z + O * (A[1] - z),
                        w[2] = L + O * (A[2] - L),
                        w
                    }
                    ,
                    Ie.hermite = function(w, C, A, O, F, z) {
                        var L = z * z
                          , N = L * (2 * z - 3) + 1
                          , G = L * (z - 2) + z
                          , X = L * (z - 1)
                          , _e = L * (3 - 2 * z);
                        return w[0] = C[0] * N + A[0] * G + O[0] * X + F[0] * _e,
                        w[1] = C[1] * N + A[1] * G + O[1] * X + F[1] * _e,
                        w[2] = C[2] * N + A[2] * G + O[2] * X + F[2] * _e,
                        w
                    }
                    ,
                    Ie.bezier = function(w, C, A, O, F, z) {
                        var L = 1 - z
                          , N = L * L
                          , G = z * z
                          , X = N * L
                          , _e = 3 * z * N
                          , me = 3 * G * L
                          , pe = G * z;
                        return w[0] = C[0] * X + A[0] * _e + O[0] * me + F[0] * pe,
                        w[1] = C[1] * X + A[1] * _e + O[1] * me + F[1] * pe,
                        w[2] = C[2] * X + A[2] * _e + O[2] * me + F[2] * pe,
                        w
                    }
                    ,
                    Ie.random = function(w, C) {
                        C = C || 1;
                        var A = 2 * e.RANDOM() * Math.PI
                          , O = 2 * e.RANDOM() - 1
                          , F = Math.sqrt(1 - O * O) * C;
                        return w[0] = Math.cos(A) * F,
                        w[1] = Math.sin(A) * F,
                        w[2] = O * C,
                        w
                    }
                    ,
                    Ie.transformMat4 = function(w, C, A) {
                        var O = C[0]
                          , F = C[1]
                          , z = C[2]
                          , L = A[3] * O + A[7] * F + A[11] * z + A[15];
                        return w[0] = (A[0] * O + A[4] * F + A[8] * z + A[12]) / (L = L || 1),
                        w[1] = (A[1] * O + A[5] * F + A[9] * z + A[13]) / L,
                        w[2] = (A[2] * O + A[6] * F + A[10] * z + A[14]) / L,
                        w
                    }
                    ,
                    Ie.transformMat3 = function(w, C, A) {
                        var O = C[0]
                          , F = C[1]
                          , z = C[2];
                        return w[0] = O * A[0] + F * A[3] + z * A[6],
                        w[1] = O * A[1] + F * A[4] + z * A[7],
                        w[2] = O * A[2] + F * A[5] + z * A[8],
                        w
                    }
                    ,
                    Ie.transformQuat = function(w, C, A) {
                        var O = A[0]
                          , F = A[1]
                          , z = A[2]
                          , L = C[0]
                          , N = C[1]
                          , G = C[2]
                          , X = F * G - z * N
                          , _e = z * L - O * G
                          , me = O * N - F * L
                          , pe = F * me - z * _e
                          , Ne = z * X - O * me
                          , Pe = O * _e - F * X
                          , $e = 2 * A[3];
                        return _e *= $e,
                        me *= $e,
                        Ne *= 2,
                        Pe *= 2,
                        w[0] = L + (X *= $e) + (pe *= 2),
                        w[1] = N + _e + Ne,
                        w[2] = G + me + Pe,
                        w
                    }
                    ,
                    Ie.rotateX = function(w, C, A, O) {
                        var F = []
                          , z = [];
                        return F[0] = C[0] - A[0],
                        F[1] = C[1] - A[1],
                        F[2] = C[2] - A[2],
                        z[0] = F[0],
                        z[1] = F[1] * Math.cos(O) - F[2] * Math.sin(O),
                        z[2] = F[1] * Math.sin(O) + F[2] * Math.cos(O),
                        w[0] = z[0] + A[0],
                        w[1] = z[1] + A[1],
                        w[2] = z[2] + A[2],
                        w
                    }
                    ,
                    Ie.rotateY = function(w, C, A, O) {
                        var F = []
                          , z = [];
                        return F[0] = C[0] - A[0],
                        F[1] = C[1] - A[1],
                        F[2] = C[2] - A[2],
                        z[0] = F[2] * Math.sin(O) + F[0] * Math.cos(O),
                        z[1] = F[1],
                        z[2] = F[2] * Math.cos(O) - F[0] * Math.sin(O),
                        w[0] = z[0] + A[0],
                        w[1] = z[1] + A[1],
                        w[2] = z[2] + A[2],
                        w
                    }
                    ,
                    Ie.rotateZ = function(w, C, A, O) {
                        var F = []
                          , z = [];
                        return F[0] = C[0] - A[0],
                        F[1] = C[1] - A[1],
                        F[2] = C[2] - A[2],
                        z[0] = F[0] * Math.cos(O) - F[1] * Math.sin(O),
                        z[1] = F[0] * Math.sin(O) + F[1] * Math.cos(O),
                        z[2] = F[2],
                        w[0] = z[0] + A[0],
                        w[1] = z[1] + A[1],
                        w[2] = z[2] + A[2],
                        w
                    }
                    ,
                    Ie.angle = function(w, C) {
                        var A = w[0]
                          , O = w[1]
                          , F = w[2]
                          , z = C[0]
                          , L = C[1]
                          , N = C[2]
                          , G = Math.sqrt(A * A + O * O + F * F) * Math.sqrt(z * z + L * L + N * N)
                          , X = G && b(w, C) / G;
                        return Math.acos(Math.min(Math.max(X, -1), 1))
                    }
                    ,
                    Ie.zero = function(w) {
                        return w[0] = 0,
                        w[1] = 0,
                        w[2] = 0,
                        w
                    }
                    ,
                    Ie.str = function(w) {
                        return "vec3(" + w[0] + ", " + w[1] + ", " + w[2] + ")"
                    }
                    ,
                    Ie.exactEquals = function(w, C) {
                        return w[0] === C[0] && w[1] === C[1] && w[2] === C[2]
                    }
                    ,
                    Ie.equals = function(w, C) {
                        var A = w[0]
                          , O = w[1]
                          , F = w[2]
                          , z = C[0]
                          , L = C[1]
                          , N = C[2];
                        return Math.abs(A - z) <= e.EPSILON * Math.max(1, Math.abs(A), Math.abs(z)) && Math.abs(O - L) <= e.EPSILON * Math.max(1, Math.abs(O), Math.abs(L)) && Math.abs(F - N) <= e.EPSILON * Math.max(1, Math.abs(F), Math.abs(N))
                    }
                    ,
                    Ie.forEach = Ie.sqrLen = Ie.len = Ie.sqrDist = Ie.dist = Ie.div = Ie.mul = Ie.sub = void 0;
                    var e = function(w) {
                        if (w && w.__esModule)
                            return w;
                        if (null === w || "object" !== n(w) && "function" != typeof w)
                            return {
                                default: w
                            };
                        var A = o(void 0);
                        if (A && A.has(w))
                            return A.get(w);
                        var O = {}
                          , F = Object.defineProperty && Object.getOwnPropertyDescriptor;
                        for (var z in w)
                            if ("default" !== z && Object.prototype.hasOwnProperty.call(w, z)) {
                                var L = F ? Object.getOwnPropertyDescriptor(w, z) : null;
                                L && (L.get || L.set) ? Object.defineProperty(O, z, L) : O[z] = w[z]
                            }
                        return O.default = w,
                        A && A.set(w, O),
                        O
                    }(Me());
                    function o(w) {
                        if ("function" != typeof WeakMap)
                            return null;
                        var C = new WeakMap
                          , A = new WeakMap;
                        return (o = function(O) {
                            return O ? A : C
                        }
                        )(w)
                    }
                    function a() {
                        var w = new e.ARRAY_TYPE(3);
                        return e.ARRAY_TYPE != Float32Array && (w[0] = 0,
                        w[1] = 0,
                        w[2] = 0),
                        w
                    }
                    function u(w) {
                        return Math.hypot(w[0], w[1], w[2])
                    }
                    function l(w, C, A) {
                        return w[0] = C[0] - A[0],
                        w[1] = C[1] - A[1],
                        w[2] = C[2] - A[2],
                        w
                    }
                    function p(w, C, A) {
                        return w[0] = C[0] * A[0],
                        w[1] = C[1] * A[1],
                        w[2] = C[2] * A[2],
                        w
                    }
                    function g(w, C, A) {
                        return w[0] = C[0] / A[0],
                        w[1] = C[1] / A[1],
                        w[2] = C[2] / A[2],
                        w
                    }
                    function x(w, C) {
                        return Math.hypot(C[0] - w[0], C[1] - w[1], C[2] - w[2])
                    }
                    function T(w, C) {
                        var A = C[0] - w[0]
                          , O = C[1] - w[1]
                          , F = C[2] - w[2];
                        return A * A + O * O + F * F
                    }
                    function f(w) {
                        var C = w[0]
                          , A = w[1]
                          , O = w[2];
                        return C * C + A * A + O * O
                    }
                    function b(w, C) {
                        return w[0] * C[0] + w[1] * C[1] + w[2] * C[2]
                    }
                    Ie.sub = l,
                    Ie.mul = p,
                    Ie.div = g,
                    Ie.dist = x,
                    Ie.sqrDist = T,
                    Ie.len = u,
                    Ie.sqrLen = f;
                    var P, v = (P = a(),
                    function(w, C, A, O, F, z) {
                        var L, N;
                        for (C || (C = 3),
                        A || (A = 0),
                        N = O ? Math.min(O * C + A, w.length) : w.length,
                        L = A; L < N; L += C)
                            P[0] = w[L],
                            P[1] = w[L + 1],
                            P[2] = w[L + 2],
                            F(P, P, z),
                            w[L] = P[0],
                            w[L + 1] = P[1],
                            w[L + 2] = P[2];
                        return w
                    }
                    );
                    return Ie.forEach = v,
                    Ie
                }
                var Ye, yt, ht = {};
                function mo() {
                    if (Ye)
                        return ht;
                    function n(v) {
                        return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(w) {
                            return typeof w
                        }
                        : function(w) {
                            return w && "function" == typeof Symbol && w.constructor === Symbol && w !== Symbol.prototype ? "symbol" : typeof w
                        }
                        )(v)
                    }
                    Ye = 1,
                    Object.defineProperty(ht, "__esModule", {
                        value: !0
                    }),
                    ht.create = a,
                    ht.clone = function(v) {
                        var w = new e.ARRAY_TYPE(4);
                        return w[0] = v[0],
                        w[1] = v[1],
                        w[2] = v[2],
                        w[3] = v[3],
                        w
                    }
                    ,
                    ht.fromValues = function(v, w, C, A) {
                        var O = new e.ARRAY_TYPE(4);
                        return O[0] = v,
                        O[1] = w,
                        O[2] = C,
                        O[3] = A,
                        O
                    }
                    ,
                    ht.copy = function(v, w) {
                        return v[0] = w[0],
                        v[1] = w[1],
                        v[2] = w[2],
                        v[3] = w[3],
                        v
                    }
                    ,
                    ht.set = function(v, w, C, A, O) {
                        return v[0] = w,
                        v[1] = C,
                        v[2] = A,
                        v[3] = O,
                        v
                    }
                    ,
                    ht.add = function(v, w, C) {
                        return v[0] = w[0] + C[0],
                        v[1] = w[1] + C[1],
                        v[2] = w[2] + C[2],
                        v[3] = w[3] + C[3],
                        v
                    }
                    ,
                    ht.subtract = u,
                    ht.multiply = l,
                    ht.divide = p,
                    ht.ceil = function(v, w) {
                        return v[0] = Math.ceil(w[0]),
                        v[1] = Math.ceil(w[1]),
                        v[2] = Math.ceil(w[2]),
                        v[3] = Math.ceil(w[3]),
                        v
                    }
                    ,
                    ht.floor = function(v, w) {
                        return v[0] = Math.floor(w[0]),
                        v[1] = Math.floor(w[1]),
                        v[2] = Math.floor(w[2]),
                        v[3] = Math.floor(w[3]),
                        v
                    }
                    ,
                    ht.min = function(v, w, C) {
                        return v[0] = Math.min(w[0], C[0]),
                        v[1] = Math.min(w[1], C[1]),
                        v[2] = Math.min(w[2], C[2]),
                        v[3] = Math.min(w[3], C[3]),
                        v
                    }
                    ,
                    ht.max = function(v, w, C) {
                        return v[0] = Math.max(w[0], C[0]),
                        v[1] = Math.max(w[1], C[1]),
                        v[2] = Math.max(w[2], C[2]),
                        v[3] = Math.max(w[3], C[3]),
                        v
                    }
                    ,
                    ht.round = function(v, w) {
                        return v[0] = Math.round(w[0]),
                        v[1] = Math.round(w[1]),
                        v[2] = Math.round(w[2]),
                        v[3] = Math.round(w[3]),
                        v
                    }
                    ,
                    ht.scale = function(v, w, C) {
                        return v[0] = w[0] * C,
                        v[1] = w[1] * C,
                        v[2] = w[2] * C,
                        v[3] = w[3] * C,
                        v
                    }
                    ,
                    ht.scaleAndAdd = function(v, w, C, A) {
                        return v[0] = w[0] + C[0] * A,
                        v[1] = w[1] + C[1] * A,
                        v[2] = w[2] + C[2] * A,
                        v[3] = w[3] + C[3] * A,
                        v
                    }
                    ,
                    ht.distance = g,
                    ht.squaredDistance = x,
                    ht.length = T,
                    ht.squaredLength = f,
                    ht.negate = function(v, w) {
                        return v[0] = -w[0],
                        v[1] = -w[1],
                        v[2] = -w[2],
                        v[3] = -w[3],
                        v
                    }
                    ,
                    ht.inverse = function(v, w) {
                        return v[0] = 1 / w[0],
                        v[1] = 1 / w[1],
                        v[2] = 1 / w[2],
                        v[3] = 1 / w[3],
                        v
                    }
                    ,
                    ht.normalize = function(v, w) {
                        var C = w[0]
                          , A = w[1]
                          , O = w[2]
                          , F = w[3]
                          , z = C * C + A * A + O * O + F * F;
                        return z > 0 && (z = 1 / Math.sqrt(z)),
                        v[0] = C * z,
                        v[1] = A * z,
                        v[2] = O * z,
                        v[3] = F * z,
                        v
                    }
                    ,
                    ht.dot = function(v, w) {
                        return v[0] * w[0] + v[1] * w[1] + v[2] * w[2] + v[3] * w[3]
                    }
                    ,
                    ht.cross = function(v, w, C, A) {
                        var O = C[0] * A[1] - C[1] * A[0]
                          , F = C[0] * A[2] - C[2] * A[0]
                          , z = C[0] * A[3] - C[3] * A[0]
                          , L = C[1] * A[2] - C[2] * A[1]
                          , N = C[1] * A[3] - C[3] * A[1]
                          , G = C[2] * A[3] - C[3] * A[2]
                          , X = w[0]
                          , _e = w[1]
                          , me = w[2]
                          , pe = w[3];
                        return v[0] = _e * G - me * N + pe * L,
                        v[1] = -X * G + me * z - pe * F,
                        v[2] = X * N - _e * z + pe * O,
                        v[3] = -X * L + _e * F - me * O,
                        v
                    }
                    ,
                    ht.lerp = function(v, w, C, A) {
                        var O = w[0]
                          , F = w[1]
                          , z = w[2]
                          , L = w[3];
                        return v[0] = O + A * (C[0] - O),
                        v[1] = F + A * (C[1] - F),
                        v[2] = z + A * (C[2] - z),
                        v[3] = L + A * (C[3] - L),
                        v
                    }
                    ,
                    ht.random = function(v, w) {
                        var C, A, O, F, z, L;
                        w = w || 1;
                        do {
                            z = (C = 2 * e.RANDOM() - 1) * C + (A = 2 * e.RANDOM() - 1) * A
                        } while (z >= 1);
                        do {
                            L = (O = 2 * e.RANDOM() - 1) * O + (F = 2 * e.RANDOM() - 1) * F
                        } while (L >= 1);
                        var N = Math.sqrt((1 - z) / L);
                        return v[0] = w * C,
                        v[1] = w * A,
                        v[2] = w * O * N,
                        v[3] = w * F * N,
                        v
                    }
                    ,
                    ht.transformMat4 = function(v, w, C) {
                        var A = w[0]
                          , O = w[1]
                          , F = w[2]
                          , z = w[3];
                        return v[0] = C[0] * A + C[4] * O + C[8] * F + C[12] * z,
                        v[1] = C[1] * A + C[5] * O + C[9] * F + C[13] * z,
                        v[2] = C[2] * A + C[6] * O + C[10] * F + C[14] * z,
                        v[3] = C[3] * A + C[7] * O + C[11] * F + C[15] * z,
                        v
                    }
                    ,
                    ht.transformQuat = function(v, w, C) {
                        var A = w[0]
                          , O = w[1]
                          , F = w[2]
                          , z = C[0]
                          , L = C[1]
                          , N = C[2]
                          , G = C[3]
                          , X = G * A + L * F - N * O
                          , _e = G * O + N * A - z * F
                          , me = G * F + z * O - L * A
                          , pe = -z * A - L * O - N * F;
                        return v[0] = X * G + pe * -z + _e * -N - me * -L,
                        v[1] = _e * G + pe * -L + me * -z - X * -N,
                        v[2] = me * G + pe * -N + X * -L - _e * -z,
                        v[3] = w[3],
                        v
                    }
                    ,
                    ht.zero = function(v) {
                        return v[0] = 0,
                        v[1] = 0,
                        v[2] = 0,
                        v[3] = 0,
                        v
                    }
                    ,
                    ht.str = function(v) {
                        return "vec4(" + v[0] + ", " + v[1] + ", " + v[2] + ", " + v[3] + ")"
                    }
                    ,
                    ht.exactEquals = function(v, w) {
                        return v[0] === w[0] && v[1] === w[1] && v[2] === w[2] && v[3] === w[3]
                    }
                    ,
                    ht.equals = function(v, w) {
                        var C = v[0]
                          , A = v[1]
                          , O = v[2]
                          , F = v[3]
                          , z = w[0]
                          , L = w[1]
                          , N = w[2]
                          , G = w[3];
                        return Math.abs(C - z) <= e.EPSILON * Math.max(1, Math.abs(C), Math.abs(z)) && Math.abs(A - L) <= e.EPSILON * Math.max(1, Math.abs(A), Math.abs(L)) && Math.abs(O - N) <= e.EPSILON * Math.max(1, Math.abs(O), Math.abs(N)) && Math.abs(F - G) <= e.EPSILON * Math.max(1, Math.abs(F), Math.abs(G))
                    }
                    ,
                    ht.forEach = ht.sqrLen = ht.len = ht.sqrDist = ht.dist = ht.div = ht.mul = ht.sub = void 0;
                    var e = function(v) {
                        if (v && v.__esModule)
                            return v;
                        if (null === v || "object" !== n(v) && "function" != typeof v)
                            return {
                                default: v
                            };
                        var C = o(void 0);
                        if (C && C.has(v))
                            return C.get(v);
                        var A = {}
                          , O = Object.defineProperty && Object.getOwnPropertyDescriptor;
                        for (var F in v)
                            if ("default" !== F && Object.prototype.hasOwnProperty.call(v, F)) {
                                var z = O ? Object.getOwnPropertyDescriptor(v, F) : null;
                                z && (z.get || z.set) ? Object.defineProperty(A, F, z) : A[F] = v[F]
                            }
                        return A.default = v,
                        C && C.set(v, A),
                        A
                    }(Me());
                    function o(v) {
                        if ("function" != typeof WeakMap)
                            return null;
                        var w = new WeakMap
                          , C = new WeakMap;
                        return (o = function(A) {
                            return A ? C : w
                        }
                        )(v)
                    }
                    function a() {
                        var v = new e.ARRAY_TYPE(4);
                        return e.ARRAY_TYPE != Float32Array && (v[0] = 0,
                        v[1] = 0,
                        v[2] = 0,
                        v[3] = 0),
                        v
                    }
                    function u(v, w, C) {
                        return v[0] = w[0] - C[0],
                        v[1] = w[1] - C[1],
                        v[2] = w[2] - C[2],
                        v[3] = w[3] - C[3],
                        v
                    }
                    function l(v, w, C) {
                        return v[0] = w[0] * C[0],
                        v[1] = w[1] * C[1],
                        v[2] = w[2] * C[2],
                        v[3] = w[3] * C[3],
                        v
                    }
                    function p(v, w, C) {
                        return v[0] = w[0] / C[0],
                        v[1] = w[1] / C[1],
                        v[2] = w[2] / C[2],
                        v[3] = w[3] / C[3],
                        v
                    }
                    function g(v, w) {
                        return Math.hypot(w[0] - v[0], w[1] - v[1], w[2] - v[2], w[3] - v[3])
                    }
                    function x(v, w) {
                        var C = w[0] - v[0]
                          , A = w[1] - v[1]
                          , O = w[2] - v[2]
                          , F = w[3] - v[3];
                        return C * C + A * A + O * O + F * F
                    }
                    function T(v) {
                        return Math.hypot(v[0], v[1], v[2], v[3])
                    }
                    function f(v) {
                        var w = v[0]
                          , C = v[1]
                          , A = v[2]
                          , O = v[3];
                        return w * w + C * C + A * A + O * O
                    }
                    ht.sub = u,
                    ht.mul = l,
                    ht.div = p,
                    ht.dist = g,
                    ht.sqrDist = x,
                    ht.len = T,
                    ht.sqrLen = f;
                    var b, P = (b = a(),
                    function(v, w, C, A, O, F) {
                        var z, L;
                        for (w || (w = 4),
                        C || (C = 0),
                        L = A ? Math.min(A * w + C, v.length) : v.length,
                        z = C; z < L; z += w)
                            b[0] = v[z],
                            b[1] = v[z + 1],
                            b[2] = v[z + 2],
                            b[3] = v[z + 3],
                            O(b, b, F),
                            v[z] = b[0],
                            v[z + 1] = b[1],
                            v[z + 2] = b[2],
                            v[z + 3] = b[3];
                        return v
                    }
                    );
                    return ht.forEach = P,
                    ht
                }
                function no() {
                    if (yt)
                        return ge;
                    function n(Pe) {
                        return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function($e) {
                            return typeof $e
                        }
                        : function($e) {
                            return $e && "function" == typeof Symbol && $e.constructor === Symbol && $e !== Symbol.prototype ? "symbol" : typeof $e
                        }
                        )(Pe)
                    }
                    yt = 1,
                    Object.defineProperty(ge, "__esModule", {
                        value: !0
                    }),
                    ge.create = g,
                    ge.identity = function(Pe) {
                        return Pe[0] = 0,
                        Pe[1] = 0,
                        Pe[2] = 0,
                        Pe[3] = 1,
                        Pe
                    }
                    ,
                    ge.setAxisAngle = x,
                    ge.getAxisAngle = function(Pe, $e) {
                        var We = 2 * Math.acos($e[3])
                          , je = Math.sin(We / 2);
                        return je > e.EPSILON ? (Pe[0] = $e[0] / je,
                        Pe[1] = $e[1] / je,
                        Pe[2] = $e[2] / je) : (Pe[0] = 1,
                        Pe[1] = 0,
                        Pe[2] = 0),
                        We
                    }
                    ,
                    ge.getAngle = function(Pe, $e) {
                        var We = C(Pe, $e);
                        return Math.acos(2 * We * We - 1)
                    }
                    ,
                    ge.multiply = T,
                    ge.rotateX = function(Pe, $e, We) {
                        We *= .5;
                        var je = $e[0]
                          , Ke = $e[1]
                          , rt = $e[2]
                          , at = $e[3]
                          , ot = Math.sin(We)
                          , Ct = Math.cos(We);
                        return Pe[0] = je * Ct + at * ot,
                        Pe[1] = Ke * Ct + rt * ot,
                        Pe[2] = rt * Ct - Ke * ot,
                        Pe[3] = at * Ct - je * ot,
                        Pe
                    }
                    ,
                    ge.rotateY = function(Pe, $e, We) {
                        We *= .5;
                        var je = $e[0]
                          , Ke = $e[1]
                          , rt = $e[2]
                          , at = $e[3]
                          , ot = Math.sin(We)
                          , Ct = Math.cos(We);
                        return Pe[0] = je * Ct - rt * ot,
                        Pe[1] = Ke * Ct + at * ot,
                        Pe[2] = rt * Ct + je * ot,
                        Pe[3] = at * Ct - Ke * ot,
                        Pe
                    }
                    ,
                    ge.rotateZ = function(Pe, $e, We) {
                        We *= .5;
                        var je = $e[0]
                          , Ke = $e[1]
                          , rt = $e[2]
                          , at = $e[3]
                          , ot = Math.sin(We)
                          , Ct = Math.cos(We);
                        return Pe[0] = je * Ct + Ke * ot,
                        Pe[1] = Ke * Ct - je * ot,
                        Pe[2] = rt * Ct + at * ot,
                        Pe[3] = at * Ct - rt * ot,
                        Pe
                    }
                    ,
                    ge.calculateW = function(Pe, $e) {
                        var We = $e[0]
                          , je = $e[1]
                          , Ke = $e[2];
                        return Pe[0] = We,
                        Pe[1] = je,
                        Pe[2] = Ke,
                        Pe[3] = Math.sqrt(Math.abs(1 - We * We - je * je - Ke * Ke)),
                        Pe
                    }
                    ,
                    ge.exp = f,
                    ge.ln = b,
                    ge.pow = function(Pe, $e, We) {
                        return b(Pe, $e),
                        w(Pe, Pe, We),
                        f(Pe, Pe),
                        Pe
                    }
                    ,
                    ge.slerp = P,
                    ge.random = function(Pe) {
                        var $e = e.RANDOM()
                          , We = e.RANDOM()
                          , je = e.RANDOM()
                          , Ke = Math.sqrt(1 - $e)
                          , rt = Math.sqrt($e);
                        return Pe[0] = Ke * Math.sin(2 * Math.PI * We),
                        Pe[1] = Ke * Math.cos(2 * Math.PI * We),
                        Pe[2] = rt * Math.sin(2 * Math.PI * je),
                        Pe[3] = rt * Math.cos(2 * Math.PI * je),
                        Pe
                    }
                    ,
                    ge.invert = function(Pe, $e) {
                        var We = $e[0]
                          , je = $e[1]
                          , Ke = $e[2]
                          , rt = $e[3]
                          , at = We * We + je * je + Ke * Ke + rt * rt
                          , ot = at ? 1 / at : 0;
                        return Pe[0] = -We * ot,
                        Pe[1] = -je * ot,
                        Pe[2] = -Ke * ot,
                        Pe[3] = rt * ot,
                        Pe
                    }
                    ,
                    ge.conjugate = function(Pe, $e) {
                        return Pe[0] = -$e[0],
                        Pe[1] = -$e[1],
                        Pe[2] = -$e[2],
                        Pe[3] = $e[3],
                        Pe
                    }
                    ,
                    ge.fromMat3 = v,
                    ge.fromEuler = function(Pe, $e, We, je) {
                        var Ke = .5 * Math.PI / 180;
                        $e *= Ke,
                        We *= Ke,
                        je *= Ke;
                        var rt = Math.sin($e)
                          , at = Math.cos($e)
                          , ot = Math.sin(We)
                          , Ct = Math.cos(We)
                          , Zt = Math.sin(je)
                          , Ot = Math.cos(je);
                        return Pe[0] = rt * Ct * Ot - at * ot * Zt,
                        Pe[1] = at * ot * Ot + rt * Ct * Zt,
                        Pe[2] = at * Ct * Zt - rt * ot * Ot,
                        Pe[3] = at * Ct * Ot + rt * ot * Zt,
                        Pe
                    }
                    ,
                    ge.str = function(Pe) {
                        return "quat(" + Pe[0] + ", " + Pe[1] + ", " + Pe[2] + ", " + Pe[3] + ")"
                    }
                    ,
                    ge.setAxes = ge.sqlerp = ge.rotationTo = ge.equals = ge.exactEquals = ge.normalize = ge.sqrLen = ge.squaredLength = ge.len = ge.length = ge.lerp = ge.dot = ge.scale = ge.mul = ge.add = ge.set = ge.copy = ge.fromValues = ge.clone = void 0;
                    var e = p(Me())
                      , o = p(re())
                      , a = p(gt())
                      , u = p(mo());
                    function l(Pe) {
                        if ("function" != typeof WeakMap)
                            return null;
                        var $e = new WeakMap
                          , We = new WeakMap;
                        return (l = function(je) {
                            return je ? We : $e
                        }
                        )(Pe)
                    }
                    function p(Pe, $e) {
                        if (Pe && Pe.__esModule)
                            return Pe;
                        if (null === Pe || "object" !== n(Pe) && "function" != typeof Pe)
                            return {
                                default: Pe
                            };
                        var We = l($e);
                        if (We && We.has(Pe))
                            return We.get(Pe);
                        var je = {}
                          , Ke = Object.defineProperty && Object.getOwnPropertyDescriptor;
                        for (var rt in Pe)
                            if ("default" !== rt && Object.prototype.hasOwnProperty.call(Pe, rt)) {
                                var at = Ke ? Object.getOwnPropertyDescriptor(Pe, rt) : null;
                                at && (at.get || at.set) ? Object.defineProperty(je, rt, at) : je[rt] = Pe[rt]
                            }
                        return je.default = Pe,
                        We && We.set(Pe, je),
                        je
                    }
                    function g() {
                        var Pe = new e.ARRAY_TYPE(4);
                        return e.ARRAY_TYPE != Float32Array && (Pe[0] = 0,
                        Pe[1] = 0,
                        Pe[2] = 0),
                        Pe[3] = 1,
                        Pe
                    }
                    function x(Pe, $e, We) {
                        We *= .5;
                        var je = Math.sin(We);
                        return Pe[0] = je * $e[0],
                        Pe[1] = je * $e[1],
                        Pe[2] = je * $e[2],
                        Pe[3] = Math.cos(We),
                        Pe
                    }
                    function T(Pe, $e, We) {
                        var je = $e[0]
                          , Ke = $e[1]
                          , rt = $e[2]
                          , at = $e[3]
                          , ot = We[0]
                          , Ct = We[1]
                          , Zt = We[2]
                          , Ot = We[3];
                        return Pe[0] = je * Ot + at * ot + Ke * Zt - rt * Ct,
                        Pe[1] = Ke * Ot + at * Ct + rt * ot - je * Zt,
                        Pe[2] = rt * Ot + at * Zt + je * Ct - Ke * ot,
                        Pe[3] = at * Ot - je * ot - Ke * Ct - rt * Zt,
                        Pe
                    }
                    function f(Pe, $e) {
                        var We = $e[0]
                          , je = $e[1]
                          , Ke = $e[2]
                          , rt = $e[3]
                          , at = Math.sqrt(We * We + je * je + Ke * Ke)
                          , ot = Math.exp(rt)
                          , Ct = at > 0 ? ot * Math.sin(at) / at : 0;
                        return Pe[0] = We * Ct,
                        Pe[1] = je * Ct,
                        Pe[2] = Ke * Ct,
                        Pe[3] = ot * Math.cos(at),
                        Pe
                    }
                    function b(Pe, $e) {
                        var We = $e[0]
                          , je = $e[1]
                          , Ke = $e[2]
                          , rt = $e[3]
                          , at = Math.sqrt(We * We + je * je + Ke * Ke)
                          , ot = at > 0 ? Math.atan2(at, rt) / at : 0;
                        return Pe[0] = We * ot,
                        Pe[1] = je * ot,
                        Pe[2] = Ke * ot,
                        Pe[3] = .5 * Math.log(We * We + je * je + Ke * Ke + rt * rt),
                        Pe
                    }
                    function P(Pe, $e, We, je) {
                        var Ke, rt, at, ot, Ct, Zt = $e[0], Ot = $e[1], lo = $e[2], io = $e[3], fo = We[0], Bt = We[1], Ro = We[2], ho = We[3];
                        return (rt = Zt * fo + Ot * Bt + lo * Ro + io * ho) < 0 && (rt = -rt,
                        fo = -fo,
                        Bt = -Bt,
                        Ro = -Ro,
                        ho = -ho),
                        1 - rt > e.EPSILON ? (Ke = Math.acos(rt),
                        at = Math.sin(Ke),
                        ot = Math.sin((1 - je) * Ke) / at,
                        Ct = Math.sin(je * Ke) / at) : (ot = 1 - je,
                        Ct = je),
                        Pe[0] = ot * Zt + Ct * fo,
                        Pe[1] = ot * Ot + Ct * Bt,
                        Pe[2] = ot * lo + Ct * Ro,
                        Pe[3] = ot * io + Ct * ho,
                        Pe
                    }
                    function v(Pe, $e) {
                        var We, je = $e[0] + $e[4] + $e[8];
                        if (je > 0)
                            We = Math.sqrt(je + 1),
                            Pe[3] = .5 * We,
                            Pe[0] = ($e[5] - $e[7]) * (We = .5 / We),
                            Pe[1] = ($e[6] - $e[2]) * We,
                            Pe[2] = ($e[1] - $e[3]) * We;
                        else {
                            var Ke = 0;
                            $e[4] > $e[0] && (Ke = 1),
                            $e[8] > $e[3 * Ke + Ke] && (Ke = 2);
                            var rt = (Ke + 1) % 3
                              , at = (Ke + 2) % 3;
                            We = Math.sqrt($e[3 * Ke + Ke] - $e[3 * rt + rt] - $e[3 * at + at] + 1),
                            Pe[Ke] = .5 * We,
                            Pe[3] = ($e[3 * rt + at] - $e[3 * at + rt]) * (We = .5 / We),
                            Pe[rt] = ($e[3 * rt + Ke] + $e[3 * Ke + rt]) * We,
                            Pe[at] = ($e[3 * at + Ke] + $e[3 * Ke + at]) * We
                        }
                        return Pe
                    }
                    ge.clone = u.clone,
                    ge.fromValues = u.fromValues,
                    ge.copy = u.copy,
                    ge.set = u.set,
                    ge.add = u.add,
                    ge.mul = T;
                    var w = u.scale;
                    ge.scale = w;
                    var C = u.dot;
                    ge.dot = C,
                    ge.lerp = u.lerp;
                    var A = u.length;
                    ge.length = A,
                    ge.len = A;
                    var O = u.squaredLength;
                    ge.squaredLength = O,
                    ge.sqrLen = O;
                    var F = u.normalize;
                    ge.normalize = F,
                    ge.exactEquals = u.exactEquals,
                    ge.equals = u.equals;
                    var z, L, N, G = (z = a.create(),
                    L = a.fromValues(1, 0, 0),
                    N = a.fromValues(0, 1, 0),
                    function(Pe, $e, We) {
                        var je = a.dot($e, We);
                        return je < -.999999 ? (a.cross(z, L, $e),
                        a.len(z) < 1e-6 && a.cross(z, N, $e),
                        a.normalize(z, z),
                        x(Pe, z, Math.PI),
                        Pe) : je > .999999 ? (Pe[0] = 0,
                        Pe[1] = 0,
                        Pe[2] = 0,
                        Pe[3] = 1,
                        Pe) : (a.cross(z, $e, We),
                        Pe[0] = z[0],
                        Pe[1] = z[1],
                        Pe[2] = z[2],
                        Pe[3] = 1 + je,
                        F(Pe, Pe))
                    }
                    );
                    ge.rotationTo = G;
                    var X, _e, me = (X = g(),
                    _e = g(),
                    function(Pe, $e, We, je, Ke, rt) {
                        return P(X, $e, Ke, rt),
                        P(_e, We, je, rt),
                        P(Pe, X, _e, 2 * rt * (1 - rt)),
                        Pe
                    }
                    );
                    ge.sqlerp = me;
                    var pe, Ne = (pe = o.create(),
                    function(Pe, $e, We, je) {
                        return pe[0] = We[0],
                        pe[3] = We[1],
                        pe[6] = We[2],
                        pe[1] = je[0],
                        pe[4] = je[1],
                        pe[7] = je[2],
                        pe[2] = -$e[0],
                        pe[5] = -$e[1],
                        pe[8] = -$e[2],
                        F(Pe, v(Pe, pe))
                    }
                    );
                    return ge.setAxes = Ne,
                    ge
                }
                var Co, Lt = {};
                var co, Jt, po = {};
                function Et() {
                    if (co)
                        return po;
                    function n(v) {
                        return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(w) {
                            return typeof w
                        }
                        : function(w) {
                            return w && "function" == typeof Symbol && w.constructor === Symbol && w !== Symbol.prototype ? "symbol" : typeof w
                        }
                        )(v)
                    }
                    co = 1,
                    Object.defineProperty(po, "__esModule", {
                        value: !0
                    }),
                    po.create = a,
                    po.clone = function(v) {
                        var w = new e.ARRAY_TYPE(2);
                        return w[0] = v[0],
                        w[1] = v[1],
                        w
                    }
                    ,
                    po.fromValues = function(v, w) {
                        var C = new e.ARRAY_TYPE(2);
                        return C[0] = v,
                        C[1] = w,
                        C
                    }
                    ,
                    po.copy = function(v, w) {
                        return v[0] = w[0],
                        v[1] = w[1],
                        v
                    }
                    ,
                    po.set = function(v, w, C) {
                        return v[0] = w,
                        v[1] = C,
                        v
                    }
                    ,
                    po.add = function(v, w, C) {
                        return v[0] = w[0] + C[0],
                        v[1] = w[1] + C[1],
                        v
                    }
                    ,
                    po.subtract = u,
                    po.multiply = l,
                    po.divide = p,
                    po.ceil = function(v, w) {
                        return v[0] = Math.ceil(w[0]),
                        v[1] = Math.ceil(w[1]),
                        v
                    }
                    ,
                    po.floor = function(v, w) {
                        return v[0] = Math.floor(w[0]),
                        v[1] = Math.floor(w[1]),
                        v
                    }
                    ,
                    po.min = function(v, w, C) {
                        return v[0] = Math.min(w[0], C[0]),
                        v[1] = Math.min(w[1], C[1]),
                        v
                    }
                    ,
                    po.max = function(v, w, C) {
                        return v[0] = Math.max(w[0], C[0]),
                        v[1] = Math.max(w[1], C[1]),
                        v
                    }
                    ,
                    po.round = function(v, w) {
                        return v[0] = Math.round(w[0]),
                        v[1] = Math.round(w[1]),
                        v
                    }
                    ,
                    po.scale = function(v, w, C) {
                        return v[0] = w[0] * C,
                        v[1] = w[1] * C,
                        v
                    }
                    ,
                    po.scaleAndAdd = function(v, w, C, A) {
                        return v[0] = w[0] + C[0] * A,
                        v[1] = w[1] + C[1] * A,
                        v
                    }
                    ,
                    po.distance = g,
                    po.squaredDistance = x,
                    po.length = T,
                    po.squaredLength = f,
                    po.negate = function(v, w) {
                        return v[0] = -w[0],
                        v[1] = -w[1],
                        v
                    }
                    ,
                    po.inverse = function(v, w) {
                        return v[0] = 1 / w[0],
                        v[1] = 1 / w[1],
                        v
                    }
                    ,
                    po.normalize = function(v, w) {
                        var C = w[0]
                          , A = w[1]
                          , O = C * C + A * A;
                        return O > 0 && (O = 1 / Math.sqrt(O)),
                        v[0] = w[0] * O,
                        v[1] = w[1] * O,
                        v
                    }
                    ,
                    po.dot = function(v, w) {
                        return v[0] * w[0] + v[1] * w[1]
                    }
                    ,
                    po.cross = function(v, w, C) {
                        var A = w[0] * C[1] - w[1] * C[0];
                        return v[0] = v[1] = 0,
                        v[2] = A,
                        v
                    }
                    ,
                    po.lerp = function(v, w, C, A) {
                        var O = w[0]
                          , F = w[1];
                        return v[0] = O + A * (C[0] - O),
                        v[1] = F + A * (C[1] - F),
                        v
                    }
                    ,
                    po.random = function(v, w) {
                        w = w || 1;
                        var C = 2 * e.RANDOM() * Math.PI;
                        return v[0] = Math.cos(C) * w,
                        v[1] = Math.sin(C) * w,
                        v
                    }
                    ,
                    po.transformMat2 = function(v, w, C) {
                        var A = w[0]
                          , O = w[1];
                        return v[0] = C[0] * A + C[2] * O,
                        v[1] = C[1] * A + C[3] * O,
                        v
                    }
                    ,
                    po.transformMat2d = function(v, w, C) {
                        var A = w[0]
                          , O = w[1];
                        return v[0] = C[0] * A + C[2] * O + C[4],
                        v[1] = C[1] * A + C[3] * O + C[5],
                        v
                    }
                    ,
                    po.transformMat3 = function(v, w, C) {
                        var A = w[0]
                          , O = w[1];
                        return v[0] = C[0] * A + C[3] * O + C[6],
                        v[1] = C[1] * A + C[4] * O + C[7],
                        v
                    }
                    ,
                    po.transformMat4 = function(v, w, C) {
                        var A = w[0]
                          , O = w[1];
                        return v[0] = C[0] * A + C[4] * O + C[12],
                        v[1] = C[1] * A + C[5] * O + C[13],
                        v
                    }
                    ,
                    po.rotate = function(v, w, C, A) {
                        var O = w[0] - C[0]
                          , F = w[1] - C[1]
                          , z = Math.sin(A)
                          , L = Math.cos(A);
                        return v[0] = O * L - F * z + C[0],
                        v[1] = O * z + F * L + C[1],
                        v
                    }
                    ,
                    po.angle = function(v, w) {
                        var C = v[0]
                          , A = v[1]
                          , O = w[0]
                          , F = w[1]
                          , z = Math.sqrt(C * C + A * A) * Math.sqrt(O * O + F * F);
                        return Math.acos(Math.min(Math.max(z && (C * O + A * F) / z, -1), 1))
                    }
                    ,
                    po.zero = function(v) {
                        return v[0] = 0,
                        v[1] = 0,
                        v
                    }
                    ,
                    po.str = function(v) {
                        return "vec2(" + v[0] + ", " + v[1] + ")"
                    }
                    ,
                    po.exactEquals = function(v, w) {
                        return v[0] === w[0] && v[1] === w[1]
                    }
                    ,
                    po.equals = function(v, w) {
                        var C = v[0]
                          , A = v[1]
                          , O = w[0]
                          , F = w[1];
                        return Math.abs(C - O) <= e.EPSILON * Math.max(1, Math.abs(C), Math.abs(O)) && Math.abs(A - F) <= e.EPSILON * Math.max(1, Math.abs(A), Math.abs(F))
                    }
                    ,
                    po.forEach = po.sqrLen = po.sqrDist = po.dist = po.div = po.mul = po.sub = po.len = void 0;
                    var e = function(v) {
                        if (v && v.__esModule)
                            return v;
                        if (null === v || "object" !== n(v) && "function" != typeof v)
                            return {
                                default: v
                            };
                        var C = o(void 0);
                        if (C && C.has(v))
                            return C.get(v);
                        var A = {}
                          , O = Object.defineProperty && Object.getOwnPropertyDescriptor;
                        for (var F in v)
                            if ("default" !== F && Object.prototype.hasOwnProperty.call(v, F)) {
                                var z = O ? Object.getOwnPropertyDescriptor(v, F) : null;
                                z && (z.get || z.set) ? Object.defineProperty(A, F, z) : A[F] = v[F]
                            }
                        return A.default = v,
                        C && C.set(v, A),
                        A
                    }(Me());
                    function o(v) {
                        if ("function" != typeof WeakMap)
                            return null;
                        var w = new WeakMap
                          , C = new WeakMap;
                        return (o = function(A) {
                            return A ? C : w
                        }
                        )(v)
                    }
                    function a() {
                        var v = new e.ARRAY_TYPE(2);
                        return e.ARRAY_TYPE != Float32Array && (v[0] = 0,
                        v[1] = 0),
                        v
                    }
                    function u(v, w, C) {
                        return v[0] = w[0] - C[0],
                        v[1] = w[1] - C[1],
                        v
                    }
                    function l(v, w, C) {
                        return v[0] = w[0] * C[0],
                        v[1] = w[1] * C[1],
                        v
                    }
                    function p(v, w, C) {
                        return v[0] = w[0] / C[0],
                        v[1] = w[1] / C[1],
                        v
                    }
                    function g(v, w) {
                        return Math.hypot(w[0] - v[0], w[1] - v[1])
                    }
                    function x(v, w) {
                        var C = w[0] - v[0]
                          , A = w[1] - v[1];
                        return C * C + A * A
                    }
                    function T(v) {
                        return Math.hypot(v[0], v[1])
                    }
                    function f(v) {
                        var w = v[0]
                          , C = v[1];
                        return w * w + C * C
                    }
                    po.len = T,
                    po.sub = u,
                    po.mul = l,
                    po.div = p,
                    po.dist = g,
                    po.sqrDist = x,
                    po.sqrLen = f;
                    var b, P = (b = a(),
                    function(v, w, C, A, O, F) {
                        var z, L;
                        for (w || (w = 2),
                        C || (C = 0),
                        L = A ? Math.min(A * w + C, v.length) : v.length,
                        z = C; z < L; z += w)
                            b[0] = v[z],
                            b[1] = v[z + 1],
                            O(b, b, F),
                            v[z] = b[0],
                            v[z + 1] = b[1];
                        return v
                    }
                    );
                    return po.forEach = P,
                    po
                }
                var At, Re, ve, ne, B = function Kt() {
                    if (Jt)
                        return _t;
                    function n(v) {
                        return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(w) {
                            return typeof w
                        }
                        : function(w) {
                            return w && "function" == typeof Symbol && w.constructor === Symbol && w !== Symbol.prototype ? "symbol" : typeof w
                        }
                        )(v)
                    }
                    Jt = 1,
                    Object.defineProperty(_t, "__esModule", {
                        value: !0
                    }),
                    _t.vec4 = _t.vec3 = _t.vec2 = _t.quat2 = _t.quat = _t.mat4 = _t.mat3 = _t.mat2d = _t.mat2 = _t.glMatrix = void 0;
                    var e = P(Me());
                    _t.glMatrix = e;
                    var o = P(Qe());
                    _t.mat2 = o;
                    var a = P(Ce());
                    _t.mat2d = a;
                    var u = P(re());
                    _t.mat3 = u;
                    var l = P(ze());
                    _t.mat4 = l;
                    var p = P(no());
                    _t.quat = p;
                    var g = P(function Ft() {
                        if (Co)
                            return Lt;
                        function n(P) {
                            return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(v) {
                                return typeof v
                            }
                            : function(v) {
                                return v && "function" == typeof Symbol && v.constructor === Symbol && v !== Symbol.prototype ? "symbol" : typeof v
                            }
                            )(P)
                        }
                        Co = 1,
                        Object.defineProperty(Lt, "__esModule", {
                            value: !0
                        }),
                        Lt.create = function() {
                            var P = new e.ARRAY_TYPE(8);
                            return e.ARRAY_TYPE != Float32Array && (P[0] = 0,
                            P[1] = 0,
                            P[2] = 0,
                            P[4] = 0,
                            P[5] = 0,
                            P[6] = 0,
                            P[7] = 0),
                            P[3] = 1,
                            P
                        }
                        ,
                        Lt.clone = function(P) {
                            var v = new e.ARRAY_TYPE(8);
                            return v[0] = P[0],
                            v[1] = P[1],
                            v[2] = P[2],
                            v[3] = P[3],
                            v[4] = P[4],
                            v[5] = P[5],
                            v[6] = P[6],
                            v[7] = P[7],
                            v
                        }
                        ,
                        Lt.fromValues = function(P, v, w, C, A, O, F, z) {
                            var L = new e.ARRAY_TYPE(8);
                            return L[0] = P,
                            L[1] = v,
                            L[2] = w,
                            L[3] = C,
                            L[4] = A,
                            L[5] = O,
                            L[6] = F,
                            L[7] = z,
                            L
                        }
                        ,
                        Lt.fromRotationTranslationValues = function(P, v, w, C, A, O, F) {
                            var z = new e.ARRAY_TYPE(8);
                            z[0] = P,
                            z[1] = v,
                            z[2] = w,
                            z[3] = C;
                            var L = .5 * A
                              , N = .5 * O
                              , G = .5 * F;
                            return z[4] = L * C + N * w - G * v,
                            z[5] = N * C + G * P - L * w,
                            z[6] = G * C + L * v - N * P,
                            z[7] = -L * P - N * v - G * w,
                            z
                        }
                        ,
                        Lt.fromRotationTranslation = p,
                        Lt.fromTranslation = function(P, v) {
                            return P[0] = 0,
                            P[1] = 0,
                            P[2] = 0,
                            P[3] = 1,
                            P[4] = .5 * v[0],
                            P[5] = .5 * v[1],
                            P[6] = .5 * v[2],
                            P[7] = 0,
                            P
                        }
                        ,
                        Lt.fromRotation = function(P, v) {
                            return P[0] = v[0],
                            P[1] = v[1],
                            P[2] = v[2],
                            P[3] = v[3],
                            P[4] = 0,
                            P[5] = 0,
                            P[6] = 0,
                            P[7] = 0,
                            P
                        }
                        ,
                        Lt.fromMat4 = function(P, v) {
                            var w = o.create();
                            a.getRotation(w, v);
                            var C = new e.ARRAY_TYPE(3);
                            return a.getTranslation(C, v),
                            p(P, w, C),
                            P
                        }
                        ,
                        Lt.copy = g,
                        Lt.identity = function(P) {
                            return P[0] = 0,
                            P[1] = 0,
                            P[2] = 0,
                            P[3] = 1,
                            P[4] = 0,
                            P[5] = 0,
                            P[6] = 0,
                            P[7] = 0,
                            P
                        }
                        ,
                        Lt.set = function(P, v, w, C, A, O, F, z, L) {
                            return P[0] = v,
                            P[1] = w,
                            P[2] = C,
                            P[3] = A,
                            P[4] = O,
                            P[5] = F,
                            P[6] = z,
                            P[7] = L,
                            P
                        }
                        ,
                        Lt.getDual = function(P, v) {
                            return P[0] = v[4],
                            P[1] = v[5],
                            P[2] = v[6],
                            P[3] = v[7],
                            P
                        }
                        ,
                        Lt.setDual = function(P, v) {
                            return P[4] = v[0],
                            P[5] = v[1],
                            P[6] = v[2],
                            P[7] = v[3],
                            P
                        }
                        ,
                        Lt.getTranslation = function(P, v) {
                            var w = v[4]
                              , C = v[5]
                              , A = v[6]
                              , O = v[7]
                              , F = -v[0]
                              , z = -v[1]
                              , L = -v[2]
                              , N = v[3];
                            return P[0] = 2 * (w * N + O * F + C * L - A * z),
                            P[1] = 2 * (C * N + O * z + A * F - w * L),
                            P[2] = 2 * (A * N + O * L + w * z - C * F),
                            P
                        }
                        ,
                        Lt.translate = function(P, v, w) {
                            var C = v[0]
                              , A = v[1]
                              , O = v[2]
                              , F = v[3]
                              , z = .5 * w[0]
                              , L = .5 * w[1]
                              , N = .5 * w[2]
                              , G = v[4]
                              , X = v[5]
                              , _e = v[6]
                              , me = v[7];
                            return P[0] = C,
                            P[1] = A,
                            P[2] = O,
                            P[3] = F,
                            P[4] = F * z + A * N - O * L + G,
                            P[5] = F * L + O * z - C * N + X,
                            P[6] = F * N + C * L - A * z + _e,
                            P[7] = -C * z - A * L - O * N + me,
                            P
                        }
                        ,
                        Lt.rotateX = function(P, v, w) {
                            var C = -v[0]
                              , A = -v[1]
                              , O = -v[2]
                              , F = v[3]
                              , z = v[4]
                              , L = v[5]
                              , N = v[6]
                              , G = v[7]
                              , X = z * F + G * C + L * O - N * A
                              , _e = L * F + G * A + N * C - z * O
                              , me = N * F + G * O + z * A - L * C
                              , pe = G * F - z * C - L * A - N * O;
                            return o.rotateX(P, v, w),
                            P[4] = X * (F = P[3]) + pe * (C = P[0]) + _e * (O = P[2]) - me * (A = P[1]),
                            P[5] = _e * F + pe * A + me * C - X * O,
                            P[6] = me * F + pe * O + X * A - _e * C,
                            P[7] = pe * F - X * C - _e * A - me * O,
                            P
                        }
                        ,
                        Lt.rotateY = function(P, v, w) {
                            var C = -v[0]
                              , A = -v[1]
                              , O = -v[2]
                              , F = v[3]
                              , z = v[4]
                              , L = v[5]
                              , N = v[6]
                              , G = v[7]
                              , X = z * F + G * C + L * O - N * A
                              , _e = L * F + G * A + N * C - z * O
                              , me = N * F + G * O + z * A - L * C
                              , pe = G * F - z * C - L * A - N * O;
                            return o.rotateY(P, v, w),
                            P[4] = X * (F = P[3]) + pe * (C = P[0]) + _e * (O = P[2]) - me * (A = P[1]),
                            P[5] = _e * F + pe * A + me * C - X * O,
                            P[6] = me * F + pe * O + X * A - _e * C,
                            P[7] = pe * F - X * C - _e * A - me * O,
                            P
                        }
                        ,
                        Lt.rotateZ = function(P, v, w) {
                            var C = -v[0]
                              , A = -v[1]
                              , O = -v[2]
                              , F = v[3]
                              , z = v[4]
                              , L = v[5]
                              , N = v[6]
                              , G = v[7]
                              , X = z * F + G * C + L * O - N * A
                              , _e = L * F + G * A + N * C - z * O
                              , me = N * F + G * O + z * A - L * C
                              , pe = G * F - z * C - L * A - N * O;
                            return o.rotateZ(P, v, w),
                            P[4] = X * (F = P[3]) + pe * (C = P[0]) + _e * (O = P[2]) - me * (A = P[1]),
                            P[5] = _e * F + pe * A + me * C - X * O,
                            P[6] = me * F + pe * O + X * A - _e * C,
                            P[7] = pe * F - X * C - _e * A - me * O,
                            P
                        }
                        ,
                        Lt.rotateByQuatAppend = function(P, v, w) {
                            var C = w[0]
                              , A = w[1]
                              , O = w[2]
                              , F = w[3]
                              , z = v[0]
                              , L = v[1]
                              , N = v[2]
                              , G = v[3];
                            return P[0] = z * F + G * C + L * O - N * A,
                            P[1] = L * F + G * A + N * C - z * O,
                            P[2] = N * F + G * O + z * A - L * C,
                            P[3] = G * F - z * C - L * A - N * O,
                            P[4] = (z = v[4]) * F + (G = v[7]) * C + (L = v[5]) * O - (N = v[6]) * A,
                            P[5] = L * F + G * A + N * C - z * O,
                            P[6] = N * F + G * O + z * A - L * C,
                            P[7] = G * F - z * C - L * A - N * O,
                            P
                        }
                        ,
                        Lt.rotateByQuatPrepend = function(P, v, w) {
                            var C = v[0]
                              , A = v[1]
                              , O = v[2]
                              , F = v[3]
                              , z = w[0]
                              , L = w[1]
                              , N = w[2]
                              , G = w[3];
                            return P[0] = C * G + F * z + A * N - O * L,
                            P[1] = A * G + F * L + O * z - C * N,
                            P[2] = O * G + F * N + C * L - A * z,
                            P[3] = F * G - C * z - A * L - O * N,
                            P[4] = C * (G = w[7]) + F * (z = w[4]) + A * (N = w[6]) - O * (L = w[5]),
                            P[5] = A * G + F * L + O * z - C * N,
                            P[6] = O * G + F * N + C * L - A * z,
                            P[7] = F * G - C * z - A * L - O * N,
                            P
                        }
                        ,
                        Lt.rotateAroundAxis = function(P, v, w, C) {
                            if (Math.abs(C) < e.EPSILON)
                                return g(P, v);
                            var A = Math.hypot(w[0], w[1], w[2]);
                            C *= .5;
                            var O = Math.sin(C)
                              , F = O * w[0] / A
                              , z = O * w[1] / A
                              , L = O * w[2] / A
                              , N = Math.cos(C)
                              , G = v[0]
                              , X = v[1]
                              , _e = v[2]
                              , me = v[3];
                            P[0] = G * N + me * F + X * L - _e * z,
                            P[1] = X * N + me * z + _e * F - G * L,
                            P[2] = _e * N + me * L + G * z - X * F,
                            P[3] = me * N - G * F - X * z - _e * L;
                            var pe = v[4]
                              , Ne = v[5]
                              , Pe = v[6]
                              , $e = v[7];
                            return P[4] = pe * N + $e * F + Ne * L - Pe * z,
                            P[5] = Ne * N + $e * z + Pe * F - pe * L,
                            P[6] = Pe * N + $e * L + pe * z - Ne * F,
                            P[7] = $e * N - pe * F - Ne * z - Pe * L,
                            P
                        }
                        ,
                        Lt.add = function(P, v, w) {
                            return P[0] = v[0] + w[0],
                            P[1] = v[1] + w[1],
                            P[2] = v[2] + w[2],
                            P[3] = v[3] + w[3],
                            P[4] = v[4] + w[4],
                            P[5] = v[5] + w[5],
                            P[6] = v[6] + w[6],
                            P[7] = v[7] + w[7],
                            P
                        }
                        ,
                        Lt.multiply = x,
                        Lt.scale = function(P, v, w) {
                            return P[0] = v[0] * w,
                            P[1] = v[1] * w,
                            P[2] = v[2] * w,
                            P[3] = v[3] * w,
                            P[4] = v[4] * w,
                            P[5] = v[5] * w,
                            P[6] = v[6] * w,
                            P[7] = v[7] * w,
                            P
                        }
                        ,
                        Lt.lerp = function(P, v, w, C) {
                            var A = 1 - C;
                            return T(v, w) < 0 && (C = -C),
                            P[0] = v[0] * A + w[0] * C,
                            P[1] = v[1] * A + w[1] * C,
                            P[2] = v[2] * A + w[2] * C,
                            P[3] = v[3] * A + w[3] * C,
                            P[4] = v[4] * A + w[4] * C,
                            P[5] = v[5] * A + w[5] * C,
                            P[6] = v[6] * A + w[6] * C,
                            P[7] = v[7] * A + w[7] * C,
                            P
                        }
                        ,
                        Lt.invert = function(P, v) {
                            var w = b(v);
                            return P[0] = -v[0] / w,
                            P[1] = -v[1] / w,
                            P[2] = -v[2] / w,
                            P[3] = v[3] / w,
                            P[4] = -v[4] / w,
                            P[5] = -v[5] / w,
                            P[6] = -v[6] / w,
                            P[7] = v[7] / w,
                            P
                        }
                        ,
                        Lt.conjugate = function(P, v) {
                            return P[0] = -v[0],
                            P[1] = -v[1],
                            P[2] = -v[2],
                            P[3] = v[3],
                            P[4] = -v[4],
                            P[5] = -v[5],
                            P[6] = -v[6],
                            P[7] = v[7],
                            P
                        }
                        ,
                        Lt.normalize = function(P, v) {
                            var w = b(v);
                            if (w > 0) {
                                w = Math.sqrt(w);
                                var C = v[0] / w
                                  , A = v[1] / w
                                  , O = v[2] / w
                                  , F = v[3] / w
                                  , z = v[4]
                                  , L = v[5]
                                  , N = v[6]
                                  , G = v[7]
                                  , X = C * z + A * L + O * N + F * G;
                                P[0] = C,
                                P[1] = A,
                                P[2] = O,
                                P[3] = F,
                                P[4] = (z - C * X) / w,
                                P[5] = (L - A * X) / w,
                                P[6] = (N - O * X) / w,
                                P[7] = (G - F * X) / w
                            }
                            return P
                        }
                        ,
                        Lt.str = function(P) {
                            return "quat2(" + P[0] + ", " + P[1] + ", " + P[2] + ", " + P[3] + ", " + P[4] + ", " + P[5] + ", " + P[6] + ", " + P[7] + ")"
                        }
                        ,
                        Lt.exactEquals = function(P, v) {
                            return P[0] === v[0] && P[1] === v[1] && P[2] === v[2] && P[3] === v[3] && P[4] === v[4] && P[5] === v[5] && P[6] === v[6] && P[7] === v[7]
                        }
                        ,
                        Lt.equals = function(P, v) {
                            var w = P[0]
                              , C = P[1]
                              , A = P[2]
                              , O = P[3]
                              , F = P[4]
                              , z = P[5]
                              , L = P[6]
                              , N = P[7]
                              , G = v[0]
                              , X = v[1]
                              , _e = v[2]
                              , me = v[3]
                              , pe = v[4]
                              , Ne = v[5]
                              , Pe = v[6]
                              , $e = v[7];
                            return Math.abs(w - G) <= e.EPSILON * Math.max(1, Math.abs(w), Math.abs(G)) && Math.abs(C - X) <= e.EPSILON * Math.max(1, Math.abs(C), Math.abs(X)) && Math.abs(A - _e) <= e.EPSILON * Math.max(1, Math.abs(A), Math.abs(_e)) && Math.abs(O - me) <= e.EPSILON * Math.max(1, Math.abs(O), Math.abs(me)) && Math.abs(F - pe) <= e.EPSILON * Math.max(1, Math.abs(F), Math.abs(pe)) && Math.abs(z - Ne) <= e.EPSILON * Math.max(1, Math.abs(z), Math.abs(Ne)) && Math.abs(L - Pe) <= e.EPSILON * Math.max(1, Math.abs(L), Math.abs(Pe)) && Math.abs(N - $e) <= e.EPSILON * Math.max(1, Math.abs(N), Math.abs($e))
                        }
                        ,
                        Lt.sqrLen = Lt.squaredLength = Lt.len = Lt.length = Lt.dot = Lt.mul = Lt.setReal = Lt.getReal = void 0;
                        var e = l(Me())
                          , o = l(no())
                          , a = l(ze());
                        function u(P) {
                            if ("function" != typeof WeakMap)
                                return null;
                            var v = new WeakMap
                              , w = new WeakMap;
                            return (u = function(C) {
                                return C ? w : v
                            }
                            )(P)
                        }
                        function l(P, v) {
                            if (P && P.__esModule)
                                return P;
                            if (null === P || "object" !== n(P) && "function" != typeof P)
                                return {
                                    default: P
                                };
                            var w = u(v);
                            if (w && w.has(P))
                                return w.get(P);
                            var C = {}
                              , A = Object.defineProperty && Object.getOwnPropertyDescriptor;
                            for (var O in P)
                                if ("default" !== O && Object.prototype.hasOwnProperty.call(P, O)) {
                                    var F = A ? Object.getOwnPropertyDescriptor(P, O) : null;
                                    F && (F.get || F.set) ? Object.defineProperty(C, O, F) : C[O] = P[O]
                                }
                            return C.default = P,
                            w && w.set(P, C),
                            C
                        }
                        function p(P, v, w) {
                            var C = .5 * w[0]
                              , A = .5 * w[1]
                              , O = .5 * w[2]
                              , F = v[0]
                              , z = v[1]
                              , L = v[2]
                              , N = v[3];
                            return P[0] = F,
                            P[1] = z,
                            P[2] = L,
                            P[3] = N,
                            P[4] = C * N + A * L - O * z,
                            P[5] = A * N + O * F - C * L,
                            P[6] = O * N + C * z - A * F,
                            P[7] = -C * F - A * z - O * L,
                            P
                        }
                        function g(P, v) {
                            return P[0] = v[0],
                            P[1] = v[1],
                            P[2] = v[2],
                            P[3] = v[3],
                            P[4] = v[4],
                            P[5] = v[5],
                            P[6] = v[6],
                            P[7] = v[7],
                            P
                        }
                        function x(P, v, w) {
                            var C = v[0]
                              , A = v[1]
                              , O = v[2]
                              , F = v[3]
                              , z = w[4]
                              , L = w[5]
                              , N = w[6]
                              , G = w[7]
                              , X = v[4]
                              , _e = v[5]
                              , me = v[6]
                              , pe = v[7]
                              , Ne = w[0]
                              , Pe = w[1]
                              , $e = w[2]
                              , We = w[3];
                            return P[0] = C * We + F * Ne + A * $e - O * Pe,
                            P[1] = A * We + F * Pe + O * Ne - C * $e,
                            P[2] = O * We + F * $e + C * Pe - A * Ne,
                            P[3] = F * We - C * Ne - A * Pe - O * $e,
                            P[4] = C * G + F * z + A * N - O * L + X * We + pe * Ne + _e * $e - me * Pe,
                            P[5] = A * G + F * L + O * z - C * N + _e * We + pe * Pe + me * Ne - X * $e,
                            P[6] = O * G + F * N + C * L - A * z + me * We + pe * $e + X * Pe - _e * Ne,
                            P[7] = F * G - C * z - A * L - O * N + pe * We - X * Ne - _e * Pe - me * $e,
                            P
                        }
                        Lt.getReal = o.copy,
                        Lt.setReal = o.copy,
                        Lt.mul = x;
                        var T = o.dot;
                        Lt.dot = T;
                        var f = o.length;
                        Lt.length = f,
                        Lt.len = f;
                        var b = o.squaredLength;
                        return Lt.squaredLength = b,
                        Lt.sqrLen = b,
                        Lt
                    }());
                    _t.quat2 = g;
                    var x = P(Et());
                    _t.vec2 = x;
                    var T = P(gt());
                    _t.vec3 = T;
                    var f = P(mo());
                    function b(v) {
                        if ("function" != typeof WeakMap)
                            return null;
                        var w = new WeakMap
                          , C = new WeakMap;
                        return (b = function(A) {
                            return A ? C : w
                        }
                        )(v)
                    }
                    function P(v, w) {
                        if (v && v.__esModule)
                            return v;
                        if (null === v || "object" !== n(v) && "function" != typeof v)
                            return {
                                default: v
                            };
                        var C = b(w);
                        if (C && C.has(v))
                            return C.get(v);
                        var A = {}
                          , O = Object.defineProperty && Object.getOwnPropertyDescriptor;
                        for (var F in v)
                            if ("default" !== F && Object.prototype.hasOwnProperty.call(v, F)) {
                                var z = O ? Object.getOwnPropertyDescriptor(v, F) : null;
                                z && (z.get || z.set) ? Object.defineProperty(A, F, z) : A[F] = v[F]
                            }
                        return A.default = v,
                        C && C.set(v, A),
                        A
                    }
                    return _t.vec4 = f,
                    _t
                }(), de = function() {
                    if (Re)
                        return At;
                    function n(e, o, a, u) {
                        this.cx = 3 * e,
                        this.bx = 3 * (a - e) - this.cx,
                        this.ax = 1 - this.cx - this.bx,
                        this.cy = 3 * o,
                        this.by = 3 * (u - o) - this.cy,
                        this.ay = 1 - this.cy - this.by,
                        this.p1x = e,
                        this.p1y = o,
                        this.p2x = a,
                        this.p2y = u
                    }
                    return Re = 1,
                    At = n,
                    n.prototype = {
                        sampleCurveX: function(e) {
                            return ((this.ax * e + this.bx) * e + this.cx) * e
                        },
                        sampleCurveY: function(e) {
                            return ((this.ay * e + this.by) * e + this.cy) * e
                        },
                        sampleCurveDerivativeX: function(e) {
                            return (3 * this.ax * e + 2 * this.bx) * e + this.cx
                        },
                        solveCurveX: function(e, o) {
                            if (void 0 === o && (o = 1e-6),
                            e < 0)
                                return 0;
                            if (e > 1)
                                return 1;
                            for (var a = e, u = 0; u < 8; u++) {
                                var l = this.sampleCurveX(a) - e;
                                if (Math.abs(l) < o)
                                    return a;
                                var p = this.sampleCurveDerivativeX(a);
                                if (Math.abs(p) < 1e-6)
                                    break;
                                a -= l / p
                            }
                            var g = 0
                              , x = 1;
                            for (a = e,
                            u = 0; u < 20 && (l = this.sampleCurveX(a),
                            !(Math.abs(l - e) < o)); u++)
                                e > l ? g = a : x = a,
                                a = .5 * (x - g) + g;
                            return a
                        },
                        solve: function(e, o) {
                            return this.sampleCurveY(this.solveCurveX(e, o))
                        }
                    },
                    At
                }(), lt = so(de);
                function St() {
                    if (ne)
                        return ve;
                    function n(e, o) {
                        this.x = e,
                        this.y = o
                    }
                    return ne = 1,
                    ve = n,
                    n.prototype = {
                        clone: function() {
                            return new n(this.x,this.y)
                        },
                        add: function(e) {
                            return this.clone()._add(e)
                        },
                        sub: function(e) {
                            return this.clone()._sub(e)
                        },
                        multByPoint: function(e) {
                            return this.clone()._multByPoint(e)
                        },
                        divByPoint: function(e) {
                            return this.clone()._divByPoint(e)
                        },
                        mult: function(e) {
                            return this.clone()._mult(e)
                        },
                        div: function(e) {
                            return this.clone()._div(e)
                        },
                        rotate: function(e) {
                            return this.clone()._rotate(e)
                        },
                        rotateAround: function(e, o) {
                            return this.clone()._rotateAround(e, o)
                        },
                        matMult: function(e) {
                            return this.clone()._matMult(e)
                        },
                        unit: function() {
                            return this.clone()._unit()
                        },
                        perp: function() {
                            return this.clone()._perp()
                        },
                        round: function() {
                            return this.clone()._round()
                        },
                        mag: function() {
                            return Math.sqrt(this.x * this.x + this.y * this.y)
                        },
                        equals: function(e) {
                            return this.x === e.x && this.y === e.y
                        },
                        dist: function(e) {
                            return Math.sqrt(this.distSqr(e))
                        },
                        distSqr: function(e) {
                            var o = e.x - this.x
                              , a = e.y - this.y;
                            return o * o + a * a
                        },
                        angle: function() {
                            return Math.atan2(this.y, this.x)
                        },
                        angleTo: function(e) {
                            return Math.atan2(this.y - e.y, this.x - e.x)
                        },
                        angleWith: function(e) {
                            return this.angleWithSep(e.x, e.y)
                        },
                        angleWithSep: function(e, o) {
                            return Math.atan2(this.x * o - this.y * e, this.x * e + this.y * o)
                        },
                        _matMult: function(e) {
                            var o = e[2] * this.x + e[3] * this.y;
                            return this.x = e[0] * this.x + e[1] * this.y,
                            this.y = o,
                            this
                        },
                        _add: function(e) {
                            return this.x += e.x,
                            this.y += e.y,
                            this
                        },
                        _sub: function(e) {
                            return this.x -= e.x,
                            this.y -= e.y,
                            this
                        },
                        _mult: function(e) {
                            return this.x *= e,
                            this.y *= e,
                            this
                        },
                        _div: function(e) {
                            return this.x /= e,
                            this.y /= e,
                            this
                        },
                        _multByPoint: function(e) {
                            return this.x *= e.x,
                            this.y *= e.y,
                            this
                        },
                        _divByPoint: function(e) {
                            return this.x /= e.x,
                            this.y /= e.y,
                            this
                        },
                        _unit: function() {
                            return this._div(this.mag()),
                            this
                        },
                        _perp: function() {
                            var e = this.y;
                            return this.y = this.x,
                            this.x = -e,
                            this
                        },
                        _rotate: function(e) {
                            var o = Math.cos(e)
                              , a = Math.sin(e)
                              , u = a * this.x + o * this.y;
                            return this.x = o * this.x - a * this.y,
                            this.y = u,
                            this
                        },
                        _rotateAround: function(e, o) {
                            var a = Math.cos(e)
                              , u = Math.sin(e)
                              , l = o.y + u * (this.x - o.x) + a * (this.y - o.y);
                            return this.x = o.x + a * (this.x - o.x) - u * (this.y - o.y),
                            this.y = l,
                            this
                        },
                        _round: function() {
                            return this.x = Math.round(this.x),
                            this.y = Math.round(this.y),
                            this
                        }
                    },
                    n.convert = function(e) {
                        return e instanceof n ? e : Array.isArray(e) ? new n(e[0],e[1]) : e
                    }
                    ,
                    ve
                }
                var tt = so(St());
                function $t(n, e) {
                    if (Array.isArray(n)) {
                        if (!Array.isArray(e) || n.length !== e.length)
                            return !1;
                        for (let o = 0; o < n.length; o++)
                            if (!$t(n[o], e[o]))
                                return !1;
                        return !0
                    }
                    if ("object" == typeof n && null !== n && null !== e) {
                        if ("object" != typeof e || Object.keys(n).length !== Object.keys(e).length)
                            return !1;
                        for (const o in n)
                            if (!$t(n[o], e[o]))
                                return !1;
                        return !0
                    }
                    return n === e
                }
                const Nt = Math.PI / 180
                  , Vt = 180 / Math.PI;
                function _o(n) {
                    return n * Nt
                }
                function Lo(n) {
                    return n * Vt
                }
                const ao = [[0, 0], [1, 0], [1, 1], [0, 1]];
                function bt(n) {
                    if (n <= 0)
                        return 0;
                    if (n >= 1)
                        return 1;
                    const e = n * n
                      , o = e * n;
                    return 4 * (n < .5 ? o : 3 * (n - e) + o - .75)
                }
                function Do(n, e, o, a) {
                    const u = new lt(n,e,o,a);
                    return function(l) {
                        return u.solve(l)
                    }
                }
                const Xt = Do(.25, .1, .25, 1);
                function ie(n, e, o) {
                    return Math.min(o, Math.max(e, n))
                }
                function we(n, e, o) {
                    return (o = ie((o - n) / (e - n), 0, 1)) * o * (3 - 2 * o)
                }
                function Oe(n, e, o) {
                    const a = o - e
                      , u = ((n - e) % a + a) % a + e;
                    return u === e ? o : u
                }
                function ee(n, e, o) {
                    if (!n.length)
                        return o(null, []);
                    let a = n.length;
                    const u = new Array(n.length);
                    let l = null;
                    n.forEach( (p, g) => {
                        e(p, (x, T) => {
                            x && (l = x),
                            u[g] = T,
                            0 == --a && o(l, u)
                        }
                        )
                    }
                    )
                }
                function W(n, ...e) {
                    for (const o of e)
                        for (const a in o)
                            n[a] = o[a];
                    return n
                }
                let ae = 1;
                function Ve() {
                    return ae++
                }
                function fe(n) {
                    return n <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
                }
                function Pt(n, e) {
                    n.forEach(o => {
                        e[o] && (e[o] = e[o].bind(e))
                    }
                    )
                }
                function mt(n, e) {
                    return -1 !== n.indexOf(e, n.length - e.length)
                }
                function xo(n, e, o) {
                    const a = {};
                    for (const u in n)
                        a[u] = e.call(this, n[u], u, n);
                    return a
                }
                function So(n, e, o) {
                    const a = {};
                    for (const u in n)
                        e.call(this, n[u], u, n) && (a[u] = n[u]);
                    return a
                }
                function ro(n) {
                    return Array.isArray(n) ? n.map(ro) : "object" == typeof n && n ? xo(n, ro) : n
                }
                const Vo = {};
                function vo(n) {
                    Vo[n] || (typeof console < "u" && console.warn(n),
                    Vo[n] = !0)
                }
                function ei(n, e, o) {
                    return (o.y - n.y) * (e.x - n.x) > (e.y - n.y) * (o.x - n.x)
                }
                function Ti(n) {
                    let e = 0;
                    for (let o, a, u = 0, l = n.length, p = l - 1; u < l; p = u++)
                        o = n[u],
                        a = n[p],
                        e += (a.x - o.x) * (o.y + a.y);
                    return e
                }
                function ci([n,e,o]) {
                    const a = _o(e + 90)
                      , u = _o(o);
                    return {
                        x: n * Math.cos(a) * Math.sin(u),
                        y: n * Math.sin(a) * Math.sin(u),
                        z: n * Math.cos(u),
                        azimuthal: e,
                        polar: o
                    }
                }
                function ji() {
                    return typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope
                }
                function yn(n) {
                    const e = {};
                    if (n.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (o, a, u, l) => {
                        const p = u || l;
                        return e[a] = !p || p.toLowerCase(),
                        ""
                    }
                    ),
                    e["max-age"]) {
                        const o = parseInt(e["max-age"], 10);
                        isNaN(o) ? delete e["max-age"] : e["max-age"] = o
                    }
                    return e
                }
                let Dr = null;
                function Ln(n, e) {
                    return [n[4 * e], n[4 * e + 1], n[4 * e + 2], n[4 * e + 3]]
                }
                function Lr(n, e, o, a) {
                    for (; e < o; ) {
                        const u = e + o >> 1;
                        n[u] < a ? e = u + 1 : o = u
                    }
                    return e
                }
                function xt(n, e, o, a) {
                    for (; e < o; ) {
                        const u = e + o >> 1;
                        n[u] <= a ? e = u + 1 : o = u
                    }
                    return e
                }
                function Z(n) {
                    return n > 0 ? 1 / (1.001 - n) : 1 + n
                }
                function se(n) {
                    return n > 0 ? 1 - 1 / (1.001 - n) : -n
                }
                const Ee = {
                    API_URL: "https://api.mapbox.com",
                    get API_URL_REGEX() {
                        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i
                    },
                    get API_TILEJSON_REGEX() {
                        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i
                    },
                    get API_SPRITE_REGEX() {
                        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i
                    },
                    get API_FONTS_REGEX() {
                        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i
                    },
                    get API_STYLE_REGEX() {
                        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i
                    },
                    get API_CDN_URL_REGEX() {
                        return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i
                    },
                    get EVENTS_URL() {
                        if (!Ee.API_URL)
                            return null;
                        try {
                            const n = new URL(Ee.API_URL);
                            return "api.mapbox.cn" === n.hostname ? "https://events.mapbox.cn/events/v2" : "api.mapbox.com" === n.hostname ? "https://events.mapbox.com/events/v2" : null
                        } catch {
                            return null
                        }
                    },
                    SESSION_PATH: "/map-sessions/v1",
                    FEEDBACK_URL: "https://apps.mapbox.com/feedback",
                    TILE_URL_VERSION: "v4",
                    RASTER_URL_PREFIX: "raster/v1",
                    RASTERARRAYS_URL_PREFIX: "rasterarrays/v1",
                    REQUIRE_ACCESS_TOKEN: !0,
                    ACCESS_TOKEN: null,
                    DEFAULT_STYLE: "mapbox://styles/mapbox/standard",
                    MAX_PARALLEL_IMAGE_REQUESTS: 16,
                    DRACO_URL: "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm",
                    MESHOPT_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm",
                    MESHOPT_SIMD_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm",
                    GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf",
                    TILES3D_URL_PREFIX: "3dtiles/v1"
                };
                function He(n) {
                    return Ee.API_URL_REGEX.test(n)
                }
                function oe(n) {
                    return Ee.API_SPRITE_REGEX.test(n)
                }
                let ue, J, q, le, Se, st;
                function Rt() {
                    return null == ue && (ue = self.OffscreenCanvas && new OffscreenCanvas(1,1).getContext("2d") && "function" == typeof self.createImageBitmap),
                    ue
                }
                const Qt = {
                    now: () => void 0 !== le ? le : performance.now(),
                    setNow(n) {
                        le = n
                    },
                    restoreNow() {
                        le = void 0
                    },
                    frame(n) {
                        const e = requestAnimationFrame(n);
                        return {
                            cancel: () => cancelAnimationFrame(e)
                        }
                    },
                    getImageData(n, e=0) {
                        const {width: o, height: a} = n;
                        Se || (Se = document.createElement("canvas"));
                        const u = Se.getContext("2d", {
                            willReadFrequently: !0
                        });
                        if (!u)
                            throw new Error("failed to create canvas 2d context");
                        return (o > Se.width || a > Se.height) && (Se.width = o,
                        Se.height = a),
                        u.clearRect(-e, -e, o + 2 * e, a + 2 * e),
                        u.drawImage(n, 0, 0, o, a),
                        u.getImageData(-e, -e, o + 2 * e, a + 2 * e)
                    },
                    resolveURL: n => (J || (J = document.createElement("a")),
                    J.href = n,
                    J.href),
                    get devicePixelRatio() {
                        return window.devicePixelRatio
                    },
                    get prefersReducedMotion() {
                        return !!window.matchMedia && (null == q && (q = window.matchMedia("(prefers-reduced-motion: reduce)")),
                        q.matches)
                    },
                    hasCanvasFingerprintNoise() {
                        if (void 0 !== st)
                            return st;
                        if (!Rt())
                            return st = !1,
                            !1;
                        const n = new OffscreenCanvas(85,1)
                          , e = n.getContext("2d", {
                            willReadFrequently: !0
                        });
                        let o = 0;
                        for (let u = 0; u < n.width; ++u)
                            e.fillStyle = "rgba(".concat(o++, ",").concat(o++, ",").concat(o++, ", 255)"),
                            e.fillRect(u, 0, 1, 1);
                        const a = e.getImageData(0, 0, n.width, n.height);
                        o = 0;
                        for (let u = 0; u < a.data.length; ++u)
                            if (u % 4 != 3 && o++ !== a.data[u])
                                return st = !0,
                                !0;
                        return st = !1,
                        !1
                    }
                };
                function wo(n, e) {
                    const o = n.indexOf("?");
                    if (o < 0)
                        return "".concat(n, "?").concat(new URLSearchParams(e).toString());
                    const a = new URLSearchParams(n.slice(o));
                    for (const u in e)
                        a.set(u, e[u]);
                    return "".concat(n.slice(0, o), "?").concat(a.toString())
                }
                function Ho(n, e={
                    persistentParams: []
                }) {
                    const o = n.indexOf("?");
                    if (o < 0)
                        return n;
                    const a = new URLSearchParams
                      , u = new URLSearchParams(n.slice(o));
                    for (const p of e.persistentParams) {
                        const g = u.get(p);
                        g && a.set(p, g)
                    }
                    const l = a.toString();
                    return "".concat(n.slice(0, o)).concat(l.length > 0 ? "?".concat(l) : "")
                }
                const Jo = "mapbox-tiles";
                let qo = 500
                  , Go = 50;
                const Ii = ["language", "worldview", "jobid"];
                let Ci, fi;
                function Ai() {
                    try {
                        return caches
                    } catch {}
                }
                function Fi() {
                    const n = Ai();
                    n && null == Ci && (Ci = n.open(Jo))
                }
                let fn = 1 / 0;
                const Yn = {
                    supported: !1,
                    testSupport: function(n) {
                        !xs && Fn && (Hr ? jl(n) : Sn = n)
                    }
                };
                let Sn, Fn, xs = !1, Hr = !1;
                const Gl = typeof self < "u" ? self : {};
                function jl(n) {
                    const e = n.createTexture();
                    n.bindTexture(n.TEXTURE_2D, e);
                    try {
                        if (n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, Fn),
                        n.isContextLost())
                            return;
                        Yn.supported = !0
                    } catch {}
                    n.deleteTexture(e),
                    xs = !0
                }
                Gl.document && (Fn = Gl.document.createElement("img"),
                Fn.onload = function() {
                    Sn && jl(Sn),
                    Sn = null,
                    Hr = !0
                }
                ,
                Fn.onerror = function() {
                    xs = !0,
                    Sn = null
                }
                ,
                Fn.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
                const bs = {
                    Unknown: "Unknown",
                    Style: "Style",
                    Source: "Source",
                    Tile: "Tile",
                    Glyphs: "Glyphs",
                    SpriteImage: "SpriteImage",
                    SpriteJSON: "SpriteJSON",
                    Iconset: "Iconset",
                    Image: "Image",
                    Model: "Model"
                };
                "function" == typeof Object.freeze && Object.freeze(bs);
                class Va extends Error {
                    constructor(e, o, a) {
                        401 === o && He(a) && (e += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"),
                        super(e),
                        this.status = o,
                        this.url = a
                    }
                    toString() {
                        return "".concat(this.name, ": ").concat(this.message, " (").concat(this.status, "): ").concat(this.url)
                    }
                }
                const js = ji() ? () => self.worker && self.worker.referrer : () => ("blob:" === location.protocol ? parent : self).location.href
                  , ls = function(n, e) {
                    if (!(/^file:/.test(o = n.url) || /^file:/.test(js()) && !/^\w+:/.test(o))) {
                        if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty("signal"))
                            return function(a, u) {
                                const l = new AbortController
                                  , p = new Request(a.url,{
                                    method: a.method || "GET",
                                    body: a.body,
                                    credentials: a.credentials,
                                    headers: a.headers,
                                    referrer: js(),
                                    referrerPolicy: a.referrerPolicy,
                                    signal: l.signal
                                });
                                let g = !1
                                  , x = !1;
                                const T = (f = p.url).indexOf("sku=") > 0 && He(f);
                                var f;
                                "json" === a.type && p.headers.set("Accept", "application/json");
                                const b = (v, w, C) => {
                                    if (x)
                                        return;
                                    if (v && "SecurityError" !== v.message && vo(v.toString()),
                                    w && C)
                                        return P(w);
                                    const A = Date.now();
                                    fetch(p).then(O => {
                                        if (O.ok) {
                                            const F = T ? O.clone() : null;
                                            return P(O, F, A)
                                        }
                                        return u(new Va(O.statusText,O.status,a.url))
                                    }
                                    ).catch(O => {
                                        "AbortError" !== O.name && u(new Error("".concat(O.message, " ").concat(a.url)))
                                    }
                                    )
                                }
                                  , P = (v, w, C) => {
                                    ("arrayBuffer" === a.type ? v.arrayBuffer() : "json" === a.type ? v.json() : v.text()).then(A => {
                                        x || (w && C && function(O, F, z) {
                                            if (Fi(),
                                            null == Ci)
                                                return;
                                            const L = yn(F.headers.get("Cache-Control") || "");
                                            if (L["no-store"])
                                                return;
                                            const N = {
                                                status: F.status,
                                                statusText: F.statusText,
                                                headers: new Headers
                                            };
                                            F.headers.forEach( (_e, me) => N.headers.set(me, _e)),
                                            L["max-age"] && N.headers.set("Expires", new Date(z + 1e3 * L["max-age"]).toUTCString());
                                            const G = N.headers.get("Expires");
                                            if (!G || new Date(G).getTime() - z < 42e4)
                                                return;
                                            let X = Ho(O.url, {
                                                persistentParams: Ii
                                            });
                                            if (206 === F.status) {
                                                const _e = O.headers.get("Range");
                                                if (!_e)
                                                    return;
                                                N.status = 200,
                                                X = wo(X, {
                                                    range: _e
                                                })
                                            }
                                            !function(_e, me) {
                                                if (void 0 === fi)
                                                    try {
                                                        new Response(new ReadableStream),
                                                        fi = !0
                                                    } catch {
                                                        fi = !1
                                                    }
                                                fi ? me(_e.body) : _e.blob().then(me)
                                            }(F, _e => {
                                                const me = new Response(200 !== (pe = F.status) && 404 !== pe && [101, 103, 204, 205, 304].includes(pe) ? null : _e,N);
                                                var pe;
                                                Fi(),
                                                null != Ci && Ci.then(Ne => Ne.put(X, me)).catch(Ne => vo(Ne.message))
                                            }
                                            )
                                        }(p, w, C),
                                        g = !0,
                                        u(null, A, v.headers.get("Cache-Control"), v.headers.get("Expires")))
                                    }
                                    ).catch(A => {
                                        x || u(new Error(A.message))
                                    }
                                    )
                                }
                                ;
                                return T ? function(v, w) {
                                    if (Fi(),
                                    null == Ci)
                                        return w(null);
                                    Ci.then(C => {
                                        let A = Ho(v.url, {
                                            persistentParams: Ii
                                        });
                                        const O = v.headers.get("Range");
                                        O && (A = wo(A, {
                                            range: O
                                        })),
                                        C.match(A).then(F => {
                                            const z = function(L) {
                                                if (!L)
                                                    return !1;
                                                const N = new Date(L.headers.get("Expires") || 0)
                                                  , G = yn(L.headers.get("Cache-Control") || "");
                                                return N > Date.now() && !G["no-cache"]
                                            }(F);
                                            C.delete(A),
                                            z && C.put(A, F.clone()),
                                            w(null, F, z)
                                        }
                                        ).catch(w)
                                    }
                                    ).catch(w)
                                }(p, b) : b(null, null),
                                {
                                    cancel: () => {
                                        x = !0,
                                        g || l.abort()
                                    }
                                }
                            }(n, e);
                        if (ji() && self.worker && self.worker.actor)
                            return self.worker.actor.send("getResource", n, e, void 0, !0)
                    }
                    var o;
                    return function(a, u) {
                        const l = new XMLHttpRequest;
                        l.open(a.method || "GET", a.url, !0),
                        "arrayBuffer" === a.type && (l.responseType = "arraybuffer");
                        for (const p in a.headers)
                            l.setRequestHeader(p, a.headers[p]);
                        return "json" === a.type && (l.responseType = "text",
                        l.setRequestHeader("Accept", "application/json")),
                        l.withCredentials = "include" === a.credentials,
                        l.onerror = () => {
                            u(new Error(l.statusText))
                        }
                        ,
                        l.onload = () => {
                            if ((l.status >= 200 && l.status < 300 || 0 === l.status) && null !== l.response) {
                                let p = l.response;
                                if ("json" === a.type)
                                    try {
                                        p = JSON.parse(l.response)
                                    } catch (g) {
                                        return u(g)
                                    }
                                u(null, p, l.getResponseHeader("Cache-Control"), l.getResponseHeader("Expires"))
                            } else
                                u(new Va(l.statusText,l.status,a.url))
                        }
                        ,
                        l.send(a.body),
                        {
                            cancel: () => l.abort()
                        }
                    }(n, e)
                }
                  , fr = function(n, e) {
                    return ls(W(n, {
                        type: "arrayBuffer"
                    }), e)
                };
                function jc(n) {
                    const e = document.createElement("a");
                    return e.href = n,
                    e.protocol === location.protocol && e.host === location.host
                }
                const Vc = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
                let Ha, wa;
                Ha = [],
                wa = 0;
                const Wa = function(n, e) {
                    if (Yn.supported && (n.headers || (n.headers = {}),
                    n.headers.accept = "image/webp,*/*"),
                    wa >= Ee.MAX_PARALLEL_IMAGE_REQUESTS) {
                        const l = {
                            requestParameters: n,
                            callback: e,
                            cancelled: !1,
                            cancel() {
                                this.cancelled = !0
                            }
                        };
                        return Ha.push(l),
                        l
                    }
                    wa++;
                    let o = !1;
                    const a = () => {
                        if (!o)
                            for (o = !0,
                            wa--; Ha.length && wa < Ee.MAX_PARALLEL_IMAGE_REQUESTS; ) {
                                const l = Ha.shift()
                                  , {requestParameters: p, callback: g, cancelled: x} = l;
                                x || (l.cancel = Wa(p, g).cancel)
                            }
                    }
                      , u = fr(n, (l, p, g, x) => {
                        a(),
                        l ? e(l) : p && (self.createImageBitmap ? function(T, f) {
                            const b = new Blob([new Uint8Array(T)],{
                                type: "image/png"
                            });
                            createImageBitmap(b).then(P => {
                                f(null, P)
                            }
                            ).catch(P => {
                                f(new Error("Could not load image because of ".concat(P.message, ". Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.")))
                            }
                            )
                        }(p, (T, f) => e(T, f, g, x)) : function(T, f) {
                            const b = new Image;
                            b.onload = () => {
                                f(null, b),
                                URL.revokeObjectURL(b.src),
                                b.onload = null,
                                requestAnimationFrame( () => {
                                    b.src = Vc
                                }
                                )
                            }
                            ,
                            b.onerror = () => f(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                            const P = new Blob([new Uint8Array(T)],{
                                type: "image/png"
                            });
                            b.src = T.byteLength ? URL.createObjectURL(P) : Vc
                        }(p, (T, f) => e(T, f, g, x)))
                    }
                    );
                    return {
                        cancel: () => {
                            u.cancel(),
                            a()
                        }
                    }
                };
                var Hc, ur, Sr, _r = {
                    exports: {}
                }, Fr = {
                    exports: {}
                }, cs = {
                    exports: {}
                }, Vs = function() {
                    if (Sr)
                        return _r.exports;
                    Sr = 1;
                    var n = (Hc || (Hc = 1,
                    Fr.exports = function(o, a) {
                        var u, l, p, g, x, T, f, b;
                        for (l = o.length - (u = 3 & o.length),
                        p = a,
                        x = 3432918353,
                        T = 461845907,
                        b = 0; b < l; )
                            f = 255 & o.charCodeAt(b) | (255 & o.charCodeAt(++b)) << 8 | (255 & o.charCodeAt(++b)) << 16 | (255 & o.charCodeAt(++b)) << 24,
                            ++b,
                            p = 27492 + (65535 & (g = 5 * (65535 & (p = (p ^= f = (65535 & (f = (f = (65535 & f) * x + (((f >>> 16) * x & 65535) << 16) & 4294967295) << 15 | f >>> 17)) * T + (((f >>> 16) * T & 65535) << 16) & 4294967295) << 13 | p >>> 19)) + ((5 * (p >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (g >>> 16) & 65535) << 16);
                        switch (f = 0,
                        u) {
                        case 3:
                            f ^= (255 & o.charCodeAt(b + 2)) << 16;
                        case 2:
                            f ^= (255 & o.charCodeAt(b + 1)) << 8;
                        case 1:
                            p ^= f = (65535 & (f = (f = (65535 & (f ^= 255 & o.charCodeAt(b))) * x + (((f >>> 16) * x & 65535) << 16) & 4294967295) << 15 | f >>> 17)) * T + (((f >>> 16) * T & 65535) << 16) & 4294967295
                        }
                        return p ^= o.length,
                        p = 2246822507 * (65535 & (p ^= p >>> 16)) + ((2246822507 * (p >>> 16) & 65535) << 16) & 4294967295,
                        p = 3266489909 * (65535 & (p ^= p >>> 13)) + ((3266489909 * (p >>> 16) & 65535) << 16) & 4294967295,
                        (p ^= p >>> 16) >>> 0
                    }
                    ),
                    Fr.exports)
                      , e = (ur || (ur = 1,
                    cs.exports = function(o, a) {
                        for (var u, l = o.length, p = a ^ l, g = 0; l >= 4; )
                            u = 1540483477 * (65535 & (u = 255 & o.charCodeAt(g) | (255 & o.charCodeAt(++g)) << 8 | (255 & o.charCodeAt(++g)) << 16 | (255 & o.charCodeAt(++g)) << 24)) + ((1540483477 * (u >>> 16) & 65535) << 16),
                            p = 1540483477 * (65535 & p) + ((1540483477 * (p >>> 16) & 65535) << 16) ^ (u = 1540483477 * (65535 & (u ^= u >>> 24)) + ((1540483477 * (u >>> 16) & 65535) << 16)),
                            l -= 4,
                            ++g;
                        switch (l) {
                        case 3:
                            p ^= (255 & o.charCodeAt(g + 2)) << 16;
                        case 2:
                            p ^= (255 & o.charCodeAt(g + 1)) << 8;
                        case 1:
                            p = 1540483477 * (65535 & (p ^= 255 & o.charCodeAt(g))) + ((1540483477 * (p >>> 16) & 65535) << 16)
                        }
                        return p = 1540483477 * (65535 & (p ^= p >>> 13)) + ((1540483477 * (p >>> 16) & 65535) << 16),
                        (p ^= p >>> 15) >>> 0
                    }
                    ),
                    cs.exports);
                    return _r.exports = n,
                    _r.exports.murmur3 = n,
                    _r.exports.murmur2 = e,
                    _r.exports
                }(), Xa = so(Vs);
                class Wr {
                    constructor(e, ...o) {
                        W(this, o[0] || {}),
                        this.type = e
                    }
                }
                class hs extends Wr {
                    constructor(e, o={}) {
                        super("error", W({
                            error: e
                        }, o))
                    }
                }
                function Ya(n, e, o) {
                    o[n] && -1 !== o[n].indexOf(e) || (o[n] = o[n] || [],
                    o[n].push(e))
                }
                function Wc(n, e, o) {
                    if (o && o[n]) {
                        const a = o[n].indexOf(e);
                        -1 !== a && o[n].splice(a, 1)
                    }
                }
                class Hs {
                    on(e, o) {
                        return this._listeners = this._listeners || {},
                        Ya(e, o, this._listeners),
                        this
                    }
                    off(e, o) {
                        return Wc(e, o, this._listeners),
                        Wc(e, o, this._oneTimeListeners),
                        this
                    }
                    once(e, o) {
                        return o ? (this._oneTimeListeners = this._oneTimeListeners || {},
                        Ya(e, o, this._oneTimeListeners),
                        this) : new Promise(a => this.once(e, a))
                    }
                    fire(e, o) {
                        const a = "string" == typeof e ? new Wr(e,o) : e
                          , u = a.type;
                        if (this.listens(u)) {
                            a.target = this;
                            const l = this._listeners && this._listeners[u] ? this._listeners[u].slice() : [];
                            for (const x of l)
                                x.call(this, a);
                            const p = this._oneTimeListeners && this._oneTimeListeners[u] ? this._oneTimeListeners[u].slice() : [];
                            for (const x of p)
                                Wc(u, x, this._oneTimeListeners),
                                x.call(this, a);
                            const g = this._eventedParent;
                            g && (W(a, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData),
                            g.fire(a))
                        } else
                            a instanceof hs && console.error(a.error);
                        return this
                    }
                    listens(e) {
                        return !!(this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e))
                    }
                    setEventedParent(e, o) {
                        return this._eventedParent = e,
                        this._eventedParentData = o,
                        this
                    }
                }
                var Ir, Za = {}, Ka = function() {
                    if (Ir)
                        return Za;
                    Ir = 1;
                    var n = {
                        transparent: [0, 0, 0, 0],
                        aliceblue: [240, 248, 255, 1],
                        antiquewhite: [250, 235, 215, 1],
                        aqua: [0, 255, 255, 1],
                        aquamarine: [127, 255, 212, 1],
                        azure: [240, 255, 255, 1],
                        beige: [245, 245, 220, 1],
                        bisque: [255, 228, 196, 1],
                        black: [0, 0, 0, 1],
                        blanchedalmond: [255, 235, 205, 1],
                        blue: [0, 0, 255, 1],
                        blueviolet: [138, 43, 226, 1],
                        brown: [165, 42, 42, 1],
                        burlywood: [222, 184, 135, 1],
                        cadetblue: [95, 158, 160, 1],
                        chartreuse: [127, 255, 0, 1],
                        chocolate: [210, 105, 30, 1],
                        coral: [255, 127, 80, 1],
                        cornflowerblue: [100, 149, 237, 1],
                        cornsilk: [255, 248, 220, 1],
                        crimson: [220, 20, 60, 1],
                        cyan: [0, 255, 255, 1],
                        darkblue: [0, 0, 139, 1],
                        darkcyan: [0, 139, 139, 1],
                        darkgoldenrod: [184, 134, 11, 1],
                        darkgray: [169, 169, 169, 1],
                        darkgreen: [0, 100, 0, 1],
                        darkgrey: [169, 169, 169, 1],
                        darkkhaki: [189, 183, 107, 1],
                        darkmagenta: [139, 0, 139, 1],
                        darkolivegreen: [85, 107, 47, 1],
                        darkorange: [255, 140, 0, 1],
                        darkorchid: [153, 50, 204, 1],
                        darkred: [139, 0, 0, 1],
                        darksalmon: [233, 150, 122, 1],
                        darkseagreen: [143, 188, 143, 1],
                        darkslateblue: [72, 61, 139, 1],
                        darkslategray: [47, 79, 79, 1],
                        darkslategrey: [47, 79, 79, 1],
                        darkturquoise: [0, 206, 209, 1],
                        darkviolet: [148, 0, 211, 1],
                        deeppink: [255, 20, 147, 1],
                        deepskyblue: [0, 191, 255, 1],
                        dimgray: [105, 105, 105, 1],
                        dimgrey: [105, 105, 105, 1],
                        dodgerblue: [30, 144, 255, 1],
                        firebrick: [178, 34, 34, 1],
                        floralwhite: [255, 250, 240, 1],
                        forestgreen: [34, 139, 34, 1],
                        fuchsia: [255, 0, 255, 1],
                        gainsboro: [220, 220, 220, 1],
                        ghostwhite: [248, 248, 255, 1],
                        gold: [255, 215, 0, 1],
                        goldenrod: [218, 165, 32, 1],
                        gray: [128, 128, 128, 1],
                        green: [0, 128, 0, 1],
                        greenyellow: [173, 255, 47, 1],
                        grey: [128, 128, 128, 1],
                        honeydew: [240, 255, 240, 1],
                        hotpink: [255, 105, 180, 1],
                        indianred: [205, 92, 92, 1],
                        indigo: [75, 0, 130, 1],
                        ivory: [255, 255, 240, 1],
                        khaki: [240, 230, 140, 1],
                        lavender: [230, 230, 250, 1],
                        lavenderblush: [255, 240, 245, 1],
                        lawngreen: [124, 252, 0, 1],
                        lemonchiffon: [255, 250, 205, 1],
                        lightblue: [173, 216, 230, 1],
                        lightcoral: [240, 128, 128, 1],
                        lightcyan: [224, 255, 255, 1],
                        lightgoldenrodyellow: [250, 250, 210, 1],
                        lightgray: [211, 211, 211, 1],
                        lightgreen: [144, 238, 144, 1],
                        lightgrey: [211, 211, 211, 1],
                        lightpink: [255, 182, 193, 1],
                        lightsalmon: [255, 160, 122, 1],
                        lightseagreen: [32, 178, 170, 1],
                        lightskyblue: [135, 206, 250, 1],
                        lightslategray: [119, 136, 153, 1],
                        lightslategrey: [119, 136, 153, 1],
                        lightsteelblue: [176, 196, 222, 1],
                        lightyellow: [255, 255, 224, 1],
                        lime: [0, 255, 0, 1],
                        limegreen: [50, 205, 50, 1],
                        linen: [250, 240, 230, 1],
                        magenta: [255, 0, 255, 1],
                        maroon: [128, 0, 0, 1],
                        mediumaquamarine: [102, 205, 170, 1],
                        mediumblue: [0, 0, 205, 1],
                        mediumorchid: [186, 85, 211, 1],
                        mediumpurple: [147, 112, 219, 1],
                        mediumseagreen: [60, 179, 113, 1],
                        mediumslateblue: [123, 104, 238, 1],
                        mediumspringgreen: [0, 250, 154, 1],
                        mediumturquoise: [72, 209, 204, 1],
                        mediumvioletred: [199, 21, 133, 1],
                        midnightblue: [25, 25, 112, 1],
                        mintcream: [245, 255, 250, 1],
                        mistyrose: [255, 228, 225, 1],
                        moccasin: [255, 228, 181, 1],
                        navajowhite: [255, 222, 173, 1],
                        navy: [0, 0, 128, 1],
                        oldlace: [253, 245, 230, 1],
                        olive: [128, 128, 0, 1],
                        olivedrab: [107, 142, 35, 1],
                        orange: [255, 165, 0, 1],
                        orangered: [255, 69, 0, 1],
                        orchid: [218, 112, 214, 1],
                        palegoldenrod: [238, 232, 170, 1],
                        palegreen: [152, 251, 152, 1],
                        paleturquoise: [175, 238, 238, 1],
                        palevioletred: [219, 112, 147, 1],
                        papayawhip: [255, 239, 213, 1],
                        peachpuff: [255, 218, 185, 1],
                        peru: [205, 133, 63, 1],
                        pink: [255, 192, 203, 1],
                        plum: [221, 160, 221, 1],
                        powderblue: [176, 224, 230, 1],
                        purple: [128, 0, 128, 1],
                        rebeccapurple: [102, 51, 153, 1],
                        red: [255, 0, 0, 1],
                        rosybrown: [188, 143, 143, 1],
                        royalblue: [65, 105, 225, 1],
                        saddlebrown: [139, 69, 19, 1],
                        salmon: [250, 128, 114, 1],
                        sandybrown: [244, 164, 96, 1],
                        seagreen: [46, 139, 87, 1],
                        seashell: [255, 245, 238, 1],
                        sienna: [160, 82, 45, 1],
                        silver: [192, 192, 192, 1],
                        skyblue: [135, 206, 235, 1],
                        slateblue: [106, 90, 205, 1],
                        slategray: [112, 128, 144, 1],
                        slategrey: [112, 128, 144, 1],
                        snow: [255, 250, 250, 1],
                        springgreen: [0, 255, 127, 1],
                        steelblue: [70, 130, 180, 1],
                        tan: [210, 180, 140, 1],
                        teal: [0, 128, 128, 1],
                        thistle: [216, 191, 216, 1],
                        tomato: [255, 99, 71, 1],
                        turquoise: [64, 224, 208, 1],
                        violet: [238, 130, 238, 1],
                        wheat: [245, 222, 179, 1],
                        white: [255, 255, 255, 1],
                        whitesmoke: [245, 245, 245, 1],
                        yellow: [255, 255, 0, 1],
                        yellowgreen: [154, 205, 50, 1]
                    };
                    function e(l) {
                        return (l = Math.round(l)) < 0 ? 0 : l > 255 ? 255 : l
                    }
                    function o(l) {
                        return e("%" === l[l.length - 1] ? parseFloat(l) / 100 * 255 : parseInt(l))
                    }
                    function a(l) {
                        return (p = "%" === l[l.length - 1] ? parseFloat(l) / 100 : parseFloat(l)) < 0 ? 0 : p > 1 ? 1 : p;
                        var p
                    }
                    function u(l, p, g) {
                        return g < 0 ? g += 1 : g > 1 && (g -= 1),
                        6 * g < 1 ? l + (p - l) * g * 6 : 2 * g < 1 ? p : 3 * g < 2 ? l + (p - l) * (2 / 3 - g) * 6 : l
                    }
                    try {
                        Za.parseCSSColor = function(l) {
                            var p, g = l.replace(/ /g, "").toLowerCase();
                            if (g in n)
                                return n[g].slice();
                            if ("#" === g[0])
                                return 4 === g.length ? (p = parseInt(g.substr(1), 16)) >= 0 && p <= 4095 ? [(3840 & p) >> 4 | (3840 & p) >> 8, 240 & p | (240 & p) >> 4, 15 & p | (15 & p) << 4, 1] : null : 7 === g.length && (p = parseInt(g.substr(1), 16)) >= 0 && p <= 16777215 ? [(16711680 & p) >> 16, (65280 & p) >> 8, 255 & p, 1] : null;
                            var x = g.indexOf("(")
                              , T = g.indexOf(")");
                            if (-1 !== x && T + 1 === g.length) {
                                var f = g.substr(0, x)
                                  , b = g.substr(x + 1, T - (x + 1)).split(",")
                                  , P = 1;
                                switch (f) {
                                case "rgba":
                                    if (4 !== b.length)
                                        return null;
                                    P = a(b.pop());
                                case "rgb":
                                    return 3 !== b.length ? null : [o(b[0]), o(b[1]), o(b[2]), P];
                                case "hsla":
                                    if (4 !== b.length)
                                        return null;
                                    P = a(b.pop());
                                case "hsl":
                                    if (3 !== b.length)
                                        return null;
                                    var v = (parseFloat(b[0]) % 360 + 360) % 360 / 360
                                      , w = a(b[1])
                                      , C = a(b[2])
                                      , A = C <= .5 ? C * (w + 1) : C + w - C * w
                                      , O = 2 * C - A;
                                    return [e(255 * u(O, A, v + 1 / 3)), e(255 * u(O, A, v)), e(255 * u(O, A, v - 1 / 3)), P];
                                default:
                                    return null
                                }
                            }
                            return null
                        }
                    } catch {}
                    return Za
                }();
                class wi {
                    constructor(e, o, a, u=1) {
                        this.r = e,
                        this.g = o,
                        this.b = a,
                        this.a = u
                    }
                    static parse(e) {
                        if (!e)
                            return;
                        if (e instanceof wi)
                            return e;
                        if ("string" != typeof e)
                            return;
                        const o = Ka.parseCSSColor(e);
                        return o ? new wi(o[0] / 255 * o[3],o[1] / 255 * o[3],o[2] / 255 * o[3],o[3]) : void 0
                    }
                    toStringPremultipliedAlpha() {
                        const [e,o,a,u] = 0 === this.a ? [0, 0, 0, 0] : [255 * this.r / this.a, 255 * this.g / this.a, 255 * this.b / this.a, this.a];
                        return "rgba(".concat(Math.round(e), ",").concat(Math.round(o), ",").concat(Math.round(a), ",").concat(u, ")")
                    }
                    toString() {
                        const [e,o,a,u] = [this.r, this.g, this.b, this.a];
                        return "rgba(".concat(Math.round(255 * e), ",").concat(Math.round(255 * o), ",").concat(Math.round(255 * a), ",").concat(u, ")")
                    }
                    toRenderColor(e) {
                        const {r: o, g: a, b: u, a: l} = this;
                        return new pp(e,o,a,u,l)
                    }
                    clone() {
                        return new wi(this.r,this.g,this.b,this.a)
                    }
                }
                class pp {
                    constructor(e, o, a, u, l) {
                        if (e) {
                            const p = e.image.height
                              , g = p * p;
                            o = 0 === l ? 0 : o / l * (p - 1),
                            a = 0 === l ? 0 : a / l * (p - 1),
                            u = 0 === l ? 0 : u / l * (p - 1);
                            const x = Math.floor(o)
                              , T = Math.floor(a)
                              , f = Math.floor(u)
                              , b = Math.ceil(o)
                              , P = Math.ceil(a)
                              , v = Math.ceil(u)
                              , w = o - x
                              , C = a - T
                              , A = u - f
                              , O = e.image.data
                              , F = 4 * (x + T * g + f * p)
                              , z = 4 * (x + T * g + v * p)
                              , L = 4 * (x + P * g + f * p)
                              , N = 4 * (x + P * g + v * p)
                              , G = 4 * (b + T * g + f * p)
                              , X = 4 * (b + T * g + v * p)
                              , _e = 4 * (b + P * g + f * p)
                              , me = 4 * (b + P * g + v * p);
                            if (F < 0 || me >= O.length)
                                throw new Error("out of range");
                            this.r = jo(jo(jo(O[F], O[z], A), jo(O[L], O[N], A), C), jo(jo(O[G], O[X], A), jo(O[_e], O[me], A), C), w) / 255 * l,
                            this.g = jo(jo(jo(O[F + 1], O[z + 1], A), jo(O[L + 1], O[N + 1], A), C), jo(jo(O[G + 1], O[X + 1], A), jo(O[_e + 1], O[me + 1], A), C), w) / 255 * l,
                            this.b = jo(jo(jo(O[F + 2], O[z + 2], A), jo(O[L + 2], O[N + 2], A), C), jo(jo(O[G + 2], O[X + 2], A), jo(O[_e + 2], O[me + 2], A), C), w) / 255 * l,
                            this.a = l
                        } else
                            this.r = o,
                            this.g = a,
                            this.b = u,
                            this.a = l
                    }
                    toArray() {
                        const {r: e, g: o, b: a, a: u} = this;
                        return 0 === u ? [0, 0, 0, 0] : [255 * e / u, 255 * o / u, 255 * a / u, u]
                    }
                    toHslaArray() {
                        if (0 === this.a)
                            return [0, 0, 0, 0];
                        const {r: e, g: o, b: a, a: u} = this
                          , l = Math.min(Math.max(e / u, 0), 1)
                          , p = Math.min(Math.max(o / u, 0), 1)
                          , g = Math.min(Math.max(a / u, 0), 1)
                          , x = Math.min(l, p, g)
                          , T = Math.max(l, p, g)
                          , f = (x + T) / 2;
                        if (x === T)
                            return [0, 0, 100 * f, u];
                        const b = T - x
                          , P = f > .5 ? b / (2 - T - x) : b / (T + x);
                        let v = 0;
                        return T === l ? v = (p - g) / b + (p < g ? 6 : 0) : T === p ? v = (g - l) / b + 2 : T === g && (v = (l - p) / b + 4),
                        v *= 60,
                        [Math.min(Math.max(v, 0), 360), Math.min(Math.max(100 * P, 0), 100), Math.min(Math.max(100 * f, 0), 100), u]
                    }
                    toArray01() {
                        const {r: e, g: o, b: a, a: u} = this;
                        return 0 === u ? [0, 0, 0, 0] : [e / u, o / u, a / u, u]
                    }
                    toArray01Scaled(e) {
                        const {r: o, g: a, b: u, a: l} = this;
                        return 0 === l ? [0, 0, 0] : [o / l * e, a / l * e, u / l * e]
                    }
                    toArray01PremultipliedAlpha() {
                        const {r: e, g: o, b: a, a: u} = this;
                        return [e, o, a, u]
                    }
                    toArray01Linear() {
                        const {r: e, g: o, b: a, a: u} = this;
                        return 0 === u ? [0, 0, 0, 0] : [Math.pow(e / u, 2.2), Math.pow(o / u, 2.2), Math.pow(a / u, 2.2), u]
                    }
                }
                function jo(n, e, o) {
                    return n * (1 - o) + e * o
                }
                function Vl(n, e, o) {
                    return n.map( (a, u) => jo(a, e[u], o))
                }
                wi.black = new wi(0,0,0,1),
                wi.white = new wi(1,1,1,1),
                wi.transparent = new wi(0,0,0,0),
                wi.red = new wi(1,0,0,1),
                wi.blue = new wi(0,0,1,1);
                var xi = Object.freeze({
                    __proto__: null,
                    array: Vl,
                    color: function(n, e, o) {
                        return new wi(jo(n.r, e.r, o),jo(n.g, e.g, o),jo(n.b, e.b, o),jo(n.a, e.a, o))
                    },
                    number: jo
                });
                function Hl(n, ...e) {
                    for (const o of e)
                        for (const a in o)
                            n[a] = o[a];
                    return n
                }
                class Zn extends Error {
                    constructor(e, o) {
                        super(o),
                        this.message = o,
                        this.key = e
                    }
                }
                class Wl {
                    constructor(e, o=[]) {
                        this.parent = e,
                        this.bindings = {};
                        for (const [a,u] of o)
                            this.bindings[a] = u
                    }
                    concat(e) {
                        return new Wl(this,e)
                    }
                    get(e) {
                        if (this.bindings[e])
                            return this.bindings[e];
                        if (this.parent)
                            return this.parent.get(e);
                        throw new Error("".concat(e, " not found in scope."))
                    }
                    has(e) {
                        return !!this.bindings[e] || !!this.parent && this.parent.has(e)
                    }
                }
                const Ws = {
                    kind: "null"
                }
                  , To = {
                    kind: "number"
                }
                  , Pi = {
                    kind: "string"
                }
                  , bi = {
                    kind: "boolean"
                }
                  , Hn = {
                    kind: "color"
                }
                  , Xs = {
                    kind: "object"
                }
                  , _i = {
                    kind: "value"
                }
                  , Xl = {
                    kind: "collator"
                }
                  , Xr = {
                    kind: "formatted"
                }
                  , Ys = {
                    kind: "resolvedImage"
                };
                function An(n, e) {
                    return {
                        kind: "array",
                        itemType: n,
                        N: e
                    }
                }
                function Vi(n) {
                    if ("array" === n.kind) {
                        const e = Vi(n.itemType);
                        return "number" == typeof n.N ? "array<".concat(e, ", ").concat(n.N, ">") : "value" === n.itemType.kind ? "array" : "array<".concat(e, ">")
                    }
                    return n.kind
                }
                const qa = [Ws, To, Pi, bi, Hn, Xr, Xs, An(_i), Ys];
                function Zs(n, e) {
                    if ("error" === e.kind)
                        return null;
                    if ("array" === n.kind) {
                        if ("array" === e.kind && (0 === e.N && "value" === e.itemType.kind || !Zs(n.itemType, e.itemType)) && ("number" != typeof n.N || n.N === e.N))
                            return null
                    } else {
                        if (n.kind === e.kind)
                            return null;
                        if ("value" === n.kind)
                            for (const o of qa)
                                if (!Zs(o, e))
                                    return null
                    }
                    return "Expected ".concat(Vi(n), " but found ").concat(Vi(e), " instead.")
                }
                function Pa(n, e) {
                    return e.some(o => o.kind === n.kind)
                }
                function Ks(n, e) {
                    return e.some(o => "null" === o ? null === n : "array" === o ? Array.isArray(n) : "object" === o ? n && !Array.isArray(n) && "object" == typeof n : o === typeof n)
                }
                class Ja {
                    constructor(e, o, a) {
                        this.sensitivity = e ? o ? "variant" : "case" : o ? "accent" : "base",
                        this.locale = a,
                        this.collator = new Intl.Collator(this.locale ? this.locale : [],{
                            sensitivity: this.sensitivity,
                            usage: "search"
                        })
                    }
                    compare(e, o) {
                        return this.collator.compare(e, o)
                    }
                    resolvedLocale() {
                        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
                    }
                }
                class Ma {
                    constructor(e, o, a, u, l) {
                        this.text = e.normalize ? e.normalize() : e,
                        this.image = o,
                        this.scale = a,
                        this.fontStack = u,
                        this.textColor = l
                    }
                }
                class Nn {
                    constructor(e) {
                        this.sections = e
                    }
                    static fromString(e) {
                        return new Nn([new Ma(e,null,null,null,null)])
                    }
                    isEmpty() {
                        return 0 === this.sections.length || !this.sections.some(e => 0 !== e.text.length || e.image && e.image.namePrimary)
                    }
                    static factory(e) {
                        return e instanceof Nn ? e : Nn.fromString(e)
                    }
                    toString() {
                        return 0 === this.sections.length ? "" : this.sections.map(e => e.text).join("")
                    }
                    serialize() {
                        const e = ["format"];
                        for (const o of this.sections) {
                            if (o.image) {
                                e.push(["image", o.image.namePrimary]);
                                continue
                            }
                            e.push(o.text);
                            const a = {};
                            o.fontStack && (a["text-font"] = ["literal", o.fontStack.split(",")]),
                            o.scale && (a["font-scale"] = o.scale),
                            o.textColor && (a["text-color"] = ["rgba"].concat(o.textColor.toRenderColor(null).toArray())),
                            e.push(a)
                        }
                        return e
                    }
                }
                class ir {
                    constructor(e, o) {
                        if (this.id = e,
                        this.options = o || {
                            params: {}
                        },
                        this.options.transform) {
                            const {a, b: u, c: l, d: p, e: g, f: x} = this.options.transform;
                            this.options.transform = new DOMMatrix([a, u, l, p, g, x])
                        } else
                            this.options.transform = new DOMMatrix([1, 0, 0, 1, 0, 0])
                    }
                    static deserializeId(e) {
                        return JSON.parse(e).id
                    }
                    static deserializeFromString(e) {
                        const o = JSON.parse(e)
                          , {a, b: u, c: l, d: p, e: g, f: x} = o.options.transform;
                        return new DOMMatrix([a, u, l, p, g, x]),
                        new ir(o.id,o.options)
                    }
                    scaleSelf(e) {
                        return this.options.transform = this.options.transform.scale(e),
                        this
                    }
                    serialize() {
                        const e = {
                            id: this.id
                        };
                        this.options && (e.options = this.options);
                        const {a: o, b: a, c: u, d: l, e: p, f: g} = this.options.transform;
                        return e.options.transform = {
                            a: o,
                            b: a,
                            c: u,
                            d: l,
                            e: p,
                            f: g
                        },
                        JSON.stringify(e)
                    }
                }
                class In {
                    constructor(e) {
                        this.namePrimary = e.namePrimary,
                        e.nameSecondary && (this.nameSecondary = e.nameSecondary),
                        e.optionsPrimary && (this.optionsPrimary = e.optionsPrimary),
                        e.optionsSecondary && (this.optionsSecondary = e.optionsSecondary),
                        this.available = e.available
                    }
                    toString() {
                        return this.namePrimary && this.nameSecondary ? "[".concat(this.namePrimary, ",").concat(this.nameSecondary, "]") : this.namePrimary
                    }
                    getPrimary() {
                        return new ir(this.namePrimary,{
                            params: this.optionsPrimary && this.optionsPrimary.params || {}
                        })
                    }
                    getSerializedPrimary() {
                        return this.getPrimary().serialize()
                    }
                    getSecondary() {
                        return this.nameSecondary ? new ir(this.nameSecondary,{
                            params: this.optionsSecondary && this.optionsSecondary.params || {}
                        }) : null
                    }
                    static from(e) {
                        return "string" == typeof e ? In.build(e) : e
                    }
                    static build(e, o, a, u) {
                        return e ? new In({
                            namePrimary: e,
                            nameSecondary: o,
                            optionsPrimary: a,
                            optionsSecondary: u,
                            available: !1
                        }) : null
                    }
                }
                function ws(n, e, o, a) {
                    return "number" == typeof n && n >= 0 && n <= 255 && "number" == typeof e && e >= 0 && e <= 255 && "number" == typeof o && o >= 0 && o <= 255 ? void 0 === a || "number" == typeof a && a >= 0 && a <= 1 ? null : "Invalid rgba value [".concat([n, e, o, a].join(", "), "]: 'a' must be between 0 and 1.") : "Invalid rgba value [".concat(("number" == typeof a ? [n, e, o, a] : [n, e, o]).join(", "), "]: 'r', 'g', and 'b' must be between 0 and 255.")
                }
                function Ps(n) {
                    if (null === n || "string" == typeof n || "boolean" == typeof n || "number" == typeof n || n instanceof wi || n instanceof Ja || n instanceof Nn || n instanceof In)
                        return !0;
                    if (Array.isArray(n)) {
                        for (const e of n)
                            if (!Ps(e))
                                return !1;
                        return !0
                    }
                    if ("object" == typeof n) {
                        for (const e in n)
                            if (!Ps(n[e]))
                                return !1;
                        return !0
                    }
                    return !1
                }
                function en(n) {
                    if (null === n)
                        return Ws;
                    if ("string" == typeof n)
                        return Pi;
                    if ("boolean" == typeof n)
                        return bi;
                    if ("number" == typeof n)
                        return To;
                    if (n instanceof wi)
                        return Hn;
                    if (n instanceof Ja)
                        return Xl;
                    if (n instanceof Nn)
                        return Xr;
                    if (n instanceof In)
                        return Ys;
                    if (Array.isArray(n)) {
                        const e = n.length;
                        let o;
                        for (const a of n) {
                            const u = en(a);
                            if (o) {
                                if (o === u)
                                    continue;
                                o = _i;
                                break
                            }
                            o = u
                        }
                        return An(o || _i, e)
                    }
                    return Xs
                }
                function gr(n) {
                    const e = typeof n;
                    return null === n ? "" : "string" === e || "number" === e || "boolean" === e ? String(n) : n instanceof wi ? n.toStringPremultipliedAlpha() : n instanceof Nn || n instanceof In ? n.toString() : JSON.stringify(n)
                }
                class Ar {
                    constructor(e, o) {
                        this.type = e,
                        this.value = o
                    }
                    static parse(e, o) {
                        if (2 !== e.length)
                            return o.error("'literal' expression requires exactly one argument, but found ".concat(e.length - 1, " instead."));
                        if (!Ps(e[1]))
                            return o.error("invalid value");
                        const a = e[1];
                        let u = en(a);
                        const l = o.expectedType;
                        return "array" !== u.kind || 0 !== u.N || !l || "array" !== l.kind || "number" == typeof l.N && 0 !== l.N || (u = l),
                        new Ar(u,a)
                    }
                    evaluate() {
                        return this.value
                    }
                    eachChild() {}
                    outputDefined() {
                        return !0
                    }
                    serialize() {
                        return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof wi ? ["rgba"].concat(this.value.toRenderColor(null).toArray()) : this.value instanceof Nn ? this.value.serialize() : this.value
                    }
                }
                class Xi {
                    constructor(e) {
                        this.name = "ExpressionEvaluationError",
                        this.message = e
                    }
                    toJSON() {
                        return this.message
                    }
                }
                const yr = {
                    string: Pi,
                    number: To,
                    boolean: bi,
                    object: Xs
                };
                class On {
                    constructor(e, o) {
                        this.type = e,
                        this.args = o
                    }
                    static parse(e, o) {
                        if (e.length < 2)
                            return o.error("Expected at least one argument.");
                        let a, u = 1;
                        const l = e[0];
                        if ("array" === l) {
                            let g, x;
                            if (e.length > 2) {
                                const T = e[1];
                                if ("string" != typeof T || !(T in yr) || "object" === T)
                                    return o.error('The item type argument of "array" must be one of string, number, boolean', 1);
                                g = yr[T],
                                u++
                            } else
                                g = _i;
                            if (e.length > 3) {
                                if (null !== e[2] && ("number" != typeof e[2] || e[2] < 0 || e[2] !== Math.floor(e[2])))
                                    return o.error('The length argument to "array" must be a positive integer literal', 2);
                                x = e[2],
                                u++
                            }
                            a = An(g, x)
                        } else
                            a = yr[l];
                        const p = [];
                        for (; u < e.length; u++) {
                            const g = o.parse(e[u], u, _i);
                            if (!g)
                                return null;
                            p.push(g)
                        }
                        return new On(a,p)
                    }
                    evaluate(e) {
                        for (let o = 0; o < this.args.length; o++) {
                            const a = this.args[o].evaluate(e);
                            if (!Zs(this.type, en(a)))
                                return a;
                            if (o === this.args.length - 1)
                                throw new Xi("The expression ".concat(JSON.stringify(this.args[o].serialize()), " evaluated to ").concat(Vi(en(a)), " but was expected to be of type ").concat(Vi(this.type), "."))
                        }
                        return null
                    }
                    eachChild(e) {
                        this.args.forEach(e)
                    }
                    outputDefined() {
                        return this.args.every(e => e.outputDefined())
                    }
                    serialize() {
                        const e = this.type
                          , o = [e.kind];
                        if ("array" === e.kind) {
                            const a = e.itemType;
                            if ("string" === a.kind || "number" === a.kind || "boolean" === a.kind) {
                                o.push(a.kind);
                                const u = e.N;
                                ("number" == typeof u || this.args.length > 1) && o.push(u)
                            }
                        }
                        return o.concat(this.args.map(a => a.serialize()))
                    }
                }
                class Yr {
                    constructor(e) {
                        this.type = Xr,
                        this.sections = e
                    }
                    static parse(e, o) {
                        if (e.length < 2)
                            return o.error("Expected at least one argument.");
                        const a = e[1];
                        if (!Array.isArray(a) && "object" == typeof a)
                            return o.error("First argument must be an image or text section.");
                        const u = [];
                        let l = !1;
                        for (let p = 1; p <= e.length - 1; ++p) {
                            const g = e[p];
                            if (l && "object" == typeof g && !Array.isArray(g)) {
                                l = !1;
                                let x = null;
                                if (g["font-scale"] && (x = o.parseObjectValue(g["font-scale"], p, "font-scale", To),
                                !x))
                                    return null;
                                let T = null;
                                if (g["text-font"] && (T = o.parseObjectValue(g["text-font"], p, "text-font", An(Pi)),
                                !T))
                                    return null;
                                let f = null;
                                if (g["text-color"] && (f = o.parseObjectValue(g["text-color"], p, "text-color", Hn),
                                !f))
                                    return null;
                                const b = u[u.length - 1];
                                b.scale = x,
                                b.font = T,
                                b.textColor = f
                            } else {
                                const x = o.parse(e[p], p, _i);
                                if (!x)
                                    return null;
                                const T = x.type.kind;
                                if ("string" !== T && "value" !== T && "null" !== T && "resolvedImage" !== T)
                                    return o.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                                l = !0,
                                u.push({
                                    content: x,
                                    scale: null,
                                    font: null,
                                    textColor: null
                                })
                            }
                        }
                        return new Yr(u)
                    }
                    evaluate(e) {
                        return new Nn(this.sections.map(o => {
                            const a = o.content.evaluate(e);
                            return en(a) === Ys ? new Ma("",a,null,null,null) : new Ma(gr(a),null,o.scale ? o.scale.evaluate(e) : null,o.font ? o.font.evaluate(e).join(",") : null,o.textColor ? o.textColor.evaluate(e) : null)
                        }
                        ))
                    }
                    eachChild(e) {
                        for (const o of this.sections)
                            e(o.content),
                            o.scale && e(o.scale),
                            o.font && e(o.font),
                            o.textColor && e(o.textColor)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        const e = ["format"];
                        for (const o of this.sections) {
                            e.push(o.content.serialize());
                            const a = {};
                            o.scale && (a["font-scale"] = o.scale.serialize()),
                            o.font && (a["text-font"] = o.font.serialize()),
                            o.textColor && (a["text-color"] = o.textColor.serialize()),
                            e.push(a)
                        }
                        return e
                    }
                }
                class qs {
                    constructor(e, o, a, u) {
                        this._imageWarnHistory = {},
                        this.type = Ys,
                        this.inputPrimary = e,
                        this.inputSecondary = o,
                        this.inputPrimaryParams = a,
                        this.inputSecondaryParams = u
                    }
                    static parse(e, o) {
                        if (e.length < 2)
                            return o.error("Expected two or more arguments.");
                        let a = 1;
                        const u = [];
                        function l() {
                            if (a < e.length) {
                                const g = o.parse(e[a], a++, Pi);
                                return g ? (u.push({
                                    image: g,
                                    options: void 0
                                }),
                                !0) : (o.error(u.length ? "Secondary image variant is not a string." : "No image name provided."),
                                !1)
                            }
                            return !0
                        }
                        function p() {
                            if (a < e.length) {
                                if (null === (g = e[a]) || "object" != typeof g || Array.isArray(g))
                                    return !0;
                                const x = e[a].params
                                  , T = o.concat(a);
                                if (!x)
                                    return a++,
                                    !0;
                                if ("object" != typeof x || x.constructor !== Object)
                                    return T.error('Image options "params" should be an object'),
                                    !1;
                                const f = {}
                                  , b = T.concat(void 0, "params");
                                for (const P in x) {
                                    if (!P)
                                        return b.error("Image parameter name should be non-empty"),
                                        !1;
                                    const v = b.concat(void 0, P).parse(x[P], void 0, Hn, void 0, {
                                        typeAnnotation: "coerce"
                                    });
                                    if (!v)
                                        return !1;
                                    f[P] = v
                                }
                                return u[u.length - 1].options = f,
                                a++,
                                !0
                            }
                            var g;
                            return !0
                        }
                        for (let g = 0; g < 2; g++)
                            if (!l() || !p())
                                return;
                        return new qs(u[0].image,u[1] ? u[1].image : void 0,u[0].options,u[1] ? u[1].options : void 0)
                    }
                    evaluateParams(e, o) {
                        const a = {};
                        if (o) {
                            for (const u in o)
                                if (o[u])
                                    try {
                                        const l = o[u].evaluate(e)
                                          , p = 'Ignoring image parameter "'.concat(u, '" with semi-transparent color ').concat(l.toString());
                                        if (1 !== l.a) {
                                            this._imageWarnHistory[p] || (console.warn(p),
                                            this._imageWarnHistory[p] = !0);
                                            continue
                                        }
                                        a[u] = l
                                    } catch {
                                        continue
                                    }
                            if (0 !== Object.keys(a).length)
                                return {
                                    params: a
                                }
                        }
                    }
                    evaluate(e) {
                        const o = In.build(this.inputPrimary.evaluate(e), this.inputSecondary ? this.inputSecondary.evaluate(e) : void 0, this.inputPrimaryParams ? this.evaluateParams(e, this.inputPrimaryParams) : void 0, this.inputSecondaryParams ? this.evaluateParams(e, this.inputSecondaryParams) : void 0);
                        return o && e.availableImages && (o.available = e.availableImages.indexOf(o.namePrimary) > -1,
                        o.nameSecondary && o.available && e.availableImages && (o.available = e.availableImages.indexOf(o.nameSecondary) > -1)),
                        o
                    }
                    eachChild(e) {
                        if (e(this.inputPrimary),
                        this.inputPrimaryParams)
                            for (const o in this.inputPrimaryParams)
                                this.inputPrimaryParams[o] && e(this.inputPrimaryParams[o]);
                        if (this.inputSecondary && (e(this.inputSecondary),
                        this.inputSecondaryParams))
                            for (const o in this.inputSecondaryParams)
                                this.inputSecondaryParams[o] && e(this.inputSecondaryParams[o])
                    }
                    outputDefined() {
                        return !1
                    }
                    serializeParams(e) {
                        const o = {};
                        if (e) {
                            for (const a in e)
                                e[a] && (o[a] = e[a].serialize());
                            return {
                                params: o
                            }
                        }
                    }
                    serialize() {
                        const e = ["image", this.inputPrimary.serialize()];
                        return this.inputPrimaryParams && e.push(this.serializeParams(this.inputPrimaryParams)),
                        this.inputSecondary && (e.push(this.inputSecondary.serialize()),
                        this.inputSecondaryParams && e.push(this.serializeParams(this.inputSecondaryParams))),
                        e
                    }
                }
                function Ms(n) {
                    return n instanceof Number ? "number" : n instanceof String ? "string" : n instanceof Boolean ? "boolean" : Array.isArray(n) ? "array" : null === n ? "null" : typeof n
                }
                const ou = {
                    "to-boolean": bi,
                    "to-color": Hn,
                    "to-number": To,
                    "to-string": Pi
                };
                class Zr {
                    constructor(e, o) {
                        this.type = e,
                        this.args = o
                    }
                    static parse(e, o) {
                        if (e.length < 2)
                            return o.error("Expected at least one argument.");
                        const a = e[0]
                          , u = [];
                        let l = Ws;
                        if ("to-array" === a) {
                            if (!Array.isArray(e[1]))
                                return null;
                            const p = e[1].length;
                            if (o.expectedType) {
                                if ("array" !== o.expectedType.kind)
                                    return o.error("Expected ".concat(o.expectedType.kind, " but found array."));
                                l = An(o.expectedType.itemType, p)
                            } else {
                                if (!(p > 0 && Ps(e[1][0])))
                                    return null;
                                l = An(en(e[1][0]), p)
                            }
                            for (let g = 0; g < p; g++) {
                                const x = e[1][g];
                                let T;
                                if ("array" === Ms(x))
                                    T = o.parse(x, void 0, l.itemType);
                                else {
                                    const f = Ms(x);
                                    if (f !== l.itemType.kind)
                                        return o.error("Expected ".concat(l.itemType.kind, " but found ").concat(f, "."));
                                    T = o.registry.literal.parse(["literal", void 0 === x ? null : x], o)
                                }
                                if (!T)
                                    return null;
                                u.push(T)
                            }
                        } else {
                            if (("to-boolean" === a || "to-string" === a) && 2 !== e.length)
                                return o.error("Expected one argument.");
                            l = ou[a];
                            for (let p = 1; p < e.length; p++) {
                                const g = o.parse(e[p], p, _i);
                                if (!g)
                                    return null;
                                u.push(g)
                            }
                        }
                        return new Zr(l,u)
                    }
                    evaluate(e) {
                        if ("boolean" === this.type.kind)
                            return !!this.args[0].evaluate(e);
                        if ("color" === this.type.kind) {
                            let o, a;
                            for (const u of this.args) {
                                if (o = u.evaluate(e),
                                a = null,
                                o instanceof wi)
                                    return o;
                                if ("string" == typeof o) {
                                    const l = e.parseColor(o);
                                    if (l)
                                        return l
                                } else if (Array.isArray(o) && (a = o.length < 3 || o.length > 4 ? "Invalid rbga value ".concat(JSON.stringify(o), ": expected an array containing either three or four numeric values.") : ws(o[0], o[1], o[2], o[3]),
                                !a))
                                    return new wi(o[0] / 255,o[1] / 255,o[2] / 255,o[3])
                            }
                            throw new Xi(a || "Could not parse color from value '".concat("string" == typeof o ? o : String(JSON.stringify(o)), "'"))
                        }
                        if ("number" === this.type.kind) {
                            let o = null;
                            for (const a of this.args) {
                                if (o = a.evaluate(e),
                                null === o)
                                    return 0;
                                const u = Number(o);
                                if (!isNaN(u))
                                    return u
                            }
                            throw new Xi("Could not convert ".concat(JSON.stringify(o), " to number."))
                        }
                        return "formatted" === this.type.kind ? Nn.fromString(gr(this.args[0].evaluate(e))) : "resolvedImage" === this.type.kind ? In.build(gr(this.args[0].evaluate(e))) : "array" === this.type.kind ? this.args.map(o => o.evaluate(e)) : gr(this.args[0].evaluate(e))
                    }
                    eachChild(e) {
                        this.args.forEach(e)
                    }
                    outputDefined() {
                        return this.args.every(e => e.outputDefined())
                    }
                    serialize() {
                        if ("formatted" === this.type.kind)
                            return new Yr([{
                                content: this.args[0],
                                scale: null,
                                font: null,
                                textColor: null
                            }]).serialize();
                        if ("resolvedImage" === this.type.kind)
                            return new qs(this.args[0]).serialize();
                        const e = "array" === this.type.kind ? [] : ["to-".concat(this.type.kind)];
                        return this.eachChild(o => {
                            e.push(o.serialize())
                        }
                        ),
                        e
                    }
                }
                const Xc = ["Unknown", "Point", "LineString", "Polygon"];
                class Qa {
                    constructor(e, o) {
                        this.globals = null,
                        this.feature = null,
                        this.featureState = null,
                        this.formattedSection = null,
                        this._parseColorCache = {},
                        this.availableImages = null,
                        this.canonical = null,
                        this.featureTileCoord = null,
                        this.featureDistanceData = null,
                        this.scope = e,
                        this.options = o
                    }
                    id() {
                        return this.feature && void 0 !== this.feature.id ? this.feature.id : null
                    }
                    geometryType() {
                        return this.feature ? "number" == typeof this.feature.type ? Xc[this.feature.type] : this.feature.type : null
                    }
                    geometry() {
                        return this.feature && "geometry"in this.feature ? this.feature.geometry : null
                    }
                    canonicalID() {
                        return this.canonical
                    }
                    properties() {
                        return this.feature && this.feature.properties || {}
                    }
                    measureLight(e) {
                        return this.globals.brightness || 0
                    }
                    distanceFromCenter() {
                        if (this.featureTileCoord && this.featureDistanceData) {
                            const e = this.featureDistanceData.center
                              , o = this.featureDistanceData.scale
                              , {x: a, y: u} = this.featureTileCoord;
                            return this.featureDistanceData.bearing[0] * (a * o - e[0]) + this.featureDistanceData.bearing[1] * (u * o - e[1])
                        }
                        return 0
                    }
                    parseColor(e) {
                        let o = this._parseColorCache[e];
                        return o || (o = this._parseColorCache[e] = wi.parse(e)),
                        o
                    }
                    getConfig(e) {
                        return this.options ? this.options.get(e) : null
                    }
                }
                class nr {
                    constructor(e, o, a, u, l) {
                        this.name = e,
                        this.type = o,
                        this._evaluate = a,
                        this.args = u,
                        this._overloadIndex = l
                    }
                    evaluate(e) {
                        if (!this._evaluate) {
                            const o = nr.definitions[this.name];
                            this._evaluate = Array.isArray(o) ? o[2] : o.overloads[this._overloadIndex][1]
                        }
                        return this._evaluate(e, this.args)
                    }
                    eachChild(e) {
                        this.args.forEach(e)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        return [this.name].concat(this.args.map(e => e.serialize()))
                    }
                    static parse(e, o) {
                        const a = e[0]
                          , u = nr.definitions[a];
                        if (!u)
                            return o.error('Unknown expression "'.concat(a, '". If you wanted a literal array, use ["literal", [...]].'), 0);
                        const l = Array.isArray(u) ? u[0] : u.type
                          , p = Array.isArray(u) ? [[u[1], u[2]]] : u.overloads
                          , g = [];
                        let x = null
                          , T = -1;
                        for (const [f,b] of p) {
                            if (Array.isArray(f) && f.length !== e.length - 1)
                                continue;
                            g.push(f),
                            T++,
                            x = new ds(o.registry,o.path,null,o.scope,void 0,o._scope,o.options);
                            const P = [];
                            let v = !1;
                            for (let w = 1; w < e.length; w++) {
                                const C = e[w]
                                  , A = Array.isArray(f) ? f[w - 1] : f.type
                                  , O = x.parse(C, 1 + P.length, A);
                                if (!O) {
                                    v = !0;
                                    break
                                }
                                P.push(O)
                            }
                            if (!v)
                                if (Array.isArray(f) && f.length !== P.length)
                                    x.error("Expected ".concat(f.length, " arguments, but found ").concat(P.length, " instead."));
                                else {
                                    for (let w = 0; w < P.length; w++) {
                                        const C = Array.isArray(f) ? f[w] : f.type
                                          , A = P[w];
                                        x.concat(w + 1).checkSubtype(C, A.type)
                                    }
                                    if (0 === x.errors.length)
                                        return new nr(a,l,b,P,T)
                                }
                        }
                        if (1 === g.length)
                            o.errors.push(...x.errors);
                        else {
                            const f = (g.length ? g : p.map( ([P]) => P)).map(el).join(" | ")
                              , b = [];
                            for (let P = 1; P < e.length; P++) {
                                const v = o.parse(e[P], 1 + b.length);
                                if (!v)
                                    return null;
                                b.push(Vi(v.type))
                            }
                            o.error("Expected arguments of type ".concat(f, ", but found (").concat(b.join(", "), ") instead."))
                        }
                        return null
                    }
                    static register(e, o) {
                        nr.definitions = o;
                        for (const a in o)
                            e[a] = nr
                    }
                }
                function el(n) {
                    return Array.isArray(n) ? "(".concat(n.map(Vi).join(", "), ")") : "(".concat(Vi(n.type), "...)")
                }
                class tl {
                    constructor(e, o, a) {
                        this.type = Xl,
                        this.locale = a,
                        this.caseSensitive = e,
                        this.diacriticSensitive = o
                    }
                    static parse(e, o) {
                        if (2 !== e.length)
                            return o.error("Expected one argument.");
                        const a = e[1];
                        if ("object" != typeof a || Array.isArray(a))
                            return o.error("Collator options argument must be an object.");
                        const u = void 0 === a["case-sensitive"] ? o.parse(!1, 1, bi) : o.parseObjectValue(a["case-sensitive"], 1, "case-sensitive", bi);
                        if (!u)
                            return null;
                        const l = void 0 === a["diacritic-sensitive"] ? o.parse(!1, 1, bi) : o.parseObjectValue(a["diacritic-sensitive"], 1, "diacritic-sensitive", bi);
                        if (!l)
                            return null;
                        let p = null;
                        return a.locale && (p = o.parseObjectValue(a.locale, 1, "locale", Pi),
                        !p) ? null : new tl(u,l,p)
                    }
                    evaluate(e) {
                        return new Ja(this.caseSensitive.evaluate(e),this.diacriticSensitive.evaluate(e),this.locale ? this.locale.evaluate(e) : null)
                    }
                    eachChild(e) {
                        e(this.caseSensitive),
                        e(this.diacriticSensitive),
                        this.locale && e(this.locale)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        const e = {};
                        return e["case-sensitive"] = this.caseSensitive.serialize(),
                        e["diacritic-sensitive"] = this.diacriticSensitive.serialize(),
                        this.locale && (e.locale = this.locale.serialize()),
                        ["collator", e]
                    }
                }
                function Yc(n, e, o=0, a=n.length - 1, u=iu) {
                    for (; a > o; ) {
                        if (a - o > 600) {
                            const x = a - o + 1
                              , T = e - o + 1
                              , f = Math.log(x)
                              , b = .5 * Math.exp(2 * f / 3)
                              , P = .5 * Math.sqrt(f * b * (x - b) / x) * (T - x / 2 < 0 ? -1 : 1);
                            Yc(n, e, Math.max(o, Math.floor(e - T * b / x + P)), Math.min(a, Math.floor(e + (x - T) * b / x + P)), u)
                        }
                        const l = n[e];
                        let p = o
                          , g = a;
                        for (Ta(n, o, e),
                        u(n[a], l) > 0 && Ta(n, o, a); p < g; ) {
                            for (Ta(n, p, g),
                            p++,
                            g--; u(n[p], l) < 0; )
                                p++;
                            for (; u(n[g], l) > 0; )
                                g--
                        }
                        0 === u(n[o], l) ? Ta(n, o, g) : (g++,
                        Ta(n, g, a)),
                        g <= e && (o = g + 1),
                        e <= g && (a = g - 1)
                    }
                }
                function Ta(n, e, o) {
                    const a = n[e];
                    n[e] = n[o],
                    n[o] = a
                }
                function iu(n, e) {
                    return n < e ? -1 : n > e ? 1 : 0
                }
                function nu(n) {
                    let e = 0;
                    for (let o, a, u = 0, l = n.length, p = l - 1; u < l; p = u++)
                        o = n[u],
                        a = n[p],
                        e += (a.x - o.x) * (o.y + a.y);
                    return e
                }
                function Ca(n, e) {
                    n[0] = Math.min(n[0], e[0]),
                    n[1] = Math.min(n[1], e[1]),
                    n[2] = Math.max(n[2], e[0]),
                    n[3] = Math.max(n[3], e[1])
                }
                function Ea(n, e) {
                    return !(n[0] <= e[0] || n[2] >= e[2] || n[1] <= e[1] || n[3] >= e[3])
                }
                function Zc(n, e, o) {
                    const a = n[0] - e[0]
                      , u = n[1] - e[1]
                      , l = n[0] - o[0]
                      , p = n[1] - o[1];
                    return a * p - l * u == 0 && a * l <= 0 && u * p <= 0
                }
                function vr(n, e, o=!1) {
                    let a = !1;
                    for (let g = 0, x = e.length; g < x; g++) {
                        const T = e[g];
                        for (let f = 0, b = T.length, P = b - 1; f < b; P = f++) {
                            const v = T[P]
                              , w = T[f];
                            if (Zc(n, v, w))
                                return o;
                            (l = v)[1] > (u = n)[1] != (p = w)[1] > u[1] && u[0] < (p[0] - l[0]) * (u[1] - l[1]) / (p[1] - l[1]) + l[0] && (a = !a)
                        }
                    }
                    var u, l, p;
                    return a
                }
                function Kc(n, e, o, a) {
                    const u = a[0] - o[0]
                      , l = a[1] - o[1]
                      , p = (n[0] - o[0]) * l - u * (n[1] - o[1])
                      , g = (e[0] - o[0]) * l - u * (e[1] - o[1]);
                    return p > 0 && g < 0 || p < 0 && g > 0
                }
                function ol(n, e, o, a) {
                    return (u = [a[0] - o[0], a[1] - o[1]])[0] * (l = [e[0] - n[0], e[1] - n[1]])[1] - u[1] * l[0] != 0 && !(!Kc(n, e, o, a) || !Kc(o, a, n, e));
                    var u, l
                }
                const kr = 8192;
                function qc(n, e) {
                    const o = (180 + n[0]) / 360
                      , a = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + n[1] * Math.PI / 360))) / 360
                      , u = Math.pow(2, e.z);
                    return [Math.round(o * u * kr), Math.round(a * u * kr)]
                }
                function Jc(n, e) {
                    for (let o = 0; o < e.length; o++)
                        if (vr(n, e[o]))
                            return !0;
                    return !1
                }
                function ru(n, e, o) {
                    for (const a of o)
                        for (let u = 0, l = a.length, p = l - 1; u < l; p = u++)
                            if (ol(n, e, a[p], a[u]))
                                return !0;
                    return !1
                }
                function Yl(n, e) {
                    for (let o = 0; o < n.length; ++o)
                        if (!vr(n[o], e))
                            return !1;
                    for (let o = 0; o < n.length - 1; ++o)
                        if (ru(n[o], n[o + 1], e))
                            return !1;
                    return !0
                }
                function Js(n, e) {
                    for (let o = 0; o < e.length; o++)
                        if (Yl(n, e[o]))
                            return !0;
                    return !1
                }
                function si(n, e, o) {
                    const a = [];
                    for (let u = 0; u < n.length; u++) {
                        const l = [];
                        for (let p = 0; p < n[u].length; p++) {
                            const g = qc(n[u][p], o);
                            Ca(e, g),
                            l.push(g)
                        }
                        a.push(l)
                    }
                    return a
                }
                function Fo(n, e, o) {
                    const a = [];
                    for (let u = 0; u < n.length; u++) {
                        const l = si(n[u], e, o);
                        a.push(l)
                    }
                    return a
                }
                function Ts(n, e, o, a) {
                    if (n[0] < o[0] || n[0] > o[2]) {
                        const u = .5 * a;
                        let l = n[0] - o[0] > u ? -a : o[0] - n[0] > u ? a : 0;
                        0 === l && (l = n[0] - o[2] > u ? -a : o[2] - n[0] > u ? a : 0),
                        n[0] += l
                    }
                    Ca(e, n)
                }
                function Xo(n, e, o, a) {
                    const u = Math.pow(2, a.z) * kr
                      , l = [a.x * kr, a.y * kr]
                      , p = [];
                    if (!n)
                        return p;
                    for (const g of n)
                        for (const x of g) {
                            const T = [x.x + l[0], x.y + l[1]];
                            Ts(T, e, o, u),
                            p.push(T)
                        }
                    return p
                }
                function il(n, e, o, a) {
                    const u = Math.pow(2, a.z) * kr
                      , l = [a.x * kr, a.y * kr]
                      , p = [];
                    if (!n)
                        return p;
                    for (const x of n) {
                        const T = [];
                        for (const f of x) {
                            const b = [f.x + l[0], f.y + l[1]];
                            Ca(e, b),
                            T.push(b)
                        }
                        p.push(T)
                    }
                    if (e[2] - e[0] <= u / 2) {
                        (g = e)[0] = g[1] = 1 / 0,
                        g[2] = g[3] = -1 / 0;
                        for (const x of p)
                            for (const T of x)
                                Ts(T, e, o, u)
                    }
                    var g;
                    return p
                }
                class zr {
                    constructor(e, o) {
                        this.type = bi,
                        this.geojson = e,
                        this.geometries = o
                    }
                    static parse(e, o) {
                        if (2 !== e.length)
                            return o.error("'within' expression requires exactly one argument, but found ".concat(e.length - 1, " instead."));
                        if (Ps(e[1])) {
                            const a = e[1];
                            if ("FeatureCollection" === a.type)
                                for (let u = 0; u < a.features.length; ++u) {
                                    const l = a.features[u].geometry.type;
                                    if ("Polygon" === l || "MultiPolygon" === l)
                                        return new zr(a,a.features[u].geometry)
                                }
                            else if ("Feature" === a.type) {
                                const u = a.geometry.type;
                                if ("Polygon" === u || "MultiPolygon" === u)
                                    return new zr(a,a.geometry)
                            } else if ("Polygon" === a.type || "MultiPolygon" === a.type)
                                return new zr(a,a)
                        }
                        return o.error("'within' expression requires valid geojson object that contains polygon geometry type.")
                    }
                    evaluate(e) {
                        if (null != e.geometry() && null != e.canonicalID()) {
                            if ("Point" === e.geometryType())
                                return function(o, a) {
                                    const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , l = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , p = o.canonicalID();
                                    if (!p)
                                        return !1;
                                    if ("Polygon" === a.type) {
                                        const g = si(a.coordinates, l, p)
                                          , x = Xo(o.geometry(), u, l, p);
                                        if (!Ea(u, l))
                                            return !1;
                                        for (const T of x)
                                            if (!vr(T, g))
                                                return !1
                                    }
                                    if ("MultiPolygon" === a.type) {
                                        const g = Fo(a.coordinates, l, p)
                                          , x = Xo(o.geometry(), u, l, p);
                                        if (!Ea(u, l))
                                            return !1;
                                        for (const T of x)
                                            if (!Jc(T, g))
                                                return !1
                                    }
                                    return !0
                                }(e, this.geometries);
                            if ("LineString" === e.geometryType())
                                return function(o, a) {
                                    const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , l = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , p = o.canonicalID();
                                    if (!p)
                                        return !1;
                                    if ("Polygon" === a.type) {
                                        const g = si(a.coordinates, l, p)
                                          , x = il(o.geometry(), u, l, p);
                                        if (!Ea(u, l))
                                            return !1;
                                        for (const T of x)
                                            if (!Yl(T, g))
                                                return !1
                                    }
                                    if ("MultiPolygon" === a.type) {
                                        const g = Fo(a.coordinates, l, p)
                                          , x = il(o.geometry(), u, l, p);
                                        if (!Ea(u, l))
                                            return !1;
                                        for (const T of x)
                                            if (!Js(T, g))
                                                return !1
                                    }
                                    return !0
                                }(e, this.geometries)
                        }
                        return !1
                    }
                    eachChild() {}
                    outputDefined() {
                        return !0
                    }
                    serialize() {
                        return ["within", this.geojson]
                    }
                }
                const zo = {
                    kilometers: 1,
                    miles: 1e3 / 1609.344,
                    nauticalmiles: 1e3 / 1852,
                    meters: 1e3,
                    metres: 1e3,
                    yards: 1e3 / .9144,
                    feet: 1e3 / .3048,
                    inches: 1e3 / .0254
                }
                  , vn = 1 / 298.257223563
                  , nl = vn * (2 - vn)
                  , Qs = Math.PI / 180;
                class Cs {
                    static fromTile(e, o, a) {
                        const u = Math.PI * (1 - 2 * (e + .5) / Math.pow(2, o))
                          , l = Math.atan(.5 * (Math.exp(u) - Math.exp(-u))) / Qs;
                        return new Cs(l,a)
                    }
                    static get units() {
                        return zo
                    }
                    constructor(e, o) {
                        if (void 0 === e)
                            throw new Error("No latitude given.");
                        if (o && !zo[o])
                            throw new Error("Unknown unit ".concat(o, ". Use one of: ").concat(Object.keys(zo).join(", ")));
                        const a = 6378.137 * Qs * (o ? zo[o] : 1)
                          , u = Math.cos(e * Qs)
                          , l = 1 / (1 - nl * (1 - u * u))
                          , p = Math.sqrt(l);
                        this.kx = a * p * u,
                        this.ky = a * p * l * (1 - nl)
                    }
                    distance(e, o) {
                        const a = Kn(e[0] - o[0]) * this.kx
                          , u = (e[1] - o[1]) * this.ky;
                        return Math.sqrt(a * a + u * u)
                    }
                    bearing(e, o) {
                        const a = Kn(o[0] - e[0]) * this.kx;
                        return Math.atan2(a, (o[1] - e[1]) * this.ky) / Qs
                    }
                    destination(e, o, a) {
                        const u = a * Qs;
                        return this.offset(e, Math.sin(u) * o, Math.cos(u) * o)
                    }
                    offset(e, o, a) {
                        return [e[0] + o / this.kx, e[1] + a / this.ky]
                    }
                    lineDistance(e) {
                        let o = 0;
                        for (let a = 0; a < e.length - 1; a++)
                            o += this.distance(e[a], e[a + 1]);
                        return o
                    }
                    area(e) {
                        let o = 0;
                        for (let a = 0; a < e.length; a++) {
                            const u = e[a];
                            for (let l = 0, p = u.length, g = p - 1; l < p; g = l++)
                                o += Kn(u[l][0] - u[g][0]) * (u[l][1] + u[g][1]) * (a ? -1 : 1)
                        }
                        return Math.abs(o) / 2 * this.kx * this.ky
                    }
                    along(e, o) {
                        let a = 0;
                        if (o <= 0)
                            return e[0];
                        for (let u = 0; u < e.length - 1; u++) {
                            const l = e[u]
                              , p = e[u + 1]
                              , g = this.distance(l, p);
                            if (a += g,
                            a > o)
                                return wn(l, p, (o - (a - g)) / g)
                        }
                        return e[e.length - 1]
                    }
                    pointToSegmentDistance(e, o, a) {
                        let[u,l] = o
                          , p = Kn(a[0] - u) * this.kx
                          , g = (a[1] - l) * this.ky;
                        if (0 !== p || 0 !== g) {
                            const x = (Kn(e[0] - u) * this.kx * p + (e[1] - l) * this.ky * g) / (p * p + g * g);
                            x > 1 ? (u = a[0],
                            l = a[1]) : x > 0 && (u += p / this.kx * x,
                            l += g / this.ky * x)
                        }
                        return p = Kn(e[0] - u) * this.kx,
                        g = (e[1] - l) * this.ky,
                        Math.sqrt(p * p + g * g)
                    }
                    pointOnLine(e, o) {
                        let a = 1 / 0
                          , u = e[0][0]
                          , l = e[0][1]
                          , p = 0
                          , g = 0;
                        for (let x = 0; x < e.length - 1; x++) {
                            let T = e[x][0]
                              , f = e[x][1]
                              , b = Kn(e[x + 1][0] - T) * this.kx
                              , P = (e[x + 1][1] - f) * this.ky
                              , v = 0;
                            0 === b && 0 === P || (v = (Kn(o[0] - T) * this.kx * b + (o[1] - f) * this.ky * P) / (b * b + P * P),
                            v > 1 ? (T = e[x + 1][0],
                            f = e[x + 1][1]) : v > 0 && (T += b / this.kx * v,
                            f += P / this.ky * v)),
                            b = Kn(o[0] - T) * this.kx,
                            P = (o[1] - f) * this.ky;
                            const w = b * b + P * P;
                            w < a && (a = w,
                            u = T,
                            l = f,
                            p = x,
                            g = v)
                        }
                        return {
                            point: [u, l],
                            index: p,
                            t: Math.max(0, Math.min(1, g))
                        }
                    }
                    lineSlice(e, o, a) {
                        let u = this.pointOnLine(a, e)
                          , l = this.pointOnLine(a, o);
                        if (u.index > l.index || u.index === l.index && u.t > l.t) {
                            const T = u;
                            u = l,
                            l = T
                        }
                        const p = [u.point]
                          , g = u.index + 1
                          , x = l.index;
                        !ea(a[g], p[0]) && g <= x && p.push(a[g]);
                        for (let T = g + 1; T <= x; T++)
                            p.push(a[T]);
                        return ea(a[x], l.point) || p.push(l.point),
                        p
                    }
                    lineSliceAlong(e, o, a) {
                        let u = 0;
                        const l = [];
                        for (let p = 0; p < a.length - 1; p++) {
                            const g = a[p]
                              , x = a[p + 1]
                              , T = this.distance(g, x);
                            if (u += T,
                            u > e && 0 === l.length && l.push(wn(g, x, (e - (u - T)) / T)),
                            u >= o)
                                return l.push(wn(g, x, (o - (u - T)) / T)),
                                l;
                            u > e && l.push(x)
                        }
                        return l
                    }
                    bufferPoint(e, o) {
                        const a = o / this.ky
                          , u = o / this.kx;
                        return [e[0] - u, e[1] - a, e[0] + u, e[1] + a]
                    }
                    bufferBBox(e, o) {
                        const a = o / this.ky
                          , u = o / this.kx;
                        return [e[0] - u, e[1] - a, e[2] + u, e[3] + a]
                    }
                    insideBBox(e, o) {
                        return Kn(e[0] - o[0]) >= 0 && Kn(e[0] - o[2]) <= 0 && e[1] >= o[1] && e[1] <= o[3]
                    }
                }
                function ea(n, e) {
                    return n[0] === e[0] && n[1] === e[1]
                }
                function wn(n, e, o) {
                    const a = Kn(e[0] - n[0]);
                    return [n[0] + a * o, n[1] + (e[1] - n[1]) * o]
                }
                function Kn(n) {
                    for (; n < -180; )
                        n += 360;
                    for (; n > 180; )
                        n -= 360;
                    return n
                }
                class rl {
                    constructor(e=[], o= (a, u) => a < u ? -1 : a > u ? 1 : 0) {
                        if (this.data = e,
                        this.length = this.data.length,
                        this.compare = o,
                        this.length > 0)
                            for (let a = (this.length >> 1) - 1; a >= 0; a--)
                                this._down(a)
                    }
                    push(e) {
                        this.data.push(e),
                        this._up(this.length++)
                    }
                    pop() {
                        if (0 === this.length)
                            return;
                        const e = this.data[0]
                          , o = this.data.pop();
                        return --this.length > 0 && (this.data[0] = o,
                        this._down(0)),
                        e
                    }
                    peek() {
                        return this.data[0]
                    }
                    _up(e) {
                        const {data: o, compare: a} = this
                          , u = o[e];
                        for (; e > 0; ) {
                            const l = e - 1 >> 1
                              , p = o[l];
                            if (a(u, p) >= 0)
                                break;
                            o[e] = p,
                            e = l
                        }
                        o[e] = u
                    }
                    _down(e) {
                        const {data: o, compare: a} = this
                          , u = this.length >> 1
                          , l = o[e];
                        for (; e < u; ) {
                            let p = 1 + (e << 1);
                            const g = p + 1;
                            if (g < this.length && a(o[g], o[p]) < 0 && (p = g),
                            a(o[p], l) >= 0)
                                break;
                            o[e] = o[p],
                            e = p
                        }
                        o[e] = l
                    }
                }
                var uo = 8192;
                function sl(n, e) {
                    return e.dist - n.dist
                }
                function Qc(n) {
                    const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                    if (e.length !== n.length)
                        return !1;
                    for (let o = 0; o < e.length; o++)
                        if (e[o] !== n[o])
                            return !1;
                    return !0
                }
                function ta(n) {
                    return n[1] - n[0] + 1
                }
                function Br(n, e) {
                    const o = n[1] >= n[0] && n[1] < e;
                    return o || console.warn("Distance Expression: Index is out of range"),
                    o
                }
                function Es(n, e) {
                    if (n[0] > n[1])
                        return [null, null];
                    const o = ta(n);
                    if (e) {
                        if (2 === o)
                            return [n, null];
                        const a = Math.floor(o / 2);
                        return [[n[0], n[0] + a], [n[0] + a, n[1]]]
                    }
                    {
                        if (1 === o)
                            return [n, null];
                        const a = Math.floor(o / 2) - 1;
                        return [[n[0], n[0] + a], [n[0] + a + 1, n[1]]]
                    }
                }
                function Ss(n, e) {
                    const o = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                    if (!Br(e, n.length))
                        return o;
                    for (let a = e[0]; a <= e[1]; ++a)
                        Ca(o, n[a]);
                    return o
                }
                function oa(n) {
                    const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                    for (let o = 0; o < n.length; ++o)
                        for (let a = 0; a < n[o].length; ++a)
                            Ca(e, n[o][a]);
                    return e
                }
                function Sa(n, e, o) {
                    if (Qc(n) || Qc(e))
                        return NaN;
                    let a = 0
                      , u = 0;
                    return n[2] < e[0] && (a = e[0] - n[2]),
                    n[0] > e[2] && (a = n[0] - e[2]),
                    n[1] > e[3] && (u = n[1] - e[3]),
                    n[3] < e[1] && (u = e[1] - n[3]),
                    o.distance([0, 0], [a, u])
                }
                function su(n) {
                    return 360 * n - 180
                }
                function eh(n) {
                    return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n) * Math.PI / 180)) - 90
                }
                function th(n, e) {
                    const o = Math.pow(2, e.z)
                      , a = (n.y / uo + e.y) / o;
                    return [su((n.x / uo + e.x) / o), eh(a)]
                }
                function oh(n, e) {
                    const o = [];
                    for (let a = 0; a < n.length; ++a)
                        o.push(th(n[a], e));
                    return o
                }
                function au(n, e, o) {
                    const a = o.pointOnLine(e, n).point;
                    return o.distance(n, a)
                }
                function lu(n, e, o, a, u) {
                    const l = o.slice(a[0], a[1] + 1);
                    let p = 1 / 0;
                    for (let g = e[0]; g <= e[1]; ++g)
                        if (0 === (p = Math.min(p, au(n[g], l, u))))
                            return 0;
                    return p
                }
                function al(n, e, o, a, u) {
                    const l = Math.min(u.pointToSegmentDistance(n, o, a), u.pointToSegmentDistance(e, o, a))
                      , p = Math.min(u.pointToSegmentDistance(o, n, e), u.pointToSegmentDistance(a, n, e));
                    return Math.min(l, p)
                }
                function ia(n, e, o, a, u) {
                    if (!Br(e, n.length) || !Br(a, o.length))
                        return NaN;
                    let l = 1 / 0;
                    for (let p = e[0]; p < e[1]; ++p)
                        for (let g = a[0]; g < a[1]; ++g) {
                            if (ol(n[p], n[p + 1], o[g], o[g + 1]))
                                return 0;
                            l = Math.min(l, al(n[p], n[p + 1], o[g], o[g + 1], u))
                        }
                    return l
                }
                function cu(n, e, o, a, u) {
                    if (!Br(e, n.length) || !Br(a, o.length))
                        return NaN;
                    let l = 1 / 0;
                    for (let p = e[0]; p <= e[1]; ++p)
                        for (let g = a[0]; g <= a[1]; ++g)
                            if (0 === (l = Math.min(l, u.distance(n[p], o[g]))))
                                return l;
                    return l
                }
                function dp(n, e, o) {
                    if (vr(n, e, !0))
                        return 0;
                    let a = 1 / 0;
                    for (const u of e) {
                        const l = u.length;
                        if (l < 2)
                            return console.warn("Distance Expression: Invalid polygon!"),
                            NaN;
                        if (u[0] !== u[l - 1] && 0 === (a = Math.min(a, o.pointToSegmentDistance(n, u[l - 1], u[0]))) || 0 === (a = Math.min(a, au(n, u, o))))
                            return a
                    }
                    return a
                }
                function Zl(n, e, o, a) {
                    if (!Br(e, n.length))
                        return NaN;
                    for (let l = e[0]; l <= e[1]; ++l)
                        if (vr(n[l], o, !0))
                            return 0;
                    let u = 1 / 0;
                    for (let l = e[0]; l < e[1]; ++l)
                        for (const p of o)
                            for (let g = 0, x = p.length, T = x - 1; g < x; T = g++) {
                                if (ol(n[l], n[l + 1], p[T], p[g]))
                                    return 0;
                                u = Math.min(u, al(n[l], n[l + 1], p[T], p[g], a))
                            }
                    return u
                }
                function ih(n, e) {
                    for (const o of n)
                        for (let a = 0; a <= o.length - 1; ++a)
                            if (vr(o[a], e, !0))
                                return !0;
                    return !1
                }
                function nh(n, e, o, a=1 / 0) {
                    const u = oa(n)
                      , l = oa(e);
                    if (a !== 1 / 0 && Sa(u, l, o) >= a)
                        return a;
                    if (Ea(u, l)) {
                        if (ih(n, e))
                            return 0
                    } else if (ih(e, n))
                        return 0;
                    let p = a;
                    for (const g of n)
                        for (let x = 0, T = g.length, f = T - 1; x < T; f = x++)
                            for (const b of e)
                                for (let P = 0, v = b.length, w = v - 1; P < v; w = P++) {
                                    if (ol(g[f], g[x], b[w], b[P]))
                                        return 0;
                                    p = Math.min(p, al(g[f], g[x], b[w], b[P], o))
                                }
                    return p
                }
                function pr(n, e, o, a, u, l, p) {
                    if (null === l || null === p)
                        return;
                    const g = Sa(Ss(a, l), Ss(u, p), o);
                    g < e && n.push({
                        dist: g,
                        range1: l,
                        range2: p
                    })
                }
                function Kl(n, e, o, a, u=1 / 0) {
                    let l = Math.min(a.distance(n[0], o[0][0]), u);
                    if (0 === l)
                        return l;
                    const p = new rl([{
                        dist: 0,
                        range1: [0, n.length - 1],
                        range2: [0, 0]
                    }],sl)
                      , g = e ? 50 : 100
                      , x = oa(o);
                    for (; p.length; ) {
                        const T = p.pop();
                        if (T.dist >= l)
                            continue;
                        const f = T.range1;
                        if (ta(f) <= g) {
                            if (!Br(f, n.length))
                                return NaN;
                            if (e) {
                                const b = Zl(n, f, o, a);
                                if (0 === (l = Math.min(l, b)))
                                    return l
                            } else
                                for (let b = f[0]; b <= f[1]; ++b) {
                                    const P = dp(n[b], o, a);
                                    if (0 === (l = Math.min(l, P)))
                                        return l
                                }
                        } else {
                            const b = Es(f, e);
                            if (null !== b[0]) {
                                const P = Sa(Ss(n, b[0]), x, a);
                                P < l && p.push({
                                    dist: P,
                                    range1: b[0],
                                    range2: [0, 0]
                                })
                            }
                            if (null !== b[1]) {
                                const P = Sa(Ss(n, b[1]), x, a);
                                P < l && p.push({
                                    dist: P,
                                    range1: b[1],
                                    range2: [0, 0]
                                })
                            }
                        }
                    }
                    return l
                }
                function rh(n, e, o, a, u, l=1 / 0) {
                    let p = Math.min(l, u.distance(n[0], o[0]));
                    if (0 === p)
                        return p;
                    const g = new rl([{
                        dist: 0,
                        range1: [0, n.length - 1],
                        range2: [0, o.length - 1]
                    }],sl)
                      , x = e ? 50 : 100
                      , T = a ? 50 : 100;
                    for (; g.length; ) {
                        const f = g.pop();
                        if (f.dist >= p)
                            continue;
                        const b = f.range1
                          , P = f.range2;
                        if (ta(b) <= x && ta(P) <= T) {
                            if (!Br(b, n.length) || !Br(P, o.length))
                                return NaN;
                            if (e && a ? p = Math.min(p, ia(n, b, o, P, u)) : e || a ? e && !a ? p = Math.min(p, lu(o, P, n, b, u)) : !e && a && (p = Math.min(p, lu(n, b, o, P, u))) : p = Math.min(p, cu(n, b, o, P, u)),
                            0 === p)
                                return p
                        } else {
                            const v = Es(b, e)
                              , w = Es(P, a);
                            pr(g, p, u, n, o, v[0], w[0]),
                            pr(g, p, u, n, o, v[0], w[1]),
                            pr(g, p, u, n, o, v[1], w[0]),
                            pr(g, p, u, n, o, v[1], w[1])
                        }
                    }
                    return p
                }
                function ll(n, e, o, a, u=1 / 0) {
                    let l = u;
                    const p = Ss(n, [0, n.length - 1]);
                    for (const g of o)
                        if (!(l !== 1 / 0 && Sa(p, Ss(g, [0, g.length - 1]), a) >= l) && (l = Math.min(l, rh(n, e, g, !0, a, l)),
                        0 === l))
                            return l;
                    return l
                }
                function Is(n, e, o, a, u=1 / 0) {
                    let l = u;
                    const p = Ss(n, [0, n.length - 1]);
                    for (const g of o) {
                        if (l !== 1 / 0 && Sa(p, oa(g), a) >= l)
                            continue;
                        const x = Kl(n, e, g, a, l);
                        if (isNaN(x))
                            return x;
                        if (0 === (l = Math.min(l, x)))
                            return l
                    }
                    return l
                }
                function ql(n) {
                    return "Point" === n || "MultiPoint" === n || "LineString" === n || "MultiLineString" === n || "Polygon" === n || "MultiPolygon" === n
                }
                class us {
                    constructor(e, o) {
                        this.type = To,
                        this.geojson = e,
                        this.geometries = o
                    }
                    static parse(e, o) {
                        if (2 !== e.length)
                            return o.error("'distance' expression requires either one argument, but found ' ".concat(e.length - 1, " instead."));
                        if (Ps(e[1])) {
                            const a = e[1];
                            if ("FeatureCollection" === a.type) {
                                for (let u = 0; u < a.features.length; ++u)
                                    if (ql(a.features[u].geometry.type))
                                        return new us(a,a.features[u].geometry)
                            } else if ("Feature" === a.type) {
                                if (ql(a.geometry.type))
                                    return new us(a,a.geometry)
                            } else if (ql(a.type))
                                return new us(a,a)
                        }
                        return o.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj].")
                    }
                    evaluate(e) {
                        const o = e.geometry()
                          , a = e.canonicalID();
                        if (null != o && null != a) {
                            if ("Point" === e.geometryType())
                                return function(u, l, p) {
                                    const g = [];
                                    for (const T of u)
                                        for (const f of T)
                                            g.push(th(f, l));
                                    const x = new Cs(g[0][1],"meters");
                                    return "Point" === p.type || "MultiPoint" === p.type || "LineString" === p.type ? rh(g, !1, "Point" === p.type ? [p.coordinates] : p.coordinates, "LineString" === p.type, x) : "MultiLineString" === p.type ? ll(g, !1, p.coordinates, x) : "Polygon" === p.type || "MultiPolygon" === p.type ? Is(g, !1, "Polygon" === p.type ? [p.coordinates] : p.coordinates, x) : null
                                }(o, a, this.geometries);
                            if ("LineString" === e.geometryType())
                                return function(u, l, p) {
                                    const g = [];
                                    for (const T of u) {
                                        const f = [];
                                        for (const b of T)
                                            f.push(th(b, l));
                                        g.push(f)
                                    }
                                    const x = new Cs(g[0][0][1],"meters");
                                    if ("Point" === p.type || "MultiPoint" === p.type || "LineString" === p.type)
                                        return ll("Point" === p.type ? [p.coordinates] : p.coordinates, "LineString" === p.type, g, x);
                                    if ("MultiLineString" === p.type) {
                                        let T = 1 / 0;
                                        for (let f = 0; f < p.coordinates.length; f++) {
                                            const b = ll(p.coordinates[f], !0, g, x, T);
                                            if (isNaN(b))
                                                return b;
                                            if (0 === (T = Math.min(T, b)))
                                                return T
                                        }
                                        return T
                                    }
                                    if ("Polygon" === p.type || "MultiPolygon" === p.type) {
                                        let T = 1 / 0;
                                        for (let f = 0; f < g.length; f++) {
                                            const b = Is(g[f], !0, "Polygon" === p.type ? [p.coordinates] : p.coordinates, x, T);
                                            if (isNaN(b))
                                                return b;
                                            if (0 === (T = Math.min(T, b)))
                                                return T
                                        }
                                        return T
                                    }
                                    return null
                                }(o, a, this.geometries);
                            if ("Polygon" === e.geometryType())
                                return function(u, l, p) {
                                    const g = [];
                                    for (const T of function(f) {
                                        const P = f.length;
                                        if (P <= 1)
                                            return [f];
                                        const v = [];
                                        let w, C;
                                        for (let A = 0; A < P; A++) {
                                            const O = nu(f[A]);
                                            0 !== O && (f[A].area = Math.abs(O),
                                            void 0 === C && (C = O < 0),
                                            C === O < 0 ? (w && v.push(w),
                                            w = [f[A]]) : w.push(f[A]))
                                        }
                                        return w && v.push(w),
                                        v
                                    }(u)) {
                                        const f = [];
                                        for (let b = 0; b < T.length; ++b)
                                            f.push(oh(T[b], l));
                                        g.push(f)
                                    }
                                    const x = new Cs(g[0][0][0][1],"meters");
                                    if ("Point" === p.type || "MultiPoint" === p.type || "LineString" === p.type)
                                        return Is("Point" === p.type ? [p.coordinates] : p.coordinates, "LineString" === p.type, g, x);
                                    if ("MultiLineString" === p.type) {
                                        let T = 1 / 0;
                                        for (let f = 0; f < p.coordinates.length; f++) {
                                            const b = Is(p.coordinates[f], !0, g, x, T);
                                            if (isNaN(b))
                                                return b;
                                            if (0 === (T = Math.min(T, b)))
                                                return T
                                        }
                                        return T
                                    }
                                    return "Polygon" === p.type || "MultiPolygon" === p.type ? function(T, f, b) {
                                        let P = 1 / 0;
                                        for (const v of T)
                                            for (const w of f) {
                                                const C = nh(v, w, b, P);
                                                if (isNaN(C))
                                                    return C;
                                                if (0 === (P = Math.min(P, C)))
                                                    return P
                                            }
                                        return P
                                    }("Polygon" === p.type ? [p.coordinates] : p.coordinates, g, x) : null
                                }(o, a, this.geometries);
                            console.warn("Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.")
                        } else
                            console.warn("Distance Expression: requirs valid feature and canonical information.");
                        return null
                    }
                    eachChild() {}
                    outputDefined() {
                        return !0
                    }
                    serialize() {
                        return ["distance", this.geojson]
                    }
                }
                function Jl(n, e) {
                    switch (n) {
                    case "string":
                        return gr(e);
                    case "number":
                        return +e;
                    case "boolean":
                        return !!e;
                    case "color":
                        return wi.parse(e);
                    case "formatted":
                        return Nn.fromString(gr(e));
                    case "resolvedImage":
                        return In.build(gr(e))
                    }
                    return e
                }
                function cl(n, e, o, a) {
                    return void 0 !== a && (n = a * Math.round(n / a)),
                    void 0 !== e && n < e && (n = e),
                    void 0 !== o && n > o && (n = o),
                    n
                }
                class qn {
                    constructor(e, o, a) {
                        this.type = e,
                        this.key = o,
                        this.scope = a
                    }
                    static parse(e, o) {
                        let a = o.expectedType;
                        if (null == a && (a = _i),
                        e.length < 2 || e.length > 3)
                            return o.error("Invalid number of arguments for 'config' expression.");
                        const u = o.parse(e[1], 1);
                        if (!(u instanceof Ar))
                            return o.error("Key name of 'config' expression must be a string literal.");
                        if (e.length >= 3) {
                            const l = o.parse(e[2], 2);
                            return l instanceof Ar ? new qn(a,gr(u.value),gr(l.value)) : o.error("Scope of 'config' expression must be a string literal.")
                        }
                        return new qn(a,gr(u.value))
                    }
                    evaluate(e) {
                        const o = [this.key, this.scope, e.scope].filter(Boolean).join("\x1f")
                          , a = e.getConfig(o);
                        if (!a)
                            return null;
                        const {type: u, value: l, values: p, minValue: g, maxValue: x, stepValue: T} = a
                          , f = a.default.evaluate(e);
                        let b = f;
                        if (l) {
                            const P = e.scope;
                            e.scope = (P || "").split("\x1f").slice(1).join("\x1f"),
                            b = l.evaluate(e),
                            e.scope = P
                        }
                        return u && (b = Jl(u, b)),
                        void 0 === b || void 0 === g && void 0 === x && void 0 === T || ("number" == typeof b ? b = cl(b, g, x, T) : Array.isArray(b) && (b = b.map(P => "number" == typeof P ? cl(P, g, x, T) : P))),
                        void 0 !== l && void 0 !== b && p && !p.includes(b) && (b = f,
                        u && (b = Jl(u, b))),
                        (u && u !== this.type || void 0 !== b && en(b) !== this.type) && (b = Jl(this.type.kind, b)),
                        b
                    }
                    eachChild() {}
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        const e = ["config", this.key];
                        return this.scope && e.concat(this.key),
                        e
                    }
                }
                function Wn(n) {
                    if (n instanceof nr && ("get" === n.name && 1 === n.args.length || "feature-state" === n.name || "has" === n.name && 1 === n.args.length || "properties" === n.name || "geometry-type" === n.name || "id" === n.name || /^filter-/.test(n.name)) || n instanceof zr || n instanceof us)
                        return !1;
                    let e = !0;
                    return n.eachChild(o => {
                        e && !Wn(o) && (e = !1)
                    }
                    ),
                    e
                }
                function ps(n) {
                    if (n instanceof nr && "feature-state" === n.name)
                        return !1;
                    let e = !0;
                    return n.eachChild(o => {
                        e && !ps(o) && (e = !1)
                    }
                    ),
                    e
                }
                function zn(n) {
                    if (n instanceof qn)
                        return new Set([n.key]);
                    let e = new Set;
                    return n.eachChild(o => {
                        e = new Set([...e, ...zn(o)])
                    }
                    ),
                    e
                }
                function rr(n, e) {
                    if (n instanceof nr && e.indexOf(n.name) >= 0)
                        return !1;
                    let o = !0;
                    return n.eachChild(a => {
                        o && !rr(a, e) && (o = !1)
                    }
                    ),
                    o
                }
                class qr {
                    constructor(e, o) {
                        this.type = o.type,
                        this.name = e,
                        this.boundExpression = o
                    }
                    static parse(e, o) {
                        if (2 !== e.length || "string" != typeof e[1])
                            return o.error("'var' expression requires exactly one string literal argument.");
                        const a = e[1];
                        return o.scope.has(a) ? new qr(a,o.scope.get(a)) : o.error('Unknown variable "'.concat(a, '". Make sure "').concat(a, '" has been bound in an enclosing "let" expression before using it.'), 1)
                    }
                    evaluate(e) {
                        return this.boundExpression.evaluate(e)
                    }
                    eachChild() {}
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        return ["var", this.name]
                    }
                }
                class As {
                    constructor(e, o=[], a, u=new Wl, l=[], p, g) {
                        this.registry = e,
                        this.path = o,
                        this.key = o.map(x => "string" == typeof x ? "['".concat(x, "']") : "[".concat(x, "]")).join(""),
                        this.scope = u,
                        this.errors = l,
                        this.expectedType = a,
                        this._scope = p,
                        this.options = g
                    }
                    parse(e, o, a, u, l={}) {
                        return o || a ? this.concat(o, null, a, u)._parse(e, l) : this._parse(e, l)
                    }
                    parseObjectValue(e, o, a, u, l, p={}) {
                        return this.concat(o, a, u, l)._parse(e, p)
                    }
                    _parse(e, o) {
                        function a(u, l, p) {
                            return "assert" === p ? new On(l,[u]) : "coerce" === p ? new Zr(l,[u]) : u
                        }
                        if (null !== e && "string" != typeof e && "boolean" != typeof e && "number" != typeof e || (e = ["literal", e]),
                        Array.isArray(e)) {
                            if (0 === e.length)
                                return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                            const u = "string" == typeof e[0] ? this.registry[e[0]] : void 0;
                            if (u) {
                                let l = u.parse(e, this);
                                if (!l)
                                    return null;
                                if (this.expectedType) {
                                    const p = this.expectedType
                                      , g = l.type;
                                    if ("string" !== p.kind && "number" !== p.kind && "boolean" !== p.kind && "object" !== p.kind && "array" !== p.kind || "value" !== g.kind)
                                        if ("color" !== p.kind && "formatted" !== p.kind && "resolvedImage" !== p.kind || "value" !== g.kind && "string" !== g.kind) {
                                            if (this.checkSubtype(p, g))
                                                return null
                                        } else
                                            l = a(l, p, o.typeAnnotation || "coerce");
                                    else
                                        l = a(l, p, o.typeAnnotation || "assert")
                                }
                                if (!(l instanceof Ar) && "resolvedImage" !== l.type.kind && Ia(l)) {
                                    const p = new Qa(this._scope,this.options);
                                    try {
                                        l = new Ar(l.type,l.evaluate(p))
                                    } catch (g) {
                                        return this.error(g.message),
                                        null
                                    }
                                }
                                return l
                            }
                            return Zr.parse(["to-array", e], this)
                        }
                        return this.error(void 0 === e ? "'undefined' value invalid. Use null instead." : "object" == typeof e ? 'Bare objects invalid. Use ["literal", {...}] instead.' : "Expected an array, but found ".concat(typeof e, " instead."))
                    }
                    concat(e, o, a, u) {
                        let l = "number" == typeof e ? this.path.concat(e) : this.path;
                        l = "string" == typeof o ? l.concat(o) : l;
                        const p = u ? this.scope.concat(u) : this.scope;
                        return new As(this.registry,l,a || null,p,this.errors,this._scope,this.options)
                    }
                    error(e, ...o) {
                        const a = "".concat(this.key).concat(o.map(u => "[".concat(u, "]")).join(""));
                        this.errors.push(new Zn(a,e))
                    }
                    checkSubtype(e, o) {
                        const a = Zs(e, o);
                        return a && this.error(a),
                        a
                    }
                }
                var ds = As;
                function Ia(n) {
                    if (n instanceof qr)
                        return Ia(n.boundExpression);
                    if (n instanceof nr && "error" === n.name || n instanceof tl || n instanceof zr || n instanceof us || n instanceof qn)
                        return !1;
                    const e = n instanceof Zr || n instanceof On;
                    let o = !0;
                    return n.eachChild(a => {
                        o = e ? o && Ia(a) : o && a instanceof Ar
                    }
                    ),
                    !!o && Wn(n) && rr(n, ["zoom", "heatmap-density", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light", "raster-particle-speed"])
                }
                function Ur(n, e) {
                    const o = n.length - 1;
                    let a, u, l = 0, p = o, g = 0;
                    for (; l <= p; )
                        if (g = Math.floor((l + p) / 2),
                        a = n[g],
                        u = n[g + 1],
                        a <= e) {
                            if (g === o || e < u)
                                return g;
                            l = g + 1
                        } else {
                            if (!(a > e))
                                throw new Xi("Input is not a number.");
                            p = g - 1
                        }
                    return 0
                }
                class mi {
                    constructor(e, o, a) {
                        this.type = e,
                        this.input = o,
                        this.labels = [],
                        this.outputs = [];
                        for (const [u,l] of a)
                            this.labels.push(u),
                            this.outputs.push(l)
                    }
                    static parse(e, o) {
                        if (e.length - 1 < 4)
                            return o.error("Expected at least 4 arguments, but found only ".concat(e.length - 1, "."));
                        if ((e.length - 1) % 2 != 0)
                            return o.error("Expected an even number of arguments.");
                        const a = o.parse(e[1], 1, To);
                        if (!a)
                            return null;
                        const u = [];
                        let l = null;
                        o.expectedType && "value" !== o.expectedType.kind && (l = o.expectedType);
                        for (let p = 1; p < e.length; p += 2) {
                            const g = 1 === p ? -1 / 0 : e[p]
                              , x = e[p + 1]
                              , T = p
                              , f = p + 1;
                            if ("number" != typeof g)
                                return o.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', T);
                            if (u.length && u[u.length - 1][0] >= g)
                                return o.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', T);
                            const b = o.parse(x, f, l);
                            if (!b)
                                return null;
                            l = l || b.type,
                            u.push([g, b])
                        }
                        return new mi(l,a,u)
                    }
                    evaluate(e) {
                        const o = this.labels
                          , a = this.outputs;
                        if (1 === o.length)
                            return a[0].evaluate(e);
                        const u = this.input.evaluate(e);
                        if (u <= o[0])
                            return a[0].evaluate(e);
                        const l = o.length;
                        return u >= o[l - 1] ? a[l - 1].evaluate(e) : a[Ur(o, u)].evaluate(e)
                    }
                    eachChild(e) {
                        e(this.input);
                        for (const o of this.outputs)
                            e(o)
                    }
                    outputDefined() {
                        return this.outputs.every(e => e.outputDefined())
                    }
                    serialize() {
                        const e = ["step", this.input.serialize()];
                        for (let o = 0; o < this.labels.length; o++)
                            o > 0 && e.push(this.labels[o]),
                            e.push(this.outputs[o].serialize());
                        return e
                    }
                }
                const tc = 4 / 29
                  , ms = 6 / 29
                  , oc = 3 * ms * ms
                  , qi = ms * ms * ms
                  , sh = Math.PI / 180
                  , ah = 180 / Math.PI;
                function fs(n) {
                    return n > qi ? Math.pow(n, 1 / 3) : n / oc + tc
                }
                function xn(n) {
                    return n > ms ? n * n * n : oc * (n - tc)
                }
                function $n(n) {
                    return 255 * (n <= .0031308 ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - .055)
                }
                function hl(n) {
                    return (n /= 255) <= .04045 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4)
                }
                function ic(n) {
                    const e = hl(n.r)
                      , o = hl(n.g)
                      , a = hl(n.b)
                      , u = fs((.4124564 * e + .3575761 * o + .1804375 * a) / .95047)
                      , l = fs((.2126729 * e + .7151522 * o + .072175 * a) / 1);
                    return {
                        l: 116 * l - 16,
                        a: 500 * (u - l),
                        b: 200 * (l - fs((.0193339 * e + .119192 * o + .9503041 * a) / 1.08883)),
                        alpha: n.a
                    }
                }
                function lh(n) {
                    let e = (n.l + 16) / 116
                      , o = isNaN(n.a) ? e : e + n.a / 500
                      , a = isNaN(n.b) ? e : e - n.b / 200;
                    return e = 1 * xn(e),
                    o = .95047 * xn(o),
                    a = 1.08883 * xn(a),
                    new wi($n(3.2404542 * o - 1.5371385 * e - .4985314 * a),$n(-.969266 * o + 1.8760108 * e + .041556 * a),$n(.0556434 * o - .2040259 * e + 1.0572252 * a),n.alpha)
                }
                function hu(n, e, o) {
                    const a = e - n;
                    return n + o * (a > 180 || a < -180 ? a - 360 * Math.round(a / 360) : a)
                }
                const Aa = {
                    forward: ic,
                    reverse: lh,
                    interpolate: function(n, e, o) {
                        return {
                            l: jo(n.l, e.l, o),
                            a: jo(n.a, e.a, o),
                            b: jo(n.b, e.b, o),
                            alpha: jo(n.alpha, e.alpha, o)
                        }
                    }
                }
                  , _s = {
                    forward: function(n) {
                        const {l: e, a: o, b: a} = ic(n)
                          , u = Math.atan2(a, o) * ah;
                        return {
                            h: u < 0 ? u + 360 : u,
                            c: Math.sqrt(o * o + a * a),
                            l: e,
                            alpha: n.a
                        }
                    },
                    reverse: function(n) {
                        const e = n.h * sh
                          , o = n.c;
                        return lh({
                            l: n.l,
                            a: Math.cos(e) * o,
                            b: Math.sin(e) * o,
                            alpha: n.alpha
                        })
                    },
                    interpolate: function(n, e, o) {
                        return {
                            h: hu(n.h, e.h, o),
                            c: jo(n.c, e.c, o),
                            l: jo(n.l, e.l, o),
                            alpha: jo(n.alpha, e.alpha, o)
                        }
                    }
                };
                var uu = Object.freeze({
                    __proto__: null,
                    hcl: _s,
                    lab: Aa
                });
                class Jn {
                    constructor(e, o, a, u, l, p) {
                        this.type = e,
                        this.operator = o,
                        this.interpolation = a,
                        this.input = u,
                        this.dynamicStops = l,
                        this.labels = [],
                        this.outputs = [];
                        for (const [g,x] of p)
                            this.labels.push(g),
                            this.outputs.push(x)
                    }
                    static interpolationFactor(e, o, a, u) {
                        let l = 0;
                        if ("exponential" === e.name)
                            l = nc(o, e.base, a, u);
                        else if ("linear" === e.name)
                            l = nc(o, 1, a, u);
                        else if ("cubic-bezier" === e.name) {
                            const p = e.controlPoints;
                            l = new lt(p[0],p[1],p[2],p[3]).solve(nc(o, 1, a, u))
                        }
                        return l
                    }
                    static parse(e, o) {
                        let[a,u,l,...p] = e;
                        if (!Array.isArray(u) || 0 === u.length)
                            return o.error("Expected an interpolation type expression.", 1);
                        if ("linear" === u[0])
                            u = {
                                name: "linear"
                            };
                        else if ("exponential" === u[0]) {
                            const T = u[1];
                            if ("number" != typeof T)
                                return o.error("Exponential interpolation requires a numeric base.", 1, 1);
                            u = {
                                name: "exponential",
                                base: T
                            }
                        } else {
                            if ("cubic-bezier" !== u[0])
                                return o.error("Unknown interpolation type ".concat(String(u[0])), 1, 0);
                            {
                                const T = u.slice(1);
                                if (4 !== T.length || T.some(f => "number" != typeof f || f < 0 || f > 1))
                                    return o.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                                u = {
                                    name: "cubic-bezier",
                                    controlPoints: T
                                }
                            }
                        }
                        if (e.length - 1 < 3)
                            return o.error("Expected at least 3 arguments, but found only ".concat(e.length - 1, "."));
                        if (e.length - 1 > 3 && (e.length - 1) % 2 != 0)
                            return o.error("Expected an even number of arguments.");
                        if (l = o.parse(l, 2, To),
                        !l)
                            return null;
                        const g = [];
                        let x = null;
                        if ("interpolate-hcl" === a || "interpolate-lab" === a ? x = Hn : o.expectedType && "value" !== o.expectedType.kind && (x = o.expectedType),
                        e.length - 1 == 3) {
                            const T = o.parse(p[0], 3, _i);
                            return T ? new Jn(x,a,u,l,T,g) : null
                        }
                        for (let T = 0; T < p.length; T += 2) {
                            const f = p[T]
                              , b = p[T + 1]
                              , P = T + 3
                              , v = T + 4;
                            if ("number" != typeof f)
                                return o.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', P);
                            if (g.length && g[g.length - 1][0] >= f)
                                return o.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', P);
                            const w = o.parse(b, v, x);
                            if (!w)
                                return null;
                            x = x || w.type,
                            g.push([f, w])
                        }
                        return "number" === x.kind || "color" === x.kind || "array" === x.kind && "number" === x.itemType.kind && "number" == typeof x.N ? new Jn(x,a,u,l,null,g) : o.error("Type ".concat(Vi(x), " is not interpolatable."))
                    }
                    evaluate(e) {
                        let o = this.labels
                          , a = this.outputs;
                        if (this.dynamicStops) {
                            const f = this.dynamicStops.evaluate(e);
                            if (f.length % 2 != 0)
                                throw new Xi("Expected an even number of arguments.");
                            o = [],
                            a = [];
                            for (let b = 0; b < f.length; b += 2) {
                                const P = f[b]
                                  , v = new Ar(To,f[b + 1]);
                                if ("number" != typeof P)
                                    throw new Xi('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.');
                                if (o.length && o[o.length - 1] >= P)
                                    throw new Xi('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.');
                                o.push(P),
                                a.push(v)
                            }
                            if (0 === o.length)
                                throw new Xi("Expected at least one input/output pair.")
                        }
                        if (1 === o.length)
                            return a[0].evaluate(e);
                        const u = this.input.evaluate(e);
                        if (u <= o[0])
                            return a[0].evaluate(e);
                        const l = o.length;
                        if (u >= o[l - 1])
                            return a[l - 1].evaluate(e);
                        const p = Ur(o, u)
                          , g = Jn.interpolationFactor(this.interpolation, u, o[p], o[p + 1])
                          , x = a[p].evaluate(e)
                          , T = a[p + 1].evaluate(e);
                        return "interpolate" === this.operator ? xi[this.type.kind.toLowerCase()](x, T, g) : "interpolate-hcl" === this.operator ? _s.reverse(_s.interpolate(_s.forward(x), _s.forward(T), g)) : Aa.reverse(Aa.interpolate(Aa.forward(x), Aa.forward(T), g))
                    }
                    eachChild(e) {
                        e(this.input);
                        for (const o of this.outputs)
                            e(o)
                    }
                    outputDefined() {
                        return this.outputs.every(e => e.outputDefined())
                    }
                    serialize() {
                        let e;
                        e = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
                        const o = [this.operator, e, this.input.serialize()];
                        if (this.dynamicStops)
                            o.push(this.dynamicStops.serialize());
                        else
                            for (let a = 0; a < this.labels.length; a++)
                                o.push(this.labels[a], this.outputs[a].serialize());
                        return o
                    }
                }
                function nc(n, e, o, a) {
                    const u = a - o
                      , l = n - o;
                    return 0 === u ? 0 : 1 === e ? l / u : (Math.pow(e, l) - 1) / (Math.pow(e, u) - 1)
                }
                class rc {
                    constructor(e, o) {
                        this.type = e,
                        this.args = o
                    }
                    static parse(e, o) {
                        if (e.length < 2)
                            return o.error("Expectected at least one argument.");
                        let a = null;
                        const u = o.expectedType;
                        u && "value" !== u.kind && (a = u);
                        const l = [];
                        for (const g of e.slice(1)) {
                            const x = o.parse(g, 1 + l.length, a, void 0, {
                                typeAnnotation: "omit"
                            });
                            if (!x)
                                return null;
                            a = a || x.type,
                            l.push(x)
                        }
                        const p = u && l.some(g => Zs(u, g.type));
                        return new rc(p ? _i : a,l)
                    }
                    evaluate(e) {
                        let o, a = null, u = 0;
                        for (const l of this.args) {
                            if (u++,
                            a = l.evaluate(e),
                            a && a instanceof In && !a.available && (o || (o = a),
                            a = null,
                            u === this.args.length))
                                return o;
                            if (null !== a)
                                break
                        }
                        return a
                    }
                    eachChild(e) {
                        this.args.forEach(e)
                    }
                    outputDefined() {
                        return this.args.every(e => e.outputDefined())
                    }
                    serialize() {
                        const e = ["coalesce"];
                        return this.eachChild(o => {
                            e.push(o.serialize())
                        }
                        ),
                        e
                    }
                }
                class ul {
                    constructor(e, o) {
                        this.type = o.type,
                        this.bindings = [].concat(e),
                        this.result = o
                    }
                    evaluate(e) {
                        return this.result.evaluate(e)
                    }
                    eachChild(e) {
                        for (const o of this.bindings)
                            e(o[1]);
                        e(this.result)
                    }
                    static parse(e, o) {
                        if (e.length < 4)
                            return o.error("Expected at least 3 arguments, but found ".concat(e.length - 1, " instead."));
                        const a = [];
                        for (let l = 1; l < e.length - 1; l += 2) {
                            const p = e[l];
                            if ("string" != typeof p)
                                return o.error("Expected string, but found ".concat(typeof p, " instead."), l);
                            if (/[^a-zA-Z0-9_]/.test(p))
                                return o.error("Variable names must contain only alphanumeric characters or '_'.", l);
                            const g = o.parse(e[l + 1], l + 1);
                            if (!g)
                                return null;
                            a.push([p, g])
                        }
                        const u = o.parse(e[e.length - 1], e.length - 1, o.expectedType, a);
                        return u ? new ul(a,u) : null
                    }
                    outputDefined() {
                        return this.result.outputDefined()
                    }
                    serialize() {
                        const e = ["let"];
                        for (const [o,a] of this.bindings)
                            e.push(o, a.serialize());
                        return e.push(this.result.serialize()),
                        e
                    }
                }
                class Oa {
                    constructor(e, o, a) {
                        this.type = e,
                        this.index = o,
                        this.input = a
                    }
                    static parse(e, o) {
                        if (3 !== e.length)
                            return o.error("Expected 2 arguments, but found ".concat(e.length - 1, " instead."));
                        const a = o.parse(e[1], 1, To)
                          , u = o.parse(e[2], 2, An(o.expectedType || _i));
                        return a && u ? new Oa(u.type.itemType,a,u) : null
                    }
                    evaluate(e) {
                        const o = this.index.evaluate(e)
                          , a = this.input.evaluate(e);
                        if (o < 0)
                            throw new Xi("Array index out of bounds: ".concat(o, " < 0."));
                        if (o > a.length - 1)
                            throw new Xi("Array index out of bounds: ".concat(o, " > ").concat(a.length - 1, "."));
                        if (o === Math.floor(o))
                            return a[o];
                        const u = Math.floor(o)
                          , l = Math.ceil(o)
                          , p = a[u]
                          , g = a[l];
                        if ("number" != typeof p || "number" != typeof g)
                            throw new Xi("Cannot interpolate between non-number values at index ".concat(o, "."));
                        const x = o - u;
                        return p * (1 - x) + g * x
                    }
                    eachChild(e) {
                        e(this.index),
                        e(this.input)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        return ["at", this.index.serialize(), this.input.serialize()]
                    }
                }
                class ch {
                    constructor(e, o) {
                        this.type = bi,
                        this.needle = e,
                        this.haystack = o
                    }
                    static parse(e, o) {
                        if (3 !== e.length)
                            return o.error("Expected 2 arguments, but found ".concat(e.length - 1, " instead."));
                        const a = o.parse(e[1], 1, _i)
                          , u = o.parse(e[2], 2, _i);
                        return a && u ? Pa(a.type, [bi, Pi, To, Ws, _i]) ? new ch(a,u) : o.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(Vi(a.type), " instead")) : null
                    }
                    evaluate(e) {
                        const o = this.needle.evaluate(e)
                          , a = this.haystack.evaluate(e);
                        if (null == a)
                            return !1;
                        if (!Ks(o, ["boolean", "string", "number", "null"]))
                            throw new Xi("Expected first argument to be of type boolean, string, number or null, but found ".concat(Vi(en(o)), " instead."));
                        if (!Ks(a, ["string", "array"]))
                            throw new Xi("Expected second argument to be of type array or string, but found ".concat(Vi(en(a)), " instead."));
                        return a.indexOf(o) >= 0
                    }
                    eachChild(e) {
                        e(this.needle),
                        e(this.haystack)
                    }
                    outputDefined() {
                        return !0
                    }
                    serialize() {
                        return ["in", this.needle.serialize(), this.haystack.serialize()]
                    }
                }
                class sc {
                    constructor(e, o, a) {
                        this.type = To,
                        this.needle = e,
                        this.haystack = o,
                        this.fromIndex = a
                    }
                    static parse(e, o) {
                        if (e.length <= 2 || e.length >= 5)
                            return o.error("Expected 3 or 4 arguments, but found ".concat(e.length - 1, " instead."));
                        const a = o.parse(e[1], 1, _i)
                          , u = o.parse(e[2], 2, _i);
                        if (!a || !u)
                            return null;
                        if (!Pa(a.type, [bi, Pi, To, Ws, _i]))
                            return o.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(Vi(a.type), " instead"));
                        if (4 === e.length) {
                            const l = o.parse(e[3], 3, To);
                            return l ? new sc(a,u,l) : null
                        }
                        return new sc(a,u)
                    }
                    evaluate(e) {
                        const o = this.needle.evaluate(e)
                          , a = this.haystack.evaluate(e);
                        if (!Ks(o, ["boolean", "string", "number", "null"]))
                            throw new Xi("Expected first argument to be of type boolean, string, number or null, but found ".concat(Vi(en(o)), " instead."));
                        if (!Ks(a, ["string", "array"]))
                            throw new Xi("Expected second argument to be of type array or string, but found ".concat(Vi(en(a)), " instead."));
                        if (this.fromIndex) {
                            const u = this.fromIndex.evaluate(e);
                            return a.indexOf(o, u)
                        }
                        return a.indexOf(o)
                    }
                    eachChild(e) {
                        e(this.needle),
                        e(this.haystack),
                        this.fromIndex && e(this.fromIndex)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        if (null != this.fromIndex && void 0 !== this.fromIndex) {
                            const e = this.fromIndex.serialize();
                            return ["index-of", this.needle.serialize(), this.haystack.serialize(), e]
                        }
                        return ["index-of", this.needle.serialize(), this.haystack.serialize()]
                    }
                }
                class ac {
                    constructor(e, o, a, u, l, p) {
                        this.inputType = e,
                        this.type = o,
                        this.input = a,
                        this.cases = u,
                        this.outputs = l,
                        this.otherwise = p
                    }
                    static parse(e, o) {
                        if (e.length < 5)
                            return o.error("Expected at least 4 arguments, but found only ".concat(e.length - 1, "."));
                        if (e.length % 2 != 1)
                            return o.error("Expected an even number of arguments.");
                        let a, u;
                        o.expectedType && "value" !== o.expectedType.kind && (u = o.expectedType);
                        const l = {}
                          , p = [];
                        for (let T = 2; T < e.length - 1; T += 2) {
                            let f = e[T];
                            const b = e[T + 1];
                            Array.isArray(f) || (f = [f]);
                            const P = o.concat(T);
                            if (0 === f.length)
                                return P.error("Expected at least one branch label.");
                            for (const w of f) {
                                if ("number" != typeof w && "string" != typeof w)
                                    return P.error("Branch labels must be numbers or strings.");
                                if ("number" == typeof w && Math.abs(w) > Number.MAX_SAFE_INTEGER)
                                    return P.error("Branch labels must be integers no larger than ".concat(Number.MAX_SAFE_INTEGER, "."));
                                if ("number" == typeof w && Math.floor(w) !== w)
                                    return P.error("Numeric branch labels must be integer values.");
                                if (a) {
                                    if (P.checkSubtype(a, en(w)))
                                        return null
                                } else
                                    a = en(w);
                                if (void 0 !== l[String(w)])
                                    return P.error("Branch labels must be unique.");
                                l[String(w)] = p.length
                            }
                            const v = o.parse(b, T, u);
                            if (!v)
                                return null;
                            u = u || v.type,
                            p.push(v)
                        }
                        const g = o.parse(e[1], 1, _i);
                        if (!g)
                            return null;
                        const x = o.parse(e[e.length - 1], e.length - 1, u);
                        return x ? "value" !== g.type.kind && o.concat(1).checkSubtype(a, g.type) ? null : new ac(a,u,g,l,p,x) : null
                    }
                    evaluate(e) {
                        const o = this.input.evaluate(e);
                        return (en(o) === this.inputType && this.outputs[this.cases[o]] || this.otherwise).evaluate(e)
                    }
                    eachChild(e) {
                        e(this.input),
                        this.outputs.forEach(e),
                        e(this.otherwise)
                    }
                    outputDefined() {
                        return this.outputs.every(e => e.outputDefined()) && this.otherwise.outputDefined()
                    }
                    serialize() {
                        const e = ["match", this.input.serialize()]
                          , o = Object.keys(this.cases).sort()
                          , a = []
                          , u = {};
                        for (const p of o) {
                            const g = u[this.cases[p]];
                            void 0 === g ? (u[this.cases[p]] = a.length,
                            a.push([this.cases[p], [p]])) : a[g][1].push(p)
                        }
                        const l = p => "number" === this.inputType.kind ? Number(p) : p;
                        for (const [p,g] of a)
                            e.push(1 === g.length ? l(g[0]) : g.map(l)),
                            e.push(this.outputs[p].serialize());
                        return e.push(this.otherwise.serialize()),
                        e
                    }
                }
                class lc {
                    constructor(e, o, a) {
                        this.type = e,
                        this.branches = o,
                        this.otherwise = a
                    }
                    static parse(e, o) {
                        if (e.length < 4)
                            return o.error("Expected at least 3 arguments, but found only ".concat(e.length - 1, "."));
                        if (e.length % 2 != 0)
                            return o.error("Expected an odd number of arguments.");
                        let a;
                        o.expectedType && "value" !== o.expectedType.kind && (a = o.expectedType);
                        const u = [];
                        for (let p = 1; p < e.length - 1; p += 2) {
                            const g = o.parse(e[p], p, bi);
                            if (!g)
                                return null;
                            const x = o.parse(e[p + 1], p + 1, a);
                            if (!x)
                                return null;
                            u.push([g, x]),
                            a = a || x.type
                        }
                        const l = o.parse(e[e.length - 1], e.length - 1, a);
                        return l ? new lc(a,u,l) : null
                    }
                    evaluate(e) {
                        for (const [o,a] of this.branches)
                            if (o.evaluate(e))
                                return a.evaluate(e);
                        return this.otherwise.evaluate(e)
                    }
                    eachChild(e) {
                        for (const [o,a] of this.branches)
                            e(o),
                            e(a);
                        e(this.otherwise)
                    }
                    outputDefined() {
                        return this.branches.every( ([e,o]) => o.outputDefined()) && this.otherwise.outputDefined()
                    }
                    serialize() {
                        const e = ["case"];
                        return this.eachChild(o => {
                            e.push(o.serialize())
                        }
                        ),
                        e
                    }
                }
                class pl {
                    constructor(e, o, a, u) {
                        this.type = e,
                        this.input = o,
                        this.beginIndex = a,
                        this.endIndex = u
                    }
                    static parse(e, o) {
                        if (e.length <= 2 || e.length >= 5)
                            return o.error("Expected 3 or 4 arguments, but found ".concat(e.length - 1, " instead."));
                        const a = o.parse(e[1], 1, _i)
                          , u = o.parse(e[2], 2, To);
                        if (!a || !u)
                            return null;
                        if (!Pa(a.type, [An(_i), Pi, _i]))
                            return o.error("Expected first argument to be of type array or string, but found ".concat(Vi(a.type), " instead"));
                        if (4 === e.length) {
                            const l = o.parse(e[3], 3, To);
                            return l ? new pl(a.type,a,u,l) : null
                        }
                        return new pl(a.type,a,u)
                    }
                    evaluate(e) {
                        const o = this.input.evaluate(e)
                          , a = this.beginIndex.evaluate(e);
                        if (!Ks(o, ["string", "array"]))
                            throw new Xi("Expected first argument to be of type array or string, but found ".concat(Vi(en(o)), " instead."));
                        if (this.endIndex) {
                            const u = this.endIndex.evaluate(e);
                            return o.slice(a, u)
                        }
                        return o.slice(a)
                    }
                    eachChild(e) {
                        e(this.input),
                        e(this.beginIndex),
                        this.endIndex && e(this.endIndex)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        if (null != this.endIndex && void 0 !== this.endIndex) {
                            const e = this.endIndex.serialize();
                            return ["slice", this.input.serialize(), this.beginIndex.serialize(), e]
                        }
                        return ["slice", this.input.serialize(), this.beginIndex.serialize()]
                    }
                }
                function dl(n, e) {
                    return "==" === n || "!=" === n ? "boolean" === e.kind || "string" === e.kind || "number" === e.kind || "null" === e.kind || "value" === e.kind : "string" === e.kind || "number" === e.kind || "value" === e.kind
                }
                function hh(n, e, o, a) {
                    return 0 === a.compare(e, o)
                }
                function na(n, e, o) {
                    const a = "==" !== n && "!=" !== n;
                    return class M0 {
                        constructor(l, p, g) {
                            this.type = bi,
                            this.lhs = l,
                            this.rhs = p,
                            this.collator = g,
                            this.hasUntypedArgument = "value" === l.type.kind || "value" === p.type.kind
                        }
                        static parse(l, p) {
                            if (3 !== l.length && 4 !== l.length)
                                return p.error("Expected two or three arguments.");
                            const g = l[0];
                            let x = p.parse(l[1], 1, _i);
                            if (!x)
                                return null;
                            if (!dl(g, x.type))
                                return p.concat(1).error('"'.concat(g, "\" comparisons are not supported for type '").concat(Vi(x.type), "'."));
                            let T = p.parse(l[2], 2, _i);
                            if (!T)
                                return null;
                            if (!dl(g, T.type))
                                return p.concat(2).error('"'.concat(g, "\" comparisons are not supported for type '").concat(Vi(T.type), "'."));
                            if (x.type.kind !== T.type.kind && "value" !== x.type.kind && "value" !== T.type.kind)
                                return p.error("Cannot compare types '".concat(Vi(x.type), "' and '").concat(Vi(T.type), "'."));
                            a && ("value" === x.type.kind && "value" !== T.type.kind ? x = new On(T.type,[x]) : "value" !== x.type.kind && "value" === T.type.kind && (T = new On(x.type,[T])));
                            let f = null;
                            if (4 === l.length) {
                                if ("string" !== x.type.kind && "string" !== T.type.kind && "value" !== x.type.kind && "value" !== T.type.kind)
                                    return p.error("Cannot use collator to compare non-string types.");
                                if (f = p.parse(l[3], 3, Xl),
                                !f)
                                    return null
                            }
                            return new M0(x,T,f)
                        }
                        evaluate(l) {
                            const p = this.lhs.evaluate(l)
                              , g = this.rhs.evaluate(l);
                            if (a && this.hasUntypedArgument) {
                                const x = en(p)
                                  , T = en(g);
                                if (x.kind !== T.kind || "string" !== x.kind && "number" !== x.kind)
                                    throw new Xi('Expected arguments for "'.concat(n, '" to be (string, string) or (number, number), but found (').concat(x.kind, ", ").concat(T.kind, ") instead."))
                            }
                            if (this.collator && !a && this.hasUntypedArgument) {
                                const x = en(p)
                                  , T = en(g);
                                if ("string" !== x.kind || "string" !== T.kind)
                                    return e(l, p, g)
                            }
                            return this.collator ? o(l, p, g, this.collator.evaluate(l)) : e(l, p, g)
                        }
                        eachChild(l) {
                            l(this.lhs),
                            l(this.rhs),
                            this.collator && l(this.collator)
                        }
                        outputDefined() {
                            return !0
                        }
                        serialize() {
                            const l = [n];
                            return this.eachChild(p => {
                                l.push(p.serialize())
                            }
                            ),
                            l
                        }
                    }
                }
                const cc = na("==", function(n, e, o) {
                    return e === o
                }, hh)
                  , pu = na("!=", function(n, e, o) {
                    return e !== o
                }, function(n, e, o, a) {
                    return !hh(0, e, o, a)
                })
                  , du = na("<", function(n, e, o) {
                    return e < o
                }, function(n, e, o, a) {
                    return a.compare(e, o) < 0
                })
                  , mu = na(">", function(n, e, o) {
                    return e > o
                }, function(n, e, o, a) {
                    return a.compare(e, o) > 0
                })
                  , uh = na("<=", function(n, e, o) {
                    return e <= o
                }, function(n, e, o, a) {
                    return a.compare(e, o) <= 0
                })
                  , fu = na(">=", function(n, e, o) {
                    return e >= o
                }, function(n, e, o, a) {
                    return a.compare(e, o) >= 0
                });
                class xr {
                    constructor(e, o, a, u, l, p) {
                        this.type = Pi,
                        this.number = e,
                        this.locale = o,
                        this.currency = a,
                        this.unit = u,
                        this.minFractionDigits = l,
                        this.maxFractionDigits = p
                    }
                    static parse(e, o) {
                        if (3 !== e.length)
                            return o.error("Expected two arguments.");
                        const a = o.parse(e[1], 1, To);
                        if (!a)
                            return null;
                        const u = e[2];
                        if ("object" != typeof u || Array.isArray(u))
                            return o.error("NumberFormat options argument must be an object.");
                        let l = null;
                        if (u.locale && (l = o.parseObjectValue(u.locale, 2, "locale", Pi),
                        !l))
                            return null;
                        let p = null;
                        if (u.currency && (p = o.parseObjectValue(u.currency, 2, "currency", Pi),
                        !p))
                            return null;
                        let g = null;
                        if (u.unit && (g = o.parseObjectValue(u.unit, 2, "unit", Pi),
                        !g))
                            return null;
                        let x = null;
                        if (u["min-fraction-digits"] && (x = o.parseObjectValue(u["min-fraction-digits"], 2, "min-fraction-digits", To),
                        !x))
                            return null;
                        let T = null;
                        return u["max-fraction-digits"] && (T = o.parseObjectValue(u["max-fraction-digits"], 2, "max-fraction-digits", To),
                        !T) ? null : new xr(a,l,p,g,x,T)
                    }
                    evaluate(e) {
                        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [],{
                            style: (this.currency ? "currency" : this.unit && "unit") || "decimal",
                            currency: this.currency ? this.currency.evaluate(e) : void 0,
                            unit: this.unit ? this.unit.evaluate(e) : void 0,
                            minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0,
                            maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0
                        }).format(this.number.evaluate(e))
                    }
                    eachChild(e) {
                        e(this.number),
                        this.locale && e(this.locale),
                        this.currency && e(this.currency),
                        this.unit && e(this.unit),
                        this.minFractionDigits && e(this.minFractionDigits),
                        this.maxFractionDigits && e(this.maxFractionDigits)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        const e = {};
                        return this.locale && (e.locale = this.locale.serialize()),
                        this.currency && (e.currency = this.currency.serialize()),
                        this.unit && (e.unit = this.unit.serialize()),
                        this.minFractionDigits && (e["min-fraction-digits"] = this.minFractionDigits.serialize()),
                        this.maxFractionDigits && (e["max-fraction-digits"] = this.maxFractionDigits.serialize()),
                        ["number-format", this.number.serialize(), e]
                    }
                }
                class hc {
                    constructor(e) {
                        this.type = To,
                        this.input = e
                    }
                    static parse(e, o) {
                        if (2 !== e.length)
                            return o.error("Expected 1 argument, but found ".concat(e.length - 1, " instead."));
                        const a = o.parse(e[1], 1);
                        return a ? "array" !== a.type.kind && "string" !== a.type.kind && "value" !== a.type.kind ? o.error("Expected argument of type string or array, but found ".concat(Vi(a.type), " instead.")) : new hc(a) : null
                    }
                    evaluate(e) {
                        const o = this.input.evaluate(e);
                        if ("string" == typeof o || Array.isArray(o))
                            return o.length;
                        throw new Xi("Expected value to be of type string or array, but found ".concat(Vi(en(o)), " instead."))
                    }
                    eachChild(e) {
                        e(this.input)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        const e = ["length"];
                        return this.eachChild(o => {
                            e.push(o.serialize())
                        }
                        ),
                        e
                    }
                }
                function uc(n) {
                    return function() {
                        n = 1831565813 + (n |= 0) | 0;
                        let e = Math.imul(n ^ n >>> 15, 1 | n);
                        return e = e + Math.imul(e ^ e >>> 7, 61 | e) ^ e,
                        ((e ^ e >>> 14) >>> 0) / 4294967296
                    }
                }
                const ra = {
                    "==": cc,
                    "!=": pu,
                    ">": mu,
                    "<": du,
                    ">=": fu,
                    "<=": uh,
                    array: On,
                    at: Oa,
                    boolean: On,
                    case: lc,
                    coalesce: rc,
                    collator: tl,
                    format: Yr,
                    image: qs,
                    in: ch,
                    "index-of": sc,
                    interpolate: Jn,
                    "interpolate-hcl": Jn,
                    "interpolate-lab": Jn,
                    length: hc,
                    let: ul,
                    literal: Ar,
                    match: ac,
                    number: On,
                    "number-format": xr,
                    object: On,
                    slice: pl,
                    step: mi,
                    string: On,
                    "to-boolean": Zr,
                    "to-color": Zr,
                    "to-number": Zr,
                    "to-string": Zr,
                    var: qr,
                    within: zr,
                    distance: us,
                    config: qn
                };
                function ph(n, [e,o,a,u]) {
                    e = e.evaluate(n),
                    o = o.evaluate(n),
                    a = a.evaluate(n);
                    const l = u ? u.evaluate(n) : 1
                      , p = ws(e, o, a, l);
                    if (p)
                        throw new Xi(p);
                    return new wi(e / 255 * l,o / 255 * l,a / 255 * l,l)
                }
                function dh(n, [e,o,a,u]) {
                    e = e.evaluate(n),
                    o = o.evaluate(n),
                    a = a.evaluate(n);
                    const l = u ? u.evaluate(n) : 1
                      , p = (f = o,
                    b = a,
                    P = l,
                    "number" == typeof (T = e) && T >= 0 && T <= 360 ? "number" == typeof f && f >= 0 && f <= 100 && "number" == typeof b && b >= 0 && b <= 100 ? void 0 === P || "number" == typeof P && P >= 0 && P <= 1 ? null : "Invalid hsla value [".concat([T, f, b, P].join(", "), "]: 'a' must be between 0 and 1.") : "Invalid hsla value [".concat(("number" == typeof P ? [T, f, b, P] : [T, f, b]).join(", "), "]: 's', and 'l' must be between 0 and 100.") : "Invalid hsla value [".concat(("number" == typeof P ? [T, f, b, P] : [T, f, b]).join(", "), "]: 'h' must be between 0 and 360."));
                    var T, f, b, P;
                    if (p)
                        throw new Xi(p);
                    const g = "hsla(".concat(e, ", ").concat(o, "%, ").concat(a, "%, ").concat(l, ")")
                      , x = wi.parse(g);
                    if (!x)
                        throw new Xi("Failed to parse HSLA color: ".concat(g));
                    return x
                }
                function ml(n, e) {
                    return n in e
                }
                function Ra(n, e) {
                    const o = e[n];
                    return void 0 === o ? null : o
                }
                function br(n) {
                    return {
                        type: n
                    }
                }
                function pc(n) {
                    return {
                        result: "success",
                        value: n
                    }
                }
                function Jr(n) {
                    return {
                        result: "error",
                        value: n
                    }
                }
                function dc(n, e) {
                    return !!n && !!n.parameters && n.parameters.indexOf(e) > -1
                }
                function sa(n) {
                    return "data-driven" === n["property-type"]
                }
                function fl(n) {
                    return dc(n.expression, "measure-light")
                }
                function mh(n) {
                    return dc(n.expression, "zoom")
                }
                function mc(n) {
                    return !!n.expression && n.expression.interpolated
                }
                function _l(n) {
                    return "object" == typeof n && null !== n && !Array.isArray(n)
                }
                function fh(n) {
                    return n
                }
                function _h(n, e) {
                    const o = "color" === e.type
                      , a = n.stops && "object" == typeof n.stops[0][0]
                      , u = a || !(a || void 0 !== n.property)
                      , l = n.type || (mc(e) ? "exponential" : "interval");
                    if (o && ((n = Hl({}, n)).stops && (n.stops = n.stops.map(T => [T[0], wi.parse(T[1])])),
                    n.default = wi.parse(n.default ? n.default : e.default)),
                    n.colorSpace && "rgb" !== n.colorSpace && !uu[n.colorSpace])
                        throw new Error("Unknown color space: ".concat(n.colorSpace));
                    let p, g, x;
                    if ("exponential" === l)
                        p = fc;
                    else if ("interval" === l)
                        p = gh;
                    else if ("categorical" === l) {
                        p = _u,
                        g = Object.create(null);
                        for (const T of n.stops)
                            g[T[0]] = T[1];
                        x = typeof n.stops[0][0]
                    } else {
                        if ("identity" !== l)
                            throw new Error('Unknown function type "'.concat(l, '"'));
                        p = gl
                    }
                    if (a) {
                        const T = {}
                          , f = [];
                        for (let v = 0; v < n.stops.length; v++) {
                            const w = n.stops[v]
                              , C = w[0].zoom;
                            void 0 === T[C] && (T[C] = {
                                zoom: C,
                                type: n.type,
                                property: n.property,
                                default: n.default,
                                stops: []
                            },
                            f.push(C)),
                            T[C].stops.push([w[0].value, w[1]])
                        }
                        const b = [];
                        for (const v of f)
                            b.push([T[v].zoom, _h(T[v], e)]);
                        const P = {
                            name: "linear"
                        };
                        return {
                            kind: "composite",
                            interpolationType: P,
                            interpolationFactor: Jn.interpolationFactor.bind(void 0, P),
                            zoomStops: b.map(v => v[0]),
                            evaluate: ({zoom: v}, w) => fc({
                                stops: b,
                                base: n.base
                            }, e, v).evaluate(v, w)
                        }
                    }
                    if (u) {
                        const T = "exponential" === l ? {
                            name: "exponential",
                            base: void 0 !== n.base ? n.base : 1
                        } : null;
                        return {
                            kind: "camera",
                            interpolationType: T,
                            interpolationFactor: Jn.interpolationFactor.bind(void 0, T),
                            zoomStops: n.stops.map(f => f[0]),
                            evaluate: ({zoom: f}) => p(n, e, f, g, x)
                        }
                    }
                    return {
                        kind: "source",
                        evaluate(T, f) {
                            const b = f && f.properties ? f.properties[n.property] : void 0;
                            return void 0 === b ? Da(n.default, e.default) : p(n, e, b, g, x)
                        }
                    }
                }
                function Da(n, e, o) {
                    return void 0 !== n ? n : void 0 !== e ? e : void 0 !== o ? o : void 0
                }
                function _u(n, e, o, a, u) {
                    return Da(typeof o === u ? a[o] : void 0, n.default, e.default)
                }
                function gh(n, e, o) {
                    if ("number" !== Ms(o))
                        return Da(n.default, e.default);
                    const a = n.stops.length;
                    if (1 === a || o <= n.stops[0][0])
                        return n.stops[0][1];
                    if (o >= n.stops[a - 1][0])
                        return n.stops[a - 1][1];
                    const u = Ur(n.stops.map(l => l[0]), o);
                    return n.stops[u][1]
                }
                function fc(n, e, o) {
                    const a = void 0 !== n.base ? n.base : 1;
                    if ("number" !== Ms(o))
                        return Da(n.default, e.default);
                    const u = n.stops.length;
                    if (1 === u || o <= n.stops[0][0])
                        return n.stops[0][1];
                    if (o >= n.stops[u - 1][0])
                        return n.stops[u - 1][1];
                    const l = Ur(n.stops.map(f => f[0]), o)
                      , p = function(f, b, P, v) {
                        const w = v - P
                          , C = f - P;
                        return 0 === w ? 0 : 1 === b ? C / w : (Math.pow(b, C) - 1) / (Math.pow(b, w) - 1)
                    }(o, a, n.stops[l][0], n.stops[l + 1][0])
                      , g = n.stops[l][1]
                      , x = n.stops[l + 1][1];
                    let T = xi[e.type] || fh;
                    if (n.colorSpace && "rgb" !== n.colorSpace) {
                        const f = uu[n.colorSpace];
                        T = (b, P) => f.reverse(f.interpolate(f.forward(b), f.forward(P), p))
                    }
                    return "function" == typeof g.evaluate ? {
                        evaluate(...f) {
                            const b = g.evaluate.apply(void 0, f)
                              , P = x.evaluate.apply(void 0, f);
                            if (void 0 !== b && void 0 !== P)
                                return T(b, P, p)
                        }
                    } : T(g, x, p)
                }
                function gl(n, e, o) {
                    return "color" === e.type ? o = wi.parse(o) : "formatted" === e.type ? o = Nn.fromString(o.toString()) : "resolvedImage" === e.type ? o = In.build(o.toString()) : Ms(o) === e.type || "enum" === e.type && e.values[o] || (o = void 0),
                    Da(o, n.default, e.default)
                }
                nr.register(ra, {
                    error: [{
                        kind: "error"
                    }, [Pi], (n, [e]) => {
                        throw new Xi(e.evaluate(n))
                    }
                    ],
                    typeof: [Pi, [_i], (n, [e]) => Vi(en(e.evaluate(n)))],
                    "to-rgba": [An(To, 4), [Hn], (n, [e]) => e.evaluate(n).toRenderColor(null).toArray()],
                    "to-hsla": [An(To, 4), [Hn], (n, [e]) => e.evaluate(n).toRenderColor(null).toHslaArray()],
                    rgb: [Hn, [To, To, To], ph],
                    rgba: [Hn, [To, To, To, To], ph],
                    hsl: [Hn, [To, To, To], dh],
                    hsla: [Hn, [To, To, To, To], dh],
                    has: {
                        type: bi,
                        overloads: [[[Pi], (n, [e]) => ml(e.evaluate(n), n.properties())], [[Pi, Xs], (n, [e,o]) => ml(e.evaluate(n), o.evaluate(n))]]
                    },
                    get: {
                        type: _i,
                        overloads: [[[Pi], (n, [e]) => Ra(e.evaluate(n), n.properties())], [[Pi, Xs], (n, [e,o]) => Ra(e.evaluate(n), o.evaluate(n))]]
                    },
                    "feature-state": [_i, [Pi], (n, [e]) => Ra(e.evaluate(n), n.featureState || {})],
                    properties: [Xs, [], n => n.properties()],
                    "geometry-type": [Pi, [], n => n.geometryType()],
                    id: [_i, [], n => n.id()],
                    zoom: [To, [], n => n.globals.zoom],
                    pitch: [To, [], n => n.globals.pitch || 0],
                    "distance-from-center": [To, [], n => n.distanceFromCenter()],
                    "measure-light": [To, [Pi], (n, [e]) => n.measureLight(e.evaluate(n))],
                    "heatmap-density": [To, [], n => n.globals.heatmapDensity || 0],
                    "line-progress": [To, [], n => n.globals.lineProgress || 0],
                    "raster-value": [To, [], n => n.globals.rasterValue || 0],
                    "raster-particle-speed": [To, [], n => n.globals.rasterParticleSpeed || 0],
                    "sky-radial-progress": [To, [], n => n.globals.skyRadialProgress || 0],
                    accumulated: [_i, [], n => void 0 === n.globals.accumulated ? null : n.globals.accumulated],
                    "+": [To, br(To), (n, e) => {
                        let o = 0;
                        for (const a of e)
                            o += a.evaluate(n);
                        return o
                    }
                    ],
                    "*": [To, br(To), (n, e) => {
                        let o = 1;
                        for (const a of e)
                            o *= a.evaluate(n);
                        return o
                    }
                    ],
                    "-": {
                        type: To,
                        overloads: [[[To, To], (n, [e,o]) => e.evaluate(n) - o.evaluate(n)], [[To], (n, [e]) => -e.evaluate(n)]]
                    },
                    "/": [To, [To, To], (n, [e,o]) => e.evaluate(n) / o.evaluate(n)],
                    "%": [To, [To, To], (n, [e,o]) => e.evaluate(n) % o.evaluate(n)],
                    ln2: [To, [], () => Math.LN2],
                    pi: [To, [], () => Math.PI],
                    e: [To, [], () => Math.E],
                    "^": [To, [To, To], (n, [e,o]) => Math.pow(e.evaluate(n), o.evaluate(n))],
                    sqrt: [To, [To], (n, [e]) => Math.sqrt(e.evaluate(n))],
                    log10: [To, [To], (n, [e]) => Math.log(e.evaluate(n)) / Math.LN10],
                    ln: [To, [To], (n, [e]) => Math.log(e.evaluate(n))],
                    log2: [To, [To], (n, [e]) => Math.log(e.evaluate(n)) / Math.LN2],
                    sin: [To, [To], (n, [e]) => Math.sin(e.evaluate(n))],
                    cos: [To, [To], (n, [e]) => Math.cos(e.evaluate(n))],
                    tan: [To, [To], (n, [e]) => Math.tan(e.evaluate(n))],
                    asin: [To, [To], (n, [e]) => Math.asin(e.evaluate(n))],
                    acos: [To, [To], (n, [e]) => Math.acos(e.evaluate(n))],
                    atan: [To, [To], (n, [e]) => Math.atan(e.evaluate(n))],
                    min: [To, br(To), (n, e) => Math.min(...e.map(o => o.evaluate(n)))],
                    max: [To, br(To), (n, e) => Math.max(...e.map(o => o.evaluate(n)))],
                    abs: [To, [To], (n, [e]) => Math.abs(e.evaluate(n))],
                    round: [To, [To], (n, [e]) => {
                        const o = e.evaluate(n);
                        return o < 0 ? -Math.round(-o) : Math.round(o)
                    }
                    ],
                    floor: [To, [To], (n, [e]) => Math.floor(e.evaluate(n))],
                    ceil: [To, [To], (n, [e]) => Math.ceil(e.evaluate(n))],
                    "filter-==": [bi, [Pi, _i], (n, [e,o]) => n.properties()[e.value] === o.value],
                    "filter-id-==": [bi, [_i], (n, [e]) => n.id() === e.value],
                    "filter-type-==": [bi, [Pi], (n, [e]) => n.geometryType() === e.value],
                    "filter-<": [bi, [Pi, _i], (n, [e,o]) => {
                        const a = n.properties()[e.value]
                          , u = o.value;
                        return typeof a == typeof u && a < u
                    }
                    ],
                    "filter-id-<": [bi, [_i], (n, [e]) => {
                        const o = n.id()
                          , a = e.value;
                        return typeof o == typeof a && o < a
                    }
                    ],
                    "filter->": [bi, [Pi, _i], (n, [e,o]) => {
                        const a = n.properties()[e.value]
                          , u = o.value;
                        return typeof a == typeof u && a > u
                    }
                    ],
                    "filter-id->": [bi, [_i], (n, [e]) => {
                        const o = n.id()
                          , a = e.value;
                        return typeof o == typeof a && o > a
                    }
                    ],
                    "filter-<=": [bi, [Pi, _i], (n, [e,o]) => {
                        const a = n.properties()[e.value]
                          , u = o.value;
                        return typeof a == typeof u && a <= u
                    }
                    ],
                    "filter-id-<=": [bi, [_i], (n, [e]) => {
                        const o = n.id()
                          , a = e.value;
                        return typeof o == typeof a && o <= a
                    }
                    ],
                    "filter->=": [bi, [Pi, _i], (n, [e,o]) => {
                        const a = n.properties()[e.value]
                          , u = o.value;
                        return typeof a == typeof u && a >= u
                    }
                    ],
                    "filter-id->=": [bi, [_i], (n, [e]) => {
                        const o = n.id()
                          , a = e.value;
                        return typeof o == typeof a && o >= a
                    }
                    ],
                    "filter-has": [bi, [_i], (n, [e]) => e.value in n.properties()],
                    "filter-has-id": [bi, [], n => null !== n.id() && void 0 !== n.id()],
                    "filter-type-in": [bi, [An(Pi)], (n, [e]) => e.value.indexOf(n.geometryType()) >= 0],
                    "filter-id-in": [bi, [An(_i)], (n, [e]) => e.value.indexOf(n.id()) >= 0],
                    "filter-in-small": [bi, [Pi, An(_i)], (n, [e,o]) => o.value.indexOf(n.properties()[e.value]) >= 0],
                    "filter-in-large": [bi, [Pi, An(_i)], (n, [e,o]) => function(a, u, l, p) {
                        for (; l <= p; ) {
                            const g = l + p >> 1;
                            if (u[g] === a)
                                return !0;
                            u[g] > a ? p = g - 1 : l = g + 1
                        }
                        return !1
                    }(n.properties()[e.value], o.value, 0, o.value.length - 1)],
                    all: {
                        type: bi,
                        overloads: [[[bi, bi], (n, [e,o]) => e.evaluate(n) && o.evaluate(n)], [br(bi), (n, e) => {
                            for (const o of e)
                                if (!o.evaluate(n))
                                    return !1;
                            return !0
                        }
                        ]]
                    },
                    any: {
                        type: bi,
                        overloads: [[[bi, bi], (n, [e,o]) => e.evaluate(n) || o.evaluate(n)], [br(bi), (n, e) => {
                            for (const o of e)
                                if (o.evaluate(n))
                                    return !0;
                            return !1
                        }
                        ]]
                    },
                    "!": [bi, [bi], (n, [e]) => !e.evaluate(n)],
                    "is-supported-script": [bi, [Pi], (n, [e]) => {
                        const o = n.globals && n.globals.isSupportedScript;
                        return !o || o(e.evaluate(n))
                    }
                    ],
                    upcase: [Pi, [Pi], (n, [e]) => e.evaluate(n).toUpperCase()],
                    downcase: [Pi, [Pi], (n, [e]) => e.evaluate(n).toLowerCase()],
                    concat: [Pi, br(_i), (n, e) => e.map(o => gr(o.evaluate(n))).join("")],
                    "resolved-locale": [Pi, [Xl], (n, [e]) => e.evaluate(n).resolvedLocale()],
                    random: [To, [To, To, _i], (n, e) => {
                        const [o,a,u] = e.map(p => p.evaluate(n));
                        if (o > a || o === a)
                            return o;
                        let l;
                        if ("string" == typeof u)
                            l = function(p) {
                                let g = 0;
                                if (0 === p.length)
                                    return g;
                                for (let x = 0; x < p.length; x++)
                                    g = (g << 5) - g + p.charCodeAt(x),
                                    g |= 0;
                                return g
                            }(u);
                        else {
                            if ("number" != typeof u)
                                throw new Xi("Invalid seed input: ".concat(u));
                            l = u
                        }
                        return o + uc(l)() * (a - o)
                    }
                    ]
                });
                class _c {
                    constructor(e, o, a, u) {
                        var l;
                        this.expression = e,
                        this._warningHistory = {},
                        this._evaluator = new Qa(a,u),
                        this._defaultValue = o ? "color" === (l = o).type && (_l(l.default) || Array.isArray(l.default)) ? new wi(0,0,0,0) : "color" === l.type ? wi.parse(l.default) || null : void 0 === l.default ? null : l.default : null,
                        this._enumValues = o && "enum" === o.type ? o.values : null,
                        this.configDependencies = zn(e)
                    }
                    evaluateWithoutErrorHandling(e, o, a, u, l, p, g, x) {
                        return this._evaluator.globals = e,
                        this._evaluator.feature = o,
                        this._evaluator.featureState = a,
                        this._evaluator.canonical = u || null,
                        this._evaluator.availableImages = l || null,
                        this._evaluator.formattedSection = p,
                        this._evaluator.featureTileCoord = g || null,
                        this._evaluator.featureDistanceData = x || null,
                        this.expression.evaluate(this._evaluator)
                    }
                    evaluate(e, o, a, u, l, p, g, x) {
                        this._evaluator.globals = e,
                        this._evaluator.feature = o || null,
                        this._evaluator.featureState = a || null,
                        this._evaluator.canonical = u || null,
                        this._evaluator.availableImages = l || null,
                        this._evaluator.formattedSection = p || null,
                        this._evaluator.featureTileCoord = g || null,
                        this._evaluator.featureDistanceData = x || null;
                        try {
                            const T = this.expression.evaluate(this._evaluator);
                            if (null == T || "number" == typeof T && T != T)
                                return this._defaultValue;
                            if (this._enumValues && !(T in this._enumValues))
                                throw new Xi("Expected value to be one of ".concat(Object.keys(this._enumValues).map(f => JSON.stringify(f)).join(", "), ", but found ").concat(JSON.stringify(T), " instead."));
                            return T
                        } catch (T) {
                            return this._warningHistory[T.message] || (this._warningHistory[T.message] = !0,
                            typeof console < "u" && console.warn('Failed to evaluate expression "'.concat(JSON.stringify(this.expression.serialize()), '". ').concat(T.message))),
                            this._defaultValue
                        }
                    }
                }
                function yl(n) {
                    return Array.isArray(n) && n.length > 0 && "string" == typeof n[0] && n[0]in ra
                }
                function La(n, e, o, a) {
                    const u = new ds(ra,[],e ? function(p) {
                        const g = {
                            color: Hn,
                            string: Pi,
                            number: To,
                            enum: Pi,
                            boolean: bi,
                            formatted: Xr,
                            resolvedImage: Ys
                        };
                        return "array" === p.type ? An(g[p.value] || _i, p.length) : g[p.type]
                    }(e) : void 0,void 0,void 0,o,a)
                      , l = u.parse(n, void 0, void 0, void 0, e && "string" === e.type ? {
                        typeAnnotation: "coerce"
                    } : void 0);
                    return l ? pc(new _c(l,e,o,a)) : Jr(u.errors)
                }
                class gc {
                    constructor(e, o, a, u) {
                        this.kind = e,
                        this._styleExpression = o,
                        this.isLightConstant = a,
                        this.isLineProgressConstant = u,
                        this.isStateDependent = "constant" !== e && !ps(o.expression),
                        this.configDependencies = zn(o.expression)
                    }
                    evaluateWithoutErrorHandling(e, o, a, u, l, p) {
                        return this._styleExpression.evaluateWithoutErrorHandling(e, o, a, u, l, p)
                    }
                    evaluate(e, o, a, u, l, p) {
                        return this._styleExpression.evaluate(e, o, a, u, l, p)
                    }
                }
                class aa {
                    constructor(e, o, a, u, l, p) {
                        this.kind = e,
                        this.zoomStops = a,
                        this._styleExpression = o,
                        this.isStateDependent = "camera" !== e && !ps(o.expression),
                        this.isLightConstant = l,
                        this.isLineProgressConstant = p,
                        this.configDependencies = zn(o.expression),
                        this.interpolationType = u
                    }
                    evaluateWithoutErrorHandling(e, o, a, u, l, p) {
                        return this._styleExpression.evaluateWithoutErrorHandling(e, o, a, u, l, p)
                    }
                    evaluate(e, o, a, u, l, p) {
                        return this._styleExpression.evaluate(e, o, a, u, l, p)
                    }
                    interpolationFactor(e, o, a) {
                        return this.interpolationType ? Jn.interpolationFactor(this.interpolationType, e, o, a) : 0
                    }
                }
                function yc(n, e, o, a) {
                    if ("error" === (n = La(n, e, o, a)).result)
                        return n;
                    const u = n.value.expression
                      , l = Wn(u);
                    if (!l && !sa(e))
                        return Jr([new Zn("","data expressions not supported")]);
                    const p = rr(u, ["zoom", "pitch", "distance-from-center"]);
                    if (!p && !mh(e))
                        return Jr([new Zn("","zoom expressions not supported")]);
                    const g = rr(u, ["measure-light"]);
                    if (!g && !fl(e))
                        return Jr([new Zn("","measure-light expression not supported")]);
                    const x = rr(u, ["line-progress"]);
                    if (!x && !dc(e.expression, "line-progress"))
                        return Jr([new Zn("","line-progress expression not supported")]);
                    const T = e.expression && e.expression.relaxZoomRestriction
                      , f = V(u);
                    return f || p || T ? f instanceof Zn ? Jr([f]) : f instanceof Jn && !mc(e) ? Jr([new Zn("",'"interpolate" expressions cannot be used with this property')]) : pc(f ? new aa(l && x ? "camera" : "composite",n.value,f.labels,f instanceof Jn ? f.interpolation : void 0,g,x) : new gc(l && x ? "constant" : "source",n.value,g,x)) : Jr([new Zn("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.')])
                }
                class U {
                    constructor(e, o) {
                        this._parameters = e,
                        this._specification = o,
                        Hl(this, _h(this._parameters, this._specification))
                    }
                    static deserialize(e) {
                        return new U(e._parameters,e._specification)
                    }
                    static serialize(e) {
                        return {
                            _parameters: e._parameters,
                            _specification: e._specification
                        }
                    }
                }
                function V(n) {
                    let e = null;
                    if (n instanceof ul)
                        e = V(n.result);
                    else if (n instanceof rc) {
                        for (const o of n.args)
                            if (e = V(o),
                            e)
                                break
                    } else
                        (n instanceof mi || n instanceof Jn) && n.input instanceof nr && "zoom" === n.input.name && (e = n);
                    return e instanceof Zn || n.eachChild(o => {
                        const a = V(o);
                        a instanceof Zn ? e = a : e && a && e !== a && (e = new Zn("",'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
                    }
                    ),
                    e
                }
                var te, Q, ce = function() {
                    if (Q)
                        return te;
                    Q = 1,
                    te = e;
                    var n = 3;
                    function e(o, a, u) {
                        var l = this.cells = [];
                        if (o instanceof ArrayBuffer) {
                            this.arrayBuffer = o;
                            var p = new Int32Array(this.arrayBuffer);
                            o = p[0],
                            this.d = (a = p[1]) + 2 * (u = p[2]);
                            for (var g = 0; g < this.d * this.d; g++) {
                                var x = p[n + g]
                                  , T = p[n + g + 1];
                                l.push(x === T ? null : p.subarray(x, T))
                            }
                            var f = p[n + l.length + 1];
                            this.keys = p.subarray(p[n + l.length], f),
                            this.bboxes = p.subarray(f),
                            this.insert = this._insertReadonly
                        } else {
                            this.d = a + 2 * u;
                            for (var b = 0; b < this.d * this.d; b++)
                                l.push([]);
                            this.keys = [],
                            this.bboxes = []
                        }
                        this.n = a,
                        this.extent = o,
                        this.padding = u,
                        this.scale = a / o,
                        this.uid = 0;
                        var P = u / a * o;
                        this.min = -P,
                        this.max = o + P
                    }
                    return e.prototype.insert = function(o, a, u, l, p) {
                        this._forEachCell(a, u, l, p, this._insertCell, this.uid++),
                        this.keys.push(o),
                        this.bboxes.push(a),
                        this.bboxes.push(u),
                        this.bboxes.push(l),
                        this.bboxes.push(p)
                    }
                    ,
                    e.prototype._insertReadonly = function() {
                        throw "Cannot insert into a GridIndex created from an ArrayBuffer."
                    }
                    ,
                    e.prototype._insertCell = function(o, a, u, l, p, g) {
                        this.cells[p].push(g)
                    }
                    ,
                    e.prototype.query = function(o, a, u, l, p) {
                        var g = this.min
                          , x = this.max;
                        if (o <= g && a <= g && x <= u && x <= l && !p)
                            return Array.prototype.slice.call(this.keys);
                        var T = [];
                        return this._forEachCell(o, a, u, l, this._queryCell, T, {}, p),
                        T
                    }
                    ,
                    e.prototype._queryCell = function(o, a, u, l, p, g, x, T) {
                        var f = this.cells[p];
                        if (null !== f)
                            for (var b = this.keys, P = this.bboxes, v = 0; v < f.length; v++) {
                                var w = f[v];
                                if (void 0 === x[w]) {
                                    var C = 4 * w;
                                    (T ? T(P[C + 0], P[C + 1], P[C + 2], P[C + 3]) : o <= P[C + 2] && a <= P[C + 3] && u >= P[C + 0] && l >= P[C + 1]) ? (x[w] = !0,
                                    g.push(b[w])) : x[w] = !1
                                }
                            }
                    }
                    ,
                    e.prototype._forEachCell = function(o, a, u, l, p, g, x, T) {
                        for (var f = this._convertToCellCoord(o), b = this._convertToCellCoord(a), P = this._convertToCellCoord(u), v = this._convertToCellCoord(l), w = f; w <= P; w++)
                            for (var C = b; C <= v; C++) {
                                var A = this.d * C + w;
                                if ((!T || T(this._convertFromCellCoord(w), this._convertFromCellCoord(C), this._convertFromCellCoord(w + 1), this._convertFromCellCoord(C + 1))) && p.call(this, o, a, u, l, A, g, x, T))
                                    return
                            }
                    }
                    ,
                    e.prototype._convertFromCellCoord = function(o) {
                        return (o - this.padding) / this.scale
                    }
                    ,
                    e.prototype._convertToCellCoord = function(o) {
                        return Math.max(0, Math.min(this.d - 1, Math.floor(o * this.scale) + this.padding))
                    }
                    ,
                    e.prototype.toArrayBuffer = function() {
                        if (this.arrayBuffer)
                            return this.arrayBuffer;
                        for (var o = this.cells, a = n + this.cells.length + 1 + 1, u = 0, l = 0; l < this.cells.length; l++)
                            u += this.cells[l].length;
                        var p = new Int32Array(a + u + this.keys.length + this.bboxes.length);
                        p[0] = this.extent,
                        p[1] = this.n,
                        p[2] = this.padding;
                        for (var g = a, x = 0; x < o.length; x++) {
                            var T = o[x];
                            p[n + x] = g,
                            p.set(T, g),
                            g += T.length
                        }
                        return p[n + o.length] = g,
                        p.set(this.keys, g),
                        p[n + o.length + 1] = g += this.keys.length,
                        p.set(this.bboxes, g),
                        g += this.bboxes.length,
                        p.buffer
                    }
                    ,
                    te
                }(), xe = so(ce);
                const Je = {};
                function Fe(n, e, o={}) {
                    Object.defineProperty(n, "_classRegistryKey", {
                        value: e,
                        writable: !1
                    }),
                    Je[e] = {
                        klass: n,
                        omit: o.omit || []
                    }
                }
                Fe(Object, "Object"),
                xe.serialize = function(n, e) {
                    const o = n.toArrayBuffer();
                    return e && e.add(o),
                    {
                        buffer: o
                    }
                }
                ,
                xe.deserialize = function(n) {
                    return new xe(n.buffer)
                }
                ,
                Object.defineProperty(xe, "name", {
                    value: "Grid"
                }),
                Fe(xe, "Grid"),
                typeof DOMMatrix < "u" && Fe(DOMMatrix, "DOMMatrix"),
                Fe(wi, "Color"),
                Fe(Error, "Error"),
                Fe(Nn, "Formatted"),
                Fe(Ma, "FormattedSection"),
                Fe(Va, "AJAXError"),
                Fe(In, "ResolvedImage"),
                Fe(U, "StylePropertyFunction"),
                Fe(_c, "StyleExpression", {
                    omit: ["_evaluator"]
                }),
                Fe(ir, "ImageIdWithOptions"),
                Fe(aa, "ZoomDependentExpression"),
                Fe(gc, "ZoomConstantExpression"),
                Fe(nr, "CompoundExpression", {
                    omit: ["_evaluate"]
                });
                for (const n in ra)
                    Je[ra[n]._classRegistryKey] || Fe(ra[n], "Expression".concat(n));
                function It(n) {
                    return n && typeof ArrayBuffer < "u" && (n instanceof ArrayBuffer || n.constructor && "ArrayBuffer" === n.constructor.name)
                }
                function go(n) {
                    return self.ImageBitmap && n instanceof ImageBitmap
                }
                function yo(n, e) {
                    if (null == n || "boolean" == typeof n || "number" == typeof n || "string" == typeof n || n instanceof Boolean || n instanceof Number || n instanceof String || n instanceof Date || n instanceof RegExp)
                        return n;
                    if (It(n) || go(n))
                        return e && e.add(n),
                        n;
                    if (ArrayBuffer.isView(n))
                        return e && e.add(n.buffer),
                        n;
                    if (n instanceof ImageData)
                        return e && e.add(n.data.buffer),
                        n;
                    if (Array.isArray(n)) {
                        const o = [];
                        for (const a of n)
                            o.push(yo(a, e));
                        return o
                    }
                    if (n instanceof Map) {
                        const o = {
                            $name: "Map"
                        };
                        for (const [a,u] of n.entries())
                            o[a] = yo(u);
                        return o
                    }
                    if (n instanceof Set) {
                        const o = {
                            $name: "Set"
                        };
                        let a = 0;
                        for (const u of n.values())
                            o[++a] = yo(u);
                        return o
                    }
                    if ("object" == typeof n) {
                        const o = n.constructor
                          , a = o._classRegistryKey;
                        if (!a)
                            throw new Error("Can't serialize object of unregistered class \"".concat(a, '".'));
                        const u = o.serialize ? o.serialize(n, e) : {};
                        if (!o.serialize) {
                            for (const l in n)
                                n.hasOwnProperty(l) && (Je[a].omit.indexOf(l) >= 0 || (u[l] = yo(n[l], e)));
                            n instanceof Error && (u.message = n.message)
                        }
                        if (u.$name)
                            throw new Error("$name property is reserved for worker serialization logic.");
                        return "Object" !== a && (u.$name = a),
                        u
                    }
                    throw new Error("can't serialize object of type " + typeof n)
                }
                function Io(n) {
                    if (null == n || "boolean" == typeof n || "number" == typeof n || "string" == typeof n || n instanceof Boolean || n instanceof Number || n instanceof String || n instanceof Date || n instanceof RegExp || It(n) || go(n) || ArrayBuffer.isView(n) || n instanceof ImageData)
                        return n;
                    if (Array.isArray(n))
                        return n.map(Io);
                    if ("object" == typeof n) {
                        const e = n.$name || "Object";
                        if ("Map" === e) {
                            const u = new Map;
                            for (const l of Object.keys(n))
                                "$name" !== l && u.set(l, Io(n[l]));
                            return u
                        }
                        if ("Set" === e) {
                            const u = new Set;
                            for (const l of Object.keys(n))
                                "$name" !== l && u.add(Io(n[l]));
                            return u
                        }
                        const {klass: o} = Je[e];
                        if (!o)
                            throw new Error("Can't deserialize unregistered class \"".concat(e, '".'));
                        if (o.deserialize)
                            return o.deserialize(n);
                        const a = Object.create(o.prototype);
                        for (const u of Object.keys(n))
                            "$name" !== u && (a[u] = Io(n[u]));
                        return a
                    }
                    throw new Error("can't deserialize object of type " + typeof n)
                }
                const kt_Latin_1_Supplement = n => n >= 128 && n <= 255
                  , kt_Arabic = n => n >= 1536 && n <= 1791
                  , kt_Arabic_Supplement = n => n >= 1872 && n <= 1919
                  , kt_Arabic_Extended_A = n => n >= 2208 && n <= 2303
                  , kt_Hangul_Jamo = n => n >= 4352 && n <= 4607
                  , kt_Unified_Canadian_Aboriginal_Syllabics = n => n >= 5120 && n <= 5759
                  , kt_Khmer = n => n >= 6016 && n <= 6143
                  , kt_Unified_Canadian_Aboriginal_Syllabics_Extended = n => n >= 6320 && n <= 6399
                  , kt_General_Punctuation = n => n >= 8192 && n <= 8303
                  , kt_Letterlike_Symbols = n => n >= 8448 && n <= 8527
                  , kt_Number_Forms = n => n >= 8528 && n <= 8591
                  , kt_Miscellaneous_Technical = n => n >= 8960 && n <= 9215
                  , kt_Control_Pictures = n => n >= 9216 && n <= 9279
                  , kt_Optical_Character_Recognition = n => n >= 9280 && n <= 9311
                  , kt_Enclosed_Alphanumerics = n => n >= 9312 && n <= 9471
                  , kt_Geometric_Shapes = n => n >= 9632 && n <= 9727
                  , kt_Miscellaneous_Symbols = n => n >= 9728 && n <= 9983
                  , kt_Miscellaneous_Symbols_and_Arrows = n => n >= 11008 && n <= 11263
                  , kt_CJK_Radicals_Supplement = n => n >= 11904 && n <= 12031
                  , kt_Kangxi_Radicals = n => n >= 12032 && n <= 12255
                  , kt_Ideographic_Description_Characters = n => n >= 12272 && n <= 12287
                  , kt_CJK_Symbols_and_Punctuation = n => n >= 12288 && n <= 12351
                  , kt_Hiragana = n => n >= 12352 && n <= 12447
                  , kt_Katakana = n => n >= 12448 && n <= 12543
                  , kt_Bopomofo = n => n >= 12544 && n <= 12591
                  , kt_Hangul_Compatibility_Jamo = n => n >= 12592 && n <= 12687
                  , kt_Kanbun = n => n >= 12688 && n <= 12703
                  , kt_Bopomofo_Extended = n => n >= 12704 && n <= 12735
                  , kt_CJK_Strokes = n => n >= 12736 && n <= 12783
                  , kt_Katakana_Phonetic_Extensions = n => n >= 12784 && n <= 12799
                  , kt_Enclosed_CJK_Letters_and_Months = n => n >= 12800 && n <= 13055
                  , kt_CJK_Compatibility = n => n >= 13056 && n <= 13311
                  , kt_CJK_Unified_Ideographs_Extension_A = n => n >= 13312 && n <= 19903
                  , kt_Yijing_Hexagram_Symbols = n => n >= 19904 && n <= 19967
                  , kt_CJK_Unified_Ideographs = n => n >= 19968 && n <= 40959
                  , kt_Yi_Syllables = n => n >= 40960 && n <= 42127
                  , kt_Yi_Radicals = n => n >= 42128 && n <= 42191
                  , kt_Hangul_Jamo_Extended_A = n => n >= 43360 && n <= 43391
                  , kt_Hangul_Syllables = n => n >= 44032 && n <= 55215
                  , kt_Hangul_Jamo_Extended_B = n => n >= 55216 && n <= 55295
                  , kt_Private_Use_Area = n => n >= 57344 && n <= 63743
                  , kt_CJK_Compatibility_Ideographs = n => n >= 63744 && n <= 64255
                  , kt_Arabic_Presentation_Forms_A = n => n >= 64336 && n <= 65023
                  , kt_Vertical_Forms = n => n >= 65040 && n <= 65055
                  , kt_CJK_Compatibility_Forms = n => n >= 65072 && n <= 65103
                  , kt_Small_Form_Variants = n => n >= 65104 && n <= 65135
                  , kt_Arabic_Presentation_Forms_B = n => n >= 65136 && n <= 65279
                  , kt_Halfwidth_and_Fullwidth_Forms = n => n >= 65280 && n <= 65519
                  , kt_Osage = n => n >= 66736 && n <= 66815
                  , kt_CJK_Unified_Ideographs_Extension_B = n => n >= 131072 && n <= 173791;
                function Wo(n) {
                    for (const e of n)
                        if (ai(e.charCodeAt(0)))
                            return !0;
                    return !1
                }
                function ti(n) {
                    for (const e of n)
                        if (!Bi(e.charCodeAt(0)))
                            return !1;
                    return !0
                }
                function Bi(n) {
                    return !(kt_Arabic(n) || kt_Arabic_Supplement(n) || kt_Arabic_Extended_A(n) || kt_Arabic_Presentation_Forms_A(n) || kt_Arabic_Presentation_Forms_B(n))
                }
                function ai(n) {
                    return !(746 !== n && 747 !== n && (n < 4352 || !(kt_Bopomofo_Extended(n) || kt_Bopomofo(n) || kt_CJK_Compatibility_Forms(n) && !(n >= 65097 && n <= 65103) || kt_CJK_Compatibility_Ideographs(n) || kt_CJK_Compatibility(n) || kt_CJK_Radicals_Supplement(n) || kt_CJK_Strokes(n) || !(!kt_CJK_Symbols_and_Punctuation(n) || n >= 12296 && n <= 12305 || n >= 12308 && n <= 12319 || 12336 === n) || kt_CJK_Unified_Ideographs_Extension_A(n) || kt_CJK_Unified_Ideographs(n) || kt_Enclosed_CJK_Letters_and_Months(n) || kt_Hangul_Compatibility_Jamo(n) || kt_Hangul_Jamo_Extended_A(n) || kt_Hangul_Jamo_Extended_B(n) || kt_Hangul_Jamo(n) || kt_Hangul_Syllables(n) || kt_Hiragana(n) || kt_Ideographic_Description_Characters(n) || kt_Kanbun(n) || kt_Kangxi_Radicals(n) || kt_Katakana_Phonetic_Extensions(n) || kt_Katakana(n) && 12540 !== n || !(!kt_Halfwidth_and_Fullwidth_Forms(n) || 65288 === n || 65289 === n || 65293 === n || n >= 65306 && n <= 65310 || 65339 === n || 65341 === n || 65343 === n || n >= 65371 && n <= 65503 || 65507 === n || n >= 65512 && n <= 65519) || !(!kt_Small_Form_Variants(n) || n >= 65112 && n <= 65118 || n >= 65123 && n <= 65126) || kt_Unified_Canadian_Aboriginal_Syllabics(n) || kt_Unified_Canadian_Aboriginal_Syllabics_Extended(n) || kt_Vertical_Forms(n) || kt_Yijing_Hexagram_Symbols(n) || kt_Yi_Syllables(n) || kt_Yi_Radicals(n))))
                }
                function oi(n) {
                    return !(ai(n) || (e = n,
                    kt_Latin_1_Supplement(e) && (167 === e || 169 === e || 174 === e || 177 === e || 188 === e || 189 === e || 190 === e || 215 === e || 247 === e) || kt_General_Punctuation(e) && (8214 === e || 8224 === e || 8225 === e || 8240 === e || 8241 === e || 8251 === e || 8252 === e || 8258 === e || 8263 === e || 8264 === e || 8265 === e || 8273 === e) || kt_Letterlike_Symbols(e) || kt_Number_Forms(e) || kt_Miscellaneous_Technical(e) && (e >= 8960 && e <= 8967 || e >= 8972 && e <= 8991 || e >= 8996 && e <= 9e3 || 9003 === e || e >= 9085 && e <= 9114 || e >= 9150 && e <= 9165 || 9167 === e || e >= 9169 && e <= 9179 || e >= 9186 && e <= 9215) || kt_Control_Pictures(e) && 9251 !== e || kt_Optical_Character_Recognition(e) || kt_Enclosed_Alphanumerics(e) || kt_Geometric_Shapes(e) || kt_Miscellaneous_Symbols(e) && !(e >= 9754 && e <= 9759) || kt_Miscellaneous_Symbols_and_Arrows(e) && (e >= 11026 && e <= 11055 || e >= 11088 && e <= 11097 || e >= 11192 && e <= 11243) || kt_CJK_Symbols_and_Punctuation(e) || kt_Katakana(e) || kt_Private_Use_Area(e) || kt_CJK_Compatibility_Forms(e) || kt_Small_Form_Variants(e) || kt_Halfwidth_and_Fullwidth_Forms(e) || 8734 === e || 8756 === e || 8757 === e || e >= 9984 && e <= 10087 || e >= 10102 && e <= 10131 || 65532 === e || 65533 === e));
                    var e
                }
                function rn(n) {
                    return n >= 1424 && n <= 2303 || kt_Arabic_Presentation_Forms_A(n) || kt_Arabic_Presentation_Forms_B(n)
                }
                function Pn(n, e) {
                    return !(!e && rn(n) || n >= 2304 && n <= 3583 || n >= 3840 && n <= 4255 || kt_Khmer(n))
                }
                function _n(n) {
                    for (const e of n)
                        if (rn(e.charCodeAt(0)))
                            return !0;
                    return !1
                }
                const Bn = "deferred"
                  , Oi = "loading"
                  , Oo = "loaded";
                let ui = null
                  , hi = "unavailable"
                  , pi = null;
                const Ui = function(n) {
                    n && "string" == typeof n && n.indexOf("NetworkError") > -1 && (hi = "error"),
                    ui && ui(n)
                };
                function Li() {
                    sn.fire(new Wr("pluginStateChange",{
                        pluginStatus: hi,
                        pluginURL: pi
                    }))
                }
                const sn = new Hs
                  , Nr = function() {
                    return hi
                }
                  , la = function() {
                    if (hi !== Bn || !pi)
                        throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
                    hi = Oi,
                    Li(),
                    pi && fr({
                        url: pi
                    }, n => {
                        n ? Ui(n) : (hi = Oo,
                        Li())
                    }
                    )
                }
                  , Qn = {
                    applyArabicShaping: null,
                    processBidirectionalText: null,
                    processStyledBidirectionalText: null,
                    isLoaded: () => hi === Oo || null != Qn.applyArabicShaping,
                    isLoading: () => hi === Oi,
                    setState(n) {
                        hi = n.pluginStatus,
                        pi = n.pluginURL
                    },
                    isParsed: () => null != Qn.applyArabicShaping && null != Qn.processBidirectionalText && null != Qn.processStyledBidirectionalText,
                    getPluginURL: () => pi
                };
                class Hi {
                    constructor(e, o) {
                        this.zoom = e,
                        o ? (this.now = o.now,
                        this.fadeDuration = o.fadeDuration,
                        this.transition = o.transition,
                        this.pitch = o.pitch,
                        this.brightness = o.brightness) : (this.now = 0,
                        this.fadeDuration = 0,
                        this.transition = {},
                        this.pitch = 0,
                        this.brightness = 0)
                    }
                    isSupportedScript(e) {
                        return function(o, a) {
                            for (const u of o)
                                if (!Pn(u.charCodeAt(0), a))
                                    return !1;
                            return !0
                        }(e, Qn.isLoaded())
                    }
                }
                class Os {
                    constructor(e, o, a, u) {
                        this.property = e,
                        this.value = o,
                        this.expression = function(l, p, g, x) {
                            if (_l(l))
                                return new U(l,p);
                            if (yl(l) || Array.isArray(l) && l.length > 0) {
                                const T = yc(l, p, g, x);
                                if ("error" === T.result)
                                    throw new Error(T.value.map(f => "".concat(f.key, ": ").concat(f.message)).join(", "));
                                return T.value
                            }
                            {
                                let T = l;
                                return "string" == typeof l && "color" === p.type && (T = wi.parse(l)),
                                {
                                    kind: "constant",
                                    configDependencies: new Set,
                                    evaluate: () => T
                                }
                            }
                        }(void 0 === o ? e.specification.default : o, e.specification, a, u)
                    }
                    isDataDriven() {
                        return "source" === this.expression.kind || "composite" === this.expression.kind
                    }
                    possiblyEvaluate(e, o, a) {
                        return this.property.possiblyEvaluate(this, e, o, a)
                    }
                }
                class vl {
                    constructor(e, o, a) {
                        this.property = e,
                        this.value = new Os(e,void 0,o,a)
                    }
                    transitioned(e, o) {
                        return new Rs(this.property,this.value,o,W({}, e.transition, this.transition),e.now)
                    }
                    untransitioned() {
                        return new Rs(this.property,this.value,null,{},0)
                    }
                }
                class xl {
                    constructor(e, o, a) {
                        this._properties = e,
                        this._values = Object.create(e.defaultTransitionablePropertyValues),
                        this._scope = o,
                        this._options = a,
                        this.configDependencies = new Set
                    }
                    getValue(e) {
                        return ro(this._values[e].value.value)
                    }
                    setValue(e, o) {
                        this._values.hasOwnProperty(e) || (this._values[e] = new vl(this._values[e].property,this._scope,this._options)),
                        this._values[e].value = new Os(this._values[e].property,null === o ? void 0 : ro(o),this._scope,this._options),
                        this._values[e].value.expression.configDependencies && (this.configDependencies = new Set([...this.configDependencies, ...this._values[e].value.expression.configDependencies]))
                    }
                    setTransitionOrValue(e, o) {
                        o && (this._options = o);
                        const a = this._properties.properties;
                        if (e)
                            for (const u in e) {
                                const l = e[u];
                                if (mt(u, "-transition")) {
                                    const p = u.slice(0, -11);
                                    a[p] && this.setTransition(p, l)
                                } else
                                    a.hasOwnProperty(u) && this.setValue(u, l)
                            }
                    }
                    getTransition(e) {
                        return ro(this._values[e].transition)
                    }
                    setTransition(e, o) {
                        this._values.hasOwnProperty(e) || (this._values[e] = new vl(this._values[e].property)),
                        this._values[e].transition = ro(o) || void 0
                    }
                    serialize() {
                        const e = {};
                        for (const o of Object.keys(this._values)) {
                            const a = this.getValue(o);
                            void 0 !== a && (e[o] = a);
                            const u = this.getTransition(o);
                            void 0 !== u && (e["".concat(o, "-transition")] = u)
                        }
                        return e
                    }
                    transitioned(e, o) {
                        const a = new yh(this._properties);
                        for (const u of Object.keys(this._values))
                            a._values[u] = this._values[u].transitioned(e, o._values[u]);
                        return a
                    }
                    untransitioned() {
                        const e = new yh(this._properties);
                        for (const o of Object.keys(this._values))
                            e._values[o] = this._values[o].untransitioned();
                        return e
                    }
                }
                class Rs {
                    constructor(e, o, a, u, l) {
                        const p = u.delay || 0
                          , g = u.duration || 0;
                        l = l || 0,
                        this.property = e,
                        this.value = o,
                        this.begin = l + p,
                        this.end = this.begin + g,
                        e.specification.transition && (u.delay || u.duration) && (this.prior = a)
                    }
                    possiblyEvaluate(e, o, a) {
                        const u = e.now || 0
                          , l = this.value.possiblyEvaluate(e, o, a)
                          , p = this.prior;
                        if (p) {
                            if (u > this.end)
                                return this.prior = null,
                                l;
                            if (this.value.isDataDriven())
                                return this.prior = null,
                                l;
                            if (u < this.begin)
                                return p.possiblyEvaluate(e, o, a);
                            {
                                const g = (u - this.begin) / (this.end - this.begin);
                                return this.property.interpolate(p.possiblyEvaluate(e, o, a), l, bt(g))
                            }
                        }
                        return l
                    }
                }
                class yh {
                    constructor(e) {
                        this._properties = e,
                        this._values = Object.create(e.defaultTransitioningPropertyValues)
                    }
                    possiblyEvaluate(e, o, a) {
                        const u = new wl(this._properties);
                        for (const l of Object.keys(this._values))
                            u._values[l] = this._values[l].possiblyEvaluate(e, o, a);
                        return u
                    }
                    hasTransition() {
                        for (const e of Object.keys(this._values))
                            if (this._values[e].prior)
                                return !0;
                        return !1
                    }
                }
                class vc {
                    constructor(e, o, a) {
                        this._properties = e,
                        this._values = Object.create(e.defaultPropertyValues),
                        this._scope = o,
                        this._options = a,
                        this.configDependencies = new Set
                    }
                    getValue(e) {
                        return ro(this._values[e].value)
                    }
                    setValue(e, o) {
                        this._values[e] = new Os(this._values[e].property,null === o ? void 0 : ro(o),this._scope,this._options),
                        this._values[e].expression.configDependencies && (this.configDependencies = new Set([...this.configDependencies, ...this._values[e].expression.configDependencies]))
                    }
                    serialize() {
                        const e = {};
                        for (const o of Object.keys(this._values)) {
                            const a = this.getValue(o);
                            void 0 !== a && (e[o] = a)
                        }
                        return e
                    }
                    possiblyEvaluate(e, o, a) {
                        const u = new wl(this._properties);
                        for (const l of Object.keys(this._values))
                            u._values[l] = this._values[l].possiblyEvaluate(e, o, a);
                        return u
                    }
                }
                class bl {
                    constructor(e, o, a) {
                        this.property = e,
                        this.value = o,
                        this.parameters = a
                    }
                    isConstant() {
                        return "constant" === this.value.kind
                    }
                    constantOr(e) {
                        return "constant" === this.value.kind ? this.value.value : e
                    }
                    evaluate(e, o, a, u) {
                        return this.property.evaluate(this.value, this.parameters, e, o, a, u)
                    }
                }
                class wl {
                    constructor(e) {
                        this._properties = e,
                        this._values = Object.create(e.defaultPossiblyEvaluatedValues)
                    }
                    get(e) {
                        return this._values[e]
                    }
                }
                class eo {
                    constructor(e) {
                        this.specification = e
                    }
                    possiblyEvaluate(e, o) {
                        return e.expression.evaluate(o)
                    }
                    interpolate(e, o, a) {
                        const u = xi[this.specification.type];
                        return u ? u(e, o, a) : e
                    }
                }
                class Mo {
                    constructor(e, o) {
                        this.specification = e,
                        this.overrides = o
                    }
                    possiblyEvaluate(e, o, a, u) {
                        return new bl(this,"constant" === e.expression.kind || "camera" === e.expression.kind ? {
                            kind: "constant",
                            value: e.expression.evaluate(o, null, {}, a, u)
                        } : e.expression,o)
                    }
                    interpolate(e, o, a) {
                        if ("constant" !== e.value.kind || "constant" !== o.value.kind)
                            return e;
                        if (void 0 === e.value.value || void 0 === o.value.value)
                            return new bl(this,{
                                kind: "constant",
                                value: void 0
                            },e.parameters);
                        const u = xi[this.specification.type];
                        return u ? new bl(this,{
                            kind: "constant",
                            value: u(e.value.value, o.value.value, a)
                        },e.parameters) : e
                    }
                    evaluate(e, o, a, u, l, p) {
                        return "constant" === e.kind ? e.value : e.evaluate(o, a, u, l, p)
                    }
                }
                class ca {
                    constructor(e) {
                        this.specification = e
                    }
                    possiblyEvaluate(e, o, a, u) {
                        return !!e.expression.evaluate(o, null, {}, a, u)
                    }
                    interpolate() {
                        return !1
                    }
                }
                class cn {
                    constructor(e) {
                        this.properties = e,
                        this.defaultPropertyValues = {},
                        this.defaultTransitionablePropertyValues = {},
                        this.defaultTransitioningPropertyValues = {},
                        this.defaultPossiblyEvaluatedValues = {},
                        this.overridableProperties = [];
                        const o = new Hi(0,{});
                        for (const a in e) {
                            const u = e[a];
                            u.specification.overridable && this.overridableProperties.push(a);
                            const l = this.defaultPropertyValues[a] = new Os(u,void 0)
                              , p = this.defaultTransitionablePropertyValues[a] = new vl(u);
                            this.defaultTransitioningPropertyValues[a] = p.untransitioned(),
                            this.defaultPossiblyEvaluatedValues[a] = l.possiblyEvaluate(o)
                        }
                    }
                }
                Fe(Mo, "DataDrivenProperty"),
                Fe(eo, "DataConstantProperty"),
                Fe(ca, "ColorRampProperty");
                var ft = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"required":false,"type":"array","value":"light-3d"},"terrain":{"type":"terrain","optional":true},"fog":{"type":"fog"},"snow":{"type":"snow","experimental":true},"rain":{"type":"rain","experimental":true},"camera":{"type":"camera"},"color-theme":{"type":"colorTheme"},"indoor":{"type":"indoor","experimental":true},"imports":{"type":"array","value":"import"},"schema":{"type":"schema"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"},"models":{"type":"models"},"featuresets":{"experimental":true,"type":"featuresets"}},"featuresets":{"experimental":true,"*":{"type":"featureset"}},"featureset":{"experimental":true,"metadata":{"type":"*"},"selectors":{"type":"array","value":"selector"}},"selector":{"experimental":true,"layer":{"type":"string","required":true},"properties":{"type":"selectorProperty","required":false},"featureNamespace":{"type":"string","required":false}},"selectorProperty":{"experimental":true,"*":{"type":"*"}},"model":{"type":"string","required":true},"import":{"id":{"type":"string","required":true},"url":{"type":"string","required":true},"config":{"type":"config"},"data":{"type":"$root"},"color-theme":{"type":"colorTheme","optional":true}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","property-type":"data-constant","expression":{},"required":true},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string","required":true},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false,"property-type":"data-constant"},"shadow-quality":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"expression":{"parameters":["zoom"]},"experimental":true},"shadow-intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_ambient":{"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_raster_array","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_array":{"experimental":true,"type":{"required":true,"type":"enum","values":{"raster-array":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"rasterLayers":{"type":"*"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"},"dynamic":{"type":"boolean","default":false}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":1}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":1}},"url":{"required":false,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_model":{"type":{"required":true,"type":"enum","values":{"model":1,"batched-model":1}},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"raster-particle":{"experimental":true},"hillshade":{},"model":{"experimental":true},"background":{},"sky":{},"slot":{},"clip":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_clip","layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_raster-particle","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}}},"layout_clip":{"clip-layer-types":{"type":"array","value":"enum","values":{"model":1,"symbol":1},"default":[],"expression":{},"property-type":"data-constant"},"clip-layer-scope":{"type":"array","value":"string","default":[],"expression":{},"property-type":"data-constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"fill-elevation-reference":{"type":"enum","values":{"none":1,"hd-road-base":1,"hd-road-markup":1},"default":"none","experimental":true,"private":true,"expression":{},"property-type":"data-constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","experimental":true,"default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1,"none":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-z-offset":{"type":"number","experimental":true,"default":0,"expression":{"parameters":["zoom","feature","line-progress"]},"property-type":"data-driven"},"line-elevation-reference":{"type":"enum","values":{"none":1,"sea":1,"ground":1,"hd-road-markup":1},"default":"none","experimental":true,"expression":{},"property-type":"data-constant"},"line-cross-slope":{"type":"number","experimental":true,"expression":{},"property-type":"constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"line-width-unit":{"type":"enum","values":{"pixels":1,"meters":1},"default":"pixels","experimental":true,"private":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-elevation-reference":{"type":"enum","values":{"sea":1,"ground":1,"hd-road-markup":1},"default":"ground","experimental":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":0.1,"maximum":10,"experimental":true,"private":true,"expression":{},"property-type":"data-constant"},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":0.1,"maximum":10,"experimental":true,"private":true,"expression":{},"property-type":"data-constant"},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster-particle":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_hillshade":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster-particle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_clip":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_model":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"snow":{"density":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,0.85],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"opacity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,0.3],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","property-type":"data-constant","default":"#ffffff","experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"center-thinning":{"type":"number","property-type":"data-constant","default":0.4,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,50],"minimum":0,"maximum":360,"length":2,"value":"number","property-type":"data-constant","transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"flake-size":{"type":"number","property-type":"data-constant","default":0.71,"minimum":0,"maximum":5,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"rain":{"density":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,0.5],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["measure-light","brightness"],0,"#03113d",0.3,"#a8adbc"],"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"opacity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["measure-light","brightness"],0,0.88,1,0.7],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,1],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["measure-light","brightness"],0,"#001736",0.3,"#464646"],"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"center-thinning":{"type":"number","property-type":"data-constant","default":0.57,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,80],"minimum":0,"maximum":360,"length":2,"value":"number","property-type":"data-constant","transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"droplet-size":{"type":"array","default":[2.6,18.2],"minimum":0,"maximum":50,"length":2,"value":"number","property-type":"data-constant","transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"distortion-strength":{"type":"number","property-type":"data-constant","default":0.7,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective","property-type":"data-constant"}},"colorTheme":{"data":{"type":"string","property-type":"data-constant","expression":{}}},"indoor":{"floorplanFeaturesetId":{"type":"string","experimental":true,"property-type":"data-constant","expression":{}},"buildingFeaturesetId":{"type":"string","experimental":true,"property-type":"data-constant","expression":{}}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_raster-particle","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"fill-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-height-alignment":{"type":"enum","experimental":true,"values":{"terrain":1,"flat":1},"default":"flat","property-type":"data-constant"},"fill-extrusion-base-alignment":{"type":"enum","experimental":true,"values":{"terrain":1,"flat":1},"default":"terrain","property-type":"data-constant"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"property-type":"data-constant","type":"number","experimental":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"property-type":"data-constant","type":"number","experimental":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"property-type":"data-constant","type":"number","experimental":true,"default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"property-type":"data-constant","type":"color","experimental":true,"default":"#ffffff","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"property-type":"data-constant","type":"number","experimental":true,"default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","experimental":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","experimental":true,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"property-type":"data-constant","type":"number","experimental":true,"default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"property-type":"data-constant","type":"number","experimental":true,"default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"property-type":"data-constant","type":"boolean","default":true,"experimental":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"fill-extrusion-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"fill-extrusion-line-width":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-cast-shadows":{"type":"boolean","default":true,"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light","line-progress"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"property-type":"constant"},"line-trim-fade-range":{"type":"array","value":"number","experimental":true,"length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-trim-color":{"type":"color","experimental":true,"default":"transparent","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-border-width":{"type":"number","private":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","private":true,"default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-occlusion-opacity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"property-type":"data-constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-image-cross-fade":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"transition":true},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-color-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"symbol-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-value"]},"property-type":"color-ramp"},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"raster-array-band":{"type":"string","required":false,"experimental":true,"property-type":"data-constant"},"raster-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster-particle":{"raster-particle-array-band":{"type":"string","required":false,"property-type":"data-constant"},"raster-particle-count":{"type":"number","default":512,"minimum":1,"property-type":"data-constant"},"raster-particle-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-particle-speed"]},"property-type":"color-ramp"},"raster-particle-max-speed":{"type":"number","default":1,"minimum":1,"property-type":"data-constant"},"raster-particle-speed-factor":{"type":"number","default":0.2,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-fade-opacity-factor":{"type":"number","default":0.98,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-reset-rate-factor":{"type":"number","default":0.8,"minimum":0,"maximum":1,"property-type":"data-constant"},"raster-particle-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_background":{"background-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":[]},"experimental":true,"property-type":"data-constant"},"background-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"property-type":"data-driven"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d","property-type":"data-constant"},"model-cast-shadows":{"type":"boolean","default":true,"property-type":"data-constant"},"model-receive-shadows":{"type":"boolean","default":true,"property-type":"data-constant"},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant","transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"model-front-cutoff":{"type":"array","private":true,"value":"number","property-type":"data-constant","expression":{"interpolated":true,"parameters":["zoom"]},"length":3,"default":[0,0,1],"minimum":[0,0,0],"maximum":[1,1,1]}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
                function mp(n) {
                    return n instanceof Number || n instanceof String || n instanceof Boolean ? n.valueOf() : n
                }
                function vh(n) {
                    if (Array.isArray(n))
                        return n.map(vh);
                    if (n instanceof Object && !(n instanceof Number || n instanceof String || n instanceof Boolean)) {
                        const e = {};
                        for (const o in n)
                            e[o] = vh(n[o]);
                        return e
                    }
                    return mp(n)
                }
                function gu(n) {
                    if (!0 === n || !1 === n)
                        return !0;
                    if (!Array.isArray(n) || 0 === n.length)
                        return !1;
                    switch (n[0]) {
                    case "has":
                        return n.length >= 2 && "$id" !== n[1] && "$type" !== n[1];
                    case "in":
                        return n.length >= 3 && ("string" != typeof n[1] || Array.isArray(n[2]));
                    case "!in":
                    case "!has":
                    case "none":
                        return !1;
                    case "==":
                    case "!=":
                    case ">":
                    case ">=":
                    case "<":
                    case "<=":
                        return 3 !== n.length || Array.isArray(n[1]) || Array.isArray(n[2]);
                    case "any":
                    case "all":
                        for (const e of n.slice(1))
                            if (!gu(e) && "boolean" != typeof e)
                                return !1;
                        return !0;
                    default:
                        return !0
                    }
                }
                function fp(n, e="", o=null, a="fill") {
                    if (null == n)
                        return {
                            filter: () => !0,
                            needGeometry: !1,
                            needFeature: !1
                        };
                    gu(n) || (n = xc(n));
                    const u = n;
                    let l = !0;
                    try {
                        l = function(f) {
                            if (!Pl(f))
                                return f;
                            let b = vh(f);
                            return gp(b),
                            b = _p(b),
                            b
                        }(u)
                    } catch {
                        console.warn("Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n".concat(JSON.stringify(u, null, 2), "\n        "))
                    }
                    let p = null
                      , g = null;
                    if ("background" !== a && "sky" !== a && "slot" !== a) {
                        g = ft["filter_".concat(a)];
                        const f = La(l, g, e, o);
                        if ("error" === f.result)
                            throw new Error(f.value.map(b => "".concat(b.key, ": ").concat(b.message)).join(", "));
                        p = (b, P, v) => f.value.evaluate(b, P, {}, v)
                    }
                    let x = null
                      , T = null;
                    if (l !== u) {
                        const f = La(u, g, e, o);
                        if ("error" === f.result)
                            throw new Error(f.value.map(b => "".concat(b.key, ": ").concat(b.message)).join(", "));
                        x = (b, P, v, w, C) => f.value.evaluate(b, P, {}, v, void 0, void 0, w, C),
                        T = !Wn(f.value.expression)
                    }
                    return {
                        filter: p,
                        dynamicFilter: x || void 0,
                        needGeometry: Fa(l),
                        needFeature: !!T
                    }
                }
                function _p(n) {
                    if (!Array.isArray(n))
                        return n;
                    const e = function(o) {
                        if (Md.has(o[0]))
                            for (let a = 1; a < o.length; a++)
                                if (Pl(o[a]))
                                    return !0;
                        return o
                    }(n);
                    return !0 === e ? e : e.map(o => _p(o))
                }
                function gp(n) {
                    let e = !1;
                    const o = [];
                    if ("case" === n[0]) {
                        for (let a = 1; a < n.length - 1; a += 2)
                            e = e || Pl(n[a]),
                            o.push(n[a + 1]);
                        o.push(n[n.length - 1])
                    } else if ("match" === n[0]) {
                        e = e || Pl(n[1]);
                        for (let a = 2; a < n.length - 1; a += 2)
                            o.push(n[a + 1]);
                        o.push(n[n.length - 1])
                    } else if ("step" === n[0]) {
                        e = e || Pl(n[1]);
                        for (let a = 1; a < n.length - 1; a += 2)
                            o.push(n[a + 1])
                    }
                    e && (n.length = 0,
                    n.push("any", ...o));
                    for (let a = 1; a < n.length; a++)
                        gp(n[a])
                }
                function Pl(n) {
                    if (!Array.isArray(n))
                        return !1;
                    if ("pitch" === (e = n[0]) || "distance-from-center" === e)
                        return !0;
                    var e;
                    for (let o = 1; o < n.length; o++)
                        if (Pl(n[o]))
                            return !0;
                    return !1
                }
                const Md = new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
                function Td(n, e) {
                    return n < e ? -1 : n > e ? 1 : 0
                }
                function Fa(n) {
                    if (!Array.isArray(n))
                        return !1;
                    if ("within" === n[0] || "distance" === n[0])
                        return !0;
                    for (let e = 1; e < n.length; e++)
                        if (Fa(n[e]))
                            return !0;
                    return !1
                }
                function xc(n) {
                    if (!n)
                        return !0;
                    const e = n[0];
                    return n.length <= 1 ? "any" !== e : "==" === e ? xh(n[1], n[2], "==") : "!=" === e ? bh(xh(n[1], n[2], "==")) : "<" === e || ">" === e || "<=" === e || ">=" === e ? xh(n[1], n[2], e) : "any" === e ? (o = n.slice(1),
                    ["any"].concat(o.map(xc))) : "all" === e ? ["all"].concat(n.slice(1).map(xc)) : "none" === e ? ["all"].concat(n.slice(1).map(xc).map(bh)) : "in" === e ? bc(n[1], n.slice(2)) : "!in" === e ? bh(bc(n[1], n.slice(2))) : "has" === e ? yp(n[1]) : "!has" !== e || bh(yp(n[1]));
                    var o
                }
                function xh(n, e, o) {
                    switch (n) {
                    case "$type":
                        return ["filter-type-".concat(o), e];
                    case "$id":
                        return ["filter-id-".concat(o), e];
                    default:
                        return ["filter-".concat(o), n, e]
                    }
                }
                function bc(n, e) {
                    if (0 === e.length)
                        return !1;
                    switch (n) {
                    case "$type":
                        return ["filter-type-in", ["literal", e]];
                    case "$id":
                        return ["filter-id-in", ["literal", e]];
                    default:
                        return e.length > 200 && !e.some(o => typeof o != typeof e[0]) ? ["filter-in-large", n, ["literal", e.sort(Td)]] : ["filter-in-small", n, ["literal", e]]
                    }
                }
                function yp(n) {
                    switch (n) {
                    case "$type":
                        return !0;
                    case "$id":
                        return ["filter-has-id"];
                    default:
                        return ["filter-has", n]
                    }
                }
                function bh(n) {
                    return ["!", n]
                }
                function es(n, e) {
                    return e ? "".concat(n).concat("\x1f").concat(e) : n
                }
                const ka = "-transition"
                  , Cd = new Set(["fill", "line", "background", "hillshade", "raster"]);
                class dr extends Hs {
                    constructor(e, o, a, u, l) {
                        if (super(),
                        this.id = e.id,
                        this.fqid = es(this.id, a),
                        this.type = e.type,
                        this.scope = a,
                        this.lut = u,
                        this.options = l,
                        this._featureFilter = {
                            filter: () => !0,
                            needGeometry: !1,
                            needFeature: !1
                        },
                        this._filterCompiled = !1,
                        this.configDependencies = new Set,
                        "custom" !== e.type) {
                            if (this.metadata = e.metadata,
                            this.minzoom = e.minzoom,
                            this.maxzoom = e.maxzoom,
                            e.type && "background" !== e.type && "sky" !== e.type && "slot" !== e.type) {
                                this.source = e.source,
                                this.sourceLayer = e["source-layer"],
                                this.filter = e.filter;
                                const p = La(this.filter, ft["filter_".concat(e.type)]);
                                "error" !== p.result && (this.configDependencies = new Set([...this.configDependencies, ...p.value.configDependencies]))
                            }
                            if (e.slot && (this.slot = e.slot),
                            o.layout && (this._unevaluatedLayout = new vc(o.layout,this.scope,l),
                            this.configDependencies = new Set([...this.configDependencies, ...this._unevaluatedLayout.configDependencies])),
                            o.paint) {
                                this._transitionablePaint = new xl(o.paint,this.scope,l);
                                for (const p in e.paint)
                                    this.setPaintProperty(p, e.paint[p]);
                                for (const p in e.layout)
                                    this.setLayoutProperty(p, e.layout[p]);
                                this.configDependencies = new Set([...this.configDependencies, ...this._transitionablePaint.configDependencies]),
                                this._transitioningPaint = this._transitionablePaint.untransitioned(),
                                this.paint = new wl(o.paint)
                            }
                        }
                    }
                    onAdd(e) {}
                    onRemove(e) {}
                    isDraped(e) {
                        return !this.is3D() && Cd.has(this.type)
                    }
                    getLayoutProperty(e) {
                        return "visibility" === e ? this.visibility : this._unevaluatedLayout.getValue(e)
                    }
                    setLayoutProperty(e, o) {
                        if ("custom" === this.type && "visibility" === e)
                            return void (this.visibility = o);
                        const a = this._unevaluatedLayout;
                        a._properties.properties[e] && (a.setValue(e, o),
                        this.configDependencies = new Set([...this.configDependencies, ...a.configDependencies]),
                        "visibility" === e && this.possiblyEvaluateVisibility())
                    }
                    possiblyEvaluateVisibility() {
                        this._unevaluatedLayout._values.visibility && (this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({
                            zoom: 0
                        }))
                    }
                    getPaintProperty(e) {
                        return mt(e, ka) ? this._transitionablePaint.getTransition(e.slice(0, -11)) : this._transitionablePaint.getValue(e)
                    }
                    setPaintProperty(e, o) {
                        const a = this._transitionablePaint
                          , u = a._properties.properties;
                        if (mt(e, ka)) {
                            const b = e.slice(0, -11);
                            return u[b] && a.setTransition(b, o || void 0),
                            !1
                        }
                        if (!u[e])
                            return !1;
                        const l = a._values[e]
                          , p = l.value.isDataDriven()
                          , g = l.value;
                        a.setValue(e, o),
                        this.configDependencies = new Set([...this.configDependencies, ...a.configDependencies]),
                        this._handleSpecialPaintPropertyUpdate(e);
                        const x = a._values[e].value
                          , T = x.isDataDriven()
                          , f = mt(e, "pattern") || "line-dasharray" === e;
                        return T || p || f || this._handleOverridablePaintPropertyUpdate(e, g, x)
                    }
                    _handleSpecialPaintPropertyUpdate(e) {}
                    getProgramIds() {
                        return null
                    }
                    getDefaultProgramParams(e, o, a) {
                        return null
                    }
                    _handleOverridablePaintPropertyUpdate(e, o, a) {
                        return !1
                    }
                    isHidden(e) {
                        return !!(this.minzoom && e < this.minzoom) || !!(this.maxzoom && e >= this.maxzoom) || "none" === this.visibility
                    }
                    updateTransitions(e) {
                        this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint)
                    }
                    hasTransition() {
                        return this._transitioningPaint.hasTransition()
                    }
                    recalculate(e, o) {
                        this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, o)),
                        this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, o)
                    }
                    serialize() {
                        return So({
                            id: this.id,
                            type: this.type,
                            slot: this.slot,
                            source: this.source,
                            "source-layer": this.sourceLayer,
                            metadata: this.metadata,
                            minzoom: this.minzoom,
                            maxzoom: this.maxzoom,
                            filter: this.filter,
                            layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
                            paint: this._transitionablePaint && this._transitionablePaint.serialize()
                        }, (e, o) => !(void 0 === e || "layout" === o && !Object.keys(e).length || "paint" === o && !Object.keys(e).length))
                    }
                    is3D() {
                        return !1
                    }
                    isSky() {
                        return !1
                    }
                    isTileClipped() {
                        return !1
                    }
                    hasOffscreenPass() {
                        return !1
                    }
                    hasShadowPass() {
                        return !1
                    }
                    canCastShadows() {
                        return !1
                    }
                    hasLightBeamPass() {
                        return !1
                    }
                    cutoffRange() {
                        return 0
                    }
                    tileCoverLift() {
                        return 0
                    }
                    resize() {}
                    isStateDependent() {
                        for (const e in this.paint._values) {
                            const o = this.paint.get(e);
                            if (o instanceof bl && sa(o.property.specification) && ("source" === o.value.kind || "composite" === o.value.kind) && o.value.isStateDependent)
                                return !0
                        }
                        return !1
                    }
                    compileFilter(e) {
                        this._filterCompiled || (this._featureFilter = fp(this.filter, this.scope, e),
                        this._filterCompiled = !0)
                    }
                    invalidateCompiledFilter() {
                        this._filterCompiled = !1
                    }
                    dynamicFilter() {
                        return this._featureFilter.dynamicFilter
                    }
                    dynamicFilterNeedsFeature() {
                        return this._featureFilter.needFeature
                    }
                    getLayerRenderingStats() {
                        return this._stats
                    }
                    resetLayerRenderingStats(e) {
                        this._stats && ("shadow" === e.renderPass ? this._stats.numRenderedVerticesInShadowPass = 0 : this._stats.numRenderedVerticesInTransparentPass = 0)
                    }
                    queryRadius(e) {}
                    queryIntersectsFeature(e, o, a, u, l, p, g, x, T) {}
                }
                const Ed = {
                    Int8: Int8Array,
                    Uint8: Uint8Array,
                    Int16: Int16Array,
                    Uint16: Uint16Array,
                    Int32: Int32Array,
                    Uint32: Uint32Array,
                    Float32: Float32Array
                };
                class wc {
                    constructor(e, o) {
                        this._structArray = e,
                        this._pos1 = o * this.size,
                        this._pos2 = this._pos1 / 2,
                        this._pos4 = this._pos1 / 4,
                        this._pos8 = this._pos1 / 8
                    }
                }
                class tn {
                    constructor() {
                        this.isTransferred = !1,
                        this.capacity = -1,
                        this.resize(0)
                    }
                    static serialize(e, o) {
                        return e._trim(),
                        o && (e.isTransferred = !0,
                        o.add(e.arrayBuffer)),
                        {
                            length: e.length,
                            arrayBuffer: e.arrayBuffer
                        }
                    }
                    static deserialize(e) {
                        const o = Object.create(this.prototype);
                        return o.arrayBuffer = e.arrayBuffer,
                        o.length = e.length,
                        o.capacity = e.arrayBuffer.byteLength / o.bytesPerElement,
                        o._refreshViews(),
                        o
                    }
                    _trim() {
                        this.length !== this.capacity && (this.capacity = this.length,
                        this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement),
                        this._refreshViews())
                    }
                    clear() {
                        this.length = 0
                    }
                    resize(e) {
                        this.reserve(e),
                        this.length = e
                    }
                    reserve(e) {
                        if (e > this.capacity) {
                            this.capacity = Math.max(e, Math.floor(5 * this.capacity), 128),
                            this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                            const o = this.uint8;
                            this._refreshViews(),
                            o && this.uint8.set(o)
                        }
                    }
                    _refreshViews() {
                        throw new Error("StructArray#_refreshViews() must be implemented by each concrete StructArray layout")
                    }
                    emplace(...e) {
                        throw new Error("StructArray#emplace() must be implemented by each concrete StructArray layout")
                    }
                    emplaceBack(...e) {
                        throw new Error("StructArray#emplaceBack() must be implemented by each concrete StructArray layout")
                    }
                    destroy() {
                        this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null,
                        this.arrayBuffer = null
                    }
                }
                function Si(n, e=1) {
                    let o = 0
                      , a = 0;
                    return {
                        members: n.map(u => {
                            const l = Ed[u.type].BYTES_PER_ELEMENT
                              , p = o = wh(o, Math.max(e, l))
                              , g = u.components || 1;
                            return a = Math.max(a, l),
                            o += l * g,
                            {
                                name: u.name,
                                type: u.type,
                                components: g,
                                offset: p
                            }
                        }
                        ),
                        size: wh(o, Math.max(a, e)),
                        alignment: e
                    }
                }
                function wh(n, e) {
                    return Math.ceil(n / e) * e
                }
                class ts extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o) {
                        const a = this.length;
                        return this.resize(a + 1),
                        this.emplace(a, e, o)
                    }
                    emplace(e, o, a) {
                        const u = 2 * e;
                        return this.int16[u + 0] = o,
                        this.int16[u + 1] = a,
                        e
                    }
                }
                ts.prototype.bytesPerElement = 4,
                Fe(ts, "StructArrayLayout2i4");
                class Pc extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a) {
                        const u = this.length;
                        return this.resize(u + 1),
                        this.emplace(u, e, o, a)
                    }
                    emplace(e, o, a, u) {
                        const l = 3 * e;
                        return this.int16[l + 0] = o,
                        this.int16[l + 1] = a,
                        this.int16[l + 2] = u,
                        e
                    }
                }
                Pc.prototype.bytesPerElement = 6,
                Fe(Pc, "StructArrayLayout3i6");
                class ha extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a, u) {
                        const l = this.length;
                        return this.resize(l + 1),
                        this.emplace(l, e, o, a, u)
                    }
                    emplace(e, o, a, u, l) {
                        const p = 4 * e;
                        return this.int16[p + 0] = o,
                        this.int16[p + 1] = a,
                        this.int16[p + 2] = u,
                        this.int16[p + 3] = l,
                        e
                    }
                }
                ha.prototype.bytesPerElement = 8,
                Fe(ha, "StructArrayLayout4i8");
                class yu extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a, u, l) {
                        const p = this.length;
                        return this.resize(p + 1),
                        this.emplace(p, e, o, a, u, l)
                    }
                    emplace(e, o, a, u, l, p) {
                        const g = 5 * e;
                        return this.int16[g + 0] = o,
                        this.int16[g + 1] = a,
                        this.int16[g + 2] = u,
                        this.int16[g + 3] = l,
                        this.int16[g + 4] = p,
                        e
                    }
                }
                yu.prototype.bytesPerElement = 10,
                Fe(yu, "StructArrayLayout5i10");
                class $r extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a, u, l, p, g) {
                        const x = this.length;
                        return this.resize(x + 1),
                        this.emplace(x, e, o, a, u, l, p, g)
                    }
                    emplace(e, o, a, u, l, p, g, x) {
                        const T = 6 * e
                          , f = 12 * e
                          , b = 3 * e;
                        return this.int16[T + 0] = o,
                        this.int16[T + 1] = a,
                        this.uint8[f + 4] = u,
                        this.uint8[f + 5] = l,
                        this.uint8[f + 6] = p,
                        this.uint8[f + 7] = g,
                        this.float32[b + 2] = x,
                        e
                    }
                }
                $r.prototype.bytesPerElement = 12,
                Fe($r, "StructArrayLayout2i4ub1f12");
                class ua extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a, u) {
                        const l = this.length;
                        return this.resize(l + 1),
                        this.emplace(l, e, o, a, u)
                    }
                    emplace(e, o, a, u, l) {
                        const p = 4 * e;
                        return this.float32[p + 0] = o,
                        this.float32[p + 1] = a,
                        this.float32[p + 2] = u,
                        this.float32[p + 3] = l,
                        e
                    }
                }
                ua.prototype.bytesPerElement = 16,
                Fe(ua, "StructArrayLayout4f16");
                class Ds extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a) {
                        const u = this.length;
                        return this.resize(u + 1),
                        this.emplace(u, e, o, a)
                    }
                    emplace(e, o, a, u) {
                        const l = 3 * e;
                        return this.float32[l + 0] = o,
                        this.float32[l + 1] = a,
                        this.float32[l + 2] = u,
                        e
                    }
                }
                Ds.prototype.bytesPerElement = 12,
                Fe(Ds, "StructArrayLayout3f12");
                class pa extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a, u, l) {
                        const p = this.length;
                        return this.resize(p + 1),
                        this.emplace(p, e, o, a, u, l)
                    }
                    emplace(e, o, a, u, l, p) {
                        const g = 6 * e
                          , x = 3 * e;
                        return this.uint16[g + 0] = o,
                        this.uint16[g + 1] = a,
                        this.uint16[g + 2] = u,
                        this.uint16[g + 3] = l,
                        this.float32[x + 2] = p,
                        e
                    }
                }
                pa.prototype.bytesPerElement = 12,
                Fe(pa, "StructArrayLayout4ui1f12");
                class Ph extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a, u) {
                        const l = this.length;
                        return this.resize(l + 1),
                        this.emplace(l, e, o, a, u)
                    }
                    emplace(e, o, a, u, l) {
                        const p = 4 * e;
                        return this.uint16[p + 0] = o,
                        this.uint16[p + 1] = a,
                        this.uint16[p + 2] = u,
                        this.uint16[p + 3] = l,
                        e
                    }
                }
                Ph.prototype.bytesPerElement = 8,
                Fe(Ph, "StructArrayLayout4ui8");
                class Mh extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a, u, l, p) {
                        const g = this.length;
                        return this.resize(g + 1),
                        this.emplace(g, e, o, a, u, l, p)
                    }
                    emplace(e, o, a, u, l, p, g) {
                        const x = 6 * e;
                        return this.int16[x + 0] = o,
                        this.int16[x + 1] = a,
                        this.int16[x + 2] = u,
                        this.int16[x + 3] = l,
                        this.int16[x + 4] = p,
                        this.int16[x + 5] = g,
                        e
                    }
                }
                Mh.prototype.bytesPerElement = 12,
                Fe(Mh, "StructArrayLayout6i12");
                class vu extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a, u, l, p, g, x, T, f, b, P) {
                        const v = this.length;
                        return this.resize(v + 1),
                        this.emplace(v, e, o, a, u, l, p, g, x, T, f, b, P)
                    }
                    emplace(e, o, a, u, l, p, g, x, T, f, b, P, v) {
                        const w = 12 * e;
                        return this.int16[w + 0] = o,
                        this.int16[w + 1] = a,
                        this.int16[w + 2] = u,
                        this.int16[w + 3] = l,
                        this.uint16[w + 4] = p,
                        this.uint16[w + 5] = g,
                        this.uint16[w + 6] = x,
                        this.uint16[w + 7] = T,
                        this.int16[w + 8] = f,
                        this.int16[w + 9] = b,
                        this.int16[w + 10] = P,
                        this.int16[w + 11] = v,
                        e
                    }
                }
                vu.prototype.bytesPerElement = 24,
                Fe(vu, "StructArrayLayout4i4ui4i24");
                class xu extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a, u, l, p) {
                        const g = this.length;
                        return this.resize(g + 1),
                        this.emplace(g, e, o, a, u, l, p)
                    }
                    emplace(e, o, a, u, l, p, g) {
                        const x = 10 * e
                          , T = 5 * e;
                        return this.int16[x + 0] = o,
                        this.int16[x + 1] = a,
                        this.int16[x + 2] = u,
                        this.float32[T + 2] = l,
                        this.float32[T + 3] = p,
                        this.float32[T + 4] = g,
                        e
                    }
                }
                xu.prototype.bytesPerElement = 20,
                Fe(xu, "StructArrayLayout3i3f20");
                class bu extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer)
                    }
                    emplaceBack(e) {
                        const o = this.length;
                        return this.resize(o + 1),
                        this.emplace(o, e)
                    }
                    emplace(e, o) {
                        return this.uint32[1 * e + 0] = o,
                        e
                    }
                }
                bu.prototype.bytesPerElement = 4,
                Fe(bu, "StructArrayLayout1ul4");
                class da extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o) {
                        const a = this.length;
                        return this.resize(a + 1),
                        this.emplace(a, e, o)
                    }
                    emplace(e, o, a) {
                        const u = 2 * e;
                        return this.uint16[u + 0] = o,
                        this.uint16[u + 1] = a,
                        e
                    }
                }
                da.prototype.bytesPerElement = 4,
                Fe(da, "StructArrayLayout2ui4");
                class wu extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a, u, l, p, g, x, T, f, b, P, v) {
                        const w = this.length;
                        return this.resize(w + 1),
                        this.emplace(w, e, o, a, u, l, p, g, x, T, f, b, P, v)
                    }
                    emplace(e, o, a, u, l, p, g, x, T, f, b, P, v, w) {
                        const C = 20 * e
                          , A = 10 * e;
                        return this.int16[C + 0] = o,
                        this.int16[C + 1] = a,
                        this.int16[C + 2] = u,
                        this.int16[C + 3] = l,
                        this.int16[C + 4] = p,
                        this.float32[A + 3] = g,
                        this.float32[A + 4] = x,
                        this.float32[A + 5] = T,
                        this.float32[A + 6] = f,
                        this.int16[C + 14] = b,
                        this.uint32[A + 8] = P,
                        this.uint16[C + 18] = v,
                        this.uint16[C + 19] = w,
                        e
                    }
                }
                wu.prototype.bytesPerElement = 40,
                Fe(wu, "StructArrayLayout5i4f1i1ul2ui40");
                class Th extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a, u, l, p, g) {
                        const x = this.length;
                        return this.resize(x + 1),
                        this.emplace(x, e, o, a, u, l, p, g)
                    }
                    emplace(e, o, a, u, l, p, g, x) {
                        const T = 8 * e;
                        return this.int16[T + 0] = o,
                        this.int16[T + 1] = a,
                        this.int16[T + 2] = u,
                        this.int16[T + 4] = l,
                        this.int16[T + 5] = p,
                        this.int16[T + 6] = g,
                        this.int16[T + 7] = x,
                        e
                    }
                }
                Th.prototype.bytesPerElement = 16,
                Fe(Th, "StructArrayLayout3i2i2i16");
                class Ch extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a, u, l) {
                        const p = this.length;
                        return this.resize(p + 1),
                        this.emplace(p, e, o, a, u, l)
                    }
                    emplace(e, o, a, u, l, p) {
                        const g = 4 * e
                          , x = 8 * e;
                        return this.float32[g + 0] = o,
                        this.float32[g + 1] = a,
                        this.float32[g + 2] = u,
                        this.int16[x + 6] = l,
                        this.int16[x + 7] = p,
                        e
                    }
                }
                Ch.prototype.bytesPerElement = 16,
                Fe(Ch, "StructArrayLayout2f1f2i16");
                class Pu extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a, u, l, p) {
                        const g = this.length;
                        return this.resize(g + 1),
                        this.emplace(g, e, o, a, u, l, p)
                    }
                    emplace(e, o, a, u, l, p, g) {
                        const x = 20 * e
                          , T = 5 * e;
                        return this.uint8[x + 0] = o,
                        this.uint8[x + 1] = a,
                        this.float32[T + 1] = u,
                        this.float32[T + 2] = l,
                        this.float32[T + 3] = p,
                        this.float32[T + 4] = g,
                        e
                    }
                }
                Pu.prototype.bytesPerElement = 20,
                Fe(Pu, "StructArrayLayout2ub4f20");
                class Xn extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a) {
                        const u = this.length;
                        return this.resize(u + 1),
                        this.emplace(u, e, o, a)
                    }
                    emplace(e, o, a, u) {
                        const l = 3 * e;
                        return this.uint16[l + 0] = o,
                        this.uint16[l + 1] = a,
                        this.uint16[l + 2] = u,
                        e
                    }
                }
                Xn.prototype.bytesPerElement = 6,
                Fe(Xn, "StructArrayLayout3ui6");
                class Mu extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a, u, l, p, g, x, T, f, b, P, v, w, C, A, O, F, z, L, N) {
                        const G = this.length;
                        return this.resize(G + 1),
                        this.emplace(G, e, o, a, u, l, p, g, x, T, f, b, P, v, w, C, A, O, F, z, L, N)
                    }
                    emplace(e, o, a, u, l, p, g, x, T, f, b, P, v, w, C, A, O, F, z, L, N, G) {
                        const X = 30 * e
                          , _e = 15 * e
                          , me = 60 * e;
                        return this.int16[X + 0] = o,
                        this.int16[X + 1] = a,
                        this.int16[X + 2] = u,
                        this.float32[_e + 2] = l,
                        this.float32[_e + 3] = p,
                        this.uint16[X + 8] = g,
                        this.uint16[X + 9] = x,
                        this.uint32[_e + 5] = T,
                        this.uint32[_e + 6] = f,
                        this.uint32[_e + 7] = b,
                        this.uint16[X + 16] = P,
                        this.uint16[X + 17] = v,
                        this.uint16[X + 18] = w,
                        this.float32[_e + 10] = C,
                        this.float32[_e + 11] = A,
                        this.uint8[me + 48] = O,
                        this.uint8[me + 49] = F,
                        this.uint8[me + 50] = z,
                        this.uint32[_e + 13] = L,
                        this.int16[X + 28] = N,
                        this.uint8[me + 58] = G,
                        e
                    }
                }
                Mu.prototype.bytesPerElement = 60,
                Fe(Mu, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
                class Eh extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a, u, l, p, g, x, T, f, b, P, v, w, C, A, O, F, z, L, N, G, X, _e, me, pe, Ne, Pe, $e, We, je, Ke) {
                        const rt = this.length;
                        return this.resize(rt + 1),
                        this.emplace(rt, e, o, a, u, l, p, g, x, T, f, b, P, v, w, C, A, O, F, z, L, N, G, X, _e, me, pe, Ne, Pe, $e, We, je, Ke)
                    }
                    emplace(e, o, a, u, l, p, g, x, T, f, b, P, v, w, C, A, O, F, z, L, N, G, X, _e, me, pe, Ne, Pe, $e, We, je, Ke, rt) {
                        const at = 20 * e
                          , ot = 40 * e
                          , Ct = 80 * e;
                        return this.float32[at + 0] = o,
                        this.float32[at + 1] = a,
                        this.int16[ot + 4] = u,
                        this.int16[ot + 5] = l,
                        this.int16[ot + 6] = p,
                        this.int16[ot + 7] = g,
                        this.int16[ot + 8] = x,
                        this.int16[ot + 9] = T,
                        this.int16[ot + 10] = f,
                        this.int16[ot + 11] = b,
                        this.int16[ot + 12] = P,
                        this.uint16[ot + 13] = v,
                        this.uint16[ot + 14] = w,
                        this.uint16[ot + 15] = C,
                        this.uint16[ot + 16] = A,
                        this.uint16[ot + 17] = O,
                        this.uint16[ot + 18] = F,
                        this.uint16[ot + 19] = z,
                        this.uint16[ot + 20] = L,
                        this.uint16[ot + 21] = N,
                        this.uint16[ot + 22] = G,
                        this.uint16[ot + 23] = X,
                        this.uint16[ot + 24] = _e,
                        this.uint16[ot + 25] = me,
                        this.uint16[ot + 26] = pe,
                        this.uint16[ot + 27] = Ne,
                        this.uint32[at + 14] = Pe,
                        this.float32[at + 15] = $e,
                        this.float32[at + 16] = We,
                        this.float32[at + 17] = je,
                        this.float32[at + 18] = Ke,
                        this.uint8[Ct + 76] = rt,
                        e
                    }
                }
                Eh.prototype.bytesPerElement = 80,
                Fe(Eh, "StructArrayLayout2f9i15ui1ul4f1ub80");
                class Ml extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(e) {
                        const o = this.length;
                        return this.resize(o + 1),
                        this.emplace(o, e)
                    }
                    emplace(e, o) {
                        return this.float32[1 * e + 0] = o,
                        e
                    }
                }
                Ml.prototype.bytesPerElement = 4,
                Fe(Ml, "StructArrayLayout1f4");
                class wr extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a, u, l) {
                        const p = this.length;
                        return this.resize(p + 1),
                        this.emplace(p, e, o, a, u, l)
                    }
                    emplace(e, o, a, u, l, p) {
                        const g = 5 * e;
                        return this.float32[g + 0] = o,
                        this.float32[g + 1] = a,
                        this.float32[g + 2] = u,
                        this.float32[g + 3] = l,
                        this.float32[g + 4] = p,
                        e
                    }
                }
                wr.prototype.bytesPerElement = 20,
                Fe(wr, "StructArrayLayout5f20");
                class Sh extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a, u, l, p, g) {
                        const x = this.length;
                        return this.resize(x + 1),
                        this.emplace(x, e, o, a, u, l, p, g)
                    }
                    emplace(e, o, a, u, l, p, g, x) {
                        const T = 7 * e;
                        return this.float32[T + 0] = o,
                        this.float32[T + 1] = a,
                        this.float32[T + 2] = u,
                        this.float32[T + 3] = l,
                        this.float32[T + 4] = p,
                        this.float32[T + 5] = g,
                        this.float32[T + 6] = x,
                        e
                    }
                }
                Sh.prototype.bytesPerElement = 28,
                Fe(Sh, "StructArrayLayout7f28");
                class Tu extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a, u, l, p, g, x, T, f, b) {
                        const P = this.length;
                        return this.resize(P + 1),
                        this.emplace(P, e, o, a, u, l, p, g, x, T, f, b)
                    }
                    emplace(e, o, a, u, l, p, g, x, T, f, b, P) {
                        const v = 11 * e;
                        return this.float32[v + 0] = o,
                        this.float32[v + 1] = a,
                        this.float32[v + 2] = u,
                        this.float32[v + 3] = l,
                        this.float32[v + 4] = p,
                        this.float32[v + 5] = g,
                        this.float32[v + 6] = x,
                        this.float32[v + 7] = T,
                        this.float32[v + 8] = f,
                        this.float32[v + 9] = b,
                        this.float32[v + 10] = P,
                        e
                    }
                }
                Tu.prototype.bytesPerElement = 44,
                Fe(Tu, "StructArrayLayout11f44");
                class Cu extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a, u, l, p, g, x, T) {
                        const f = this.length;
                        return this.resize(f + 1),
                        this.emplace(f, e, o, a, u, l, p, g, x, T)
                    }
                    emplace(e, o, a, u, l, p, g, x, T, f) {
                        const b = 9 * e;
                        return this.float32[b + 0] = o,
                        this.float32[b + 1] = a,
                        this.float32[b + 2] = u,
                        this.float32[b + 3] = l,
                        this.float32[b + 4] = p,
                        this.float32[b + 5] = g,
                        this.float32[b + 6] = x,
                        this.float32[b + 7] = T,
                        this.float32[b + 8] = f,
                        e
                    }
                }
                Cu.prototype.bytesPerElement = 36,
                Fe(Cu, "StructArrayLayout9f36");
                class za extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o) {
                        const a = this.length;
                        return this.resize(a + 1),
                        this.emplace(a, e, o)
                    }
                    emplace(e, o, a) {
                        const u = 2 * e;
                        return this.float32[u + 0] = o,
                        this.float32[u + 1] = a,
                        e
                    }
                }
                za.prototype.bytesPerElement = 8,
                Fe(za, "StructArrayLayout2f8");
                class Mc extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a, u) {
                        const l = this.length;
                        return this.resize(l + 1),
                        this.emplace(l, e, o, a, u)
                    }
                    emplace(e, o, a, u, l) {
                        const p = 6 * e;
                        return this.uint32[3 * e + 0] = o,
                        this.uint16[p + 2] = a,
                        this.uint16[p + 3] = u,
                        this.uint16[p + 4] = l,
                        e
                    }
                }
                Mc.prototype.bytesPerElement = 12,
                Fe(Mc, "StructArrayLayout1ul3ui12");
                class Ih extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(e) {
                        const o = this.length;
                        return this.resize(o + 1),
                        this.emplace(o, e)
                    }
                    emplace(e, o) {
                        return this.uint16[1 * e + 0] = o,
                        e
                    }
                }
                Ih.prototype.bytesPerElement = 2,
                Fe(Ih, "StructArrayLayout1ui2");
                class Eu extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a, u, l, p, g, x, T, f, b, P, v, w, C, A) {
                        const O = this.length;
                        return this.resize(O + 1),
                        this.emplace(O, e, o, a, u, l, p, g, x, T, f, b, P, v, w, C, A)
                    }
                    emplace(e, o, a, u, l, p, g, x, T, f, b, P, v, w, C, A, O) {
                        const F = 16 * e;
                        return this.float32[F + 0] = o,
                        this.float32[F + 1] = a,
                        this.float32[F + 2] = u,
                        this.float32[F + 3] = l,
                        this.float32[F + 4] = p,
                        this.float32[F + 5] = g,
                        this.float32[F + 6] = x,
                        this.float32[F + 7] = T,
                        this.float32[F + 8] = f,
                        this.float32[F + 9] = b,
                        this.float32[F + 10] = P,
                        this.float32[F + 11] = v,
                        this.float32[F + 12] = w,
                        this.float32[F + 13] = C,
                        this.float32[F + 14] = A,
                        this.float32[F + 15] = O,
                        e
                    }
                }
                Eu.prototype.bytesPerElement = 64,
                Fe(Eu, "StructArrayLayout16f64");
                class Tc extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(e, o, a, u, l, p, g) {
                        const x = this.length;
                        return this.resize(x + 1),
                        this.emplace(x, e, o, a, u, l, p, g)
                    }
                    emplace(e, o, a, u, l, p, g, x) {
                        const T = 10 * e
                          , f = 5 * e;
                        return this.uint16[T + 0] = o,
                        this.uint16[T + 1] = a,
                        this.uint16[T + 2] = u,
                        this.uint16[T + 3] = l,
                        this.float32[f + 2] = p,
                        this.float32[f + 3] = g,
                        this.float32[f + 4] = x,
                        e
                    }
                }
                Tc.prototype.bytesPerElement = 20,
                Fe(Tc, "StructArrayLayout4ui3f20");
                class Su extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(e) {
                        const o = this.length;
                        return this.resize(o + 1),
                        this.emplace(o, e)
                    }
                    emplace(e, o) {
                        return this.int16[1 * e + 0] = o,
                        e
                    }
                }
                Su.prototype.bytesPerElement = 2,
                Fe(Su, "StructArrayLayout1i2");
                class Ah extends tn {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer)
                    }
                    emplaceBack(e) {
                        const o = this.length;
                        return this.resize(o + 1),
                        this.emplace(o, e)
                    }
                    emplace(e, o) {
                        return this.uint8[1 * e + 0] = o,
                        e
                    }
                }
                Ah.prototype.bytesPerElement = 1,
                Fe(Ah, "StructArrayLayout1ub1");
                class Cc extends wc {
                    get projectedAnchorX() {
                        return this._structArray.int16[this._pos2 + 0]
                    }
                    get projectedAnchorY() {
                        return this._structArray.int16[this._pos2 + 1]
                    }
                    get projectedAnchorZ() {
                        return this._structArray.int16[this._pos2 + 2]
                    }
                    get tileAnchorX() {
                        return this._structArray.int16[this._pos2 + 3]
                    }
                    get tileAnchorY() {
                        return this._structArray.int16[this._pos2 + 4]
                    }
                    get x1() {
                        return this._structArray.float32[this._pos4 + 3]
                    }
                    get y1() {
                        return this._structArray.float32[this._pos4 + 4]
                    }
                    get x2() {
                        return this._structArray.float32[this._pos4 + 5]
                    }
                    get y2() {
                        return this._structArray.float32[this._pos4 + 6]
                    }
                    get padding() {
                        return this._structArray.int16[this._pos2 + 14]
                    }
                    get featureIndex() {
                        return this._structArray.uint32[this._pos4 + 8]
                    }
                    get sourceLayerIndex() {
                        return this._structArray.uint16[this._pos2 + 18]
                    }
                    get bucketIndex() {
                        return this._structArray.uint16[this._pos2 + 19]
                    }
                }
                Cc.prototype.size = 40;
                class vp extends wu {
                    get(e) {
                        return new Cc(this,e)
                    }
                }
                Fe(vp, "CollisionBoxArray");
                class xp extends wc {
                    get projectedAnchorX() {
                        return this._structArray.int16[this._pos2 + 0]
                    }
                    get projectedAnchorY() {
                        return this._structArray.int16[this._pos2 + 1]
                    }
                    get projectedAnchorZ() {
                        return this._structArray.int16[this._pos2 + 2]
                    }
                    get tileAnchorX() {
                        return this._structArray.float32[this._pos4 + 2]
                    }
                    get tileAnchorY() {
                        return this._structArray.float32[this._pos4 + 3]
                    }
                    get glyphStartIndex() {
                        return this._structArray.uint16[this._pos2 + 8]
                    }
                    get numGlyphs() {
                        return this._structArray.uint16[this._pos2 + 9]
                    }
                    get vertexStartIndex() {
                        return this._structArray.uint32[this._pos4 + 5]
                    }
                    get lineStartIndex() {
                        return this._structArray.uint32[this._pos4 + 6]
                    }
                    get lineLength() {
                        return this._structArray.uint32[this._pos4 + 7]
                    }
                    get segment() {
                        return this._structArray.uint16[this._pos2 + 16]
                    }
                    get lowerSize() {
                        return this._structArray.uint16[this._pos2 + 17]
                    }
                    get upperSize() {
                        return this._structArray.uint16[this._pos2 + 18]
                    }
                    get lineOffsetX() {
                        return this._structArray.float32[this._pos4 + 10]
                    }
                    get lineOffsetY() {
                        return this._structArray.float32[this._pos4 + 11]
                    }
                    get writingMode() {
                        return this._structArray.uint8[this._pos1 + 48]
                    }
                    get placedOrientation() {
                        return this._structArray.uint8[this._pos1 + 49]
                    }
                    set placedOrientation(e) {
                        this._structArray.uint8[this._pos1 + 49] = e
                    }
                    get hidden() {
                        return this._structArray.uint8[this._pos1 + 50]
                    }
                    set hidden(e) {
                        this._structArray.uint8[this._pos1 + 50] = e
                    }
                    get crossTileID() {
                        return this._structArray.uint32[this._pos4 + 13]
                    }
                    set crossTileID(e) {
                        this._structArray.uint32[this._pos4 + 13] = e
                    }
                    get associatedIconIndex() {
                        return this._structArray.int16[this._pos2 + 28]
                    }
                    get flipState() {
                        return this._structArray.uint8[this._pos1 + 58]
                    }
                    set flipState(e) {
                        this._structArray.uint8[this._pos1 + 58] = e
                    }
                }
                xp.prototype.size = 60;
                class bp extends Mu {
                    get(e) {
                        return new xp(this,e)
                    }
                }
                Fe(bp, "PlacedSymbolArray");
                class wp extends wc {
                    get tileAnchorX() {
                        return this._structArray.float32[this._pos4 + 0]
                    }
                    get tileAnchorY() {
                        return this._structArray.float32[this._pos4 + 1]
                    }
                    get projectedAnchorX() {
                        return this._structArray.int16[this._pos2 + 4]
                    }
                    get projectedAnchorY() {
                        return this._structArray.int16[this._pos2 + 5]
                    }
                    get projectedAnchorZ() {
                        return this._structArray.int16[this._pos2 + 6]
                    }
                    get rightJustifiedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 7]
                    }
                    get centerJustifiedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 8]
                    }
                    get leftJustifiedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 9]
                    }
                    get verticalPlacedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 10]
                    }
                    get placedIconSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 11]
                    }
                    get verticalPlacedIconSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 12]
                    }
                    get key() {
                        return this._structArray.uint16[this._pos2 + 13]
                    }
                    get textBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 14]
                    }
                    get textBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 15]
                    }
                    get verticalTextBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 16]
                    }
                    get verticalTextBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 17]
                    }
                    get iconBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 18]
                    }
                    get iconBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 19]
                    }
                    get verticalIconBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 20]
                    }
                    get verticalIconBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 21]
                    }
                    get featureIndex() {
                        return this._structArray.uint16[this._pos2 + 22]
                    }
                    get numHorizontalGlyphVertices() {
                        return this._structArray.uint16[this._pos2 + 23]
                    }
                    get numVerticalGlyphVertices() {
                        return this._structArray.uint16[this._pos2 + 24]
                    }
                    get numIconVertices() {
                        return this._structArray.uint16[this._pos2 + 25]
                    }
                    get numVerticalIconVertices() {
                        return this._structArray.uint16[this._pos2 + 26]
                    }
                    get useRuntimeCollisionCircles() {
                        return this._structArray.uint16[this._pos2 + 27]
                    }
                    get crossTileID() {
                        return this._structArray.uint32[this._pos4 + 14]
                    }
                    set crossTileID(e) {
                        this._structArray.uint32[this._pos4 + 14] = e
                    }
                    get textOffset0() {
                        return this._structArray.float32[this._pos4 + 15]
                    }
                    get textOffset1() {
                        return this._structArray.float32[this._pos4 + 16]
                    }
                    get collisionCircleDiameter() {
                        return this._structArray.float32[this._pos4 + 17]
                    }
                    get zOffset() {
                        return this._structArray.float32[this._pos4 + 18]
                    }
                    set zOffset(e) {
                        this._structArray.float32[this._pos4 + 18] = e
                    }
                    get hasIconTextFit() {
                        return this._structArray.uint8[this._pos1 + 76]
                    }
                }
                wp.prototype.size = 80;
                class Pp extends Eh {
                    get(e) {
                        return new wp(this,e)
                    }
                }
                Fe(Pp, "SymbolInstanceArray");
                class Ec extends Ml {
                    getoffsetX(e) {
                        return this.float32[1 * e + 0]
                    }
                }
                Fe(Ec, "GlyphOffsetArray");
                class Sc extends ts {
                    getx(e) {
                        return this.int16[2 * e + 0]
                    }
                    gety(e) {
                        return this.int16[2 * e + 1]
                    }
                }
                Fe(Sc, "SymbolLineVertexArray");
                class Pr extends wc {
                    get featureIndex() {
                        return this._structArray.uint32[this._pos4 + 0]
                    }
                    get sourceLayerIndex() {
                        return this._structArray.uint16[this._pos2 + 2]
                    }
                    get bucketIndex() {
                        return this._structArray.uint16[this._pos2 + 3]
                    }
                    get layoutVertexArrayOffset() {
                        return this._structArray.uint16[this._pos2 + 4]
                    }
                }
                Pr.prototype.size = 12;
                class Ic extends Mc {
                    get(e) {
                        return new Pr(this,e)
                    }
                }
                Fe(Ic, "FeatureIndexArray");
                class Mp extends da {
                    geta_centroid_pos0(e) {
                        return this.uint16[2 * e + 0]
                    }
                    geta_centroid_pos1(e) {
                        return this.uint16[2 * e + 1]
                    }
                }
                Fe(Mp, "FillExtrusionCentroidArray");
                class Tp extends wc {
                    get a_join_normal_inside0() {
                        return this._structArray.int16[this._pos2 + 0]
                    }
                    get a_join_normal_inside1() {
                        return this._structArray.int16[this._pos2 + 1]
                    }
                    get a_join_normal_inside2() {
                        return this._structArray.int16[this._pos2 + 2]
                    }
                }
                Tp.prototype.size = 6;
                class Cp extends Pc {
                    get(e) {
                        return new Tp(this,e)
                    }
                }
                Fe(Cp, "FillExtrusionWallArray");
                const Sd = Si([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }], 4)
                  , Iu = Si([{
                    name: "a_pos_3",
                    components: 3,
                    type: "Int16"
                }, {
                    name: "a_pos_normal_3",
                    components: 3,
                    type: "Int16"
                }]);
                class mn {
                    constructor(e=[]) {
                        this.segments = e
                    }
                    _prepareSegment(e, o, a, u) {
                        let l = this.segments[this.segments.length - 1];
                        return e > mn.MAX_VERTEX_ARRAY_LENGTH && vo("Max vertices per segment is ".concat(mn.MAX_VERTEX_ARRAY_LENGTH, ": bucket requested ").concat(e)),
                        (!l || l.vertexLength + e > mn.MAX_VERTEX_ARRAY_LENGTH || l.sortKey !== u) && (l = {
                            vertexOffset: o,
                            primitiveOffset: a,
                            vertexLength: 0,
                            primitiveLength: 0
                        },
                        void 0 !== u && (l.sortKey = u),
                        this.segments.push(l)),
                        l
                    }
                    prepareSegment(e, o, a, u) {
                        return this._prepareSegment(e, o.length, a.length, u)
                    }
                    get() {
                        return this.segments
                    }
                    destroy() {
                        for (const e of this.segments)
                            for (const o in e.vaos)
                                e.vaos[o].destroy()
                    }
                    static simpleSegment(e, o, a, u) {
                        return new mn([{
                            vertexOffset: e,
                            primitiveOffset: o,
                            vertexLength: a,
                            primitiveLength: u,
                            vaos: {},
                            sortKey: 0
                        }])
                    }
                }
                function Oh(n, e) {
                    return 256 * (n = ie(Math.floor(n), 0, 255)) + ie(Math.floor(e), 0, 255)
                }
                mn.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1,
                Fe(mn, "SegmentVector");
                const Id = Si([{
                    name: "a_pattern",
                    components: 4,
                    type: "Uint16"
                }, {
                    name: "a_pixel_ratio",
                    components: 1,
                    type: "Float32"
                }])
                  , Ad = Si([{
                    name: "a_dash",
                    components: 4,
                    type: "Uint16"
                }]);
                class Ba {
                    constructor() {
                        this.ids = [],
                        this.uniqueIds = [],
                        this.positions = [],
                        this.indexed = !1
                    }
                    add(e, o, a, u) {
                        this.ids.push(Ep(e)),
                        this.positions.push(o, a, u)
                    }
                    eachPosition(e, o) {
                        const a = Ep(e);
                        let u = 0
                          , l = this.ids.length - 1;
                        for (; u < l; ) {
                            const p = u + l >> 1;
                            this.ids[p] >= a ? l = p : u = p + 1
                        }
                        for (; this.ids[u] === a; )
                            o(this.positions[3 * u], this.positions[3 * u + 1], this.positions[3 * u + 2]),
                            u++
                    }
                    static serialize(e, o) {
                        const a = new Float64Array(e.ids)
                          , u = new Uint32Array(e.positions);
                        return Rh(a, u, 0, a.length - 1),
                        o && (o.add(a.buffer),
                        o.add(u.buffer)),
                        {
                            ids: a,
                            positions: u
                        }
                    }
                    static deserialize(e) {
                        const o = new Ba;
                        let a;
                        o.ids = e.ids,
                        o.positions = e.positions;
                        for (const u of o.ids)
                            u !== a && o.uniqueIds.push(u),
                            a = u;
                        return o.indexed = !0,
                        o
                    }
                }
                function Ep(n) {
                    const e = +n;
                    return !isNaN(e) && Number.MIN_SAFE_INTEGER <= e && e <= Number.MAX_SAFE_INTEGER ? e : Xa(String(n))
                }
                function Rh(n, e, o, a) {
                    for (; o < a; ) {
                        const u = n[o + a >> 1];
                        let l = o - 1
                          , p = a + 1;
                        for (; ; ) {
                            do {
                                l++
                            } while (n[l] < u);
                            do {
                                p--
                            } while (n[p] > u);
                            if (l >= p)
                                break;
                            Ac(n, l, p),
                            Ac(e, 3 * l, 3 * p),
                            Ac(e, 3 * l + 1, 3 * p + 1),
                            Ac(e, 3 * l + 2, 3 * p + 2)
                        }
                        p - o < a - p ? (Rh(n, e, o, p),
                        o = p + 1) : (Rh(n, e, p + 1, a),
                        a = p)
                    }
                }
                function Ac(n, e, o) {
                    const a = n[e];
                    n[e] = n[o],
                    n[o] = a
                }
                Fe(Ba, "FeaturePositionMap");
                class Ls {
                    constructor(e) {
                        this.gl = e.gl,
                        this.initialized = !1
                    }
                    fetchUniformLocation(e, o) {
                        return this.location || this.initialized || (this.location = this.gl.getUniformLocation(e, o),
                        this.initialized = !0),
                        !!this.location
                    }
                    set(e, o, a) {
                        throw new Error("Uniform#set() must be implemented by each concrete Uniform")
                    }
                }
                class Tl extends Ls {
                    constructor(e) {
                        super(e),
                        this.current = 0
                    }
                    set(e, o, a) {
                        this.fetchUniformLocation(e, o) && this.current !== a && (this.current = a,
                        this.gl.uniform1i(this.location, a))
                    }
                }
                class hn extends Ls {
                    constructor(e) {
                        super(e),
                        this.current = 0
                    }
                    set(e, o, a) {
                        this.fetchUniformLocation(e, o) && this.current !== a && (this.current = a,
                        this.gl.uniform1f(this.location, a))
                    }
                }
                class os extends Ls {
                    constructor(e) {
                        super(e),
                        this.current = [0, 0]
                    }
                    set(e, o, a) {
                        this.fetchUniformLocation(e, o) && (a[0] === this.current[0] && a[1] === this.current[1] || (this.current = a,
                        this.gl.uniform2f(this.location, a[0], a[1])))
                    }
                }
                class Au extends Ls {
                    constructor(e) {
                        super(e),
                        this.current = [0, 0, 0]
                    }
                    set(e, o, a) {
                        this.fetchUniformLocation(e, o) && (a[0] === this.current[0] && a[1] === this.current[1] && a[2] === this.current[2] || (this.current = a,
                        this.gl.uniform3f(this.location, a[0], a[1], a[2])))
                    }
                }
                class Oc extends Ls {
                    constructor(e) {
                        super(e),
                        this.current = [0, 0, 0, 0]
                    }
                    set(e, o, a) {
                        this.fetchUniformLocation(e, o) && (a[0] === this.current[0] && a[1] === this.current[1] && a[2] === this.current[2] && a[3] === this.current[3] || (this.current = a,
                        this.gl.uniform4f(this.location, a[0], a[1], a[2], a[3])))
                    }
                }
                class Sp extends Ls {
                    constructor(e) {
                        super(e),
                        this.current = wi.transparent.toRenderColor(null)
                    }
                    set(e, o, a) {
                        this.fetchUniformLocation(e, o) && (a.r === this.current.r && a.g === this.current.g && a.b === this.current.b && a.a === this.current.a || (this.current = a,
                        this.gl.uniform4f(this.location, a.r, a.g, a.b, a.a)))
                    }
                }
                const Ou = new Float32Array(16);
                class Rc extends Ls {
                    constructor(e) {
                        super(e),
                        this.current = Ou
                    }
                    set(e, o, a) {
                        if (this.fetchUniformLocation(e, o)) {
                            if (a[12] !== this.current[12] || a[0] !== this.current[0])
                                return this.current = a,
                                void this.gl.uniformMatrix4fv(this.location, !1, a);
                            for (let u = 1; u < 16; u++)
                                if (a[u] !== this.current[u]) {
                                    this.current = a,
                                    this.gl.uniformMatrix4fv(this.location, !1, a);
                                    break
                                }
                        }
                    }
                }
                const Od = new Float32Array(9)
                  , Rd = new Float32Array(4);
                class Ru extends Ls {
                    constructor(e) {
                        super(e),
                        this.current = Rd
                    }
                    set(e, o, a) {
                        if (this.fetchUniformLocation(e, o))
                            for (let u = 0; u < 4; u++)
                                if (a[u] !== this.current[u]) {
                                    this.current = a,
                                    this.gl.uniformMatrix2fv(this.location, !1, a);
                                    break
                                }
                    }
                }
                function Dh(n) {
                    return [Oh(255 * n.r, 255 * n.g), Oh(255 * n.b, 255 * n.a)]
                }
                class Cl {
                    constructor(e, o, a, u) {
                        this.value = e,
                        this.uniformNames = o.map(l => "u_".concat(l)),
                        this.type = a,
                        this.context = u
                    }
                    setUniform(e, o, a, u, l) {
                        const p = u.constantOr(this.value);
                        o.set(e, l, p instanceof wi ? p.toRenderColor(this.ignoreLut ? null : this.context.lut) : p)
                    }
                    getBinding(e, o) {
                        return "color" === this.type ? new Sp(e) : new hn(e)
                    }
                }
                class El {
                    constructor(e, o) {
                        this.uniformNames = o.map(a => "u_".concat(a)),
                        this.pattern = null,
                        this.pixelRatio = 1
                    }
                    setConstantPatternPositions(e) {
                        this.pixelRatio = e.pixelRatio || 1,
                        this.pattern = e.tl.concat(e.br)
                    }
                    setUniform(e, o, a, u, l) {
                        const p = "u_pattern" === l || "u_dash" === l ? this.pattern : "u_pixel_ratio" === l ? this.pixelRatio : null;
                        p && o.set(e, l, p)
                    }
                    getBinding(e, o) {
                        return "u_pattern" === o || "u_dash" === o ? new Oc(e) : new hn(e)
                    }
                }
                class Fs {
                    constructor(e, o, a, u) {
                        this.expression = e,
                        this.type = a,
                        this.maxValue = 0,
                        this.paintVertexAttributes = o.map(l => ({
                            name: "a_".concat(l),
                            type: "Float32",
                            components: "color" === a ? 2 : 1,
                            offset: 0
                        })),
                        this.paintVertexArray = new u
                    }
                    populatePaintArray(e, o, a, u, l, p, g) {
                        const x = this.paintVertexArray.length
                          , T = this.expression.evaluate(new Hi(0,{
                            brightness: p
                        }), o, {}, l, u, g);
                        this.paintVertexArray.resize(e),
                        this._setPaintValue(x, e, T, this.context)
                    }
                    updatePaintArray(e, o, a, u, l, p, g) {
                        const x = this.expression.evaluate({
                            zoom: 0,
                            brightness: g
                        }, a, u, void 0, l);
                        this._setPaintValue(e, o, x, this.context)
                    }
                    _setPaintValue(e, o, a, u) {
                        if ("color" === this.type) {
                            const l = Dh(a.toRenderColor(this.ignoreLut ? null : u.lut));
                            for (let p = e; p < o; p++)
                                this.paintVertexArray.emplace(p, l[0], l[1])
                        } else {
                            for (let l = e; l < o; l++)
                                this.paintVertexArray.emplace(l, a);
                            this.maxValue = Math.max(this.maxValue, Math.abs(a))
                        }
                    }
                    upload(e) {
                        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant))
                    }
                    destroy() {
                        this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                    }
                }
                class is {
                    constructor(e, o, a, u, l, p) {
                        this.expression = e,
                        this.uniformNames = o.map(g => "u_".concat(g, "_t")),
                        this.type = a,
                        this.useIntegerZoom = u,
                        this.context = l,
                        this.maxValue = 0,
                        this.paintVertexAttributes = o.map(g => ({
                            name: "a_".concat(g),
                            type: "Float32",
                            components: "color" === a ? 4 : 2,
                            offset: 0
                        })),
                        this.paintVertexArray = new p
                    }
                    populatePaintArray(e, o, a, u, l, p, g) {
                        const x = this.expression.evaluate(new Hi(this.context.zoom,{
                            brightness: p
                        }), o, {}, l, u, g)
                          , T = this.expression.evaluate(new Hi(this.context.zoom + 1,{
                            brightness: p
                        }), o, {}, l, u, g)
                          , f = this.paintVertexArray.length;
                        this.paintVertexArray.resize(e),
                        this._setPaintValue(f, e, x, T, this.context)
                    }
                    updatePaintArray(e, o, a, u, l, p, g) {
                        const x = this.expression.evaluate({
                            zoom: this.context.zoom,
                            brightness: g
                        }, a, u, void 0, l)
                          , T = this.expression.evaluate({
                            zoom: this.context.zoom + 1,
                            brightness: g
                        }, a, u, void 0, l);
                        this._setPaintValue(e, o, x, T, this.context)
                    }
                    _setPaintValue(e, o, a, u, l) {
                        if ("color" === this.type) {
                            const p = Dh(a.toRenderColor(this.ignoreLut ? null : l.lut))
                              , g = Dh(a.toRenderColor(this.ignoreLut ? null : l.lut));
                            for (let x = e; x < o; x++)
                                this.paintVertexArray.emplace(x, p[0], p[1], g[0], g[1])
                        } else {
                            for (let p = e; p < o; p++)
                                this.paintVertexArray.emplace(p, a, u);
                            this.maxValue = Math.max(this.maxValue, Math.abs(a), Math.abs(u))
                        }
                    }
                    upload(e) {
                        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant))
                    }
                    destroy() {
                        this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                    }
                    setUniform(e, o, a, u, l) {
                        const p = this.useIntegerZoom ? Math.floor(a.zoom) : a.zoom
                          , g = ie(this.expression.interpolationFactor(p, this.context.zoom, this.context.zoom + 1), 0, 1);
                        o.set(e, l, g)
                    }
                    getBinding(e, o) {
                        return new hn(e)
                    }
                }
                class ma {
                    constructor(e, o, a, u, l) {
                        this.expression = e,
                        this.layerId = l,
                        this.paintVertexAttributes = ("array" === a ? Ad : Id).members;
                        for (let p = 0; p < o.length; ++p)
                            ;
                        this.paintVertexArray = new u
                    }
                    populatePaintArray(e, o, a, u) {
                        const l = this.paintVertexArray.length;
                        this.paintVertexArray.resize(e),
                        this._setPaintValues(l, e, o.patterns && o.patterns[this.layerId], a)
                    }
                    updatePaintArray(e, o, a, u, l, p, g) {
                        this._setPaintValues(e, o, a.patterns && a.patterns[this.layerId], p)
                    }
                    _setPaintValues(e, o, a, u) {
                        if (!u || !a)
                            return;
                        const l = u[a];
                        if (!l)
                            return;
                        const {tl: p, br: g, pixelRatio: x} = l;
                        for (let T = e; T < o; T++)
                            this.paintVertexArray.emplace(T, p[0], p[1], g[0], g[1], x)
                    }
                    upload(e) {
                        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant))
                    }
                    destroy() {
                        this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                    }
                }
                class Ua {
                    constructor(e, o, a= () => !0) {
                        this.binders = {},
                        this._buffers = [],
                        this.context = o;
                        const u = [];
                        for (const l in e.paint._values) {
                            const p = e.paint.get(l)
                              , g = e.paint.get("".concat(l, "-use-theme"));
                            if (l.endsWith("-use-theme") || !a(l) || !(p instanceof bl && sa(p.property.specification)))
                                continue;
                            const x = Lh(l, e.type)
                              , T = p.value
                              , f = p.property.specification.type
                              , b = !!p.property.useIntegerZoom
                              , P = "line-dasharray" === l || l.endsWith("pattern")
                              , v = "line-dasharray" === l && "constant" !== e.layout.get("line-cap").value.kind;
                            if ("constant" !== T.kind || v)
                                if ("source" === T.kind || v || P) {
                                    const w = Dc(l, f, "source");
                                    this.binders[l] = P ? new ma(T,x,f,w,e.id) : new Fs(T,x,f,w),
                                    u.push("/a_".concat(l))
                                } else {
                                    const w = Dc(l, f, "composite");
                                    this.binders[l] = new is(T,x,f,b,o,w),
                                    u.push("/z_".concat(l))
                                }
                            else
                                this.binders[l] = P ? new El(T.value,x) : new Cl(T.value,x,f,o),
                                u.push("/u_".concat(l));
                            g && (this.binders[l].ignoreLut = "none" === g.constantOr("default"),
                            this.binders[l].checkUseTheme = !0)
                        }
                        this.cacheKey = u.sort().join("")
                    }
                    getMaxValue(e) {
                        const o = this.binders[e];
                        return o instanceof Fs || o instanceof is ? o.maxValue : 0
                    }
                    populatePaintArrays(e, o, a, u, l, p, g) {
                        for (const x in this.binders) {
                            const T = this.binders[x];
                            T.context = this.context,
                            (T instanceof Fs || T instanceof is || T instanceof ma) && T.populatePaintArray(e, o, a, u, l, p, g)
                        }
                    }
                    setConstantPatternPositions(e) {
                        for (const o in this.binders) {
                            const a = this.binders[o];
                            a instanceof El && a.setConstantPatternPositions(e)
                        }
                    }
                    updatePaintArrays(e, o, a, u, l, p, g, x, T) {
                        let f = !1;
                        const b = Object.keys(e)
                          , P = 0 !== b.length && !x
                          , v = P ? b : o.uniqueIds;
                        this.context.lut = l.lut;
                        for (const w in this.binders) {
                            const C = this.binders[w];
                            if (C.context = this.context,
                            (C instanceof Fs || C instanceof is || C instanceof ma) && (!0 === C.expression.isStateDependent || !1 === C.expression.isLightConstant)) {
                                const A = l.paint.get(w);
                                C.expression = A.value;
                                for (const O of v) {
                                    const F = e[O.toString()];
                                    o.eachPosition(O, (z, L, N) => {
                                        const G = u.feature(z);
                                        C.updatePaintArray(L, N, G, F, p, g, T)
                                    }
                                    )
                                }
                                if (!P)
                                    for (const O of a.uniqueIds) {
                                        const F = e[O.toString()];
                                        a.eachPosition(O, (z, L, N) => {
                                            const G = u.feature(z);
                                            C.updatePaintArray(L, N, G, F, p, g, T)
                                        }
                                        )
                                    }
                                f = !0
                            }
                        }
                        return f
                    }
                    defines() {
                        const e = [];
                        for (const o in this.binders) {
                            const a = this.binders[o];
                            (a instanceof Cl || a instanceof El) && e.push(...a.uniformNames.map(u => "#define HAS_UNIFORM_".concat(u)))
                        }
                        return e
                    }
                    getBinderAttributes() {
                        const e = [];
                        for (const o in this.binders) {
                            const a = this.binders[o];
                            if (a instanceof Fs || a instanceof is || a instanceof ma)
                                for (let u = 0; u < a.paintVertexAttributes.length; u++)
                                    e.push(a.paintVertexAttributes[u].name)
                        }
                        return e
                    }
                    getBinderUniforms() {
                        const e = [];
                        for (const o in this.binders) {
                            const a = this.binders[o];
                            if (a instanceof Cl || a instanceof El || a instanceof is)
                                for (const u of a.uniformNames)
                                    e.push(u)
                        }
                        return e
                    }
                    getPaintVertexBuffers() {
                        return this._buffers
                    }
                    getUniforms(e) {
                        const o = [];
                        for (const a in this.binders) {
                            const u = this.binders[a];
                            if (u instanceof Cl || u instanceof El || u instanceof is)
                                for (const l of u.uniformNames)
                                    o.push({
                                        name: l,
                                        property: a,
                                        binding: u.getBinding(e, l)
                                    })
                        }
                        return o
                    }
                    setUniforms(e, o, a, u, l) {
                        for (const {name: p, property: g, binding: x} of a) {
                            if (this.binders[g].checkUseTheme && this.binders[g]instanceof Cl) {
                                const T = u.get("".concat(g, "-use-theme"));
                                T.isConstant() && (this.binders[g].ignoreLut = "none" === T.constantOr("default"))
                            }
                            this.binders[g].setUniform(e, x, l, u.get(g), p)
                        }
                    }
                    updatePaintBuffers() {
                        this._buffers = [];
                        for (const e in this.binders) {
                            const o = this.binders[e];
                            (o instanceof Fs || o instanceof is || o instanceof ma) && o.paintVertexBuffer && this._buffers.push(o.paintVertexBuffer)
                        }
                    }
                    upload(e) {
                        for (const o in this.binders) {
                            const a = this.binders[o];
                            (a instanceof Fs || a instanceof is || a instanceof ma) && a.upload(e)
                        }
                        this.updatePaintBuffers()
                    }
                    destroy() {
                        for (const e in this.binders) {
                            const o = this.binders[e];
                            (o instanceof Fs || o instanceof is || o instanceof ma) && o.destroy()
                        }
                    }
                }
                class fa {
                    constructor(e, o, a= () => !0) {
                        this.programConfigurations = {};
                        for (const u of e)
                            this.programConfigurations[u.id] = new Ua(u,o,a);
                        this.needsUpload = !1,
                        this._featureMap = new Ba,
                        this._featureMapWithoutIds = new Ba,
                        this._bufferOffset = 0,
                        this._idlessCounter = 0
                    }
                    populatePaintArrays(e, o, a, u, l, p, g, x) {
                        for (const T in this.programConfigurations)
                            this.programConfigurations[T].populatePaintArrays(e, o, u, l, p, g, x);
                        void 0 !== o.id ? this._featureMap.add(o.id, a, this._bufferOffset, e) : (this._featureMapWithoutIds.add(this._idlessCounter, a, this._bufferOffset, e),
                        this._idlessCounter += 1),
                        this._bufferOffset = e,
                        this.needsUpload = !0
                    }
                    updatePaintArrays(e, o, a, u, l, p, g) {
                        for (const x of a)
                            this.needsUpload = this.programConfigurations[x.id].updatePaintArrays(e, this._featureMap, this._featureMapWithoutIds, o, x, u, l, p, g || 0) || this.needsUpload
                    }
                    get(e) {
                        return this.programConfigurations[e]
                    }
                    upload(e) {
                        if (this.needsUpload) {
                            for (const o in this.programConfigurations)
                                this.programConfigurations[o].upload(e);
                            this.needsUpload = !1
                        }
                    }
                    destroy() {
                        for (const e in this.programConfigurations)
                            this.programConfigurations[e].destroy()
                    }
                }
                const Dd = {
                    "text-opacity": ["opacity"],
                    "icon-opacity": ["opacity"],
                    "text-occlusion-opacity": ["occlusion_opacity"],
                    "icon-occlusion-opacity": ["occlusion_opacity"],
                    "text-color": ["fill_color"],
                    "icon-color": ["fill_color"],
                    "text-emissive-strength": ["emissive_strength"],
                    "icon-emissive-strength": ["emissive_strength"],
                    "text-halo-color": ["halo_color"],
                    "icon-halo-color": ["halo_color"],
                    "text-halo-blur": ["halo_blur"],
                    "icon-halo-blur": ["halo_blur"],
                    "text-halo-width": ["halo_width"],
                    "icon-halo-width": ["halo_width"],
                    "symbol-z-offset": ["z_offset"],
                    "line-gap-width": ["gapwidth"],
                    "line-pattern": ["pattern", "pixel_ratio"],
                    "fill-pattern": ["pattern", "pixel_ratio"],
                    "fill-extrusion-pattern": ["pattern", "pixel_ratio"],
                    "line-dasharray": ["dash"]
                };
                function Lh(n, e) {
                    return Dd[n] || [n.replace("".concat(e, "-"), "").replace(/-/g, "_")]
                }
                const Ld = {
                    "line-pattern": {
                        source: pa,
                        composite: pa
                    },
                    "fill-pattern": {
                        source: pa,
                        composite: pa
                    },
                    "fill-extrusion-pattern": {
                        source: pa,
                        composite: pa
                    },
                    "line-dasharray": {
                        source: Ph,
                        composite: Ph
                    }
                }
                  , Fd = {
                    color: {
                        source: za,
                        composite: ua
                    },
                    number: {
                        source: Ml,
                        composite: za
                    }
                };
                function Dc(n, e, o) {
                    const a = Ld[n];
                    return a && a[o] || Fd[e][o]
                }
                Fe(Cl, "ConstantBinder"),
                Fe(El, "PatternConstantBinder"),
                Fe(Fs, "SourceExpressionBinder"),
                Fe(ma, "PatternCompositeBinder"),
                Fe(is, "CompositeExpressionBinder"),
                Fe(Ua, "ProgramConfiguration", {
                    omit: ["_buffers"]
                }),
                Fe(fa, "ProgramConfigurationSet");
                const sr = uo / Math.PI / 2
                  , kh = [64, 32, 16]
                  , Gr = -sr
                  , jr = sr;
                function Sl(n, e, o, a=sr) {
                    return o = _o(o),
                    [n * Math.sin(o) * a, -e * a, n * Math.cos(o) * a]
                }
                function _a(n, e, o) {
                    return Sl(Math.cos(_o(n)), Math.sin(_o(n)), e, o)
                }
                const Il = 6371008.8
                  , Du = 2 * Math.PI * Il;
                class Mi {
                    constructor(e, o) {
                        if (isNaN(e) || isNaN(o))
                            throw new Error("Invalid LngLat object: (".concat(e, ", ").concat(o, ")"));
                        if (this.lng = +e,
                        this.lat = +o,
                        this.lat > 90 || this.lat < -90)
                            throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
                    }
                    wrap() {
                        return new Mi(Oe(this.lng, -180, 180),this.lat)
                    }
                    toArray() {
                        return [this.lng, this.lat]
                    }
                    toString() {
                        return "LngLat(".concat(this.lng, ", ").concat(this.lat, ")")
                    }
                    distanceTo(e) {
                        const o = Math.PI / 180
                          , a = this.lat * o
                          , u = e.lat * o
                          , l = Math.sin(a) * Math.sin(u) + Math.cos(a) * Math.cos(u) * Math.cos((e.lng - this.lng) * o);
                        return Il * Math.acos(Math.min(l, 1))
                    }
                    toBounds(e=0) {
                        const o = 360 * e / 40075017
                          , a = o / Math.cos(Math.PI / 180 * this.lat);
                        return new ga({
                            lng: this.lng - a,
                            lat: this.lat - o
                        },{
                            lng: this.lng + a,
                            lat: this.lat + o
                        })
                    }
                    toEcef(e) {
                        return _a(this.lat, this.lng, sr + e * sr / Il)
                    }
                    static convert(e) {
                        if (e instanceof Mi)
                            return e;
                        if (Array.isArray(e) && (2 === e.length || 3 === e.length))
                            return new Mi(Number(e[0]),Number(e[1]));
                        if (!Array.isArray(e) && "object" == typeof e && null !== e)
                            return new Mi(Number("lng"in e ? e.lng : e.lon),Number(e.lat));
                        throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
                    }
                }
                class ga {
                    constructor(e, o) {
                        if (e)
                            if (o)
                                this.setSouthWest(e).setNorthEast(o);
                            else if (4 === e.length) {
                                const a = e;
                                this.setSouthWest([a[0], a[1]]).setNorthEast([a[2], a[3]])
                            } else {
                                const a = e;
                                this.setSouthWest(a[0]).setNorthEast(a[1])
                            }
                    }
                    setNorthEast(e) {
                        return this._ne = e instanceof Mi ? new Mi(e.lng,e.lat) : Mi.convert(e),
                        this
                    }
                    setSouthWest(e) {
                        return this._sw = e instanceof Mi ? new Mi(e.lng,e.lat) : Mi.convert(e),
                        this
                    }
                    extend(e) {
                        const o = this._sw
                          , a = this._ne;
                        let u, l;
                        if (e instanceof Mi)
                            u = e,
                            l = e;
                        else {
                            if (!(e instanceof ga))
                                return Array.isArray(e) ? 4 === e.length || e.every(Array.isArray) ? this.extend(ga.convert(e)) : this.extend(Mi.convert(e)) : "object" == typeof e && null !== e && e.hasOwnProperty("lat") && (e.hasOwnProperty("lon") || e.hasOwnProperty("lng")) ? this.extend(Mi.convert(e)) : this;
                            if (u = e._sw,
                            l = e._ne,
                            !u || !l)
                                return this
                        }
                        return o || a ? (o.lng = Math.min(u.lng, o.lng),
                        o.lat = Math.min(u.lat, o.lat),
                        a.lng = Math.max(l.lng, a.lng),
                        a.lat = Math.max(l.lat, a.lat)) : (this._sw = new Mi(u.lng,u.lat),
                        this._ne = new Mi(l.lng,l.lat)),
                        this
                    }
                    getCenter() {
                        return new Mi((this._sw.lng + this._ne.lng) / 2,(this._sw.lat + this._ne.lat) / 2)
                    }
                    getSouthWest() {
                        return this._sw
                    }
                    getNorthEast() {
                        return this._ne
                    }
                    getNorthWest() {
                        return new Mi(this.getWest(),this.getNorth())
                    }
                    getSouthEast() {
                        return new Mi(this.getEast(),this.getSouth())
                    }
                    getWest() {
                        return this._sw.lng
                    }
                    getSouth() {
                        return this._sw.lat
                    }
                    getEast() {
                        return this._ne.lng
                    }
                    getNorth() {
                        return this._ne.lat
                    }
                    toArray() {
                        return [this._sw.toArray(), this._ne.toArray()]
                    }
                    toString() {
                        return "LngLatBounds(".concat(this._sw.toString(), ", ").concat(this._ne.toString(), ")")
                    }
                    isEmpty() {
                        return !(this._sw && this._ne)
                    }
                    contains(e) {
                        const {lng: o, lat: a} = Mi.convert(e);
                        let u = this._sw.lng <= o && o <= this._ne.lng;
                        return this._sw.lng > this._ne.lng && (u = this._sw.lng >= o && o >= this._ne.lng),
                        this._sw.lat <= a && a <= this._ne.lat && u
                    }
                    static convert(e) {
                        if (e)
                            return e instanceof ga ? e : new ga(e)
                    }
                }
                function Lc(n) {
                    return Du * Math.cos(n * Math.PI / 180)
                }
                function gs(n) {
                    return (180 + n) / 360
                }
                function ks(n) {
                    return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + n * Math.PI / 360))) / 360
                }
                function ar(n, e) {
                    return n / Lc(e)
                }
                function Mr(n) {
                    return 360 * n - 180
                }
                function Gn(n) {
                    return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n) * Math.PI / 180)) - 90
                }
                function Rp(n, e) {
                    return n * Lc(Gn(e))
                }
                const un = 85.051129;
                function zd(n) {
                    return Math.cos(_o(ie(n, -un, un)))
                }
                function c(n, e) {
                    const o = ie(e, 0, 25.5)
                      , a = Math.pow(2, o);
                    return zd(n) * Du / (512 * a)
                }
                function t(n) {
                    return 1 / Math.cos(n * Math.PI / 180)
                }
                function i(n, e=0) {
                    const o = Math.exp(Math.PI * (1 - (n.y + e / uo) / (1 << n.z) * 2));
                    return 80150034 * o / (o * o + 1) / uo / (1 << n.z)
                }
                class h {
                    constructor(e, o, a=0) {
                        this.x = +e,
                        this.y = +o,
                        this.z = +a
                    }
                    static fromLngLat(e, o=0) {
                        const a = Mi.convert(e);
                        return new h(gs(a.lng),ks(a.lat),ar(o, a.lat))
                    }
                    toLngLat() {
                        return new Mi(Mr(this.x),Gn(this.y))
                    }
                    toAltitude() {
                        return Rp(this.z, this.y)
                    }
                    meterInMercatorCoordinateUnits() {
                        return 1 / Du * t(Gn(this.y))
                    }
                }
                function d(n, e, o, a, u, l, p, g, x) {
                    const T = (e + a) / 2
                      , f = (o + u) / 2
                      , b = new tt(T,f);
                    g(b),
                    function(P, v, w, C, A, O) {
                        const F = w - A
                          , z = C - O;
                        return Math.abs((C - v) * F - (w - P) * z) / Math.hypot(F, z)
                    }(b.x, b.y, l.x, l.y, p.x, p.y) >= x ? (d(n, e, o, T, f, l, b, g, x),
                    d(n, T, f, a, u, b, p, g, x)) : n.push(p)
                }
                function m(n, e, o) {
                    let a = n[0]
                      , u = a.x
                      , l = a.y;
                    e(a);
                    const p = [a];
                    for (let g = 1; g < n.length; g++) {
                        const x = n[g]
                          , {x: T, y: f} = x;
                        e(x),
                        d(p, u, l, T, f, a, x, e, o),
                        u = T,
                        l = f,
                        a = x
                    }
                    return p
                }
                function y(n, e, o, a) {
                    if (a(e, o)) {
                        const u = e.add(o)._mult(.5);
                        y(n, e, u, a),
                        y(n, u, o, a)
                    } else
                        n.push(o)
                }
                function M(n, e) {
                    let o = n[0];
                    const a = [o];
                    for (let u = 1; u < n.length; u++) {
                        const l = n[u];
                        y(a, o, l, e),
                        o = l
                    }
                    return a
                }
                const E = Math.pow(2, 14) - 1
                  , S = -E - 1;
                function I(n, e) {
                    const o = Math.round(n.x * e)
                      , a = Math.round(n.y * e);
                    return n.x = ie(o, S, E),
                    n.y = ie(a, S, E),
                    (o < n.x || o > n.x + 1 || a < n.y || a > n.y + 1) && vo("Geometry exceeds allowed extent, reduce your vector tile buffer size"),
                    n
                }
                function R(n, e, o) {
                    const a = n.loadGeometry()
                      , u = n.extent
                      , l = uo / u;
                    if (e && o && o.projection.isReprojectedInTileSpace) {
                        const p = 1 << e.z
                          , {scale: g, x, y: T, projection: f} = o
                          , b = P => {
                            const v = Mr((e.x + P.x / u) / p)
                              , w = Gn((e.y + P.y / u) / p)
                              , C = f.project(v, w);
                            P.x = (C.x * g - x) * u,
                            P.y = (C.y * g - T) * u
                        }
                        ;
                        for (let P = 0; P < a.length; P++)
                            if (1 !== n.type)
                                a[P] = m(a[P], b, 1);
                            else {
                                const v = [];
                                for (const w of a[P])
                                    w.x < 0 || w.x >= u || w.y < 0 || w.y >= u || (b(w),
                                    v.push(w));
                                a[P] = v
                            }
                    }
                    for (const p of a)
                        for (const g of p)
                            I(g, l);
                    return a
                }
                function D(n, e) {
                    return {
                        type: n.type,
                        id: n.id,
                        properties: n.properties,
                        geometry: e ? R(n) : []
                    }
                }
                function k(n, e, o, a, u) {
                    n.emplaceBack(2 * e + (a + 1) / 2, 2 * o + (u + 1) / 2)
                }
                function H(n, e, o) {
                    n.emplaceBack(e.x, e.y, e.z, 16384 * o[0], 16384 * o[1], 16384 * o[2])
                }
                class j {
                    constructor(e) {
                        this.zoom = e.zoom,
                        this.overscaling = e.overscaling,
                        this.layers = e.layers,
                        this.layerIds = this.layers.map(o => o.fqid),
                        this.index = e.index,
                        this.hasPattern = !1,
                        this.projection = e.projection,
                        this.layoutVertexArray = new ts,
                        this.indexArray = new Xn,
                        this.segments = new mn,
                        this.programConfigurations = new fa(e.layers,{
                            zoom: e.zoom,
                            lut: e.lut
                        }),
                        this.stateDependentLayerIds = this.layers.filter(o => o.isStateDependent()).map(o => o.id)
                    }
                    updateFootprints(e, o) {}
                    populate(e, o, a, u) {
                        const l = this.layers[0]
                          , p = [];
                        let g = null;
                        "circle" === l.type && (g = l.layout.get("circle-sort-key"));
                        for (const {feature: T, id: f, index: b, sourceLayerIndex: P} of e) {
                            const v = this.layers[0]._featureFilter.needGeometry
                              , w = D(T, v);
                            if (!this.layers[0]._featureFilter.filter(new Hi(this.zoom), w, a))
                                continue;
                            const C = g ? g.evaluate(w, {}, a) : void 0
                              , A = {
                                id: f,
                                properties: T.properties,
                                type: T.type,
                                sourceLayerIndex: P,
                                index: b,
                                geometry: v ? w.geometry : R(T, a, u),
                                patterns: {},
                                sortKey: C
                            };
                            p.push(A)
                        }
                        g && p.sort( (T, f) => T.sortKey - f.sortKey);
                        let x = null;
                        "globe" === u.projection.name && (this.globeExtVertexArray = new Mh,
                        x = u.projection);
                        for (const T of p) {
                            const {geometry: f, index: b, sourceLayerIndex: P} = T
                              , v = e[b].feature;
                            this.addFeature(T, f, b, o.availableImages, a, x, o.brightness),
                            o.featureIndex.insert(v, f, b, P, this.index)
                        }
                    }
                    update(e, o, a, u, l, p, g) {
                        this.programConfigurations.updatePaintArrays(e, o, l, a, u, p, g)
                    }
                    isEmpty() {
                        return 0 === this.layoutVertexArray.length
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(e) {
                        this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Sd.members),
                        this.indexBuffer = e.createIndexBuffer(this.indexArray),
                        this.globeExtVertexArray && (this.globeExtVertexBuffer = e.createVertexBuffer(this.globeExtVertexArray, Iu.members))),
                        this.programConfigurations.upload(e),
                        this.uploaded = !0
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy(),
                        this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy())
                    }
                    addFeature(e, o, a, u, l, p, g) {
                        for (const x of o)
                            for (const T of x) {
                                const f = T.x
                                  , b = T.y;
                                if (f < 0 || f >= uo || b < 0 || b >= uo)
                                    continue;
                                if (p) {
                                    const w = p.projectTilePoint(f, b, l)
                                      , C = p.upVector(l, f, b)
                                      , A = this.globeExtVertexArray;
                                    H(A, w, C),
                                    H(A, w, C),
                                    H(A, w, C),
                                    H(A, w, C)
                                }
                                const P = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, e.sortKey)
                                  , v = P.vertexLength;
                                k(this.layoutVertexArray, f, b, -1, -1),
                                k(this.layoutVertexArray, f, b, 1, -1),
                                k(this.layoutVertexArray, f, b, 1, 1),
                                k(this.layoutVertexArray, f, b, -1, 1),
                                this.indexArray.emplaceBack(v, v + 1, v + 2),
                                this.indexArray.emplaceBack(v, v + 2, v + 3),
                                P.vertexLength += 4,
                                P.primitiveLength += 2
                            }
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, a, {}, u, l, g)
                    }
                }
                function Y(n, e) {
                    for (let o = 0; o < n.length; o++)
                        if (Ge(e, n[o]))
                            return !0;
                    for (let o = 0; o < e.length; o++)
                        if (Ge(n, e[o]))
                            return !0;
                    return !!be(n, e)
                }
                function K(n, e, o) {
                    return !!Ge(n, e) || !!De(e, n, o)
                }
                function he(n, e) {
                    if (1 === n.length)
                        return Le(e, n[0]);
                    for (let o = 0; o < e.length; o++) {
                        const a = e[o];
                        for (let u = 0; u < a.length; u++)
                            if (Ge(n, a[u]))
                                return !0
                    }
                    for (let o = 0; o < n.length; o++)
                        if (Le(e, n[o]))
                            return !0;
                    for (let o = 0; o < e.length; o++)
                        if (be(n, e[o]))
                            return !0;
                    return !1
                }
                function Te(n, e, o) {
                    if (n.length > 1) {
                        if (be(n, e))
                            return !0;
                        for (let a = 0; a < e.length; a++)
                            if (De(e[a], n, o))
                                return !0
                    }
                    for (let a = 0; a < n.length; a++)
                        if (De(n[a], e, o))
                            return !0;
                    return !1
                }
                function be(n, e) {
                    if (0 === n.length || 0 === e.length)
                        return !1;
                    for (let o = 0; o < n.length - 1; o++) {
                        const a = n[o]
                          , u = n[o + 1];
                        for (let l = 0; l < e.length - 1; l++)
                            if (Ue(a, u, e[l], e[l + 1]))
                                return !0
                    }
                    return !1
                }
                function Ue(n, e, o, a) {
                    return ei(n, o, a) !== ei(e, o, a) && ei(n, e, o) !== ei(n, e, a)
                }
                function De(n, e, o) {
                    const a = o * o;
                    if (1 === e.length)
                        return n.distSqr(e[0]) < a;
                    for (let u = 1; u < e.length; u++)
                        if (ke(n, e[u - 1], e[u]) < a)
                            return !0;
                    return !1
                }
                function ke(n, e, o) {
                    const a = e.distSqr(o);
                    if (0 === a)
                        return n.distSqr(e);
                    const u = ((n.x - e.x) * (o.x - e.x) + (n.y - e.y) * (o.y - e.y)) / a;
                    return n.distSqr(u < 0 ? e : u > 1 ? o : o.sub(e)._mult(u)._add(e))
                }
                function Le(n, e) {
                    let o, a, u, l = !1;
                    for (let p = 0; p < n.length; p++) {
                        o = n[p];
                        for (let g = 0, x = o.length - 1; g < o.length; x = g++)
                            a = o[g],
                            u = o[x],
                            a.y > e.y != u.y > e.y && e.x < (u.x - a.x) * (e.y - a.y) / (u.y - a.y) + a.x && (l = !l)
                    }
                    return l
                }
                function Ge(n, e) {
                    let o = !1;
                    for (let a = 0, u = n.length - 1; a < n.length; u = a++) {
                        const l = n[a]
                          , p = n[u];
                        l.y > e.y != p.y > e.y && e.x < (p.x - l.x) * (e.y - l.y) / (p.y - l.y) + l.x && (o = !o)
                    }
                    return o
                }
                function qe(n, e, o, a, u) {
                    for (const p of n)
                        if (e <= p.x && o <= p.y && a >= p.x && u >= p.y)
                            return !0;
                    const l = [new tt(e,o), new tt(e,u), new tt(a,u), new tt(a,o)];
                    if (n.length > 2)
                        for (const p of l)
                            if (Ge(n, p))
                                return !0;
                    for (let p = 0; p < n.length - 1; p++)
                        if (vt(n[p], n[p + 1], l))
                            return !0;
                    return !1
                }
                function vt(n, e, o) {
                    const a = o[0]
                      , u = o[2];
                    if (n.x < a.x && e.x < a.x || n.x > u.x && e.x > u.x || n.y < a.y && e.y < a.y || n.y > u.y && e.y > u.y)
                        return !1;
                    const l = ei(n, e, o[0]);
                    return l !== ei(n, e, o[1]) || l !== ei(n, e, o[2]) || l !== ei(n, e, o[3])
                }
                function dt(n, e, o, a, u, l) {
                    let p = e.y - n.y
                      , g = n.x - e.x;
                    if (l = l || 0) {
                        const x = p * p + g * g;
                        if (0 === x)
                            return !0;
                        const T = Math.sqrt(x);
                        p /= T,
                        g /= T
                    }
                    return !((o.x - n.x) * p + (o.y - n.y) * g - l < 0 || (a.x - n.x) * p + (a.y - n.y) * g - l < 0 || (u.x - n.x) * p + (u.y - n.y) * g - l < 0)
                }
                function Ze(n, e, o, a, u, l, p) {
                    return !(dt(n, e, a, u, l, p) || dt(e, o, a, u, l, p) || dt(o, n, a, u, l, p) || dt(a, u, n, e, o, p) || dt(u, l, n, e, o, p) || dt(l, a, n, e, o, p))
                }
                function nt(n, e, o) {
                    const a = e.paint.get(n).value;
                    return "constant" === a.kind ? a.value : o.programConfigurations.get(e.id).getMaxValue(n)
                }
                function zt(n) {
                    return Math.sqrt(n[0] * n[0] + n[1] * n[1])
                }
                function Yt(n, e, o, a, u) {
                    if (!e[0] && !e[1])
                        return n;
                    const l = tt.convert(e)._mult(u);
                    "viewport" === o && l._rotate(-a);
                    const p = [];
                    for (let g = 0; g < n.length; g++)
                        p.push(n[g].sub(l));
                    return p
                }
                function to(n, e, o, a) {
                    const u = tt.convert(n)._mult(a);
                    return "viewport" === e && u._rotate(-o),
                    u
                }
                let ut, Gt;
                Fe(j, "CircleBucket", {
                    omit: ["layers"]
                });
                var wt, qt = {
                    exports: {}
                }, Ht = (wt || (wt = 1,
                function(o) {
                    function a(l, p, g) {
                        var x = u(256 * l, 256 * (p = Math.pow(2, g) - p - 1), g)
                          , T = u(256 * (l + 1), 256 * (p + 1), g);
                        return x[0] + "," + x[1] + "," + T[0] + "," + T[1]
                    }
                    function u(l, p, g) {
                        var x = 2 * Math.PI * 6378137 / 256 / Math.pow(2, g);
                        return [l * x - 2 * Math.PI * 6378137 / 2, p * x - 2 * Math.PI * 6378137 / 2]
                    }
                    o.getURL = function(l, p, g, x, T, f) {
                        return f = f || {},
                        l + "?" + ["bbox=" + a(g, x, T), "format=" + (f.format || "image/png"), "service=" + (f.service || "WMS"), "version=" + (f.version || "1.1.1"), "request=" + (f.request || "GetMap"), "srs=" + (f.srs || "EPSG:3857"), "width=" + (f.width || 256), "height=" + (f.height || 256), "layers=" + p].join("&")
                    }
                    ,
                    o.getTileBBox = a,
                    o.getMercCoords = u,
                    Object.defineProperty(o, "__esModule", {
                        value: !0
                    })
                }(qt.exports)),
                qt.exports);
                class Dt {
                    constructor(e, o, a) {
                        this.z = e,
                        this.x = o,
                        this.y = a,
                        this.key = Po(0, e, e, o, a)
                    }
                    equals(e) {
                        return this.z === e.z && this.x === e.x && this.y === e.y
                    }
                    url(e, o) {
                        const a = Ht.getTileBBox(this.x, this.y, this.z)
                          , u = function(l, p, g) {
                            let x, T = "";
                            for (let f = l; f > 0; f--)
                                x = 1 << f - 1,
                                T += (p & x ? 1 : 0) + (g & x ? 2 : 0);
                            return T
                        }(this.z, this.x, this.y);
                        return e[(this.x + this.y) % e.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === o ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", u).replace("{bbox-epsg-3857}", a)
                    }
                    toString() {
                        return "".concat(this.z, "/").concat(this.x, "/").concat(this.y)
                    }
                }
                class bo {
                    constructor(e, o) {
                        this.wrap = e,
                        this.canonical = o,
                        this.key = Po(e, o.z, o.z, o.x, o.y)
                    }
                }
                class oo {
                    constructor(e, o, a, u, l) {
                        this.overscaledZ = e,
                        this.wrap = o,
                        this.canonical = new Dt(a,+u,+l),
                        this.key = 0 === o && e === a ? this.canonical.key : Po(o, e, a, u, l)
                    }
                    equals(e) {
                        return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical)
                    }
                    scaledTo(e) {
                        const o = this.canonical.z - e;
                        return e > this.canonical.z ? new oo(e,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y) : new oo(e,this.wrap,e,this.canonical.x >> o,this.canonical.y >> o)
                    }
                    calculateScaledKey(e, o=!0) {
                        if (this.overscaledZ === e && o)
                            return this.key;
                        if (e > this.canonical.z)
                            return Po(this.wrap * +o, e, this.canonical.z, this.canonical.x, this.canonical.y);
                        {
                            const a = this.canonical.z - e;
                            return Po(this.wrap * +o, e, e, this.canonical.x >> a, this.canonical.y >> a)
                        }
                    }
                    isChildOf(e) {
                        if (e.wrap !== this.wrap)
                            return !1;
                        const o = this.canonical.z - e.canonical.z;
                        return 0 === e.overscaledZ || e.overscaledZ < this.overscaledZ && e.canonical.z < this.canonical.z && e.canonical.x === this.canonical.x >> o && e.canonical.y === this.canonical.y >> o
                    }
                    children(e) {
                        if (this.overscaledZ >= e)
                            return [new oo(this.overscaledZ + 1,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)];
                        const o = this.canonical.z + 1
                          , a = 2 * this.canonical.x
                          , u = 2 * this.canonical.y;
                        return [new oo(o,this.wrap,o,a,u), new oo(o,this.wrap,o,a + 1,u), new oo(o,this.wrap,o,a,u + 1), new oo(o,this.wrap,o,a + 1,u + 1)]
                    }
                    isLessThan(e) {
                        return this.wrap < e.wrap || !(this.wrap > e.wrap) && (this.overscaledZ < e.overscaledZ || !(this.overscaledZ > e.overscaledZ) && (this.canonical.x < e.canonical.x || !(this.canonical.x > e.canonical.x) && this.canonical.y < e.canonical.y))
                    }
                    wrapped() {
                        return new oo(this.overscaledZ,0,this.canonical.z,this.canonical.x,this.canonical.y)
                    }
                    unwrapTo(e) {
                        return new oo(this.overscaledZ,e,this.canonical.z,this.canonical.x,this.canonical.y)
                    }
                    overscaleFactor() {
                        return Math.pow(2, this.overscaledZ - this.canonical.z)
                    }
                    toUnwrapped() {
                        return new bo(this.wrap,this.canonical)
                    }
                    toString() {
                        return "".concat(this.overscaledZ, "/").concat(this.canonical.x, "/").concat(this.canonical.y)
                    }
                }
                function Po(n, e, o, a, u) {
                    const l = 1 << Math.min(o, 22);
                    let p = l * (u % l) + a % l;
                    return n && o < 22 && (p += l * l * ((n < 0 ? -2 * n - 1 : 2 * n) % (1 << 2 * (22 - o)))),
                    16 * (32 * p + o) + (e - o)
                }
                const Eo = [n => {
                    let e = n.canonical.x - 1
                      , o = n.wrap;
                    return e < 0 && (e = (1 << n.canonical.z) - 1,
                    o--),
                    new oo(n.overscaledZ,o,n.canonical.z,e,n.canonical.y)
                }
                , n => {
                    let e = n.canonical.x + 1
                      , o = n.wrap;
                    return e === 1 << n.canonical.z && (e = 0,
                    o++),
                    new oo(n.overscaledZ,o,n.canonical.z,e,n.canonical.y)
                }
                , n => new oo(n.overscaledZ,n.wrap,n.canonical.z,n.canonical.x,(0 === n.canonical.y ? 1 << n.canonical.z : n.canonical.y) - 1), n => new oo(n.overscaledZ,n.wrap,n.canonical.z,n.canonical.x,n.canonical.y === (1 << n.canonical.z) - 1 ? 0 : n.canonical.y + 1)];
                Fe(Dt, "CanonicalTileID"),
                Fe(oo, "OverscaledTileID", {
                    omit: ["projMatrix", "expandedProjMatrix"]
                });
                const Yo = Si([{
                    type: "Float32",
                    name: "a_globe_pos",
                    components: 3
                }, {
                    type: "Float32",
                    name: "a_uv",
                    components: 2
                }])
                  , {members: ko} = Yo
                  , Uo = Si([{
                    name: "a_pos_3",
                    components: 3,
                    type: "Int16"
                }]);
                var Zo = Si([{
                    name: "a_pos",
                    type: "Int16",
                    components: 2
                }]);
                class yi {
                    constructor(e, o) {
                        this.pos = e,
                        this.dir = o
                    }
                    intersectsPlane(e, o, a) {
                        const u = B.vec3.dot(o, this.dir);
                        if (Math.abs(u) < 1e-6)
                            return !1;
                        const l = ((e[0] - this.pos[0]) * o[0] + (e[1] - this.pos[1]) * o[1] + (e[2] - this.pos[2]) * o[2]) / u;
                        return a[0] = this.pos[0] + this.dir[0] * l,
                        a[1] = this.pos[1] + this.dir[1] * l,
                        a[2] = this.pos[2] + this.dir[2] * l,
                        !0
                    }
                    closestPointOnSphere(e, o, a) {
                        if (B.vec3.equals(this.pos, e) || 0 === o)
                            return a[0] = a[1] = a[2] = 0,
                            !1;
                        const [u,l,p] = this.dir
                          , g = this.pos[0] - e[0]
                          , x = this.pos[1] - e[1]
                          , T = this.pos[2] - e[2]
                          , f = u * u + l * l + p * p
                          , b = 2 * (g * u + x * l + T * p)
                          , P = b * b - 4 * f * (g * g + x * x + T * T - o * o);
                        if (P < 0) {
                            const v = Math.max(-b / 2, 0)
                              , w = g + u * v
                              , C = x + l * v
                              , A = T + p * v
                              , O = Math.hypot(w, C, A);
                            return a[0] = w * o / O,
                            a[1] = C * o / O,
                            a[2] = A * o / O,
                            !1
                        }
                        {
                            const v = (-b - Math.sqrt(P)) / (2 * f);
                            if (v < 0) {
                                const w = Math.hypot(g, x, T);
                                return a[0] = g * o / w,
                                a[1] = x * o / w,
                                a[2] = T * o / w,
                                !1
                            }
                            return a[0] = g + u * v,
                            a[1] = x + l * v,
                            a[2] = T + p * v,
                            !0
                        }
                    }
                }
                class li {
                    constructor(e, o, a, u, l) {
                        this.TL = e,
                        this.TR = o,
                        this.BR = a,
                        this.BL = u,
                        this.horizon = l
                    }
                    static fromInvProjectionMatrix(e, o, a) {
                        const u = [-1, 1, 1]
                          , l = [1, 1, 1]
                          , p = [1, -1, 1]
                          , g = [-1, -1, 1]
                          , x = B.vec3.transformMat4(u, u, e)
                          , T = B.vec3.transformMat4(l, l, e)
                          , f = B.vec3.transformMat4(p, p, e)
                          , b = B.vec3.transformMat4(g, g, e);
                        return new li(x,T,f,b,o / a)
                    }
                }
                function Ji(n, e, o) {
                    let a = 1 / 0
                      , u = -1 / 0;
                    const l = [];
                    for (const p of n) {
                        B.vec3.sub(l, p, e);
                        const g = B.vec3.dot(l, o);
                        a = Math.min(a, g),
                        u = Math.max(u, g)
                    }
                    return [a, u]
                }
                function on(n, e) {
                    let o = !0;
                    for (let a = 0; a < n.planes.length; a++) {
                        const u = n.planes[a];
                        let l = 0;
                        for (let p = 0; p < e.length; p++)
                            l += B.vec3.dot(u, e[p]) + u[3] >= 0;
                        if (0 === l)
                            return 0;
                        l !== e.length && (o = !1)
                    }
                    return o ? 2 : 1
                }
                function Ri(n, e) {
                    for (const o of n.projections) {
                        const a = Ji(e, n.points[0], o.axis);
                        if (o.projection[1] < a[0] || o.projection[0] > a[1])
                            return 0
                    }
                    return 1
                }
                function Ni(n, e) {
                    let o = 0;
                    const a = [0, 0, 0, 0];
                    for (let u = 0; u < n.length; u++)
                        a[0] = n[u][0],
                        a[1] = n[u][1],
                        a[2] = n[u][2],
                        a[3] = 1,
                        B.vec4.dot(a, e) >= 0 && o++;
                    return o
                }
                class ii {
                    constructor(e, o) {
                        this.points = e || new Array(8).fill([0, 0, 0]),
                        this.planes = o || new Array(6).fill([0, 0, 0, 0]),
                        this.bounds = No.fromPoints(this.points),
                        this.projections = [],
                        this.frustumEdges = [B.vec3.sub([], this.points[2], this.points[3]), B.vec3.sub([], this.points[0], this.points[3]), B.vec3.sub([], this.points[4], this.points[0]), B.vec3.sub([], this.points[5], this.points[1]), B.vec3.sub([], this.points[6], this.points[2]), B.vec3.sub([], this.points[7], this.points[3])];
                        for (const a of this.frustumEdges) {
                            const u = [0, -a[2], a[1]]
                              , l = [a[2], 0, -a[0]];
                            this.projections.push({
                                axis: u,
                                projection: Ji(this.points, this.points[0], u)
                            }),
                            this.projections.push({
                                axis: l,
                                projection: Ji(this.points, this.points[0], l)
                            })
                        }
                    }
                    static fromInvProjectionMatrix(e, o, a, u) {
                        const l = Math.pow(2, a)
                          , p = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(T => {
                            const f = B.vec4.transformMat4([], T, e)
                              , b = 1 / f[3] / o * l;
                            return B.vec4.mul(f, f, [b, b, u ? 1 / f[3] : b, b])
                        }
                        )
                          , g = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(T => {
                            const f = B.vec3.sub([], p[T[0]], p[T[1]])
                              , b = B.vec3.sub([], p[T[2]], p[T[1]])
                              , P = B.vec3.normalize([], B.vec3.cross([], f, b))
                              , v = -B.vec3.dot(P, p[T[1]]);
                            return P.concat(v)
                        }
                        )
                          , x = [];
                        for (let T = 0; T < p.length; T++)
                            x.push([p[T][0], p[T][1], p[T][2]]);
                        return new ii(x,g)
                    }
                    intersectsPrecise(e, o, a) {
                        for (let u = 0; u < o.length; u++)
                            if (!Ni(e, o[u]))
                                return 0;
                        for (let u = 0; u < this.planes.length; u++)
                            if (!Ni(e, this.planes[u]))
                                return 0;
                        for (const u of a)
                            for (const l of this.frustumEdges) {
                                const p = B.vec3.cross([], u, l)
                                  , g = B.vec3.length(p);
                                if (0 === g)
                                    continue;
                                B.vec3.scale(p, p, 1 / g);
                                const x = Ji(this.points, this.points[0], p)
                                  , T = Ji(e, this.points[0], p);
                                if (x[0] > T[1] || T[0] > x[1])
                                    return 0
                            }
                        return 1
                    }
                    containsPoint(e) {
                        for (const o of this.planes) {
                            const a = o[3];
                            if (B.vec3.dot([o[0], o[1], o[2]], e) + a < 0)
                                return !1
                        }
                        return !0
                    }
                }
                class No {
                    static fromPoints(e) {
                        const o = [1 / 0, 1 / 0, 1 / 0]
                          , a = [-1 / 0, -1 / 0, -1 / 0];
                        for (const u of e)
                            B.vec3.min(o, o, u),
                            B.vec3.max(a, a, u);
                        return new No(o,a)
                    }
                    static fromTileIdAndHeight(e, o, a) {
                        const u = 1 << e.canonical.z
                          , l = e.canonical.x
                          , p = e.canonical.y;
                        return new No([l / u, p / u, o],[(l + 1) / u, (p + 1) / u, a])
                    }
                    static applyTransform(e, o) {
                        const a = e.getCorners();
                        for (let u = 0; u < a.length; ++u)
                            B.vec3.transformMat4(a[u], a[u], o);
                        return No.fromPoints(a)
                    }
                    static applyTransformFast(e, o) {
                        const a = [o[12], o[13], o[14]]
                          , u = [...a];
                        for (let l = 0; l < 3; l++)
                            for (let p = 0; p < 3; p++) {
                                const g = o[4 * p + l]
                                  , x = g * e.min[p]
                                  , T = g * e.max[p];
                                a[l] += Math.min(x, T),
                                u[l] += Math.max(x, T)
                            }
                        return new No(a,u)
                    }
                    static projectAabbCorners(e, o) {
                        const a = e.getCorners();
                        for (let u = 0; u < a.length; ++u)
                            B.vec3.transformMat4(a[u], a[u], o);
                        return a
                    }
                    constructor(e, o) {
                        this.min = e,
                        this.max = o,
                        this.center = B.vec3.scale([], B.vec3.add([], this.min, this.max), .5)
                    }
                    quadrant(e) {
                        const o = [e % 2 == 0, e < 2]
                          , a = B.vec3.clone(this.min)
                          , u = B.vec3.clone(this.max);
                        for (let l = 0; l < o.length; l++)
                            a[l] = o[l] ? this.min[l] : this.center[l],
                            u[l] = o[l] ? this.center[l] : this.max[l];
                        return u[2] = this.max[2],
                        new No(a,u)
                    }
                    distanceX(e) {
                        return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0]
                    }
                    distanceY(e) {
                        return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1]
                    }
                    distanceZ(e) {
                        return Math.max(Math.min(this.max[2], e[2]), this.min[2]) - e[2]
                    }
                    getCorners() {
                        const e = this.min
                          , o = this.max;
                        return [[e[0], e[1], e[2]], [o[0], e[1], e[2]], [o[0], o[1], e[2]], [e[0], o[1], e[2]], [e[0], e[1], o[2]], [o[0], e[1], o[2]], [o[0], o[1], o[2]], [e[0], o[1], o[2]]]
                    }
                    intersects(e) {
                        return this.intersectsAabb(e.bounds) ? on(e, this.getCorners()) : 0
                    }
                    intersectsFlat(e) {
                        return this.intersectsAabb(e.bounds) ? on(e, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0
                    }
                    intersectsPrecise(e, o) {
                        return o || this.intersects(e) ? Ri(e, this.getCorners()) : 0
                    }
                    intersectsPreciseFlat(e, o) {
                        return o || this.intersectsFlat(e) ? Ri(e, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0
                    }
                    intersectsAabb(e) {
                        for (let o = 0; o < 3; ++o)
                            if (this.min[o] > e.max[o] || e.min[o] > this.max[o])
                                return !1;
                        return !0
                    }
                    intersectsAabbXY(e) {
                        return !(this.min[0] > e.max[0] || e.min[0] > this.max[0] || this.min[1] > e.max[1] || e.min[1] > this.max[1])
                    }
                    encapsulate(e) {
                        for (let o = 0; o < 3; o++)
                            this.min[o] = Math.min(this.min[o], e.min[o]),
                            this.max[o] = Math.max(this.max[o], e.max[o])
                    }
                    encapsulatePoint(e) {
                        for (let o = 0; o < 3; o++)
                            this.min[o] = Math.min(this.min[o], e[o]),
                            this.max[o] = Math.max(this.max[o], e[o])
                    }
                    closestPoint(e) {
                        return [Math.max(Math.min(this.max[0], e[0]), this.min[0]), Math.max(Math.min(this.max[1], e[1]), this.min[1]), Math.max(Math.min(this.max[2], e[2]), this.min[2])]
                    }
                }
                function Ei(n) {
                    return n * sr / Il
                }
                Fe(No, "Aabb");
                const Di = [new No([Gr, Gr, Gr],[jr, jr, jr]), new No([Gr, Gr, Gr],[0, 0, jr]), new No([0, Gr, Gr],[jr, 0, jr]), new No([Gr, 0, Gr],[0, jr, jr]), new No([0, 0, Gr],[jr, jr, jr])];
                function an(n, e, o, a=!0) {
                    const u = B.vec3.scale([], n._camera.position, n.worldSize)
                      , l = [e, o, 1, 1];
                    B.vec4.transformMat4(l, l, n.pixelMatrixInverse),
                    B.vec4.scale(l, l, 1 / l[3]);
                    const p = B.vec3.sub([], l, u)
                      , g = B.vec3.normalize([], p)
                      , x = n.globeMatrix
                      , T = [x[12], x[13], x[14]]
                      , f = B.vec3.sub([], T, u)
                      , b = B.vec3.length(f)
                      , P = B.vec3.normalize([], f)
                      , v = n.worldSize / (2 * Math.PI)
                      , w = B.vec3.dot(P, g)
                      , C = Math.asin(v / b);
                    if (C < Math.acos(w)) {
                        if (!a)
                            return null;
                        const Ne = []
                          , Pe = [];
                        B.vec3.scale(Ne, g, b / w),
                        B.vec3.normalize(Pe, B.vec3.sub(Pe, Ne, f)),
                        B.vec3.normalize(g, B.vec3.add(g, f, B.vec3.scale(g, Pe, Math.tan(C) * b)))
                    }
                    const A = [];
                    new yi(u,g).closestPointOnSphere(T, v, A);
                    const O = B.vec3.normalize([], Ln(x, 0))
                      , F = B.vec3.normalize([], Ln(x, 1))
                      , z = B.vec3.normalize([], Ln(x, 2))
                      , L = B.vec3.dot(O, A)
                      , N = B.vec3.dot(F, A)
                      , G = B.vec3.dot(z, A)
                      , X = Lo(Math.asin(-N / v));
                    let _e = Lo(Math.atan2(L, G));
                    _e = n.center.lng + function(Ne, Pe) {
                        const $e = (Pe - Ne + 180) % 360 - 180;
                        return $e < -180 ? $e + 360 : $e
                    }(n.center.lng, _e);
                    const me = gs(_e)
                      , pe = ie(ks(X), 0, 1);
                    return new h(me,pe)
                }
                class jn {
                    constructor(e, o, a) {
                        this.a = B.vec3.sub([], e, a),
                        this.b = B.vec3.sub([], o, a),
                        this.center = a;
                        const u = B.vec3.normalize([], this.a)
                          , l = B.vec3.normalize([], this.b);
                        this.angle = Math.acos(B.vec3.dot(u, l))
                    }
                }
                function lr(n, e) {
                    if (0 === n.angle)
                        return null;
                    let o;
                    return o = 0 === n.a[e] ? 1 / n.angle * .5 * Math.PI : 1 / n.angle * Math.atan(n.b[e] / n.a[e] / Math.sin(n.angle) - 1 / Math.tan(n.angle)),
                    o < 0 || o > 1 ? null : function(a, u, l, p) {
                        const g = Math.sin(l);
                        return a * (Math.sin((1 - p) * l) / g) + u * (Math.sin(p * l) / g)
                    }(n.a[e], n.b[e], n.angle, ie(o, 0, 1)) + n.center[e]
                }
                function bn(n) {
                    if (n.z <= 1)
                        return Di[n.z + 2 * n.y + n.x];
                    const e = Qi(Yi(n));
                    return No.fromPoints(e)
                }
                function Un(n, e, o) {
                    return B.vec3.scale(n, n, 1 - o),
                    B.vec3.scaleAndAdd(n, n, e, o)
                }
                function er(n, e, o) {
                    for (const a of n)
                        B.vec3.transformMat4(a, a, e),
                        B.vec3.scale(a, a, o)
                }
                function pn(n, e, o, a) {
                    const u = e / n.worldSize
                      , l = n.globeMatrix;
                    if (o.z <= 1) {
                        const me = bn(o).getCorners();
                        return er(me, l, u),
                        No.fromPoints(me)
                    }
                    const p = Yi(o, a)
                      , g = Qi(p, sr + Ei(n._tileCoverLift));
                    er(g, l, u);
                    const x = Number.MAX_VALUE
                      , T = [-x, -x, -x]
                      , f = [x, x, x];
                    if (p.contains(n.center)) {
                        for (const Ne of g)
                            B.vec3.min(f, f, Ne),
                            B.vec3.max(T, T, Ne);
                        T[2] = 0;
                        const me = n.point
                          , pe = [me.x * u, me.y * u, 0];
                        return B.vec3.min(f, f, pe),
                        B.vec3.max(T, T, pe),
                        new No(f,T)
                    }
                    if (n._tileCoverLift > 0) {
                        for (const me of g)
                            B.vec3.min(f, f, me),
                            B.vec3.max(T, T, me);
                        return new No(f,T)
                    }
                    const b = [l[12] * u, l[13] * u, l[14] * u]
                      , P = p.getCenter()
                      , v = ie(n.center.lat, -un, un)
                      , w = ie(P.lat, -un, un)
                      , C = gs(n.center.lng)
                      , A = ks(v);
                    let O = C - gs(P.lng);
                    const F = A - ks(w);
                    O > .5 ? O -= 1 : O < -.5 && (O += 1);
                    let z = 0;
                    if (Math.abs(O) > Math.abs(F))
                        z = O >= 0 ? 1 : 3;
                    else {
                        z = F >= 0 ? 0 : 2;
                        const me = [l[4] * u, l[5] * u, l[6] * u]
                          , pe = -Math.sin(_o(F >= 0 ? p.getSouth() : p.getNorth())) * sr;
                        B.vec3.scaleAndAdd(b, b, me, pe)
                    }
                    const L = g[z]
                      , N = g[(z + 1) % 4]
                      , G = new jn(L,N,b)
                      , X = [lr(G, 0) || L[0], lr(G, 1) || L[1], lr(G, 2) || L[2]]
                      , _e = cr(n.zoom);
                    if (_e > 0) {
                        const me = function({x: Ne, y: Pe, z: $e}, We, je, Ke, rt) {
                            const at = 1 / (1 << $e);
                            let ot = Ne * at
                              , Ct = ot + at
                              , Zt = Pe * at
                              , Ot = Zt + at
                              , lo = 0;
                            const io = (ot + Ct) / 2 - Ke;
                            return io > .5 ? lo = -1 : io < -.5 && (lo = 1),
                            ot = ((ot + lo) * We - (Ke *= We)) * je + Ke,
                            Ct = ((Ct + lo) * We - Ke) * je + Ke,
                            Zt = (Zt * We - (rt *= We)) * je + rt,
                            Ot = (Ot * We - rt) * je + rt,
                            [[ot, Ot, 0], [Ct, Ot, 0], [Ct, Zt, 0], [ot, Zt, 0]]
                        }(o, e, n._pixelsPerMercatorPixel, C, A);
                        for (let Ne = 0; Ne < g.length; Ne++)
                            Un(g[Ne], me[Ne], _e);
                        const pe = B.vec3.add([], me[z], me[(z + 1) % 4]);
                        B.vec3.scale(pe, pe, .5),
                        Un(X, pe, _e)
                    }
                    for (const me of g)
                        B.vec3.min(f, f, me),
                        B.vec3.max(T, T, me);
                    return f[2] = Math.min(L[2], N[2]),
                    B.vec3.min(f, f, X),
                    B.vec3.max(T, T, X),
                    new No(f,T)
                }
                function Yi({x: n, y: e, z: o}, a=!1) {
                    const u = 1 / (1 << o)
                      , l = new Mi(Mr(n * u),e === (1 << o) - 1 && a ? -90 : Gn((e + 1) * u))
                      , p = new Mi(Mr((n + 1) * u),0 === e && a ? 90 : Gn(e * u));
                    return new ga(l,p)
                }
                function Qi(n, e=sr) {
                    const o = _o(n.getNorth())
                      , a = _o(n.getSouth())
                      , u = Math.cos(o)
                      , l = Math.cos(a)
                      , p = Math.sin(o)
                      , g = Math.sin(a)
                      , x = n.getWest()
                      , T = n.getEast();
                    return [Sl(l, g, x, e), Sl(l, g, T, e), Sl(u, p, T, e), Sl(u, p, x, e)]
                }
                function vi(n, e, o, a) {
                    const u = 1 << o.z
                      , l = (n / uo + o.x) / u;
                    return _a(Gn((e / uo + o.y) / u), Mr(l), a)
                }
                function dn({min: n, max: e}) {
                    return 16383 / Math.max(e[0] - n[0], e[1] - n[1], e[2] - n[2])
                }
                const Vn = new Float64Array(16);
                function Wi(n) {
                    const e = dn(n)
                      , o = B.mat4.fromScaling(Vn, [e, e, e]);
                    return B.mat4.translate(o, o, B.vec3.negate([], n.min))
                }
                function tr(n) {
                    const e = B.mat4.fromTranslation(Vn, n.min)
                      , o = 1 / dn(n);
                    return B.mat4.scale(e, e, [o, o, o])
                }
                function Or(n) {
                    const e = uo / (2 * Math.PI);
                    return n / (2 * Math.PI) / e
                }
                function Tr(n, e) {
                    return uo / (512 * Math.pow(2, n)) * dn(bn(e))
                }
                function zs(n, e, o, a, u) {
                    const l = Or(o)
                      , p = [n, e, -o / (2 * Math.PI)]
                      , g = B.mat4.identity(new Float64Array(16));
                    return B.mat4.translate(g, g, p),
                    B.mat4.scale(g, g, [l, l, l]),
                    B.mat4.rotateX(g, g, _o(-u)),
                    B.mat4.rotateY(g, g, _o(-a)),
                    g
                }
                function cr(n) {
                    return we(5, 6, n)
                }
                function ns(n, e) {
                    const o = _a(e.lat, e.lng)
                      , a = function(l) {
                        const p = _a(l._center.lat, l._center.lng)
                          , g = B.vec3.fromValues(0, 1, 0);
                        let x = B.vec3.cross([], g, p);
                        const T = B.mat4.fromRotation([], -l.angle, p);
                        x = B.vec3.transformMat4(x, x, T),
                        B.mat4.fromRotation(T, -l._pitch, x);
                        const f = B.vec3.normalize([], p);
                        return B.vec3.scale(f, f, Ei(l.cameraToCenterDistance / l.pixelsPerMeter)),
                        B.vec3.transformMat4(f, f, T),
                        B.vec3.add([], p, f)
                    }(n)
                      , u = B.vec3.subtract([], a, o);
                    return B.vec3.angle(u, o)
                }
                function Cr(n, e) {
                    return ns(n, e) > Math.PI / 2 * 1.01
                }
                const ya = _o(85)
                  , ys = Math.cos(ya)
                  , $a = Math.sin(ya)
                  , Fc = B.mat4.create()
                  , zh = n => {
                    const e = [];
                    return "map" === n.paint.get("circle-pitch-alignment") && e.push("PITCH_WITH_MAP"),
                    "map" === n.paint.get("circle-pitch-scale") && e.push("SCALE_WITH_MAP"),
                    e
                }
                ;
                function Bh(n, e, o, a, u, l, p, g, x) {
                    if (l && n.queryGeometry.isAboveHorizon)
                        return !1;
                    l && (x *= n.pixelToTileUnitsFactor);
                    const T = n.tileID.canonical
                      , f = o.projection.upVectorScale(T, o.center.lat, o.worldSize).metersToTile;
                    for (const b of e)
                        for (const P of b) {
                            const v = P.add(g)
                              , w = u && o.elevation ? o.elevation.exaggeration() * u.getElevationAt(v.x, v.y, !0) : 0
                              , C = o.projection.projectTilePoint(v.x, v.y, T);
                            if (w > 0) {
                                const z = o.projection.upVector(T, v.x, v.y);
                                C.x += z[0] * f * w,
                                C.y += z[1] * f * w,
                                C.z += z[2] * f * w
                            }
                            const A = l ? v : T0(C.x, C.y, C.z, a)
                              , O = l ? n.tilespaceRays.map(z => E0(z, w)) : n.queryGeometry.screenGeometry
                              , F = B.vec4.transformMat4([], [C.x, C.y, C.z, 1], a);
                            if (!p && l ? x *= F[3] / o.cameraToCenterDistance : p && !l && (x *= o.cameraToCenterDistance / F[3]),
                            l) {
                                const z = Gn((P.y / uo + T.y) / (1 << T.z));
                                x /= o.projection.pixelsPerMeter(z, 1) / ar(1, z)
                            }
                            if (K(O, A, x))
                                return !0
                        }
                    return !1
                }
                function T0(n, e, o, a) {
                    const u = B.vec4.transformMat4([], [n, e, o, 1], a);
                    return new tt(u[0] / u[3],u[1] / u[3])
                }
                const Qm = B.vec3.fromValues(0, 0, 0)
                  , C0 = B.vec3.fromValues(0, 0, 1);
                function E0(n, e) {
                    const o = B.vec3.create();
                    return Qm[2] = e,
                    n.intersectsPlane(Qm, C0, o),
                    new tt(o[0],o[1])
                }
                class ef extends j {
                }
                let tf, of, nf, rf;
                function sf(n, {width: e, height: o}, a, u) {
                    if (u) {
                        if (u instanceof Uint8ClampedArray)
                            u = new Uint8Array(u.buffer);
                        else if (u.length !== e * o * a)
                            throw new RangeError("mismatched image size")
                    } else
                        u = new Uint8Array(e * o * a);
                    return n.width = e,
                    n.height = o,
                    n.data = u,
                    n
                }
                function af(n, e, o) {
                    const {width: a, height: u} = e;
                    a === n.width && u === n.height || (Bd(n, e, {
                        x: 0,
                        y: 0
                    }, {
                        x: 0,
                        y: 0
                    }, {
                        width: Math.min(n.width, a),
                        height: Math.min(n.height, u)
                    }, o, null),
                    n.width = a,
                    n.height = u,
                    n.data = e.data)
                }
                function Bd(n, e, o, a, u, l, p, g) {
                    if (0 === u.width || 0 === u.height)
                        return e;
                    if (u.width > n.width || u.height > n.height || o.x > n.width - u.width || o.y > n.height - u.height)
                        throw new RangeError("out of range source coordinates for image copy");
                    if (u.width > e.width || u.height > e.height || a.x > e.width - u.width || a.y > e.height - u.height)
                        throw new RangeError("out of range destination coordinates for image copy");
                    const x = n.data
                      , T = e.data
                      , f = 4 === l && g;
                    for (let b = 0; b < u.height; b++) {
                        const P = ((o.y + b) * n.width + o.x) * l
                          , v = ((a.y + b) * e.width + a.x) * l;
                        if (f)
                            for (let w = 0; w < u.width; w++) {
                                const C = P + w * l + 3
                                  , A = v + w * l;
                                T[A + 0] = 255,
                                T[A + 1] = 255,
                                T[A + 2] = 255,
                                T[A + 3] = x[C]
                            }
                        else if (p)
                            for (let w = 0; w < u.width; w++) {
                                const C = P + w * l
                                  , A = v + w * l
                                  , O = x[C + 3]
                                  , F = new wi(x[C + 0] / 255 * O,x[C + 1] / 255 * O,x[C + 2] / 255 * O,O).toRenderColor(p).toArray();
                                T[A + 0] = F[0],
                                T[A + 1] = F[1],
                                T[A + 2] = F[2],
                                T[A + 3] = F[3]
                            }
                        else
                            for (let w = 0; w < u.width * l; w++)
                                T[v + w] = x[P + w]
                    }
                    return e
                }
                Fe(ef, "HeatmapBucket", {
                    omit: ["layers"]
                });
                class Al {
                    constructor(e, o) {
                        sf(this, e, 1, o)
                    }
                    resize(e) {
                        af(this, new Al(e), 1)
                    }
                    clone() {
                        return new Al({
                            width: this.width,
                            height: this.height
                        },new Uint8Array(this.data))
                    }
                    static copy(e, o, a, u, l) {
                        Bd(e, o, a, u, l, 1, null)
                    }
                }
                class hr {
                    constructor(e, o) {
                        sf(this, e, 4, o)
                    }
                    resize(e) {
                        af(this, new hr(e), 4)
                    }
                    replace(e, o) {
                        o ? this.data.set(e) : this.data = e instanceof Uint8ClampedArray ? new Uint8Array(e.buffer) : e
                    }
                    clone() {
                        return new hr({
                            width: this.width,
                            height: this.height
                        },new Uint8Array(this.data))
                    }
                    static copy(e, o, a, u, l, p, g) {
                        Bd(e, o, a, u, l, 4, p, g)
                    }
                }
                class lf {
                    constructor(e, o) {
                        this.width = e.width,
                        this.height = e.height,
                        this.data = o instanceof Uint8Array ? new Float32Array(o.buffer) : o
                    }
                }
                function Lu(n) {
                    const e = {}
                      , o = n.resolution || 256
                      , a = n.clips ? n.clips.length : 1
                      , u = n.image || new hr({
                        width: o,
                        height: a
                    })
                      , l = (p, g, x) => {
                        e[n.evaluationKey] = x;
                        const T = n.expression.evaluate(e);
                        T && (u.data[p + g + 0] = Math.floor(255 * T.r / T.a),
                        u.data[p + g + 1] = Math.floor(255 * T.g / T.a),
                        u.data[p + g + 2] = Math.floor(255 * T.b / T.a),
                        u.data[p + g + 3] = Math.floor(255 * T.a))
                    }
                    ;
                    if (n.clips)
                        for (let p = 0, g = 0; p < a; ++p,
                        g += 4 * o)
                            for (let x = 0, T = 0; x < o; x++,
                            T += 4) {
                                const f = x / (o - 1)
                                  , {start: b, end: P} = n.clips[p];
                                l(g, T, b * (1 - f) + P * f)
                            }
                    else
                        for (let p = 0, g = 0; p < o; p++,
                        g += 4)
                            l(0, g, p / (o - 1));
                    return u
                }
                Fe(Al, "AlphaImage"),
                Fe(hr, "RGBAImage");
                const S0 = Si([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }], 4)
                  , {members: I0} = S0;
                function Fu(n, e, o=2) {
                    const a = e && e.length
                      , u = a ? e[0] * o : n.length;
                    let l = cf(n, 0, u, o, !0);
                    const p = [];
                    if (!l || l.next === l.prev)
                        return p;
                    let g, x, T;
                    if (a && (l = function(f, b, P, v) {
                        const w = [];
                        for (let C = 0, A = b.length; C < A; C++) {
                            const O = cf(f, b[C] * v, C < A - 1 ? b[C + 1] * v : f.length, v, !1);
                            O === O.next && (O.steiner = !0),
                            w.push(z0(O))
                        }
                        w.sort(L0);
                        for (let C = 0; C < w.length; C++)
                            P = F0(w[C], P);
                        return P
                    }(n, e, l, o)),
                    n.length > 80 * o) {
                        g = 1 / 0,
                        x = 1 / 0;
                        let f = -1 / 0
                          , b = -1 / 0;
                        for (let P = o; P < u; P += o) {
                            const v = n[P]
                              , w = n[P + 1];
                            v < g && (g = v),
                            w < x && (x = w),
                            v > f && (f = v),
                            w > b && (b = w)
                        }
                        T = Math.max(f - g, b - x),
                        T = 0 !== T ? 32767 / T : 0
                    }
                    return ku(l, p, o, g, x, T, 0),
                    p
                }
                function cf(n, e, o, a, u) {
                    let l;
                    if (u === function(p, g, x, T) {
                        let f = 0;
                        for (let b = g, P = x - T; b < x; b += T)
                            f += (p[P] - p[b]) * (p[b + 1] + p[P + 1]),
                            P = b;
                        return f
                    }(n, e, o, a) > 0)
                        for (let p = e; p < o; p += a)
                            l = pf(p / a | 0, n[p], n[p + 1], l);
                    else
                        for (let p = o - a; p >= e; p -= a)
                            l = pf(p / a | 0, n[p], n[p + 1], l);
                    return l && Dp(l, l.next) && (Bu(l),
                    l = l.next),
                    l
                }
                function kc(n, e) {
                    if (!n)
                        return n;
                    e || (e = n);
                    let o, a = n;
                    do {
                        if (o = !1,
                        a.steiner || !Dp(a, a.next) && 0 !== Rn(a.prev, a, a.next))
                            a = a.next;
                        else {
                            if (Bu(a),
                            a = e = a.prev,
                            a === a.next)
                                break;
                            o = !0
                        }
                    } while (o || a !== e);
                    return e
                }
                function ku(n, e, o, a, u, l, p) {
                    if (!n)
                        return;
                    !p && l && function(x, T, f, b) {
                        let P = x;
                        do {
                            0 === P.z && (P.z = Ud(P.x, P.y, T, f, b)),
                            P.prevZ = P.prev,
                            P.nextZ = P.next,
                            P = P.next
                        } while (P !== x);
                        P.prevZ.nextZ = null,
                        P.prevZ = null,
                        function(v) {
                            let w, C = 1;
                            do {
                                let A, O = v;
                                v = null;
                                let F = null;
                                for (w = 0; O; ) {
                                    w++;
                                    let z = O
                                      , L = 0;
                                    for (let G = 0; G < C && (L++,
                                    z = z.nextZ,
                                    z); G++)
                                        ;
                                    let N = C;
                                    for (; L > 0 || N > 0 && z; )
                                        0 !== L && (0 === N || !z || O.z <= z.z) ? (A = O,
                                        O = O.nextZ,
                                        L--) : (A = z,
                                        z = z.nextZ,
                                        N--),
                                        F ? F.nextZ = A : v = A,
                                        A.prevZ = F,
                                        F = A;
                                    O = z
                                }
                                F.nextZ = null,
                                C *= 2
                            } while (w > 1)
                        }(P)
                    }(n, a, u, l);
                    let g = n;
                    for (; n.prev !== n.next; ) {
                        const x = n.prev
                          , T = n.next;
                        if (l ? O0(n, a, u, l) : A0(n))
                            e.push(x.i, n.i, T.i),
                            Bu(n),
                            n = T.next,
                            g = T.next;
                        else if ((n = T) === g) {
                            p ? 1 === p ? ku(n = R0(kc(n), e), e, o, a, u, l, 2) : 2 === p && D0(n, e, o, a, u, l) : ku(kc(n), e, o, a, u, l, 1);
                            break
                        }
                    }
                }
                function A0(n) {
                    const e = n.prev
                      , o = n
                      , a = n.next;
                    if (Rn(e, o, a) >= 0)
                        return !1;
                    const u = e.x
                      , l = o.x
                      , p = a.x
                      , g = e.y
                      , x = o.y
                      , T = a.y
                      , f = u < l ? u < p ? u : p : l < p ? l : p
                      , b = g < x ? g < T ? g : T : x < T ? x : T
                      , P = u > l ? u > p ? u : p : l > p ? l : p
                      , v = g > x ? g > T ? g : T : x > T ? x : T;
                    let w = a.next;
                    for (; w !== e; ) {
                        if (w.x >= f && w.x <= P && w.y >= b && w.y <= v && Uh(u, g, l, x, p, T, w.x, w.y) && Rn(w.prev, w, w.next) >= 0)
                            return !1;
                        w = w.next
                    }
                    return !0
                }
                function O0(n, e, o, a) {
                    const u = n.prev
                      , l = n
                      , p = n.next;
                    if (Rn(u, l, p) >= 0)
                        return !1;
                    const g = u.x
                      , x = l.x
                      , T = p.x
                      , f = u.y
                      , b = l.y
                      , P = p.y
                      , v = g < x ? g < T ? g : T : x < T ? x : T
                      , w = f < b ? f < P ? f : P : b < P ? b : P
                      , C = g > x ? g > T ? g : T : x > T ? x : T
                      , A = f > b ? f > P ? f : P : b > P ? b : P
                      , O = Ud(v, w, e, o, a)
                      , F = Ud(C, A, e, o, a);
                    let z = n.prevZ
                      , L = n.nextZ;
                    for (; z && z.z >= O && L && L.z <= F; ) {
                        if (z.x >= v && z.x <= C && z.y >= w && z.y <= A && z !== u && z !== p && Uh(g, f, x, b, T, P, z.x, z.y) && Rn(z.prev, z, z.next) >= 0 || (z = z.prevZ,
                        L.x >= v && L.x <= C && L.y >= w && L.y <= A && L !== u && L !== p && Uh(g, f, x, b, T, P, L.x, L.y) && Rn(L.prev, L, L.next) >= 0))
                            return !1;
                        L = L.nextZ
                    }
                    for (; z && z.z >= O; ) {
                        if (z.x >= v && z.x <= C && z.y >= w && z.y <= A && z !== u && z !== p && Uh(g, f, x, b, T, P, z.x, z.y) && Rn(z.prev, z, z.next) >= 0)
                            return !1;
                        z = z.prevZ
                    }
                    for (; L && L.z <= F; ) {
                        if (L.x >= v && L.x <= C && L.y >= w && L.y <= A && L !== u && L !== p && Uh(g, f, x, b, T, P, L.x, L.y) && Rn(L.prev, L, L.next) >= 0)
                            return !1;
                        L = L.nextZ
                    }
                    return !0
                }
                function R0(n, e) {
                    let o = n;
                    do {
                        const a = o.prev
                          , u = o.next.next;
                        !Dp(a, u) && hf(a, o, o.next, u) && zu(a, u) && zu(u, a) && (e.push(a.i, o.i, u.i),
                        Bu(o),
                        Bu(o.next),
                        o = n = u),
                        o = o.next
                    } while (o !== n);
                    return kc(o)
                }
                function D0(n, e, o, a, u, l) {
                    let p = n;
                    do {
                        let g = p.next.next;
                        for (; g !== p.prev; ) {
                            if (p.i !== g.i && B0(p, g)) {
                                let x = uf(p, g);
                                return p = kc(p, p.next),
                                x = kc(x, x.next),
                                ku(p, e, o, a, u, l, 0),
                                void ku(x, e, o, a, u, l, 0)
                            }
                            g = g.next
                        }
                        p = p.next
                    } while (p !== n)
                }
                function L0(n, e) {
                    return n.x - e.x
                }
                function F0(n, e) {
                    const o = function(u, l) {
                        let p = l;
                        const g = u.x
                          , x = u.y;
                        let T, f = -1 / 0;
                        do {
                            if (x <= p.y && x >= p.next.y && p.next.y !== p.y) {
                                const C = p.x + (x - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                                if (C <= g && C > f && (f = C,
                                T = p.x < p.next.x ? p : p.next,
                                C === g))
                                    return T
                            }
                            p = p.next
                        } while (p !== l);
                        if (!T)
                            return null;
                        const b = T
                          , P = T.x
                          , v = T.y;
                        let w = 1 / 0;
                        p = T;
                        do {
                            if (g >= p.x && p.x >= P && g !== p.x && Uh(x < v ? g : f, x, P, v, x < v ? f : g, x, p.x, p.y)) {
                                const C = Math.abs(x - p.y) / (g - p.x);
                                zu(p, u) && (C < w || C === w && (p.x > T.x || p.x === T.x && k0(T, p))) && (T = p,
                                w = C)
                            }
                            p = p.next
                        } while (p !== b);
                        return T
                    }(n, e);
                    if (!o)
                        return e;
                    const a = uf(o, n);
                    return kc(a, a.next),
                    kc(o, o.next)
                }
                function k0(n, e) {
                    return Rn(n.prev, n, e.prev) < 0 && Rn(e.next, n, n.next) < 0
                }
                function Ud(n, e, o, a, u) {
                    return (n = 1431655765 & ((n = 858993459 & ((n = 252645135 & ((n = 16711935 & ((n = (n - o) * u | 0) | n << 8)) | n << 4)) | n << 2)) | n << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - a) * u | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
                }
                function z0(n) {
                    let e = n
                      , o = n;
                    do {
                        (e.x < o.x || e.x === o.x && e.y < o.y) && (o = e),
                        e = e.next
                    } while (e !== n);
                    return o
                }
                function Uh(n, e, o, a, u, l, p, g) {
                    return (u - p) * (e - g) >= (n - p) * (l - g) && (n - p) * (a - g) >= (o - p) * (e - g) && (o - p) * (l - g) >= (u - p) * (a - g)
                }
                function B0(n, e) {
                    return n.next.i !== e.i && n.prev.i !== e.i && !function(o, a) {
                        let u = o;
                        do {
                            if (u.i !== o.i && u.next.i !== o.i && u.i !== a.i && u.next.i !== a.i && hf(u, u.next, o, a))
                                return !0;
                            u = u.next
                        } while (u !== o);
                        return !1
                    }(n, e) && (zu(n, e) && zu(e, n) && function(o, a) {
                        let u = o
                          , l = !1;
                        const p = (o.x + a.x) / 2
                          , g = (o.y + a.y) / 2;
                        do {
                            u.y > g != u.next.y > g && u.next.y !== u.y && p < (u.next.x - u.x) * (g - u.y) / (u.next.y - u.y) + u.x && (l = !l),
                            u = u.next
                        } while (u !== o);
                        return l
                    }(n, e) && (Rn(n.prev, n, e.prev) || Rn(n, e.prev, e)) || Dp(n, e) && Rn(n.prev, n, n.next) > 0 && Rn(e.prev, e, e.next) > 0)
                }
                function Rn(n, e, o) {
                    return (e.y - n.y) * (o.x - e.x) - (e.x - n.x) * (o.y - e.y)
                }
                function Dp(n, e) {
                    return n.x === e.x && n.y === e.y
                }
                function hf(n, e, o, a) {
                    const u = Fp(Rn(n, e, o))
                      , l = Fp(Rn(n, e, a))
                      , p = Fp(Rn(o, a, n))
                      , g = Fp(Rn(o, a, e));
                    return u !== l && p !== g || !(0 !== u || !Lp(n, o, e)) || !(0 !== l || !Lp(n, a, e)) || !(0 !== p || !Lp(o, n, a)) || !(0 !== g || !Lp(o, e, a))
                }
                function Lp(n, e, o) {
                    return e.x <= Math.max(n.x, o.x) && e.x >= Math.min(n.x, o.x) && e.y <= Math.max(n.y, o.y) && e.y >= Math.min(n.y, o.y)
                }
                function Fp(n) {
                    return n > 0 ? 1 : n < 0 ? -1 : 0
                }
                function zu(n, e) {
                    return Rn(n.prev, n, n.next) < 0 ? Rn(n, e, n.next) >= 0 && Rn(n, n.prev, e) >= 0 : Rn(n, e, n.prev) < 0 || Rn(n, n.next, e) < 0
                }
                function uf(n, e) {
                    const o = Nd(n.i, n.x, n.y)
                      , a = Nd(e.i, e.x, e.y)
                      , u = n.next
                      , l = e.prev;
                    return n.next = e,
                    e.prev = n,
                    o.next = u,
                    u.prev = o,
                    a.next = o,
                    o.prev = a,
                    l.next = a,
                    a.prev = l,
                    a
                }
                function pf(n, e, o, a) {
                    const u = Nd(n, e, o);
                    return a ? (u.next = a.next,
                    u.prev = a,
                    a.next.prev = u,
                    a.next = u) : (u.prev = u,
                    u.next = u),
                    u
                }
                function Bu(n) {
                    n.next.prev = n.prev,
                    n.prev.next = n.next,
                    n.prevZ && (n.prevZ.nextZ = n.nextZ),
                    n.nextZ && (n.nextZ.prevZ = n.prevZ)
                }
                function Nd(n, e, o) {
                    return {
                        i: n,
                        x: e,
                        y: o,
                        prev: null,
                        next: null,
                        z: 0,
                        prevZ: null,
                        nextZ: null,
                        steiner: !1
                    }
                }
                function kp(n, e) {
                    const o = n.length;
                    if (o <= 1)
                        return [n];
                    const a = [];
                    let u, l;
                    for (let p = 0; p < o; p++) {
                        const g = Ti(n[p]);
                        0 !== g && (n[p].area = Math.abs(g),
                        void 0 === l && (l = g < 0),
                        l === g < 0 ? (u && a.push(u),
                        u = [n[p]]) : u.push(n[p]))
                    }
                    if (u && a.push(u),
                    e > 1)
                        for (let p = 0; p < a.length; p++)
                            a[p].length <= e || (Yc(a[p], e, 1, a[p].length - 1, U0),
                            a[p] = a[p].slice(0, e));
                    return a
                }
                function U0(n, e) {
                    return e.area - n.area
                }
                function df(n, e) {
                    if (!n)
                        return null;
                    const o = "string" == typeof n ? n : n.getPrimary().id;
                    e[o] || (e[o] = []);
                    const a = In.from(n).getPrimary();
                    return e[o].push(a),
                    a.serialize()
                }
                function $d(n, e, o) {
                    const a = o.patternDependencies;
                    let u = !1;
                    for (const l of e) {
                        const p = l.paint.get("".concat(n, "-pattern"));
                        p.isConstant() || (u = !0),
                        df(p.constantOr(null), a) && (u = !0)
                    }
                    return u
                }
                function Gd(n, e, o, a, u) {
                    const l = u.patternDependencies;
                    for (const p of e) {
                        const g = p.paint.get("".concat(n, "-pattern")).value;
                        if ("constant" !== g.kind) {
                            let x = g.evaluate({
                                zoom: a
                            }, o, {}, u.availableImages);
                            x = x && x.name ? x.name : x;
                            const T = df(x, l);
                            T && (o.patterns[p.id] = T)
                        }
                    }
                    return o
                }
                class jd {
                    constructor(e) {
                        this.zoom = e.zoom,
                        this.overscaling = e.overscaling,
                        this.layers = e.layers,
                        this.layerIds = this.layers.map(o => o.fqid),
                        this.index = e.index,
                        this.hasPattern = !1,
                        this.patternFeatures = [],
                        this.layoutVertexArray = new ts,
                        this.indexArray = new Xn,
                        this.indexArray2 = new da,
                        this.programConfigurations = new fa(e.layers,{
                            zoom: e.zoom,
                            lut: e.lut
                        }),
                        this.segments = new mn,
                        this.segments2 = new mn,
                        this.stateDependentLayerIds = this.layers.filter(o => o.isStateDependent()).map(o => o.id),
                        this.projection = e.projection
                    }
                    updateFootprints(e, o) {}
                    populate(e, o, a, u) {
                        this.hasPattern = $d("fill", this.layers, o);
                        const l = this.layers[0].layout.get("fill-sort-key")
                          , p = [];
                        for (const {feature: g, id: x, index: T, sourceLayerIndex: f} of e) {
                            const b = this.layers[0]._featureFilter.needGeometry
                              , P = D(g, b);
                            if (!this.layers[0]._featureFilter.filter(new Hi(this.zoom), P, a))
                                continue;
                            const v = l ? l.evaluate(P, {}, a, o.availableImages) : void 0
                              , w = {
                                id: x,
                                properties: g.properties,
                                type: g.type,
                                sourceLayerIndex: f,
                                index: T,
                                geometry: b ? P.geometry : R(g, a, u),
                                patterns: {},
                                sortKey: v
                            };
                            p.push(w)
                        }
                        l && p.sort( (g, x) => g.sortKey - x.sortKey);
                        for (const g of p) {
                            const {geometry: x, index: T, sourceLayerIndex: f} = g;
                            if (this.hasPattern) {
                                const b = Gd("fill", this.layers, g, this.zoom, o);
                                this.patternFeatures.push(b)
                            } else
                                this.addFeature(g, x, T, a, {}, o.availableImages, o.brightness);
                            o.featureIndex.insert(e[T].feature, x, T, f, this.index)
                        }
                    }
                    update(e, o, a, u, l, p, g) {
                        this.programConfigurations.updatePaintArrays(e, o, l, a, u, p, g)
                    }
                    addFeatures(e, o, a, u, l, p) {
                        for (const g of this.patternFeatures)
                            this.addFeature(g, g.geometry, g.index, o, a, u, p)
                    }
                    isEmpty() {
                        return 0 === this.layoutVertexArray.length
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(e) {
                        this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, I0),
                        this.indexBuffer = e.createIndexBuffer(this.indexArray),
                        this.indexBuffer2 = e.createIndexBuffer(this.indexArray2)),
                        this.programConfigurations.upload(e),
                        this.uploaded = !0
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.indexBuffer2.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy(),
                        this.segments2.destroy())
                    }
                    addFeature(e, o, a, u, l, p=[], g) {
                        for (const x of kp(o, 500)) {
                            let T = 0;
                            for (const C of x)
                                T += C.length;
                            const f = this.segments.prepareSegment(T, this.layoutVertexArray, this.indexArray)
                              , b = f.vertexLength
                              , P = []
                              , v = [];
                            for (const C of x) {
                                if (0 === C.length)
                                    continue;
                                C !== x[0] && v.push(P.length / 2);
                                const A = this.segments2.prepareSegment(C.length, this.layoutVertexArray, this.indexArray2)
                                  , O = A.vertexLength;
                                this.layoutVertexArray.emplaceBack(C[0].x, C[0].y),
                                this.indexArray2.emplaceBack(O + C.length - 1, O),
                                P.push(C[0].x),
                                P.push(C[0].y);
                                for (let F = 1; F < C.length; F++)
                                    this.layoutVertexArray.emplaceBack(C[F].x, C[F].y),
                                    this.indexArray2.emplaceBack(O + F - 1, O + F),
                                    P.push(C[F].x),
                                    P.push(C[F].y);
                                A.vertexLength += C.length,
                                A.primitiveLength += C.length
                            }
                            const w = Fu(P, v);
                            for (let C = 0; C < w.length; C += 3)
                                this.indexArray.emplaceBack(b + w[C], b + w[C + 1], b + w[C + 2]);
                            f.vertexLength += T,
                            f.primitiveLength += w.length / 3
                        }
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, a, l, p, u, g)
                    }
                }
                let mf, ff, _f, gf;
                Fe(jd, "FillBucket", {
                    omit: ["layers", "patternFeatures"]
                });
                class Vd {
                    constructor(e, o, a, u) {
                        if (this.triangleCount = o.length / 3,
                        this.min = new tt(0,0),
                        this.max = new tt(0,0),
                        this.xScale = 0,
                        this.yScale = 0,
                        this.cellsX = 0,
                        this.cellsY = 0,
                        this.cells = [],
                        this.payload = [],
                        0 === this.triangleCount || 0 === e.length)
                            return;
                        const [l,p] = [e[0].clone(), e[0].clone()];
                        for (let b = 1; b < e.length; ++b) {
                            const P = e[b];
                            l.x = Math.min(l.x, P.x),
                            l.y = Math.min(l.y, P.y),
                            p.x = Math.max(p.x, P.x),
                            p.y = Math.max(p.y, P.y)
                        }
                        if (u) {
                            const b = Math.ceil(Math.max(p.x - l.x, p.y - l.y) / u);
                            a = Math.max(a, b)
                        }
                        if (0 === a)
                            return;
                        this.min = l,
                        this.max = p;
                        const g = this.max.sub(this.min);
                        g.x = Math.max(g.x, 1),
                        g.y = Math.max(g.y, 1);
                        const x = Math.max(g.x, g.y) / a;
                        this.cellsX = Math.max(1, Math.ceil(g.x / x)),
                        this.cellsY = Math.max(1, Math.ceil(g.y / x)),
                        this.xScale = 1 / x,
                        this.yScale = 1 / x;
                        const T = [];
                        for (let b = 0; b < this.triangleCount; b++) {
                            const P = e[o[3 * b + 0]].sub(this.min)
                              , v = e[o[3 * b + 1]].sub(this.min)
                              , w = e[o[3 * b + 2]].sub(this.min)
                              , C = va(Math.floor(Math.min(P.x, v.x, w.x)), this.xScale, this.cellsX)
                              , A = va(Math.floor(Math.max(P.x, v.x, w.x)), this.xScale, this.cellsX)
                              , O = va(Math.floor(Math.min(P.y, v.y, w.y)), this.yScale, this.cellsY)
                              , F = va(Math.floor(Math.max(P.y, v.y, w.y)), this.yScale, this.cellsY)
                              , z = new tt(0,0)
                              , L = new tt(0,0)
                              , N = new tt(0,0)
                              , G = new tt(0,0);
                            for (let X = O; X <= F; ++X) {
                                z.y = L.y = X * x,
                                N.y = G.y = (X + 1) * x;
                                for (let _e = C; _e <= A; ++_e)
                                    z.x = N.x = _e * x,
                                    L.x = G.x = (_e + 1) * x,
                                    (Ze(P, v, w, z, L, G) || Ze(P, v, w, z, G, N)) && T.push({
                                        cellIdx: X * this.cellsX + _e,
                                        triIdx: b
                                    })
                            }
                        }
                        if (0 === T.length)
                            return;
                        T.sort( (b, P) => b.cellIdx - P.cellIdx || b.triIdx - P.triIdx);
                        let f = 0;
                        for (; f < T.length; ) {
                            const b = T[f].cellIdx
                              , P = {
                                start: this.payload.length,
                                len: 0
                            };
                            for (; f < T.length && T[f].cellIdx === b; )
                                ++P.len,
                                this.payload.push(T[f++].triIdx);
                            this.cells[b] = P
                        }
                    }
                    _lazyInitLookup() {
                        this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8))),
                        this.lookup.fill(0)
                    }
                    queryPoint(e, o) {
                        if (0 === this.triangleCount || 0 === this.cells.length || e.x > this.max.x || this.min.x > e.x || e.y > this.max.y || this.min.y > e.y)
                            return;
                        const a = va(e.x - this.min.x, this.xScale, this.cellsX)
                          , u = va(e.y - this.min.y, this.yScale, this.cellsY)
                          , l = this.cells[u * this.cellsX + a];
                        if (l) {
                            this._lazyInitLookup();
                            for (let p = 0; p < l.len; p++) {
                                const g = this.payload[l.start + p]
                                  , x = Math.floor(g / 8)
                                  , T = 1 << g % 8;
                                if (!(this.lookup[x] & T) && (this.lookup[x] |= T,
                                o.push(g),
                                o.length === this.triangleCount))
                                    return
                            }
                        }
                    }
                    query(e, o, a) {
                        if (0 === this.triangleCount || 0 === this.cells.length || e.x > this.max.x || this.min.x > o.x || e.y > this.max.y || this.min.y > o.y)
                            return;
                        this._lazyInitLookup();
                        const u = va(e.x - this.min.x, this.xScale, this.cellsX)
                          , l = va(o.x - this.min.x, this.xScale, this.cellsX)
                          , p = va(e.y - this.min.y, this.yScale, this.cellsY)
                          , g = va(o.y - this.min.y, this.yScale, this.cellsY);
                        for (let x = p; x <= g; x++)
                            for (let T = u; T <= l; T++) {
                                const f = this.cells[x * this.cellsX + T];
                                if (f)
                                    for (let b = 0; b < f.len; b++) {
                                        const P = this.payload[f.start + b]
                                          , v = Math.floor(P / 8)
                                          , w = 1 << P % 8;
                                        if (!(this.lookup[v] & w) && (this.lookup[v] |= w,
                                        a.push(P),
                                        a.length === this.triangleCount))
                                            return
                                    }
                            }
                    }
                }
                function va(n, e, o) {
                    return Math.max(0, Math.min(o - 1, Math.floor(n * e)))
                }
                Fe(Vd, "TriangleGridIndex");
                class yf {
                    constructor(e) {
                        this.zoom = e.zoom,
                        this.layers = e.layers,
                        this.layerIds = this.layers.map(o => o.fqid),
                        this.index = e.index,
                        this.hasPattern = !1,
                        this.stateDependentLayerIds = this.layers.filter(o => o.isStateDependent()).map(o => o.id),
                        this.footprints = []
                    }
                    updateFootprints(e, o) {
                        for (const a of this.footprints)
                            o.push({
                                footprint: a,
                                id: e
                            })
                    }
                    populate(e, o, a, u) {
                        const l = [];
                        for (const {feature: p, id: g, index: x, sourceLayerIndex: T} of e) {
                            const f = this.layers[0]._featureFilter.needGeometry
                              , b = D(p, f);
                            if (!this.layers[0]._featureFilter.filter(new Hi(this.zoom), b, a))
                                continue;
                            const P = {
                                id: g,
                                properties: p.properties,
                                type: p.type,
                                sourceLayerIndex: T,
                                index: x,
                                geometry: f ? b.geometry : R(p, a, u),
                                patterns: {}
                            };
                            l.push(P)
                        }
                        for (const p of l) {
                            const {geometry: g, index: x, sourceLayerIndex: T} = p;
                            this.addFeature(p, g, x, a, {}, o.availableImages, o.brightness),
                            o.featureIndex.insert(e[x].feature, g, x, T, this.index)
                        }
                    }
                    isEmpty() {
                        return 0 === this.footprints.length
                    }
                    uploadPending() {
                        return !1
                    }
                    upload(e) {}
                    update(e, o, a, u, l, p, g) {}
                    destroy() {}
                    addFeature(e, o, a, u, l, p=[], g) {
                        for (const x of kp(o, 2)) {
                            const T = []
                              , f = []
                              , b = []
                              , P = new tt(1 / 0,1 / 0)
                              , v = new tt(-1 / 0,-1 / 0);
                            for (const A of x)
                                if (0 !== A.length) {
                                    A !== x[0] && b.push(f.length / 2);
                                    for (let O = 0; O < A.length; O++)
                                        f.push(A[O].x),
                                        f.push(A[O].y),
                                        T.push(A[O]),
                                        P.x = Math.min(P.x, A[O].x),
                                        P.y = Math.min(P.y, A[O].y),
                                        v.x = Math.max(v.x, A[O].x),
                                        v.y = Math.max(v.y, A[O].y)
                                }
                            const w = Fu(f, b)
                              , C = new Vd(T,w,8,256);
                            this.footprints.push({
                                vertices: T,
                                indices: w,
                                grid: C,
                                min: P,
                                max: v
                            })
                        }
                    }
                }
                Fe(yf, "ClipBucket", {
                    omit: ["layers"]
                });
                const N0 = Si([{
                    name: "a_pos_normal_ed",
                    components: 4,
                    type: "Int16"
                }])
                  , $0 = Si([{
                    name: "a_pos_end",
                    components: 4,
                    type: "Int16"
                }, {
                    name: "a_angular_offset_factor",
                    components: 1,
                    type: "Int16"
                }])
                  , G0 = Si([{
                    name: "a_centroid_pos",
                    components: 2,
                    type: "Uint16"
                }])
                  , j0 = Si([{
                    name: "a_join_normal_inside",
                    components: 3,
                    type: "Int16"
                }])
                  , V0 = Si([{
                    name: "a_hidden_by_landmark",
                    components: 1,
                    type: "Uint8"
                }])
                  , H0 = Si([{
                    name: "a_pos_3",
                    components: 3,
                    type: "Int16"
                }, {
                    name: "a_pos_normal_3",
                    components: 3,
                    type: "Int16"
                }])
                  , {members: W0} = N0;
                var Hd, vf, Wd, xf, Xd, bf, wf, zp = {};
                function Pf() {
                    if (vf)
                        return Hd;
                    vf = 1;
                    var n = St();
                    function e(u, l, p, g, x) {
                        this.properties = {},
                        this.extent = p,
                        this.type = 0,
                        this._pbf = u,
                        this._geometry = -1,
                        this._keys = g,
                        this._values = x,
                        u.readFields(o, this, l)
                    }
                    function o(u, l, p) {
                        1 == u ? l.id = p.readVarint() : 2 == u ? function(g, x) {
                            for (var T = g.readVarint() + g.pos; g.pos < T; ) {
                                var f = x._keys[g.readVarint()]
                                  , b = x._values[g.readVarint()];
                                x.properties[f] = b
                            }
                        }(p, l) : 3 == u ? l.type = p.readVarint() : 4 == u && (l._geometry = p.pos)
                    }
                    function a(u) {
                        for (var l, p, g = 0, x = 0, T = u.length, f = T - 1; x < T; f = x++)
                            g += ((p = u[f]).x - (l = u[x]).x) * (l.y + p.y);
                        return g
                    }
                    return Hd = e,
                    e.types = ["Unknown", "Point", "LineString", "Polygon"],
                    e.prototype.loadGeometry = function() {
                        var u = this._pbf;
                        u.pos = this._geometry;
                        for (var l, p = u.readVarint() + u.pos, g = 1, x = 0, T = 0, f = 0, b = []; u.pos < p; ) {
                            if (x <= 0) {
                                var P = u.readVarint();
                                g = 7 & P,
                                x = P >> 3
                            }
                            if (x--,
                            1 === g || 2 === g)
                                T += u.readSVarint(),
                                f += u.readSVarint(),
                                1 === g && (l && b.push(l),
                                l = []),
                                l.push(new n(T,f));
                            else {
                                if (7 !== g)
                                    throw new Error("unknown command " + g);
                                l && l.push(l[0].clone())
                            }
                        }
                        return l && b.push(l),
                        b
                    }
                    ,
                    e.prototype.bbox = function() {
                        var u = this._pbf;
                        u.pos = this._geometry;
                        for (var l = u.readVarint() + u.pos, p = 1, g = 0, x = 0, T = 0, f = 1 / 0, b = -1 / 0, P = 1 / 0, v = -1 / 0; u.pos < l; ) {
                            if (g <= 0) {
                                var w = u.readVarint();
                                p = 7 & w,
                                g = w >> 3
                            }
                            if (g--,
                            1 === p || 2 === p)
                                (x += u.readSVarint()) < f && (f = x),
                                x > b && (b = x),
                                (T += u.readSVarint()) < P && (P = T),
                                T > v && (v = T);
                            else if (7 !== p)
                                throw new Error("unknown command " + p)
                        }
                        return [f, P, b, v]
                    }
                    ,
                    e.prototype.toGeoJSON = function(u, l, p) {
                        var g, x, T = this.extent * Math.pow(2, p), f = this.extent * u, b = this.extent * l, P = this.loadGeometry(), v = e.types[this.type];
                        function w(O) {
                            for (var F = 0; F < O.length; F++) {
                                var z = O[F];
                                O[F] = [360 * (z.x + f) / T - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (z.y + b) / T) * Math.PI / 180)) - 90]
                            }
                        }
                        switch (this.type) {
                        case 1:
                            var C = [];
                            for (g = 0; g < P.length; g++)
                                C[g] = P[g][0];
                            w(P = C);
                            break;
                        case 2:
                            for (g = 0; g < P.length; g++)
                                w(P[g]);
                            break;
                        case 3:
                            for (P = function(O) {
                                var F = O.length;
                                if (F <= 1)
                                    return [O];
                                for (var z, L, N = [], G = 0; G < F; G++) {
                                    var X = a(O[G]);
                                    0 !== X && (void 0 === L && (L = X < 0),
                                    L === X < 0 ? (z && N.push(z),
                                    z = [O[G]]) : z.push(O[G]))
                                }
                                return z && N.push(z),
                                N
                            }(P),
                            g = 0; g < P.length; g++)
                                for (x = 0; x < P[g].length; x++)
                                    w(P[g][x])
                        }
                        1 === P.length ? P = P[0] : v = "Multi" + v;
                        var A = {
                            type: "Feature",
                            geometry: {
                                type: v,
                                coordinates: P
                            },
                            properties: this.properties
                        };
                        return "id"in this && (A.id = this.id),
                        A
                    }
                    ,
                    Hd
                }
                function Mf() {
                    if (xf)
                        return Wd;
                    xf = 1;
                    var n = Pf();
                    function e(a, u) {
                        this.version = 1,
                        this.name = null,
                        this.extent = 4096,
                        this.length = 0,
                        this._pbf = a,
                        this._keys = [],
                        this._values = [],
                        this._features = [],
                        a.readFields(o, this, u),
                        this.length = this._features.length
                    }
                    function o(a, u, l) {
                        15 === a ? u.version = l.readVarint() : 1 === a ? u.name = l.readString() : 5 === a ? u.extent = l.readVarint() : 2 === a ? u._features.push(l.pos) : 3 === a ? u._keys.push(l.readString()) : 4 === a && u._values.push(function(p) {
                            for (var g = null, x = p.readVarint() + p.pos; p.pos < x; ) {
                                var T = p.readVarint() >> 3;
                                g = 1 === T ? p.readString() : 2 === T ? p.readFloat() : 3 === T ? p.readDouble() : 4 === T ? p.readVarint64() : 5 === T ? p.readVarint() : 6 === T ? p.readSVarint() : 7 === T ? p.readBoolean() : null
                            }
                            return g
                        }(l))
                    }
                    return Wd = e,
                    e.prototype.feature = function(a) {
                        if (a < 0 || a >= this._features.length)
                            throw new Error("feature index out of bounds");
                        this._pbf.pos = this._features[a];
                        var u = this._pbf.readVarint() + this._pbf.pos;
                        return new n(this._pbf,u,this.extent,this._keys,this._values)
                    }
                    ,
                    Wd
                }
                function Tf() {
                    return wf || (wf = 1,
                    zp.VectorTile = function() {
                        if (bf)
                            return Xd;
                        bf = 1;
                        var n = Mf();
                        function e(o, a, u) {
                            if (3 === o) {
                                var l = new n(u,u.readVarint() + u.pos);
                                l.length && (a[l.name] = l)
                            }
                        }
                        return Xd = function(o, a) {
                            this.layers = o.readFields(e, {}, a)
                        }
                    }(),
                    zp.VectorTileFeature = Pf(),
                    zp.VectorTileLayer = Mf()),
                    zp
                }
                var Nh = Tf();
                class zc extends tt {
                    constructor(e, o, a) {
                        super(e, o),
                        this.z = a
                    }
                }
                class Cf extends zc {
                    constructor(e, o, a, u) {
                        super(e, o, a),
                        this.w = u
                    }
                }
                function Bp(n, e, o, a) {
                    const u = []
                      , l = 0 === a ? (p, g, x, T, f, b) => {
                        p.push(new tt(b,x + (b - g) / (T - g) * (f - x)))
                    }
                    : (p, g, x, T, f, b) => {
                        p.push(new tt(g + (b - x) / (f - x) * (T - g),b))
                    }
                    ;
                    for (const p of n) {
                        const g = [];
                        for (const x of p) {
                            if (x.length <= 2)
                                continue;
                            const T = [];
                            for (let P = 0; P < x.length - 1; P++) {
                                const v = x[P].x
                                  , w = x[P].y
                                  , C = x[P + 1].x
                                  , A = x[P + 1].y
                                  , O = 0 === a ? v : w
                                  , F = 0 === a ? C : A;
                                O < e ? F > e && l(T, v, w, C, A, e) : O > o ? F < o && l(T, v, w, C, A, o) : T.push(x[P]),
                                F < e && O >= e && l(T, v, w, C, A, e),
                                F > o && O <= o && l(T, v, w, C, A, o)
                            }
                            let f = x[x.length - 1];
                            const b = 0 === a ? f.x : f.y;
                            b >= e && b <= o && T.push(f),
                            T.length && (f = T[T.length - 1],
                            T[0].x === f.x && T[0].y === f.y || T.push(T[0]),
                            g.push(T))
                        }
                        g.length && u.push(g)
                    }
                    return u
                }
                function Ef(n, e, o, a) {
                    const u = "x" === o ? "y" : "x"
                      , l = (a - n[o]) / (e[o] - n[o]);
                    n[u] = n[u] + (e[u] - n[u]) * l,
                    n[o] = a,
                    n.hasOwnProperty("z") && (n.z = jo(n.z, e.z, l)),
                    n.hasOwnProperty("w") && (n.w = jo(n.w, e.w, l))
                }
                function Sf(n, e, o, a) {
                    const u = o
                      , l = a;
                    for (const p of ["x", "y"]) {
                        let g = n
                          , x = e;
                        g[p] >= x[p] && (g = e,
                        x = n),
                        g[p] < u && x[p] > u && Ef(g, x, p, u),
                        g[p] < l && x[p] > l && Ef(x, g, p, l)
                    }
                }
                const Up = Number.MAX_SAFE_INTEGER;
                function If(n, e, o, a) {
                    return n.order < e || n.order === Up || !(n.clipMask & o) || (u = a,
                    0 !== (l = n.clipScope).length && void 0 === l.find(p => p === u));
                    var u, l
                }
                function Np(n, e) {
                    return n.x - e.x || n.y - e.y
                }
                function Af(n, e) {
                    return 0 === Np(n.min, e.min) && 0 === Np(n.max, e.max)
                }
                function Yd(n, e) {
                    return !(n.min.x > e.max.x || n.max.x < e.min.x || n.min.y > e.max.y || n.max.y < e.min.y)
                }
                function Zd(n, e) {
                    if (n.length !== e.length)
                        return !1;
                    for (let o = 0; o < n.length; o++)
                        if (n[o].sourceId !== e[o].sourceId || !Af(n[o], e[o]) || n[o].order !== e[o].order || n[o].clipMask !== e[o].clipMask || !$t(n[o].clipScope, e[o].clipScope))
                            return !1;
                    return !0
                }
                function Of(n, e, o) {
                    const a = 1 / uo
                      , u = 1 / (1 << o.canonical.z)
                      , l = (e.x * a + o.canonical.x) * u + o.wrap
                      , p = (e.y * a + o.canonical.y) * u;
                    return {
                        min: new tt((n.x * a + o.canonical.x) * u + o.wrap,(n.y * a + o.canonical.y) * u),
                        max: new tt(l,p)
                    }
                }
                function X0(n, e, o) {
                    const a = 1 << o.canonical.z
                      , u = ((e.x - o.wrap) * a - o.canonical.x) * uo
                      , l = (e.y * a - o.canonical.y) * uo;
                    return {
                        min: new tt(((n.x - o.wrap) * a - o.canonical.x) * uo,(n.y * a - o.canonical.y) * uo),
                        max: new tt(u,l)
                    }
                }
                function Rf(n, e, o, a, u, l, p) {
                    const g = n.indices
                      , x = n.vertices
                      , T = [];
                    for (let f = a; f < a + u; f += 3) {
                        const b = e[o[f + 0] + l]
                          , P = e[o[f + 1] + l]
                          , v = e[o[f + 2] + l]
                          , w = Math.min(b.x, P.x, v.x)
                          , C = Math.max(b.x, P.x, v.x)
                          , A = Math.min(b.y, P.y, v.y)
                          , O = Math.max(b.y, P.y, v.y);
                        T.length = 0,
                        n.grid.query(new tt(w,A), new tt(C,O), T);
                        for (let F = 0; F < T.length; F++) {
                            const z = T[F];
                            if (Ze(x[g[3 * z + 0]], x[g[3 * z + 1]], x[g[3 * z + 2]], b, P, v, p))
                                return !0
                        }
                    }
                    return !1
                }
                function Df(n, e, o, a) {
                    if (!n || !o)
                        return !1;
                    let u = n.vertices;
                    if (!e.canonical.equals(a.canonical) || e.wrap !== a.wrap) {
                        if (o.vertices.length < n.vertices.length)
                            return Df(o, a, n, e);
                        const l = e.canonical
                          , p = a.canonical
                          , g = Math.pow(2, p.z - l.z);
                        u = n.vertices.map(x => new tt((x.x + l.x * uo) * g - p.x * uo,(x.y + l.y * uo) * g - p.y * uo))
                    }
                    return Rf(o, u, n.indices, 0, n.indices.length, 0, 0)
                }
                function Lf(n, e, o, a) {
                    const u = Math.pow(2, a.z - o.z);
                    return new tt((n + o.x * uo) * u - a.x * uo,(e + o.y * uo) * u - a.y * uo)
                }
                function Ff(n, e) {
                    const o = [];
                    e.grid.queryPoint(n, o);
                    const a = e.indices
                      , u = e.vertices;
                    for (let l = 0; l < o.length; l++) {
                        const p = o[l];
                        if (Ge([u[a[3 * p + 0]], u[a[3 * p + 1]], u[a[3 * p + 2]]], n))
                            return !0
                    }
                    return !1
                }
                const Kd = [new tt(0,0), new tt(uo,0), new tt(uo,uo), new tt(0,uo)];
                function kf(n, e) {
                    const o = [];
                    let a = [];
                    if (!e || n.length < 2)
                        return [n];
                    if (2 === n.length)
                        return vt(n[0], n[1], Kd) ? [n] : [];
                    for (let u = 0; u < n.length + 2; u++) {
                        const l = n[u % n.length]
                          , p = n[(u + 1) % n.length]
                          , g = vt(0 === u ? n[n.length - 1] : n[(u - 1) % n.length], l, Kd)
                          , x = vt(l, p, Kd)
                          , T = g || x;
                        T && a.push(l),
                        T && x || a.length > 0 && (a.length > 1 && o.push(a),
                        a = [])
                    }
                    return a.length > 1 && o.push(a),
                    o
                }
                const qd = Nh.VectorTileFeature.types
                  , Y0 = ["fill-extrusion-base", "fill-extrusion-height", "fill-extrusion-color", "fill-extrusion-pattern", "fill-extrusion-flood-light-wall-radius", "fill-extrusion-line-width", "fill-extrusion-emissive-strength"]
                  , Z0 = ["fill-extrusion-flood-light-ground-radius"]
                  , K0 = Math.pow(2, 13)
                  , q0 = Math.pow(2, 15) - 1
                  , zf = new tt(0,1)
                  , Ol = 2147483648;
                function Uu(n, e, o, a, u, l, p, g) {
                    n.emplaceBack((e << 1) + p, (o << 1) + l, (Math.floor(a * K0) << 1) + u, Math.round(g))
                }
                function Nu(n, e, o) {
                    n.emplaceBack(e.x * uo, e.y * uo, o ? 1 : 0)
                }
                function $p(n, e, o, a, u, l) {
                    n.emplaceBack(e.x, e.y, (o.x << 1) + a, (o.y << 1) + u, l)
                }
                function $u(n, e, o) {
                    n.emplaceBack(e.x, e.y, e.z, 16384 * o[0], 16384 * o[1], 16384 * o[2])
                }
                class Bf {
                    constructor() {
                        this.vertexOffset = 0,
                        this.vertexCount = 0,
                        this.indexOffset = 0,
                        this.indexCount = 0
                    }
                }
                class Uf {
                    constructor() {
                        this.centroidXY = new tt(0,0),
                        this.vertexArrayOffset = 0,
                        this.vertexCount = 0,
                        this.groundVertexArrayOffset = 0,
                        this.groundVertexCount = 0,
                        this.flags = 0,
                        this.footprintSegIdx = -1,
                        this.footprintSegLen = 0,
                        this.polygonSegIdx = -1,
                        this.polygonSegLen = 0,
                        this.min = new tt(Number.MAX_VALUE,Number.MAX_VALUE),
                        this.max = new tt(-Number.MAX_VALUE,-Number.MAX_VALUE),
                        this.height = 0
                    }
                    span() {
                        return new tt(this.max.x - this.min.x,this.max.y - this.min.y)
                    }
                }
                class Nf {
                    constructor() {
                        this.acc = new tt(0,0),
                        this.accCount = 0,
                        this.centroidDataIndex = 0
                    }
                    startRing(e, o) {
                        e.min.x === Number.MAX_VALUE && (e.min.x = e.max.x = o.x,
                        e.min.y = e.max.y = o.y)
                    }
                    appendEdge(e, o, a) {
                        this.accCount++,
                        this.acc._add(o);
                        let u = !!this.borders;
                        o.x < e.min.x ? (e.min.x = o.x,
                        u = !0) : o.x > e.max.x && (e.max.x = o.x,
                        u = !0),
                        o.y < e.min.y ? (e.min.y = o.y,
                        u = !0) : o.y > e.max.y && (e.max.y = o.y,
                        u = !0),
                        ((0 === o.x || o.x === uo) && o.x === a.x) != ((0 === o.y || o.y === uo) && o.y === a.y) && this.processBorderOverlap(o, a),
                        u && this.checkBorderIntersection(o, a)
                    }
                    checkBorderIntersection(e, o) {
                        o.x < 0 != e.x < 0 && this.addBorderIntersection(0, jo(o.y, e.y, (0 - o.x) / (e.x - o.x))),
                        o.x > uo != e.x > uo && this.addBorderIntersection(1, jo(o.y, e.y, (uo - o.x) / (e.x - o.x))),
                        o.y < 0 != e.y < 0 && this.addBorderIntersection(2, jo(o.x, e.x, (0 - o.y) / (e.y - o.y))),
                        o.y > uo != e.y > uo && this.addBorderIntersection(3, jo(o.x, e.x, (uo - o.y) / (e.y - o.y)))
                    }
                    addBorderIntersection(e, o) {
                        this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
                        const a = this.borders[e];
                        o < a[0] && (a[0] = o),
                        o > a[1] && (a[1] = o)
                    }
                    processBorderOverlap(e, o) {
                        if (e.x === o.x) {
                            if (e.y === o.y)
                                return;
                            const a = 0 === e.x ? 0 : 1;
                            this.addBorderIntersection(a, o.y),
                            this.addBorderIntersection(a, e.y)
                        } else {
                            const a = 0 === e.y ? 2 : 3;
                            this.addBorderIntersection(a, o.x),
                            this.addBorderIntersection(a, e.x)
                        }
                    }
                    centroid() {
                        return 0 === this.accCount ? new tt(0,0) : new tt(Math.floor(Math.max(0, this.acc.x) / this.accCount),Math.floor(Math.max(0, this.acc.y) / this.accCount))
                    }
                    intersectsCount() {
                        return this.borders ? this.borders.reduce( (e, o) => e + +(o[0] !== Number.MAX_VALUE), 0) : 0
                    }
                }
                function $f(n, e) {
                    const o = n.add(e)._unit()
                      , a = ie(n.x * o.x + n.y * o.y, -1, 1);
                    var u, l, p;
                    return p = Math.acos(a),
                    Math.min(4, Math.max(-4, Math.tan(p))) / 4 * q0 * ((u = n).x * (l = e).y - u.y * l.x < 0 ? -1 : 1)
                }
                const J0 = [n => n.x < 0, n => n.x > uo, n => n.y < 0, n => n.y > uo];
                function Q0(n, e, o, a) {
                    const u = [4];
                    if (0 === a)
                        return u;
                    o._mult(a);
                    const l = n.sub(o)
                      , p = e.sub(o)
                      , g = [n, e, l, p];
                    for (let x = 0; x < 4; x++)
                        for (const T of g)
                            if (J0[x](T)) {
                                u.push(x);
                                break
                            }
                    return u
                }
                class Gf {
                    constructor(e) {
                        this.vertexArray = new yu,
                        this.indexArray = new Xn,
                        this.programConfigurations = new fa(e.layers,{
                            zoom: e.zoom,
                            lut: e.lut
                        },o => Z0.includes(o)),
                        this._segments = new mn,
                        this.hiddenByLandmarkVertexArray = new Ah,
                        this._segmentToGroundQuads = {},
                        this._segmentToGroundQuads[0] = [],
                        this._segmentToRegionTriCounts = {},
                        this._segmentToRegionTriCounts[0] = [0, 0, 0, 0, 0],
                        this.regionSegments = {},
                        this.regionSegments[4] = new mn
                    }
                    getDefaultSegment() {
                        return this.regionSegments[4]
                    }
                    hasData() {
                        return 0 !== this.vertexArray.length
                    }
                    addData(e, o, a, u=!1) {
                        const l = e.length;
                        if (l > 2) {
                            let p = Math.max(0, this._segments.get().length - 1);
                            const g = this._segments._prepareSegment(4 * l, this.vertexArray.length, 2 * this._segmentToGroundQuads[p].length);
                            let x;
                            p !== this._segments.get().length - 1 && (p++,
                            this._segmentToGroundQuads[p] = [],
                            this._segmentToRegionTriCounts[p] = [0, 0, 0, 0, 0]);
                            {
                                const T = e[0]
                                  , f = e[1];
                                x = $f(T.sub(e[l - 1])._perp()._unit(), f.sub(T)._perp()._unit())
                            }
                            for (let T = 0; T < l; T++) {
                                const f = T === l - 1 ? 0 : T + 1
                                  , b = e[T]
                                  , P = e[f]
                                  , v = e[f === l - 1 ? 0 : f + 1]
                                  , w = P.sub(b)._perp()._unit()
                                  , C = $f(w, v.sub(P)._perp()._unit())
                                  , A = x
                                  , O = C;
                                if (Jd(b, P, o) || u && Hf(b, o) && Hf(P, o)) {
                                    x = C;
                                    continue
                                }
                                const F = g.vertexLength;
                                $p(this.vertexArray, b, P, 1, 1, A),
                                $p(this.vertexArray, b, P, 1, 0, A),
                                $p(this.vertexArray, b, P, 0, 1, O),
                                $p(this.vertexArray, b, P, 0, 0, O),
                                g.vertexLength += 4;
                                const z = Q0(b, P, w, a);
                                for (const L of z)
                                    this._segmentToGroundQuads[p].push({
                                        id: F,
                                        region: L
                                    }),
                                    this._segmentToRegionTriCounts[p][L] += 2,
                                    g.primitiveLength += 2;
                                x = C
                            }
                        }
                    }
                    prepareBorderSegments() {
                        if (!this.hasData())
                            return;
                        const e = this._segments.get()
                          , o = e.length;
                        for (let a = 0; a < o; a++)
                            this._segmentToGroundQuads[a].sort( (u, l) => u.region - l.region);
                        for (let a = 0; a < o; a++) {
                            const u = this._segmentToGroundQuads[a]
                              , l = e[a]
                              , p = this._segmentToRegionTriCounts[a];
                            p.reduce( (x, T) => x + T, 0);
                            let g = 0;
                            for (let x = 0; x <= 4; x++) {
                                const T = p[x];
                                if (0 !== T) {
                                    let f = this.regionSegments[x];
                                    f || (f = this.regionSegments[x] = new mn);
                                    const b = {
                                        vertexOffset: l.vertexOffset,
                                        primitiveOffset: l.primitiveOffset + g,
                                        vertexLength: l.vertexLength,
                                        primitiveLength: T
                                    };
                                    f.get().push(b)
                                }
                                g += T
                            }
                            for (let x = 0; x < u.length; x++) {
                                const T = u[x].id;
                                this.indexArray.emplaceBack(T, T + 1, T + 3),
                                this.indexArray.emplaceBack(T, T + 3, T + 2)
                            }
                        }
                        this._segmentToGroundQuads = null,
                        this._segmentToRegionTriCounts = null,
                        this._segments.destroy(),
                        this._segments = null
                    }
                    addPaintPropertiesData(e, o, a, u, l, p) {
                        this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, e, o, a, u, l, p)
                    }
                    upload(e) {
                        this.hasData() && (this.vertexBuffer = e.createVertexBuffer(this.vertexArray, $0.members),
                        this.indexBuffer = e.createIndexBuffer(this.indexArray))
                    }
                    uploadPaintProperties(e) {
                        this.hasData() && this.programConfigurations.upload(e)
                    }
                    update(e, o, a, u, l, p, g) {
                        this.hasData() && this.programConfigurations.updatePaintArrays(e, o, a, u, l, p, g)
                    }
                    updateHiddenByLandmark(e) {
                        if (!this.hasData())
                            return;
                        const o = e.groundVertexCount + e.groundVertexArrayOffset;
                        if (0 === e.groundVertexCount)
                            return;
                        const a = e.flags & Ol ? 1 : 0;
                        for (let u = e.groundVertexArrayOffset; u < o; ++u)
                            this.hiddenByLandmarkVertexArray.emplace(u, a);
                        this._needsHiddenByLandmarkUpdate = !0
                    }
                    uploadHiddenByLandmark(e) {
                        this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = e.createVertexBuffer(this.hiddenByLandmarkVertexArray, V0.members, !0) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray),
                        this._needsHiddenByLandmarkUpdate = !1)
                    }
                    destroy() {
                        if (this.vertexBuffer) {
                            this.vertexBuffer.destroy(),
                            this.indexBuffer.destroy(),
                            this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(),
                            this._segments && this._segments.destroy(),
                            this.programConfigurations.destroy();
                            for (let e = 0; e <= 4; e++) {
                                const o = this.regionSegments[e];
                                o && o.destroy()
                            }
                        }
                    }
                }
                class Gp {
                    constructor(e) {
                        this.zoom = e.zoom,
                        this.canonical = e.canonical,
                        this.overscaling = e.overscaling,
                        this.layers = e.layers,
                        this.layerIds = this.layers.map(o => o.fqid),
                        this.index = e.index,
                        this.hasPattern = !1,
                        this.edgeRadius = 0,
                        this.projection = e.projection,
                        this.activeReplacements = [],
                        this.replacementUpdateTime = 0,
                        this.centroidData = [],
                        this.footprintIndices = new Xn,
                        this.footprintVertices = new ts,
                        this.footprintSegments = [],
                        this.layoutVertexArray = new ha,
                        this.centroidVertexArray = new Mp,
                        this.wallVertexArray = new Cp,
                        this.indexArray = new Xn,
                        this.programConfigurations = new fa(e.layers,{
                            zoom: e.zoom,
                            lut: e.lut
                        },o => Y0.includes(o)),
                        this.segments = new mn,
                        this.stateDependentLayerIds = this.layers.filter(o => o.isStateDependent()).map(o => o.id),
                        this.groundEffect = new Gf(e),
                        this.maxHeight = 0,
                        this.partLookup = {},
                        this.triangleSubSegments = [],
                        this.polygonSegments = []
                    }
                    updateFootprints(e, o) {}
                    populate(e, o, a, u) {
                        this.features = [],
                        this.hasPattern = $d("fill-extrusion", this.layers, o),
                        this.featuresOnBorder = [],
                        this.borderFeatureIndices = [[], [], [], []],
                        this.borderDoneWithNeighborZ = [-1, -1, -1, -1],
                        this.selfDEMTileTimestamp = Number.MAX_VALUE,
                        this.borderDEMTileTimestamp = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE],
                        this.tileToMeter = i(a),
                        this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter,
                        this.wallMode = 0 !== this.layers[0].paint.get("fill-extrusion-line-width").constantOr(1);
                        for (const {feature: l, id: p, index: g, sourceLayerIndex: x} of e) {
                            const T = this.layers[0]._featureFilter.needGeometry
                              , f = D(l, T);
                            if (!this.layers[0]._featureFilter.filter(new Hi(this.zoom), f, a))
                                continue;
                            const b = {
                                id: p,
                                sourceLayerIndex: x,
                                index: g,
                                geometry: T ? f.geometry : R(l, a, u),
                                properties: l.properties,
                                type: l.type,
                                patterns: {}
                            }
                              , P = this.layoutVertexArray.length
                              , v = "Polygon" === qd[b.type];
                            if (this.hasPattern)
                                this.features.push(Gd("fill-extrusion", this.layers, b, this.zoom, o));
                            else if (this.wallMode)
                                for (const w of b.geometry)
                                    for (const C of kf(w, v))
                                        this.addFeature(b, [C], g, a, {}, o.availableImages, u, o.brightness);
                            else
                                this.addFeature(b, b.geometry, g, a, {}, o.availableImages, u, o.brightness);
                            o.featureIndex.insert(l, b.geometry, g, x, this.index, P)
                        }
                        this.sortBorders(),
                        "mercator" === this.projection.name && this.splitToSubtiles(),
                        this.groundEffect.prepareBorderSegments(),
                        this.polygonSegments.length = 0
                    }
                    addFeatures(e, o, a, u, l, p) {
                        for (const g of this.features) {
                            const x = "Polygon" === qd[g.type]
                              , {geometry: T} = g;
                            if (this.wallMode)
                                for (const f of T)
                                    for (const b of kf(f, x))
                                        this.addFeature(g, [b], g.index, o, a, u, l, p);
                            else
                                this.addFeature(g, T, g.index, o, a, u, l, p)
                        }
                        this.sortBorders(),
                        "mercator" === this.projection.name && this.splitToSubtiles()
                    }
                    update(e, o, a, u, l, p, g) {
                        this.programConfigurations.updatePaintArrays(e, o, l, a, u, p, g),
                        this.groundEffect.update(e, o, l, a, u, p, g)
                    }
                    isEmpty() {
                        return 0 === this.layoutVertexArray.length
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload
                    }
                    upload(e) {
                        this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, W0),
                        this.indexBuffer = e.createIndexBuffer(this.indexArray),
                        this.wallVertexBuffer = e.createVertexBuffer(this.wallVertexArray, j0.members),
                        this.layoutVertexExtArray && (this.layoutVertexExtBuffer = e.createVertexBuffer(this.layoutVertexExtArray, H0.members, !0)),
                        this.groundEffect.upload(e)),
                        this.groundEffect.uploadPaintProperties(e),
                        this.programConfigurations.upload(e),
                        this.uploaded = !0
                    }
                    uploadCentroid(e) {
                        this.groundEffect.uploadHiddenByLandmark(e),
                        this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, G0.members, !0) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray),
                        this.needsCentroidUpdate = !1)
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(),
                        this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(),
                        this.groundEffect.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy())
                    }
                    addFeature(e, o, a, u, l, p, g, x) {
                        const T = this.layers[0].paint.get("fill-extrusion-flood-light-ground-radius").evaluate(e, {}) / this.tileToMeter
                          , f = [new tt(0,0), new tt(uo,uo)]
                          , b = g.projection
                          , P = "globe" === b.name
                          , v = this.wallMode || "Polygon" === qd[e.type]
                          , w = new Nf;
                        w.centroidDataIndex = this.centroidData.length;
                        const C = new Uf
                          , A = this.layers[0].paint.get("fill-extrusion-base").evaluate(e, {}, u) <= 0
                          , O = this.layers[0].paint.get("fill-extrusion-height").evaluate(e, {}, u);
                        let F;
                        if (C.height = O,
                        C.vertexArrayOffset = this.layoutVertexArray.length,
                        C.groundVertexArrayOffset = this.groundEffect.vertexArray.length,
                        P && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new Mh),
                        this.wallMode) {
                            if (P)
                                return void vo("Non zero fill-extrusion-line-width is not yet supported on globe.");
                            if (1 !== o.length)
                                return;
                            F = function(pe) {
                                const Ne = pe[0].x === pe[pe.length - 1].x && pe[0].y === pe[pe.length - 1].y;
                                (function(fo) {
                                    let Bt = 0;
                                    const Ro = fo.length;
                                    for (let ho = 0; ho < Ro; ho++)
                                        Bt += (fo[(ho + 1) % Ro].x - fo[ho].x) * (fo[(ho + 1) % Ro].y + fo[ho].y);
                                    return Bt >= 0
                                }
                                )(pe) || (pe = pe.reverse());
                                const $e = {
                                    geometry: [],
                                    joinNormals: [],
                                    indices: []
                                }
                                  , We = []
                                  , je = []
                                  , Ke = [];
                                let rt = pe.length;
                                for (; rt >= 2 && pe[rt - 1].equals(pe[rt - 2]); )
                                    rt--;
                                if (rt < (Ne ? 3 : 2))
                                    return $e;
                                let at, ot, Ct, Zt, Ot, lo = 0;
                                for (; lo < rt - 1 && pe[lo].equals(pe[lo + 1]); )
                                    lo++;
                                Ne && (at = pe[rt - 2],
                                Ot = pe[lo].sub(at)._unit()._perp());
                                for (let fo = lo; fo < rt; fo++) {
                                    if (Ct = fo === rt - 1 ? Ne ? pe[lo + 1] : void 0 : pe[fo + 1],
                                    Ct && pe[fo].equals(Ct))
                                        continue;
                                    Ot && (Zt = Ot),
                                    at && (ot = at),
                                    at = pe[fo],
                                    Ot = Ct ? Ct.sub(at)._unit()._perp() : Zt,
                                    Zt = Zt || Ot;
                                    let Bt = Zt.add(Ot);
                                    0 === Bt.x && 0 === Bt.y || Bt._unit();
                                    const Ro = Bt.x * Ot.x + Bt.y * Ot.y
                                      , ho = 0 !== Ro ? 1 / Ro : 1 / 0
                                      , Ao = Zt.x * Ot.y - Zt.y * Ot.x > 0;
                                    let $o = "miter";
                                    const Qo = 2;
                                    "miter" === $o && ho > Qo && ($o = "bevel"),
                                    "bevel" === $o && (ho > 100 && ($o = "flipbevel"),
                                    ho < Qo && ($o = "miter"));
                                    const ni = (di, ri, gi, Zi) => {
                                        const $i = new tt(di.x,di.y)
                                          , Ko = new tt(di.x,di.y);
                                        $i.x += ri.x * Zi,
                                        $i.y += ri.y * Zi,
                                        Ko.x -= ri.x * Math.max(gi, 1),
                                        Ko.y -= ri.y * Math.max(gi, 1),
                                        Ke.push(ri),
                                        We.push($i),
                                        je.push(Ko)
                                    }
                                    ;
                                    if ("miter" === $o)
                                        Bt._mult(ho),
                                        ni(at, Bt, 0, 0);
                                    else if ("flipbevel" === $o)
                                        Bt = Ot.mult(-1),
                                        ni(at, Bt, 0, 0),
                                        ni(at, Bt.mult(-1), 0, 0);
                                    else {
                                        const di = -Math.sqrt(ho * ho - 1)
                                          , ri = Ao ? di : 0
                                          , gi = Ao ? 0 : di;
                                        ot && ni(at, Zt, ri, gi),
                                        Ct && ni(at, Ot, ri, gi)
                                    }
                                }
                                $e.geometry = [...We, ...je.reverse(), We[0]],
                                $e.joinNormals = [...Ke, ...Ke.reverse(), Ke[Ke.length - 1]];
                                const io = $e.geometry.length - 1;
                                for (let fo = 0; fo < io / 2; fo++)
                                    if (fo + 1 < io / 2) {
                                        let Bt = fo
                                          , Ro = fo + 1
                                          , ho = io - 1 - fo
                                          , Ao = io - 2 - fo;
                                        Bt = 0 === Bt ? io - 1 : Bt - 1,
                                        Ro = 0 === Ro ? io - 1 : Ro - 1,
                                        ho = 0 === ho ? io - 1 : ho - 1,
                                        Ao = 0 === Ao ? io - 1 : Ao - 1,
                                        $e.indices.push(ho),
                                        $e.indices.push(Ro),
                                        $e.indices.push(Bt),
                                        $e.indices.push(ho),
                                        $e.indices.push(Ao),
                                        $e.indices.push(Ro)
                                    }
                                return $e
                            }(o[0]),
                            o = [F.geometry]
                        }
                        const z = (pe, Ne) => pe < (Ne.length - 1) / 2 || pe === Ne.length - 1
                          , L = this.wallMode ? [o] : kp(o, 500);
                        for (let pe = L.length - 1; pe >= 0; pe--) {
                            const Ne = L[pe];
                            (0 === Ne.length || (N = Ne[0]).every(Pe => Pe.x <= 0) || N.every(Pe => Pe.x >= uo) || N.every(Pe => Pe.y <= 0) || N.every(Pe => Pe.y >= uo)) && L.splice(pe, 1)
                        }
                        var N;
                        let G;
                        if (P)
                            G = Zf(L, f, u);
                        else {
                            G = [];
                            for (const pe of L)
                                G.push({
                                    polygon: pe,
                                    bounds: f
                                })
                        }
                        const X = v ? this.edgeRadius : 0
                          , _e = X > 0 && this.zoom < 17
                          , me = (pe, Ne) => {
                            if (0 === pe.length)
                                return !1;
                            const Pe = pe[pe.length - 1];
                            return Ne.x === Pe.x && Ne.y === Pe.y
                        }
                        ;
                        for (const {polygon: pe, bounds: Ne} of G) {
                            let Pe = 0
                              , $e = 0;
                            for (const rt of pe)
                                v && !rt[0].equals(rt[rt.length - 1]) && rt.push(rt[0]),
                                $e += v ? rt.length - 1 : rt.length;
                            const We = this.segments.prepareSegment((v ? 5 : 4) * $e, this.layoutVertexArray, this.indexArray);
                            C.footprintSegIdx < 0 && (C.footprintSegIdx = this.footprintSegments.length),
                            C.polygonSegIdx < 0 && (C.polygonSegIdx = this.polygonSegments.length);
                            const je = {
                                triangleArrayOffset: this.indexArray.length,
                                triangleCount: 0,
                                triangleSegIdx: this.segments.segments.length - 1
                            }
                              , Ke = new Bf;
                            if (Ke.vertexOffset = this.footprintVertices.length,
                            Ke.indexOffset = 3 * this.footprintIndices.length,
                            Ke.ringIndices = [],
                            v) {
                                const rt = []
                                  , at = [];
                                Pe = We.vertexLength;
                                for (let Ct = 0; Ct < pe.length; Ct++) {
                                    const Zt = pe[Ct];
                                    Zt.length && 0 !== Ct && at.push(rt.length / 2);
                                    const Ot = [];
                                    let lo, io;
                                    lo = Zt[1].sub(Zt[0])._perp()._unit(),
                                    Ke.ringIndices.push(Zt.length - 1);
                                    for (let fo = 1; fo < Zt.length; fo++) {
                                        const Bt = Zt[fo]
                                          , Ro = Zt[fo === Zt.length - 1 ? 1 : fo + 1]
                                          , ho = Bt.clone();
                                        if (X) {
                                            io = Ro.sub(Bt)._perp()._unit();
                                            const Ao = lo.add(io)._unit()
                                              , $o = X * Math.min(4, 1 / (lo.x * Ao.x + lo.y * Ao.y));
                                            ho.x += $o * Ao.x,
                                            ho.y += $o * Ao.y,
                                            ho.x = Math.round(ho.x),
                                            ho.y = Math.round(ho.y),
                                            lo = io
                                        }
                                        if (!A || 0 !== X && !_e || me(Ot, ho) || Ot.push(ho),
                                        Uu(this.layoutVertexArray, ho.x, ho.y, 0, 0, 1, 1, 0),
                                        this.wallMode) {
                                            const Ao = z(fo, Zt);
                                            Nu(this.wallVertexArray, F.joinNormals[fo], !Ao)
                                        }
                                        We.vertexLength++,
                                        this.footprintVertices.emplaceBack(Bt.x, Bt.y),
                                        rt.push(Bt.x, Bt.y),
                                        P && $u(this.layoutVertexExtArray, b.projectTilePoint(ho.x, ho.y, u), b.upVector(u, ho.x, ho.y))
                                    }
                                    A && (0 === X || _e) && (0 !== Ot.length && me(Ot, Ot[0]) && Ot.pop(),
                                    this.groundEffect.addData(Ot, Ne, T))
                                }
                                const ot = this.wallMode ? F.indices : Fu(rt, at);
                                for (let Ct = 0; Ct < ot.length; Ct += 3)
                                    this.footprintIndices.emplaceBack(Ke.vertexOffset + ot[Ct + 0], Ke.vertexOffset + ot[Ct + 1], Ke.vertexOffset + ot[Ct + 2]),
                                    this.indexArray.emplaceBack(Pe + ot[Ct], Pe + ot[Ct + 2], Pe + ot[Ct + 1]),
                                    We.primitiveLength++;
                                Ke.indexCount += ot.length,
                                Ke.vertexCount += this.footprintVertices.length - Ke.vertexOffset
                            }
                            for (let rt = 0; rt < pe.length; rt++) {
                                const at = pe[rt];
                                w.startRing(C, at[0]);
                                let ot = at.length > 4 && Wf(at[at.length - 2], at[0], at[1])
                                  , Ct = X ? e1(at[at.length - 2], at[0], at[1], X) : 0;
                                const Zt = [];
                                let Ot, lo, io;
                                lo = at[1].sub(at[0])._perp()._unit();
                                let fo = !0;
                                for (let Bt = 1, Ro = 0; Bt < at.length; Bt++) {
                                    let ho = at[Bt - 1]
                                      , Ao = at[Bt];
                                    const $o = at[Bt === at.length - 1 ? 1 : Bt + 1];
                                    if (w.appendEdge(C, Ao, ho),
                                    Jd(Ao, ho, Ne)) {
                                        X && (lo = $o.sub(Ao)._perp()._unit(),
                                        fo = !fo);
                                        continue
                                    }
                                    const Qo = Ao.sub(ho)._perp()
                                      , ni = Qo.x / (Math.abs(Qo.x) + Math.abs(Qo.y))
                                      , di = Qo.y > 0 ? 1 : 0
                                      , ri = ho.dist(Ao);
                                    if (Ro + ri > 32768 && (Ro = 0),
                                    X) {
                                        io = $o.sub(Ao)._perp()._unit();
                                        let Ko = Vf(ho, Ao, $o, jf(lo, io), X);
                                        isNaN(Ko) && (Ko = 0);
                                        const Gi = Ao.sub(ho)._unit();
                                        ho = ho.add(Gi.mult(Ct))._round(),
                                        Ao = Ao.add(Gi.mult(-Ko))._round(),
                                        Ct = Ko,
                                        lo = io,
                                        A && this.zoom >= 17 && (me(Zt, ho) || Zt.push(ho),
                                        me(Zt, Ao) || Zt.push(Ao))
                                    }
                                    const gi = We.vertexLength
                                      , Zi = at.length > 4 && Wf(ho, Ao, $o);
                                    let $i = Xf(Ro, ot, fo);
                                    if (Uu(this.layoutVertexArray, ho.x, ho.y, ni, di, 0, 0, $i),
                                    Uu(this.layoutVertexArray, ho.x, ho.y, ni, di, 0, 1, $i),
                                    this.wallMode) {
                                        const Ko = z(Bt - 1, at)
                                          , Gi = F.joinNormals[Bt - 1];
                                        Nu(this.wallVertexArray, Gi, Ko),
                                        Nu(this.wallVertexArray, Gi, Ko)
                                    }
                                    if (Ro += ri,
                                    $i = Xf(Ro, Zi, !fo),
                                    ot = Zi,
                                    Uu(this.layoutVertexArray, Ao.x, Ao.y, ni, di, 0, 0, $i),
                                    Uu(this.layoutVertexArray, Ao.x, Ao.y, ni, di, 0, 1, $i),
                                    this.wallMode) {
                                        const Ko = z(Bt, at)
                                          , Gi = F.joinNormals[Bt];
                                        Nu(this.wallVertexArray, Gi, Ko),
                                        Nu(this.wallVertexArray, Gi, Ko)
                                    }
                                    if (We.vertexLength += 4,
                                    this.indexArray.emplaceBack(gi + 0, gi + 1, gi + 2),
                                    this.indexArray.emplaceBack(gi + 1, gi + 3, gi + 2),
                                    We.primitiveLength += 2,
                                    X) {
                                        const Ko = Pe + (1 === Bt ? at.length - 2 : Bt - 2)
                                          , Gi = 1 === Bt ? Pe : Ko + 1;
                                        if (this.indexArray.emplaceBack(gi + 1, Ko, gi + 3),
                                        this.indexArray.emplaceBack(Ko, Gi, gi + 3),
                                        We.primitiveLength += 2,
                                        void 0 === Ot && (Ot = gi),
                                        !Jd($o, at[Bt], Ne)) {
                                            const ki = Bt === at.length - 1 ? Ot : We.vertexLength;
                                            this.indexArray.emplaceBack(gi + 2, gi + 3, ki),
                                            this.indexArray.emplaceBack(gi + 3, ki + 1, ki),
                                            this.indexArray.emplaceBack(gi + 3, Gi, ki + 1),
                                            We.primitiveLength += 3
                                        }
                                        fo = !fo
                                    }
                                    if (P) {
                                        const Ko = this.layoutVertexExtArray
                                          , Gi = b.projectTilePoint(ho.x, ho.y, u)
                                          , ki = b.projectTilePoint(Ao.x, Ao.y, u)
                                          , Ki = b.upVector(u, ho.x, ho.y)
                                          , Tn = b.upVector(u, Ao.x, Ao.y);
                                        $u(Ko, Gi, Ki),
                                        $u(Ko, Gi, Ki),
                                        $u(Ko, ki, Tn),
                                        $u(Ko, ki, Tn)
                                    }
                                }
                                v && (Pe += at.length - 1),
                                A && X && this.zoom >= 17 && (0 !== Zt.length && me(Zt, Zt[0]) && Zt.pop(),
                                this.groundEffect.addData(Zt, Ne, T, X > 0))
                            }
                            this.footprintSegments.push(Ke),
                            je.triangleCount = this.indexArray.length - je.triangleArrayOffset,
                            this.polygonSegments.push(je),
                            ++C.footprintSegLen,
                            ++C.polygonSegLen
                        }
                        if (C.vertexCount = this.layoutVertexArray.length - C.vertexArrayOffset,
                        C.groundVertexCount = this.groundEffect.vertexArray.length - C.groundVertexArrayOffset,
                        0 !== C.vertexCount) {
                            if (C.centroidXY = w.borders ? zf : this.encodeCentroid(w, C),
                            this.centroidData.push(C),
                            w.borders) {
                                this.featuresOnBorder.push(w);
                                const pe = this.featuresOnBorder.length - 1;
                                for (let Ne = 0; Ne < w.borders.length; Ne++)
                                    w.borders[Ne][0] !== Number.MAX_VALUE && this.borderFeatureIndices[Ne].push(pe)
                            }
                            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, a, l, p, u, x),
                            this.groundEffect.addPaintPropertiesData(e, a, l, p, u, x),
                            this.maxHeight = Math.max(this.maxHeight, O)
                        }
                    }
                    sortBorders() {
                        for (let e = 0; e < this.borderFeatureIndices.length; e++)
                            this.borderFeatureIndices[e].sort( (o, a) => this.featuresOnBorder[o].borders[e][0] - this.featuresOnBorder[a].borders[e][0])
                    }
                    splitToSubtiles() {
                        const e = [];
                        for (let g = 0; g < this.centroidData.length; g++) {
                            const x = this.centroidData[g]
                              , T = +(x.min.y + x.max.y > uo)
                              , f = 2 * T + (+(x.min.x + x.max.x > uo) ^ T);
                            for (let b = 0; b < x.polygonSegLen; b++) {
                                const P = x.polygonSegIdx + b;
                                e.push({
                                    centroidIdx: g,
                                    subtile: f,
                                    polygonSegmentIdx: P,
                                    triangleSegmentIdx: this.polygonSegments[P].triangleSegIdx
                                })
                            }
                        }
                        const o = new Xn;
                        e.sort( (g, x) => g.triangleSegmentIdx === x.triangleSegmentIdx ? g.subtile - x.subtile : g.triangleSegmentIdx - x.triangleSegmentIdx);
                        let a = 0
                          , u = 0
                          , l = 0;
                        for (const g of e) {
                            if (g.triangleSegmentIdx !== a)
                                break;
                            l++
                        }
                        const p = e.length;
                        for (; u !== e.length; ) {
                            a = e[u].triangleSegmentIdx;
                            let g = 0
                              , x = u
                              , T = u;
                            for (let f = x; f < l && e[f].subtile === g; f++)
                                T++;
                            for (; x !== l; ) {
                                const f = e[x];
                                g = f.subtile;
                                const b = this.centroidData[f.centroidIdx].min.clone()
                                  , P = this.centroidData[f.centroidIdx].max.clone()
                                  , v = {
                                    vertexOffset: this.segments.segments[a].vertexOffset,
                                    primitiveOffset: o.length,
                                    vertexLength: this.segments.segments[a].vertexLength,
                                    primitiveLength: 0,
                                    sortKey: void 0,
                                    vaos: {}
                                };
                                for (let w = x; w < T; w++) {
                                    const C = e[w]
                                      , A = this.polygonSegments[C.polygonSegmentIdx]
                                      , O = this.centroidData[C.centroidIdx].min
                                      , F = this.centroidData[C.centroidIdx].max
                                      , z = this.indexArray.uint16;
                                    for (let L = A.triangleArrayOffset; L < A.triangleArrayOffset + A.triangleCount; L++)
                                        o.emplaceBack(z[3 * L], z[3 * L + 1], z[3 * L + 2]);
                                    v.primitiveLength += A.triangleCount,
                                    b.x = Math.min(b.x, O.x),
                                    b.y = Math.min(b.y, O.y),
                                    P.x = Math.max(P.x, F.x),
                                    P.y = Math.max(P.y, F.y)
                                }
                                v.primitiveLength > 0 && this.triangleSubSegments.push({
                                    segment: v,
                                    min: b,
                                    max: P
                                }),
                                x = T;
                                for (let w = x; w < l && e[w].subtile === e[x].subtile; w++)
                                    T++
                            }
                            u = l;
                            for (let f = u; f < p && e[f].triangleSegmentIdx === e[u].triangleSegmentIdx; f++)
                                l++
                        }
                        o._trim(),
                        this.indexArray = o
                    }
                    getVisibleSegments(e, o, a) {
                        const u = new mn;
                        if (this.wallMode) {
                            for (const C of this.triangleSubSegments)
                                u.segments.push(C.segment);
                            return u
                        }
                        let l = 0
                          , p = 0;
                        const g = 1 << e.canonical.z;
                        if (o) {
                            const C = o.getMinMaxForTile(e);
                            C && (l = C.min,
                            p = C.max)
                        }
                        p += this.maxHeight;
                        const x = e.toUnwrapped();
                        let T;
                        const f = [x.canonical.x / g + x.wrap, x.canonical.y / g]
                          , b = [(x.canonical.x + 1) / g + x.wrap, (x.canonical.y + 1) / g]
                          , P = (C, A, O) => [C[0] * (1 - O[0]) + A[0] * O[0], C[1] * (1 - O[1]) + A[1] * O[1]]
                          , v = []
                          , w = [];
                        for (const C of this.triangleSubSegments) {
                            v[0] = C.min.x / uo,
                            v[1] = C.min.y / uo,
                            w[0] = C.max.x / uo,
                            w[1] = C.max.y / uo;
                            const A = P(f, b, v)
                              , O = P(f, b, w);
                            if (0 === new No([A[0], A[1], l],[O[0], O[1], p]).intersectsPrecise(a)) {
                                T && (u.segments.push(T),
                                T = void 0);
                                continue
                            }
                            const F = C.segment;
                            T && T.vertexOffset !== F.vertexOffset && (u.segments.push(T),
                            T = void 0),
                            T ? (T.vertexLength += F.vertexLength,
                            T.primitiveLength += F.primitiveLength) : T = {
                                vertexOffset: F.vertexOffset,
                                primitiveLength: F.primitiveLength,
                                vertexLength: F.vertexLength,
                                primitiveOffset: F.primitiveOffset,
                                sortKey: void 0,
                                vaos: {}
                            }
                        }
                        return T && u.segments.push(T),
                        u
                    }
                    encodeCentroid(e, o) {
                        const a = e.centroid()
                          , u = o.span()
                          , l = Math.min(7, Math.round(u.x * this.tileToMeter / 10))
                          , p = Math.min(7, Math.round(u.y * this.tileToMeter / 10));
                        return new tt(ie(a.x, 1, 8191) << 3 | l,ie(a.y, 1, 8191) << 3 | p)
                    }
                    encodeBorderCentroid(e) {
                        if (!e.borders)
                            return new tt(0,0);
                        const o = e.borders
                          , a = Number.MAX_VALUE;
                        if (o[0][0] !== a || o[1][0] !== a) {
                            const u = o[0][0] !== a ? 0 : 1;
                            return new tt(6 | (o[0][0] !== a ? 0 : 65528),(o[u][0] + o[u][1]) / 2 << 3 | 6)
                        }
                        {
                            const u = o[2][0] !== a ? 2 : 3;
                            return new tt((o[u][0] + o[u][1]) / 2 << 3 | 6,6 | (o[2][0] !== a ? 0 : 65528))
                        }
                    }
                    showCentroid(e) {
                        const o = this.centroidData[e.centroidDataIndex];
                        o.flags &= Ol,
                        o.centroidXY.x = 0,
                        o.centroidXY.y = 0,
                        this.writeCentroidToBuffer(o)
                    }
                    writeCentroidToBuffer(e) {
                        this.groundEffect.updateHiddenByLandmark(e);
                        const o = e.vertexArrayOffset
                          , a = e.vertexCount + e.vertexArrayOffset
                          , u = e.flags & Ol ? zf : e.centroidXY
                          , l = this.centroidVertexArray.geta_centroid_pos0(o);
                        if (this.centroidVertexArray.geta_centroid_pos1(o) !== u.y || l !== u.x) {
                            for (let p = o; p < a; ++p)
                                this.centroidVertexArray.emplace(p, u.x, u.y);
                            this.needsCentroidUpdate = !0
                        }
                    }
                    createCentroidsBuffer() {
                        this.centroidVertexArray.resize(this.layoutVertexArray.length),
                        this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
                        for (const e of this.centroidData)
                            this.writeCentroidToBuffer(e)
                    }
                    updateReplacement(e, o, a) {
                        if (o.updateTime === this.replacementUpdateTime)
                            return;
                        this.replacementUpdateTime = o.updateTime;
                        const u = o.getReplacementRegionsForTile(e.toUnwrapped());
                        if (Zd(this.activeReplacements, u))
                            return;
                        if (this.activeReplacements = u,
                        0 === this.centroidVertexArray.length)
                            this.createCentroidsBuffer();
                        else
                            for (const p of this.centroidData)
                                p.flags &= 2147483647;
                        const l = [];
                        for (const p of this.activeReplacements) {
                            if (p.order < a)
                                continue;
                            const g = Math.max(1, Math.pow(2, p.footprintTileId.canonical.z - e.canonical.z));
                            for (const x of this.centroidData)
                                if (!(x.flags & Ol || p.min.x > x.max.x || x.min.x > p.max.x || p.min.y > x.max.y || x.min.y > p.max.y))
                                    for (let T = 0; T < x.footprintSegLen; T++) {
                                        const f = this.footprintSegments[x.footprintSegIdx + T];
                                        if (l.length = 0,
                                        t1(this.footprintVertices, f.vertexOffset, f.vertexCount, p.footprintTileId.canonical, e.canonical, l),
                                        Rf(p.footprint, l, this.footprintIndices.uint16, f.indexOffset, f.indexCount, -f.vertexOffset, -g)) {
                                            x.flags |= Ol;
                                            break
                                        }
                                    }
                        }
                        for (const p of this.centroidData)
                            this.writeCentroidToBuffer(p);
                        this.borderDoneWithNeighborZ = [-1, -1, -1, -1]
                    }
                    footprintContainsPoint(e, o, a) {
                        let u = !1;
                        for (let l = 0; l < a.footprintSegLen; l++) {
                            const p = this.footprintSegments[a.footprintSegIdx + l];
                            let g = 0;
                            for (const x of p.ringIndices) {
                                for (let T = g, f = x + g - 1; T < x + g; f = T++) {
                                    const b = this.footprintVertices.int16[2 * (T + p.vertexOffset) + 0]
                                      , P = this.footprintVertices.int16[2 * (T + p.vertexOffset) + 1]
                                      , v = this.footprintVertices.int16[2 * (f + p.vertexOffset) + 1];
                                    P > o != v > o && e < (this.footprintVertices.int16[2 * (f + p.vertexOffset) + 0] - b) * (o - P) / (v - P) + b && (u = !u)
                                }
                                g = x
                            }
                        }
                        return u
                    }
                    getHeightAtTileCoord(e, o) {
                        let a = Number.NEGATIVE_INFINITY
                          , u = !0;
                        const l = 4 * (e + uo) * uo + (o + uo);
                        if (this.partLookup.hasOwnProperty(l)) {
                            const p = this.partLookup[l];
                            return p ? {
                                height: p.height,
                                hidden: !!(p.flags & Ol)
                            } : void 0
                        }
                        for (const p of this.centroidData)
                            e > p.max.x || p.min.x > e || o > p.max.y || p.min.y > o || this.footprintContainsPoint(e, o, p) && p && p.height > a && (a = p.height,
                            this.partLookup[l] = p,
                            u = !!(p.flags & Ol));
                        if (a !== Number.NEGATIVE_INFINITY)
                            return {
                                height: a,
                                hidden: u
                            };
                        this.partLookup[l] = void 0
                    }
                }
                function jf(n, e) {
                    const o = n.add(e)._unit();
                    return n.x * o.x + n.y * o.y
                }
                function e1(n, e, o, a) {
                    const u = e.sub(n)._perp()._unit()
                      , l = o.sub(e)._perp()._unit();
                    return Vf(n, e, o, jf(u, l), a)
                }
                function Vf(n, e, o, a, u) {
                    const l = Math.sqrt(1 - a * a);
                    return Math.min(n.dist(e) / 3, e.dist(o) / 3, u * l / a)
                }
                function Jd(n, e, o) {
                    return n.x < o[0].x && e.x < o[0].x || n.x > o[1].x && e.x > o[1].x || n.y < o[0].y && e.y < o[0].y || n.y > o[1].y && e.y > o[1].y
                }
                function Hf(n, e) {
                    return n.x < e[0].x || n.x > e[1].x || n.y < e[0].y || n.y > e[1].y
                }
                function Wf(n, e, o) {
                    if (n.x < 0 || n.x >= uo || e.x < 0 || e.x >= uo || o.x < 0 || o.x >= uo)
                        return !1;
                    const a = o.sub(e)
                      , u = a.perp()
                      , l = n.sub(e);
                    return (a.x * l.x + a.y * l.y) / Math.sqrt((a.x * a.x + a.y * a.y) * (l.x * l.x + l.y * l.y)) > -.866 && u.x * l.x + u.y * l.y < 0
                }
                function Xf(n, e, o) {
                    const a = e ? 2 | n : -3 & n;
                    return o ? 1 | a : -2 & a
                }
                function Yf() {
                    const n = Math.PI / 32
                      , e = Math.tan(n)
                      , o = Il;
                    return o * Math.sqrt(1 + 2 * e * e) - o
                }
                function Zf(n, e, o) {
                    const a = 1 << o.z
                      , u = Mr(o.x / a)
                      , l = Mr((o.x + 1) / a)
                      , p = Gn(o.y / a)
                      , g = Gn((o.y + 1) / a);
                    return function(x, T, f, b, P=0, v) {
                        const w = [];
                        if (!x.length || !f || !b)
                            return w;
                        const C = (G, X) => {
                            for (const _e of G)
                                w.push({
                                    polygon: _e,
                                    bounds: X
                                })
                        }
                          , A = Math.ceil(Math.log2(f))
                          , O = Math.ceil(Math.log2(b))
                          , F = A - O
                          , z = [];
                        for (let G = 0; G < Math.abs(F); G++)
                            z.push(F > 0 ? 0 : 1);
                        for (let G = 0; G < Math.min(A, O); G++)
                            z.push(0),
                            z.push(1);
                        let L = x;
                        if (L = Bp(L, T[0].y - P, T[1].y + P, 1),
                        L = Bp(L, T[0].x - P, T[1].x + P, 0),
                        !L.length)
                            return w;
                        const N = [];
                        for (z.length ? N.push({
                            polygons: L,
                            bounds: T,
                            depth: 0
                        }) : C(L, T); N.length; ) {
                            const G = N.pop()
                              , X = G.depth
                              , _e = z[X]
                              , me = G.bounds[0]
                              , pe = G.bounds[1]
                              , Ne = 0 === _e ? me.x : me.y
                              , Pe = 0 === _e ? pe.x : pe.y
                              , $e = v ? v(_e, Ne, Pe) : .5 * (Ne + Pe)
                              , We = Bp(G.polygons, Ne - P, $e + P, _e)
                              , je = Bp(G.polygons, $e - P, Pe + P, _e);
                            if (We.length) {
                                const Ke = [me, new tt(0 === _e ? $e : pe.x,1 === _e ? $e : pe.y)];
                                z.length > X + 1 ? N.push({
                                    polygons: We,
                                    bounds: Ke,
                                    depth: X + 1
                                }) : C(We, Ke)
                            }
                            if (je.length) {
                                const Ke = [new tt(0 === _e ? $e : me.x,1 === _e ? $e : me.y), pe];
                                z.length > X + 1 ? N.push({
                                    polygons: je,
                                    bounds: Ke,
                                    depth: X + 1
                                }) : C(je, Ke)
                            }
                        }
                        return w
                    }(n, e, Math.ceil((l - u) / 11.25), Math.ceil((p - g) / 11.25), 1, (x, T, f) => {
                        if (0 === x)
                            return .5 * (T + f);
                        {
                            const b = Gn((o.y + T / uo) / a);
                            return (ks(.5 * (Gn((o.y + f / uo) / a) + b)) * a - o.y) * uo
                        }
                    }
                    )
                }
                function t1(n, e, o, a, u, l) {
                    const p = Math.pow(2, a.z - u.z);
                    for (let g = 0; g < o; g++) {
                        let x = n.int16[2 * (g + e) + 0]
                          , T = n.int16[2 * (g + e) + 1];
                        x = (x + u.x * uo) * p - a.x * uo,
                        T = (T + u.y * uo) * p - a.y * uo,
                        l.push(new tt(x,T))
                    }
                }
                let Kf, qf;
                function Gu(n, e) {
                    return n.x * e.x + n.y * e.y
                }
                function Jf(n, e) {
                    if (1 === n.length) {
                        let o = 0;
                        const a = e[o++];
                        let u;
                        for (; !u || a.equals(u); )
                            if (u = e[o++],
                            !u)
                                return 1 / 0;
                        for (; o < e.length; o++) {
                            const l = e[o]
                              , p = n[0]
                              , g = u.sub(a)
                              , x = l.sub(a)
                              , T = p.sub(a)
                              , f = Gu(g, g)
                              , b = Gu(g, x)
                              , P = Gu(x, x)
                              , v = Gu(T, g)
                              , w = Gu(T, x)
                              , C = f * P - b * b
                              , A = (P * v - b * w) / C
                              , O = (f * w - b * v) / C
                              , F = a.z * (1 - A - O) + u.z * A + l.z * O;
                            if (isFinite(F))
                                return F
                        }
                        return 1 / 0
                    }
                    {
                        let o = 1 / 0;
                        for (const a of e)
                            o = Math.min(o, a.z);
                        return o
                    }
                }
                function Qf(n, e, o, a, u, l, p, g) {
                    const x = p * u.getElevationAt(n, e, !0, !0)
                      , T = 0 !== l[0]
                      , f = T ? 0 === l[1] ? p * (l[0] / 7 - 450) : p * function(b, P, v) {
                        const w = Math.floor(P[0] / 8)
                          , C = Math.floor(P[1] / 8)
                          , A = 10 * (P[0] - 8 * w)
                          , O = 10 * (P[1] - 8 * C)
                          , F = b.getElevationAt(w, C, !0, !0)
                          , z = b.getMeterToDEM(v)
                          , L = Math.floor(.5 * (A * z - 1))
                          , N = Math.floor(.5 * (O * z - 1))
                          , G = b.tileCoordToPixel(w, C)
                          , X = 2 * L + 1
                          , _e = 2 * N + 1
                          , me = (at = X,
                        ot = _e,
                        [(je = b).getElevationAtPixel(Ke = G.x - L, rt = G.y - N, !0), je.getElevationAtPixel(Ke + ot, rt, !0), je.getElevationAtPixel(Ke, rt + ot, !0), je.getElevationAtPixel(Ke + at, rt + ot, !0)])
                          , pe = Math.abs(me[0] - me[1])
                          , Ne = Math.abs(me[2] - me[3])
                          , Pe = Math.abs(me[0] - me[2]) + Math.abs(me[1] - me[3])
                          , $e = Math.min(.25, .5 * z * (pe + Ne) / X)
                          , We = Math.min(.25, .5 * z * Pe / _e);
                        var je, Ke, rt, at, ot;
                        return F + Math.max($e * A, We * O)
                    }(u, l, g) : x;
                    return {
                        base: x + (0 === o ? -1 : o),
                        top: T ? Math.max(f + a, x + o + 2) : x + a
                    }
                }
                Fe(Gp, "FillExtrusionBucket", {
                    omit: ["layers", "features"]
                }),
                Fe(Uf, "PartData"),
                Fe(Bf, "FootprintSegment"),
                Fe(Nf, "BorderCentroidData"),
                Fe(Gf, "GroundEffect");
                const o1 = Si([{
                    name: "a_pos_normal",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_data",
                    components: 4,
                    type: "Uint8"
                }, {
                    name: "a_linesofar",
                    components: 1,
                    type: "Float32"
                }], 4)
                  , i1 = Si([{
                    name: "a_z_offset_width",
                    components: 2,
                    type: "Float32"
                }], 4)
                  , {members: n1} = o1
                  , r1 = Si([{
                    name: "a_packed",
                    components: 4,
                    type: "Float32"
                }])
                  , {members: s1} = r1
                  , a1 = Si([{
                    name: "a_pattern_data",
                    components: 3,
                    type: "Float32"
                }])
                  , {members: l1} = a1;
                class e_ {
                    constructor(e, o) {
                        this.width = e,
                        this.height = o,
                        this.nextRow = 0,
                        this.image = new Al({
                            width: e,
                            height: o
                        }),
                        this.positions = {},
                        this.uploaded = !1
                    }
                    getDash(e, o) {
                        const a = this.getKey(e, o);
                        return this.positions[a]
                    }
                    trim() {
                        const e = this.width
                          , o = this.height = fe(this.nextRow);
                        this.image.resize({
                            width: e,
                            height: o
                        })
                    }
                    getKey(e, o) {
                        return e.join(",") + o
                    }
                    getDashRanges(e, o, a) {
                        const u = [];
                        let l = e.length % 2 == 1 ? -e[e.length - 1] * a : 0
                          , p = e[0] * a
                          , g = !0;
                        u.push({
                            left: l,
                            right: p,
                            isDash: g,
                            zeroLength: 0 === e[0]
                        });
                        let x = e[0];
                        for (let T = 1; T < e.length; T++) {
                            g = !g;
                            const f = e[T];
                            l = x * a,
                            x += f,
                            p = x * a,
                            u.push({
                                left: l,
                                right: p,
                                isDash: g,
                                zeroLength: 0 === f
                            })
                        }
                        return u
                    }
                    addRoundDash(e, o, a) {
                        const u = o / 2;
                        for (let l = -a; l <= a; l++) {
                            const p = this.width * (this.nextRow + a + l);
                            let g = 0
                              , x = e[g];
                            for (let T = 0; T < this.width; T++) {
                                T / x.right > 1 && (x = e[++g]);
                                const f = Math.abs(T - x.left)
                                  , b = Math.abs(T - x.right)
                                  , P = Math.min(f, b);
                                let v;
                                const w = l / a * (u + 1);
                                if (x.isDash) {
                                    const C = u - Math.abs(w);
                                    v = Math.sqrt(P * P + C * C)
                                } else
                                    v = u - Math.sqrt(P * P + w * w);
                                this.image.data[p + T] = Math.max(0, Math.min(255, v + 128))
                            }
                        }
                    }
                    addRegularDash(e, o) {
                        for (let x = e.length - 1; x >= 0; --x) {
                            const T = e[x]
                              , f = e[x + 1];
                            T.zeroLength ? e.splice(x, 1) : f && f.isDash === T.isDash && (f.left = T.left,
                            e.splice(x, 1))
                        }
                        const a = e[0]
                          , u = e[e.length - 1];
                        a.isDash === u.isDash && (a.left = u.left - this.width,
                        u.right = a.right + this.width);
                        const l = this.width * this.nextRow;
                        let p = 0
                          , g = e[p];
                        for (let x = 0; x < this.width; x++) {
                            x / g.right > 1 && (g = e[++p]);
                            const T = Math.abs(x - g.left)
                              , f = Math.abs(x - g.right)
                              , b = Math.min(T, f);
                            this.image.data[l + x] = Math.max(0, Math.min(255, (g.isDash ? b : -b) + o + 128))
                        }
                    }
                    addDash(e, o) {
                        const a = this.getKey(e, o);
                        if (this.positions[a])
                            return this.positions[a];
                        const u = "round" === o
                          , l = u ? 7 : 0
                          , p = 2 * l + 1;
                        if (this.nextRow + p > this.height)
                            return vo("LineAtlas out of space"),
                            null;
                        0 === e.length && e.push(1);
                        let g = 0;
                        for (let f = 0; f < e.length; f++)
                            e[f] < 0 && (vo("Negative value is found in line dasharray, replacing values with 0"),
                            e[f] = 0),
                            g += e[f];
                        if (0 !== g) {
                            const f = this.width / g
                              , b = this.getDashRanges(e, this.width, f);
                            u ? this.addRoundDash(b, f, l) : this.addRegularDash(b, "square" === o ? .5 * f : 0)
                        }
                        const x = this.nextRow + l;
                        this.nextRow += p;
                        const T = {
                            tl: [x, l],
                            br: [g, 0]
                        };
                        return this.positions[a] = T,
                        T
                    }
                }
                Fe(e_, "LineAtlas");
                const c1 = Nh.VectorTileFeature.types
                  , h1 = Math.cos(Math.PI / 180 * 37.5)
                  , u1 = Math.cos(Math.PI / 180 * 5);
                class Qd {
                    constructor(e) {
                        this.evaluationGlobals = {
                            zoom: 0,
                            lineProgress: void 0
                        },
                        this.zoom = e.zoom,
                        this.evaluationGlobals.zoom = this.zoom,
                        this.overscaling = e.overscaling,
                        this.layers = e.layers,
                        this.layerIds = this.layers.map(o => o.fqid),
                        this.index = e.index,
                        this.projection = e.projection,
                        this.hasPattern = !1,
                        this.hasZOffset = !1,
                        this.hasCrossSlope = !1,
                        this.patternFeatures = [],
                        this.lineClipsArray = [],
                        this.gradients = {},
                        this.layers.forEach(o => {
                            this.gradients[o.id] = {}
                        }
                        ),
                        this.layoutVertexArray = new $r,
                        this.layoutVertexArray2 = new ua,
                        this.patternVertexArray = new Ds,
                        this.indexArray = new Xn,
                        this.programConfigurations = new fa(e.layers,{
                            zoom: e.zoom,
                            lut: e.lut
                        }),
                        this.segments = new mn,
                        this.maxLineLength = 0,
                        this.zOffsetVertexArray = new za,
                        this.stateDependentLayerIds = this.layers.filter(o => o.isStateDependent()).map(o => o.id),
                        this.tessellationStep = e.tessellationStep ? e.tessellationStep : 128
                    }
                    updateFootprints(e, o) {}
                    populate(e, o, a, u) {
                        this.hasPattern = $d("line", this.layers, o);
                        const l = this.layers[0].layout.get("line-sort-key");
                        this.tileToMeter = i(a),
                        this.hasZOffset = !this.layers[0].isDraped();
                        const p = this.layers[0].layout.get("line-elevation-reference");
                        this.hasZOffset && "none" === p && vo("line-elevation-reference: ground is used for the layer ".concat(this.layerIds[0], " because non-zero line-z-offset value was found."));
                        const g = this.layers[0].layout.get("line-cross-slope");
                        this.hasCrossSlope = this.hasZOffset && void 0 !== g;
                        const x = [];
                        for (const {feature: P, id: v, index: w, sourceLayerIndex: C} of e) {
                            const A = this.layers[0]._featureFilter.needGeometry
                              , O = D(P, A);
                            if (!this.layers[0]._featureFilter.filter(new Hi(this.zoom), O, a))
                                continue;
                            const F = l ? l.evaluate(O, {}, a) : void 0
                              , z = {
                                id: v,
                                properties: P.properties,
                                type: P.type,
                                sourceLayerIndex: C,
                                index: w,
                                geometry: A ? O.geometry : R(P, a, u),
                                patterns: {},
                                sortKey: F
                            };
                            x.push(z)
                        }
                        l && x.sort( (P, v) => P.sortKey - v.sortKey);
                        const {lineAtlas: T, featureIndex: f} = o
                          , b = this.addConstantDashes(T);
                        for (const P of x) {
                            const {geometry: v, index: w, sourceLayerIndex: C} = P;
                            if (b && this.addFeatureDashes(P, T),
                            this.hasPattern) {
                                const A = Gd("line", this.layers, P, this.zoom, o);
                                this.patternFeatures.push(A)
                            } else
                                this.addFeature(P, v, w, a, T.positions, o.availableImages, o.brightness);
                            f.insert(e[w].feature, v, w, C, this.index)
                        }
                    }
                    addConstantDashes(e) {
                        let o = !1;
                        for (const a of this.layers) {
                            const u = a.paint.get("line-dasharray").value
                              , l = a.layout.get("line-cap").value;
                            if ("constant" !== u.kind || "constant" !== l.kind)
                                o = !0;
                            else {
                                const p = l.value
                                  , g = u.value;
                                if (!g)
                                    continue;
                                e.addDash(g, p)
                            }
                        }
                        return o
                    }
                    addFeatureDashes(e, o) {
                        const a = this.zoom;
                        for (const u of this.layers) {
                            const l = u.paint.get("line-dasharray").value
                              , p = u.layout.get("line-cap").value;
                            if ("constant" === l.kind && "constant" === p.kind)
                                continue;
                            let g, x;
                            if ("constant" === l.kind) {
                                if (g = l.value,
                                !g)
                                    continue
                            } else
                                g = l.evaluate({
                                    zoom: a
                                }, e);
                            x = "constant" === p.kind ? p.value : p.evaluate({
                                zoom: a
                            }, e),
                            o.addDash(g, x),
                            e.patterns[u.id] = o.getKey(g, x)
                        }
                    }
                    update(e, o, a, u, l, p, g) {
                        this.programConfigurations.updatePaintArrays(e, o, l, a, u, p, g)
                    }
                    addFeatures(e, o, a, u, l, p) {
                        for (const g of this.patternFeatures)
                            this.addFeature(g, g.geometry, g.index, o, a, u, p)
                    }
                    isEmpty() {
                        return 0 === this.layoutVertexArray.length
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(e) {
                        this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, s1)),
                        0 !== this.patternVertexArray.length && (this.patternVertexBuffer = e.createVertexBuffer(this.patternVertexArray, l1)),
                        !this.zOffsetVertexBuffer && this.zOffsetVertexArray.length > 0 && (this.zOffsetVertexBuffer = e.createVertexBuffer(this.zOffsetVertexArray, i1.members, !0)),
                        this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, n1),
                        this.indexBuffer = e.createIndexBuffer(this.indexArray)),
                        this.programConfigurations.upload(e),
                        this.uploaded = !0
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(),
                        this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy())
                    }
                    lineFeatureClips(e) {
                        if (e.properties && e.properties.hasOwnProperty("mapbox_clip_start") && e.properties.hasOwnProperty("mapbox_clip_end"))
                            return {
                                start: +e.properties.mapbox_clip_start,
                                end: +e.properties.mapbox_clip_end
                            }
                    }
                    addFeature(e, o, a, u, l, p, g) {
                        const x = this.layers[0].layout
                          , T = x.get("line-join").evaluate(e, {})
                          , f = x.get("line-cap").evaluate(e, {})
                          , b = x.get("line-miter-limit")
                          , P = x.get("line-round-limit");
                        this.lineClips = this.lineFeatureClips(e),
                        this.lineFeature = e,
                        this.zOffsetValue = x.get("line-z-offset").value;
                        const v = this.layers[0].paint.get("line-width").value;
                        "constant" !== v.kind && !1 === v.isLineProgressConstant && (this.variableWidthValue = v);
                        for (const w of o)
                            this.addLine(w, e, u, T, f, b, P);
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, a, l, p, u, g)
                    }
                    addLine(e, o, a, u, l, p, g) {
                        this.distance = 0,
                        this.prevDistance = 0,
                        this.scaledDistance = 0,
                        this.totalDistance = 0,
                        this.totalFeatureLength = 0,
                        this.lineSoFar = 0,
                        this.currentVertex = void 0;
                        const x = "none" === u;
                        if (this.patternJoinNone = this.hasPattern && x,
                        this.segmentStart = 0,
                        this.segmentStartf32 = 0,
                        this.segmentPoints = [],
                        this.lineClips) {
                            this.lineClipsArray.push(this.lineClips);
                            for (let z = 0; z < e.length - 1; z++)
                                this.totalDistance += e[z].dist(e[z + 1]);
                            this.totalFeatureLength = this.totalDistance / (this.lineClips.end - this.lineClips.start),
                            this.updateScaledDistance(),
                            this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance)
                        }
                        const T = "Polygon" === c1[o.type];
                        let f = e.length;
                        for (; f >= 2 && e[f - 1].equals(e[f - 2]); )
                            f--;
                        let b = 0;
                        for (; b < f - 1 && e[b].equals(e[b + 1]); )
                            b++;
                        if (f < (T ? 3 : 2))
                            return;
                        "bevel" === u && (p = 1.05);
                        const P = this.segments.prepareSegment(10 * f, this.layoutVertexArray, this.indexArray);
                        let v, w, C, A, O, F;
                        this.e1 = this.e2 = -1,
                        T && (v = e[f - 2],
                        O = e[b].sub(v)._unit()._perp());
                        for (let z = b; z < f; z++) {
                            if (C = z === f - 1 ? T ? e[b + 1] : void 0 : e[z + 1],
                            C && e[z].equals(C))
                                continue;
                            O && (A = O),
                            v && (w = v),
                            v = e[z],
                            F = this.evaluateLineProgressFeatures(w ? w.dist(v) : 0),
                            O = C ? C.sub(v)._unit()._perp() : A,
                            A = A || O;
                            const L = w && C;
                            let N = L ? u : T || x ? "butt" : l;
                            const G = A.x * O.x + A.y * O.y;
                            if (x) {
                                const We = function(je) {
                                    if (je.patternJoinNone) {
                                        const Ke = je.segmentPoints.length / 2
                                          , rt = je.lineSoFar - je.segmentStart;
                                        for (let at = 0; at < Ke; ++at) {
                                            const ot = je.segmentPoints[2 * at + 1]
                                              , Ct = Math.round(je.segmentPoints[2 * at]) + .5 + .25 * ot;
                                            je.patternVertexArray.emplaceBack(Ct, rt, je.segmentStart),
                                            je.patternVertexArray.emplaceBack(Ct, rt, je.segmentStart)
                                        }
                                        je.segmentPoints.length = 0
                                    }
                                    je.e1 = je.e2 = -1
                                };
                                if (L && G < u1) {
                                    this.updateDistance(w, v),
                                    this.addCurrentVertex(v, A, 1, 1, P, F),
                                    We(this),
                                    this.addCurrentVertex(v, O, -1, -1, P, F);
                                    continue
                                }
                                if (w) {
                                    if (!C) {
                                        this.updateDistance(w, v),
                                        this.addCurrentVertex(v, A, 1, 1, P, F),
                                        We(this);
                                        continue
                                    }
                                    N = "miter"
                                }
                            }
                            let X = A.add(O);
                            0 === X.x && 0 === X.y || X._unit();
                            const _e = X.x * O.x + X.y * O.y
                              , me = 0 !== _e ? 1 / _e : 1 / 0
                              , pe = 2 * Math.sqrt(2 - 2 * _e)
                              , Ne = _e < h1 && w && C
                              , Pe = A.x * O.y - A.y * O.x > 0
                              , $e = this.overscaling <= 16 ? 15 * uo / (512 * this.overscaling) : 0;
                            if (L && "round" === N)
                                if (me < g)
                                    N = "miter";
                                else if (me <= 2) {
                                    const We = em(v, -10, 8202);
                                    N = this.hasZOffset && (We || this.hasCrossSlope) ? "miter" : "fakeround"
                                }
                            if ("miter" === N && me > p && (N = "bevel"),
                            "bevel" === N && (me > 2 && (N = "flipbevel"),
                            me < p && (N = "miter")),
                            w && !("miter" === N && Ne) && this.updateDistance(w, v),
                            "miter" === N)
                                if (Ne) {
                                    const We = v.dist(w);
                                    if (We > 2 * $e) {
                                        const Ke = v.sub(v.sub(w)._mult($e / We)._round());
                                        this.updateDistance(w, Ke),
                                        this.addCurrentVertex(Ke, A, 0, 0, P, F),
                                        w = Ke
                                    }
                                    this.updateDistance(w, v),
                                    X._mult(me),
                                    this.addCurrentVertex(v, X, 0, 0, P, F);
                                    const je = v.dist(C);
                                    if (je > 2 * $e) {
                                        const Ke = v.add(C.sub(v)._mult($e / je)._round());
                                        this.updateDistance(v, Ke),
                                        this.addCurrentVertex(Ke, O, 0, 0, P, F),
                                        v = Ke
                                    }
                                } else
                                    X._mult(me),
                                    this.addCurrentVertex(v, X, 0, 0, P, F);
                            else if ("flipbevel" === N) {
                                if (me > 100)
                                    X = O.mult(-1);
                                else {
                                    const We = me * A.add(O).mag() / A.sub(O).mag();
                                    X._perp()._mult(We * (Pe ? -1 : 1))
                                }
                                this.addCurrentVertex(v, X, 0, 0, P, F),
                                this.addCurrentVertex(v, X.mult(-1), 0, 0, P, F)
                            } else if ("bevel" === N || "fakeround" === N) {
                                null != F && w && this.addCurrentVertex(v, A, -1, -1, P, F);
                                const We = v.dist(w) <= 2 * $e && "bevel" !== N
                                  , je = X.mult(Pe ? 1 : -1);
                                je._mult(me);
                                const Ke = O.mult(Pe ? -1 : 1)
                                  , rt = A.mult(Pe ? -1 : 1)
                                  , at = this.evaluateLineProgressFeatures(this.distance);
                                if (null == F && (this.addHalfVertex(v, je.x, je.y, !1, !Pe, 0, P, at),
                                We || this.addHalfVertex(v, je.x + 2 * rt.x, je.y + 2 * rt.y, !1, Pe, 0, P, at)),
                                "fakeround" === N) {
                                    const ot = Math.round(180 * pe / Math.PI / 20);
                                    this.addHalfVertex(v, rt.x, rt.y, !1, Pe, 0, P, at);
                                    for (let Ct = 0; Ct < ot; Ct++) {
                                        let Zt = Ct / ot;
                                        if (.5 !== Zt) {
                                            const lo = Zt - .5;
                                            Zt += Zt * lo * (Zt - 1) * ((1.0904 + G * (G * (3.55645 - 1.43519 * G) - 3.2452)) * lo * lo + (.848013 + G * (.215638 * G - 1.06021)))
                                        }
                                        const Ot = Ke.sub(rt)._mult(Zt)._add(rt)._unit();
                                        this.addHalfVertex(v, Ot.x, Ot.y, !1, Pe, 0, P, at)
                                    }
                                    this.addHalfVertex(v, Ke.x, Ke.y, !1, Pe, 0, P, at)
                                }
                                We || null != F || this.addHalfVertex(v, je.x + 2 * Ke.x, je.y + 2 * Ke.y, !1, Pe, 0, P, at),
                                null != F && C && this.addCurrentVertex(v, O, 1, 1, P, F)
                            } else
                                "butt" === N ? this.addCurrentVertex(v, X, 0, 0, P, F) : "square" === N ? (w || this.addCurrentVertex(v, X, -1, -1, P, F),
                                this.addCurrentVertex(v, X, 0, 0, P, F),
                                w && this.addCurrentVertex(v, X, 1, 1, P, F)) : "round" === N && (w && (this.addCurrentVertex(v, A, 0, 0, P, F),
                                this.addCurrentVertex(v, A, 1, 1, P, F, !0)),
                                C && (this.addCurrentVertex(v, O, -1, -1, P, F, !0),
                                this.addCurrentVertex(v, O, 0, 0, P, F)))
                        }
                    }
                    addVerticesTo(e, o, a, u, l, p, g, x, T, f) {
                        const b = (o.w - e.w) / this.tessellationStep | 0;
                        let P = 0;
                        const v = this.scaledDistance;
                        if (b > 1) {
                            this.lineSoFar = e.w;
                            const C = (o.x - e.x) / b
                              , A = (o.y - e.y) / b
                              , O = (o.z - e.z) / b
                              , F = (o.w - e.w) / b;
                            for (let z = 1; z < b; ++z) {
                                e.x += C,
                                e.y += A,
                                e.z += O,
                                this.lineSoFar += F,
                                P += F;
                                const L = this.evaluateLineProgressFeatures(this.prevDistance + P);
                                this.scaledDistance = (this.prevDistance + P) / this.totalDistance,
                                this.addHalfVertex(e, a, u, f, !1, g, T, L),
                                this.addHalfVertex(e, l, p, f, !0, -x, T, L)
                            }
                        }
                        this.lineSoFar = o.w,
                        this.scaledDistance = v;
                        const w = this.evaluateLineProgressFeatures(this.distance);
                        this.addHalfVertex(o, a, u, f, !1, g, T, w),
                        this.addHalfVertex(o, l, p, f, !0, -x, T, w)
                    }
                    evaluateLineProgressFeatures(e) {
                        if (!this.variableWidthValue && !this.hasZOffset)
                            return null;
                        this.evaluationGlobals.lineProgress = 0,
                        this.lineClips ? this.evaluationGlobals.lineProgress = Math.min(1, (this.totalFeatureLength * this.lineClips.start + e) / this.totalFeatureLength) : vo("line-progress evaluation for ".concat(this.layerIds[0], " requires enabling 'lineMetrics' for the source."));
                        let o = 0;
                        return this.variableWidthValue && "constant" !== this.variableWidthValue.kind && (o = this.variableWidthValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0),
                        this.hasZOffset ? "constant" === this.zOffsetValue.kind ? {
                            zOffset: this.zOffsetValue.value,
                            variableWidth: o
                        } : {
                            zOffset: this.zOffsetValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0,
                            variableWidth: o
                        } : {
                            zOffset: 0,
                            variableWidth: o
                        }
                    }
                    addCurrentVertex(e, o, a, u, l, p, g=!1) {
                        const x = o.x + o.y * a
                          , T = o.y - o.x * a
                          , f = o.y * u - o.x
                          , b = -o.y - o.x * u;
                        if (null != p) {
                            const P = this.hasZOffset
                              , v = -10
                              , w = 8202
                              , C = p.zOffset
                              , A = new Cf(e.x,e.y,C,this.lineSoFar)
                              , O = !!P && em(e, v, w)
                              , F = this.lineSoFar
                              , z = this.distance;
                            if (this.currentVertex)
                                if (O) {
                                    const L = this.currentVertexIsOutside
                                      , N = this.currentVertex
                                      , G = new Cf(e.x,e.y,C,this.lineSoFar);
                                    if (Sf(N, G, v, w),
                                    !em(G, v, w)) {
                                        if (L) {
                                            this.e1 = this.e2 = -1,
                                            this.distance -= N.dist(A),
                                            this.lineSoFar = N.w;
                                            const X = this.evaluateLineProgressFeatures(N.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                                            this.addHalfVertex(N, x, T, g, !1, a, l, X),
                                            this.addHalfVertex(N, f, b, g, !0, -u, l, X),
                                            this.prevDistance = this.distance
                                        }
                                        this.distance = this.prevDistance + N.dist(G),
                                        this.scaledDistance = this.distance / this.totalDistance,
                                        this.addVerticesTo(N, G, x, T, f, b, a, u, l, g),
                                        this.distance = z,
                                        this.scaledDistance = this.distance / this.totalDistance
                                    }
                                } else {
                                    const L = this.currentVertex;
                                    if (this.currentVertexIsOutside) {
                                        Sf(L, A, v, w),
                                        this.e1 = this.e2 = -1,
                                        this.distance -= L.dist(A),
                                        this.scaledDistance = this.distance / this.totalDistance,
                                        this.lineSoFar = L.w;
                                        const N = this.evaluateLineProgressFeatures(L.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                                        this.addHalfVertex(L, x, T, g, !1, a, l, N),
                                        this.addHalfVertex(L, f, b, g, !0, -u, l, N),
                                        this.prevDistance = this.distance,
                                        this.distance = z,
                                        this.scaledDistance = this.distance / this.totalDistance
                                    }
                                    this.addVerticesTo(L, A, x, T, f, b, a, u, l, g)
                                }
                            else
                                O || (this.addHalfVertex(e, x, T, g, !1, a, l, p),
                                this.addHalfVertex(e, f, b, g, !0, -u, l, p));
                            this.currentVertex = A,
                            this.currentVertexIsOutside = O,
                            this.lineSoFar = F
                        } else
                            this.addHalfVertex(e, x, T, g, !1, a, l, p),
                            this.addHalfVertex(e, f, b, g, !0, -u, l, p)
                    }
                    addHalfVertex({x: e, y: o}, a, u, l, p, g, x, T) {
                        this.patternJoinNone && (0 === this.segmentPoints.length && (this.segmentStart = this.lineSoFar,
                        this.segmentStartf32 = Math.fround(this.lineSoFar)),
                        p || this.segmentPoints.push(this.lineSoFar - this.segmentStart, g)),
                        this.layoutVertexArray.emplaceBack((e << 1) + (l ? 1 : 0), (o << 1) + (p ? 1 : 0), Math.round(63 * a) + 128, Math.round(63 * u) + 128, 1 + (0 === g ? 0 : g < 0 ? -1 : 1), 0, this.lineSoFar - this.segmentStartf32),
                        this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
                        const f = x.vertexLength++;
                        this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, f),
                        x.primitiveLength++),
                        p ? this.e2 = f : this.e1 = f,
                        null != T && this.zOffsetVertexArray.emplaceBack(T.zOffset, T.variableWidth)
                    }
                    updateScaledDistance() {
                        this.lineClips ? (this.scaledDistance = this.distance / this.totalDistance,
                        this.lineSoFar = this.totalFeatureLength * this.lineClips.start + this.distance) : this.lineSoFar = this.distance
                    }
                    updateDistance(e, o) {
                        this.prevDistance = this.distance,
                        this.distance += e.dist(o),
                        this.updateScaledDistance()
                    }
                }
                function em(n, e, o) {
                    return n.x < e || n.x > o || n.y < e || n.y > o
                }
                let t_, o_;
                function i_(n, e, o) {
                    return e * (uo / (n.tileSize * Math.pow(2, o - n.tileID.overscaledZ)))
                }
                Fe(Qd, "LineBucket", {
                    omit: ["layers", "patternFeatures", "currentVertex", "currentVertexIsOutside"]
                });
                const n_ = (n, e, o) => (1 - o) * n + o * e;
                function r_(n, e) {
                    return 1 / i_(n, 1, e.tileZoom)
                }
                function s_(n, e, o, a) {
                    return n.translatePosMatrix(a || e.tileID.projMatrix, e, o.paint.get("line-translate"), o.paint.get("line-translate-anchor"))
                }
                const a_ = n => {
                    const e = [];
                    l_(n) && e.push("RENDER_LINE_DASH"),
                    n.paint.get("line-gradient") && e.push("RENDER_LINE_GRADIENT");
                    const o = n.paint.get("line-trim-offset");
                    0 === o[0] && 0 === o[1] || e.push("RENDER_LINE_TRIM_OFFSET"),
                    0 !== n.paint.get("line-border-width").constantOr(1) && e.push("RENDER_LINE_BORDER");
                    const a = "none" === n.layout.get("line-join").constantOr("miter")
                      , u = !!n.paint.get("line-pattern").constantOr(1);
                    return a && u && e.push("LINE_JOIN_NONE"),
                    e
                }
                ;
                function l_(n) {
                    const e = n.paint.get("line-dasharray").value;
                    return e.value || "constant" !== e.kind
                }
                let tm;
                const c_ = () => tm || (tm = {
                    layout: t_ || (t_ = new cn({
                        "line-cap": new Mo(ft.layout_line["line-cap"]),
                        "line-join": new Mo(ft.layout_line["line-join"]),
                        "line-miter-limit": new eo(ft.layout_line["line-miter-limit"]),
                        "line-round-limit": new eo(ft.layout_line["line-round-limit"]),
                        "line-sort-key": new Mo(ft.layout_line["line-sort-key"]),
                        "line-z-offset": new Mo(ft.layout_line["line-z-offset"]),
                        "line-elevation-reference": new eo(ft.layout_line["line-elevation-reference"]),
                        "line-cross-slope": new eo(ft.layout_line["line-cross-slope"]),
                        visibility: new eo(ft.layout_line.visibility),
                        "line-width-unit": new eo(ft.layout_line["line-width-unit"])
                    })),
                    paint: o_ || (o_ = new cn({
                        "line-opacity": new Mo(ft.paint_line["line-opacity"]),
                        "line-color": new Mo(ft.paint_line["line-color"]),
                        "line-translate": new eo(ft.paint_line["line-translate"]),
                        "line-translate-anchor": new eo(ft.paint_line["line-translate-anchor"]),
                        "line-width": new Mo(ft.paint_line["line-width"]),
                        "line-gap-width": new Mo(ft.paint_line["line-gap-width"]),
                        "line-offset": new Mo(ft.paint_line["line-offset"]),
                        "line-blur": new Mo(ft.paint_line["line-blur"]),
                        "line-dasharray": new Mo(ft.paint_line["line-dasharray"]),
                        "line-pattern": new Mo(ft.paint_line["line-pattern"]),
                        "line-gradient": new ca(ft.paint_line["line-gradient"]),
                        "line-trim-offset": new eo(ft.paint_line["line-trim-offset"]),
                        "line-trim-fade-range": new eo(ft.paint_line["line-trim-fade-range"]),
                        "line-trim-color": new eo(ft.paint_line["line-trim-color"]),
                        "line-emissive-strength": new eo(ft.paint_line["line-emissive-strength"]),
                        "line-border-width": new Mo(ft.paint_line["line-border-width"]),
                        "line-border-color": new Mo(ft.paint_line["line-border-color"]),
                        "line-occlusion-opacity": new eo(ft.paint_line["line-occlusion-opacity"]),
                        "line-color-use-theme": new Mo({
                            type: "string",
                            default: "default",
                            "property-type": "data-driven"
                        }),
                        "line-gradient-use-theme": new Mo({
                            type: "string",
                            default: "default",
                            "property-type": "data-driven"
                        }),
                        "line-trim-color-use-theme": new Mo({
                            type: "string",
                            default: "default",
                            "property-type": "data-driven"
                        }),
                        "line-border-color-use-theme": new Mo({
                            type: "string",
                            default: "default",
                            "property-type": "data-driven"
                        })
                    }))
                },
                tm);
                class p1 extends Mo {
                    possiblyEvaluate(e, o) {
                        return o = new Hi(Math.floor(o.zoom),{
                            now: o.now,
                            fadeDuration: o.fadeDuration,
                            transition: o.transition
                        }),
                        super.possiblyEvaluate(e, o)
                    }
                    evaluate(e, o, a, u) {
                        return o = W({}, o, {
                            zoom: Math.floor(o.zoom)
                        }),
                        super.evaluate(e, o, a, u)
                    }
                }
                let ju;
                function h_(n, e) {
                    return e > 0 ? e + 2 * n : n
                }
                const d1 = Si([{
                    name: "a_pos_offset",
                    components: 4,
                    type: "Int16"
                }, {
                    name: "a_tex_size",
                    components: 4,
                    type: "Uint16"
                }, {
                    name: "a_pixeloffset",
                    components: 4,
                    type: "Int16"
                }], 4)
                  , m1 = Si([{
                    name: "a_globe_anchor",
                    components: 3,
                    type: "Int16"
                }, {
                    name: "a_globe_normal",
                    components: 3,
                    type: "Float32"
                }], 4)
                  , f1 = Si([{
                    name: "a_projected_pos",
                    components: 4,
                    type: "Float32"
                }], 4);
                Si([{
                    name: "a_fade_opacity",
                    components: 1,
                    type: "Uint32"
                }], 4);
                const _1 = Si([{
                    name: "a_auto_z_offset",
                    components: 1,
                    type: "Float32"
                }], 4)
                  , g1 = Si([{
                    name: "a_texb",
                    components: 2,
                    type: "Uint16"
                }])
                  , y1 = Si([{
                    name: "a_placed",
                    components: 2,
                    type: "Uint8"
                }, {
                    name: "a_shift",
                    components: 2,
                    type: "Float32"
                }, {
                    name: "a_elevation_from_sea",
                    components: 2,
                    type: "Float32"
                }])
                  , v1 = Si([{
                    name: "a_size_scale",
                    components: 1,
                    type: "Float32"
                }, {
                    name: "a_padding",
                    components: 2,
                    type: "Float32"
                }, {
                    name: "a_auto_z_offset",
                    components: 1,
                    type: "Float32"
                }]);
                Si([{
                    type: "Int16",
                    name: "projectedAnchorX"
                }, {
                    type: "Int16",
                    name: "projectedAnchorY"
                }, {
                    type: "Int16",
                    name: "projectedAnchorZ"
                }, {
                    type: "Int16",
                    name: "tileAnchorX"
                }, {
                    type: "Int16",
                    name: "tileAnchorY"
                }, {
                    type: "Float32",
                    name: "x1"
                }, {
                    type: "Float32",
                    name: "y1"
                }, {
                    type: "Float32",
                    name: "x2"
                }, {
                    type: "Float32",
                    name: "y2"
                }, {
                    type: "Int16",
                    name: "padding"
                }, {
                    type: "Uint32",
                    name: "featureIndex"
                }, {
                    type: "Uint16",
                    name: "sourceLayerIndex"
                }, {
                    type: "Uint16",
                    name: "bucketIndex"
                }]);
                const u_ = Si([{
                    name: "a_pos",
                    components: 3,
                    type: "Int16"
                }, {
                    name: "a_anchor_pos",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_extrude",
                    components: 2,
                    type: "Int16"
                }], 4)
                  , x1 = Si([{
                    name: "a_pos_2f",
                    components: 2,
                    type: "Float32"
                }, {
                    name: "a_radius",
                    components: 1,
                    type: "Float32"
                }, {
                    name: "a_flags",
                    components: 2,
                    type: "Int16"
                }], 4);
                Si([{
                    name: "triangle",
                    components: 3,
                    type: "Uint16"
                }]),
                Si([{
                    type: "Int16",
                    name: "projectedAnchorX"
                }, {
                    type: "Int16",
                    name: "projectedAnchorY"
                }, {
                    type: "Int16",
                    name: "projectedAnchorZ"
                }, {
                    type: "Float32",
                    name: "tileAnchorX"
                }, {
                    type: "Float32",
                    name: "tileAnchorY"
                }, {
                    type: "Uint16",
                    name: "glyphStartIndex"
                }, {
                    type: "Uint16",
                    name: "numGlyphs"
                }, {
                    type: "Uint32",
                    name: "vertexStartIndex"
                }, {
                    type: "Uint32",
                    name: "lineStartIndex"
                }, {
                    type: "Uint32",
                    name: "lineLength"
                }, {
                    type: "Uint16",
                    name: "segment"
                }, {
                    type: "Uint16",
                    name: "lowerSize"
                }, {
                    type: "Uint16",
                    name: "upperSize"
                }, {
                    type: "Float32",
                    name: "lineOffsetX"
                }, {
                    type: "Float32",
                    name: "lineOffsetY"
                }, {
                    type: "Uint8",
                    name: "writingMode"
                }, {
                    type: "Uint8",
                    name: "placedOrientation"
                }, {
                    type: "Uint8",
                    name: "hidden"
                }, {
                    type: "Uint32",
                    name: "crossTileID"
                }, {
                    type: "Int16",
                    name: "associatedIconIndex"
                }, {
                    type: "Uint8",
                    name: "flipState"
                }]),
                Si([{
                    type: "Float32",
                    name: "tileAnchorX"
                }, {
                    type: "Float32",
                    name: "tileAnchorY"
                }, {
                    type: "Int16",
                    name: "projectedAnchorX"
                }, {
                    type: "Int16",
                    name: "projectedAnchorY"
                }, {
                    type: "Int16",
                    name: "projectedAnchorZ"
                }, {
                    type: "Int16",
                    name: "rightJustifiedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "centerJustifiedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "leftJustifiedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "verticalPlacedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "placedIconSymbolIndex"
                }, {
                    type: "Int16",
                    name: "verticalPlacedIconSymbolIndex"
                }, {
                    type: "Uint16",
                    name: "key"
                }, {
                    type: "Uint16",
                    name: "textBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "textBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "verticalTextBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "verticalTextBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "iconBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "iconBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "verticalIconBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "verticalIconBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "featureIndex"
                }, {
                    type: "Uint16",
                    name: "numHorizontalGlyphVertices"
                }, {
                    type: "Uint16",
                    name: "numVerticalGlyphVertices"
                }, {
                    type: "Uint16",
                    name: "numIconVertices"
                }, {
                    type: "Uint16",
                    name: "numVerticalIconVertices"
                }, {
                    type: "Uint16",
                    name: "useRuntimeCollisionCircles"
                }, {
                    type: "Uint32",
                    name: "crossTileID"
                }, {
                    type: "Float32",
                    components: 2,
                    name: "textOffset"
                }, {
                    type: "Float32",
                    name: "collisionCircleDiameter"
                }, {
                    type: "Float32",
                    name: "zOffset"
                }, {
                    type: "Uint8",
                    name: "hasIconTextFit"
                }]),
                Si([{
                    type: "Float32",
                    name: "offsetX"
                }]),
                Si([{
                    type: "Int16",
                    name: "x"
                }, {
                    type: "Int16",
                    name: "y"
                }]);
                const Bs = 128;
                function jp(n, e, o, a, u) {
                    if ("camera" === n.kind)
                        return n.maxSize;
                    if ("composite" === n.kind) {
                        const l = e.possiblyEvaluate(new Hi(n.maxZoom), o).evaluate(u, {}, o)
                          , p = e.possiblyEvaluate(new Hi(n.minZoom), o).evaluate(u, {}, o);
                        return Math.max(l, p)
                    }
                    return e.possiblyEvaluate(new Hi(a)).evaluate(u, {}, o)
                }
                function om(n, e) {
                    const {expression: o} = e;
                    if ("constant" === o.kind)
                        return {
                            kind: "constant",
                            layoutSize: o.evaluate(new Hi(n + 1))
                        };
                    if ("source" === o.kind)
                        return {
                            kind: "source"
                        };
                    {
                        const {zoomStops: a, interpolationType: u} = o;
                        let l = 0;
                        for (; l < a.length && a[l] <= n; )
                            l++;
                        l = Math.max(0, l - 1);
                        let p = l;
                        for (; p < a.length && a[p] < n + 1; )
                            p++;
                        p = Math.min(a.length - 1, p);
                        const g = a[l]
                          , x = a[p];
                        return "composite" === o.kind ? {
                            kind: "composite",
                            minZoom: g,
                            maxZoom: x,
                            interpolationType: u
                        } : {
                            kind: "camera",
                            minZoom: g,
                            maxZoom: x,
                            minSize: o.evaluate(new Hi(g)),
                            maxSize: o.evaluate(new Hi(x)),
                            interpolationType: u
                        }
                    }
                }
                function Vp(n, {uSize: e, uSizeT: o}, {lowerSize: a, upperSize: u}) {
                    return "source" === n.kind ? a / Bs : "composite" === n.kind ? jo(a / Bs, u / Bs, o) : e
                }
                function $h(n, e, o=1) {
                    let a = 0
                      , u = 0;
                    if ("constant" === n.kind)
                        u = n.layoutSize * o;
                    else if ("source" !== n.kind) {
                        const {interpolationType: l, minZoom: p, maxZoom: g} = n
                          , x = l ? ie(Jn.interpolationFactor(l, e, p, g), 0, 1) : 0;
                        "camera" === n.kind ? u = jo(n.minSize, n.maxSize, x) * o : a = x * o
                    }
                    return {
                        uSizeT: a,
                        uSize: u
                    }
                }
                var b1 = Object.freeze({
                    __proto__: null,
                    SIZE_PACK_FACTOR: Bs,
                    evaluateSizeForFeature: Vp,
                    evaluateSizeForZoom: $h,
                    getRasterizedIconSize: jp,
                    getSizeData: om
                });
                function w1(n, e, o) {
                    return n.sections.forEach(a => {
                        a.text = function(u, l, p) {
                            const g = l.layout.get("text-transform").evaluate(p, {});
                            return "uppercase" === g ? u = u.toLocaleUpperCase() : "lowercase" === g && (u = u.toLocaleLowerCase()),
                            Qn.applyArabicShaping && (u = Qn.applyArabicShaping(u)),
                            u
                        }(a.text, e, o)
                    }
                    ),
                    n
                }
                const Vu = {
                    "!": "\ufe15",
                    "#": "\uff03",
                    $: "\uff04",
                    "%": "\uff05",
                    "&": "\uff06",
                    "(": "\ufe35",
                    ")": "\ufe36",
                    "*": "\uff0a",
                    "+": "\uff0b",
                    ",": "\ufe10",
                    "-": "\ufe32",
                    ".": "\u30fb",
                    "/": "\uff0f",
                    ":": "\ufe13",
                    ";": "\ufe14",
                    "<": "\ufe3f",
                    "=": "\uff1d",
                    ">": "\ufe40",
                    "?": "\ufe16",
                    "@": "\uff20",
                    "[": "\ufe47",
                    "\\": "\uff3c",
                    "]": "\ufe48",
                    "^": "\uff3e",
                    _: "\ufe33",
                    "`": "\uff40",
                    "{": "\ufe37",
                    "|": "\u2015",
                    "}": "\ufe38",
                    "~": "\uff5e",
                    "\xa2": "\uffe0",
                    "\xa3": "\uffe1",
                    "\xa5": "\uffe5",
                    "\xa6": "\uffe4",
                    "\xac": "\uffe2",
                    "\xaf": "\uffe3",
                    "\u2013": "\ufe32",
                    "\u2014": "\ufe31",
                    "\u2018": "\ufe43",
                    "\u2019": "\ufe44",
                    "\u201c": "\ufe41",
                    "\u201d": "\ufe42",
                    "\u2026": "\ufe19",
                    "\u2027": "\u30fb",
                    "\u20a9": "\uffe6",
                    "\u3001": "\ufe11",
                    "\u3002": "\ufe12",
                    "\u3008": "\ufe3f",
                    "\u3009": "\ufe40",
                    "\u300a": "\ufe3d",
                    "\u300b": "\ufe3e",
                    "\u300c": "\ufe41",
                    "\u300d": "\ufe42",
                    "\u300e": "\ufe43",
                    "\u300f": "\ufe44",
                    "\u3010": "\ufe3b",
                    "\u3011": "\ufe3c",
                    "\u3014": "\ufe39",
                    "\u3015": "\ufe3a",
                    "\u3016": "\ufe17",
                    "\u3017": "\ufe18",
                    "\uff01": "\ufe15",
                    "\uff08": "\ufe35",
                    "\uff09": "\ufe36",
                    "\uff0c": "\ufe10",
                    "\uff0d": "\ufe32",
                    "\uff0e": "\u30fb",
                    "\uff1a": "\ufe13",
                    "\uff1b": "\ufe14",
                    "\uff1c": "\ufe3f",
                    "\uff1e": "\ufe40",
                    "\uff1f": "\ufe16",
                    "\uff3b": "\ufe47",
                    "\uff3d": "\ufe48",
                    "\uff3f": "\ufe33",
                    "\uff5b": "\ufe37",
                    "\uff5c": "\u2015",
                    "\uff5d": "\ufe38",
                    "\uff5f": "\ufe35",
                    "\uff60": "\ufe36",
                    "\uff61": "\ufe12",
                    "\uff62": "\ufe41",
                    "\uff63": "\ufe42",
                    "\u2190": "\u2191",
                    "\u2192": "\u2193"
                };
                function P1(n) {
                    return "\ufe36" === n || "\ufe48" === n || "\ufe38" === n || "\ufe44" === n || "\ufe42" === n || "\ufe3e" === n || "\ufe3c" === n || "\ufe3a" === n || "\ufe18" === n || "\ufe40" === n || "\ufe10" === n || "\ufe13" === n || "\ufe14" === n || "\uff40" === n || "\uffe3" === n || "\ufe11" === n || "\ufe12" === n
                }
                function M1(n) {
                    return "\ufe35" === n || "\ufe47" === n || "\ufe37" === n || "\ufe43" === n || "\ufe41" === n || "\ufe3d" === n || "\ufe3b" === n || "\ufe39" === n || "\ufe17" === n || "\ufe3f" === n
                }
                var p_, im, d_, nm = {};
                /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
                function m_() {
                    if (d_)
                        return im;
                    d_ = 1,
                    im = e;
                    var n = function T1() {
                        return p_ || (p_ = 1,
                        nm.read = function(n, e, o, a, u) {
                            var l, p, g = 8 * u - a - 1, x = (1 << g) - 1, T = x >> 1, f = -7, b = o ? u - 1 : 0, P = o ? -1 : 1, v = n[e + b];
                            for (b += P,
                            l = v & (1 << -f) - 1,
                            v >>= -f,
                            f += g; f > 0; l = 256 * l + n[e + b],
                            b += P,
                            f -= 8)
                                ;
                            for (p = l & (1 << -f) - 1,
                            l >>= -f,
                            f += a; f > 0; p = 256 * p + n[e + b],
                            b += P,
                            f -= 8)
                                ;
                            if (0 === l)
                                l = 1 - T;
                            else {
                                if (l === x)
                                    return p ? NaN : 1 / 0 * (v ? -1 : 1);
                                p += Math.pow(2, a),
                                l -= T
                            }
                            return (v ? -1 : 1) * p * Math.pow(2, l - a)
                        }
                        ,
                        nm.write = function(n, e, o, a, u, l) {
                            var p, g, x, T = 8 * l - u - 1, f = (1 << T) - 1, b = f >> 1, P = 23 === u ? Math.pow(2, -24) - Math.pow(2, -77) : 0, v = a ? 0 : l - 1, w = a ? 1 : -1, C = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
                            for (e = Math.abs(e),
                            isNaN(e) || e === 1 / 0 ? (g = isNaN(e) ? 1 : 0,
                            p = f) : (p = Math.floor(Math.log(e) / Math.LN2),
                            e * (x = Math.pow(2, -p)) < 1 && (p--,
                            x *= 2),
                            (e += p + b >= 1 ? P / x : P * Math.pow(2, 1 - b)) * x >= 2 && (p++,
                            x /= 2),
                            p + b >= f ? (g = 0,
                            p = f) : p + b >= 1 ? (g = (e * x - 1) * Math.pow(2, u),
                            p += b) : (g = e * Math.pow(2, b - 1) * Math.pow(2, u),
                            p = 0)); u >= 8; n[o + v] = 255 & g,
                            v += w,
                            g /= 256,
                            u -= 8)
                                ;
                            for (p = p << u | g,
                            T += u; T > 0; n[o + v] = 255 & p,
                            v += w,
                            p /= 256,
                            T -= 8)
                                ;
                            n[o + v - w] |= 128 * C
                        }
                        ),
                        nm
                    }();
                    function e(L) {
                        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(L) ? L : new Uint8Array(L || 0),
                        this.pos = 0,
                        this.type = 0,
                        this.length = this.buf.length
                    }
                    e.Varint = 0,
                    e.Fixed64 = 1,
                    e.Bytes = 2,
                    e.Fixed32 = 5;
                    var o = 4294967296
                      , a = 1 / o
                      , u = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
                    function l(L) {
                        return L.type === e.Bytes ? L.readVarint() + L.pos : L.pos + 1
                    }
                    function g(L, N, G) {
                        var X = N <= 16383 ? 1 : N <= 2097151 ? 2 : N <= 268435455 ? 3 : Math.floor(Math.log(N) / (7 * Math.LN2));
                        G.realloc(X);
                        for (var _e = G.pos - 1; _e >= L; _e--)
                            G.buf[_e + X] = G.buf[_e]
                    }
                    function x(L, N) {
                        for (var G = 0; G < L.length; G++)
                            N.writeVarint(L[G])
                    }
                    function T(L, N) {
                        for (var G = 0; G < L.length; G++)
                            N.writeSVarint(L[G])
                    }
                    function f(L, N) {
                        for (var G = 0; G < L.length; G++)
                            N.writeFloat(L[G])
                    }
                    function b(L, N) {
                        for (var G = 0; G < L.length; G++)
                            N.writeDouble(L[G])
                    }
                    function P(L, N) {
                        for (var G = 0; G < L.length; G++)
                            N.writeBoolean(L[G])
                    }
                    function v(L, N) {
                        for (var G = 0; G < L.length; G++)
                            N.writeFixed32(L[G])
                    }
                    function w(L, N) {
                        for (var G = 0; G < L.length; G++)
                            N.writeSFixed32(L[G])
                    }
                    function C(L, N) {
                        for (var G = 0; G < L.length; G++)
                            N.writeFixed64(L[G])
                    }
                    function A(L, N) {
                        for (var G = 0; G < L.length; G++)
                            N.writeSFixed64(L[G])
                    }
                    function O(L, N) {
                        return (L[N] | L[N + 1] << 8 | L[N + 2] << 16) + 16777216 * L[N + 3]
                    }
                    function F(L, N, G) {
                        L[G] = N,
                        L[G + 1] = N >>> 8,
                        L[G + 2] = N >>> 16,
                        L[G + 3] = N >>> 24
                    }
                    function z(L, N) {
                        return (L[N] | L[N + 1] << 8 | L[N + 2] << 16) + (L[N + 3] << 24)
                    }
                    return e.prototype = {
                        destroy: function() {
                            this.buf = null
                        },
                        readFields: function(L, N, G) {
                            for (G = G || this.length; this.pos < G; ) {
                                var X = this.readVarint()
                                  , _e = X >> 3
                                  , me = this.pos;
                                this.type = 7 & X,
                                L(_e, N, this),
                                this.pos === me && this.skip(X)
                            }
                            return N
                        },
                        readMessage: function(L, N) {
                            return this.readFields(L, N, this.readVarint() + this.pos)
                        },
                        readFixed32: function() {
                            var L = O(this.buf, this.pos);
                            return this.pos += 4,
                            L
                        },
                        readSFixed32: function() {
                            var L = z(this.buf, this.pos);
                            return this.pos += 4,
                            L
                        },
                        readFixed64: function() {
                            var L = O(this.buf, this.pos) + O(this.buf, this.pos + 4) * o;
                            return this.pos += 8,
                            L
                        },
                        readSFixed64: function() {
                            var L = O(this.buf, this.pos) + z(this.buf, this.pos + 4) * o;
                            return this.pos += 8,
                            L
                        },
                        readFloat: function() {
                            var L = n.read(this.buf, this.pos, !0, 23, 4);
                            return this.pos += 4,
                            L
                        },
                        readDouble: function() {
                            var L = n.read(this.buf, this.pos, !0, 52, 8);
                            return this.pos += 8,
                            L
                        },
                        readVarint: function(L) {
                            var N, G, X = this.buf;
                            return N = 127 & (G = X[this.pos++]),
                            G < 128 ? N : (N |= (127 & (G = X[this.pos++])) << 7,
                            G < 128 ? N : (N |= (127 & (G = X[this.pos++])) << 14,
                            G < 128 ? N : (N |= (127 & (G = X[this.pos++])) << 21,
                            G < 128 ? N : function(_e, me, pe) {
                                var Ne, Pe, $e = pe.buf;
                                if (Ne = (112 & (Pe = $e[pe.pos++])) >> 4,
                                Pe < 128 || (Ne |= (127 & (Pe = $e[pe.pos++])) << 3,
                                Pe < 128) || (Ne |= (127 & (Pe = $e[pe.pos++])) << 10,
                                Pe < 128) || (Ne |= (127 & (Pe = $e[pe.pos++])) << 17,
                                Pe < 128) || (Ne |= (127 & (Pe = $e[pe.pos++])) << 24,
                                Pe < 128) || (Ne |= (1 & (Pe = $e[pe.pos++])) << 31,
                                Pe < 128))
                                    return function p(L, N, G) {
                                        return G ? 4294967296 * N + (L >>> 0) : 4294967296 * (N >>> 0) + (L >>> 0)
                                    }(_e, Ne, me);
                                throw new Error("Expected varint not more than 10 bytes")
                            }(N |= (15 & (G = X[this.pos])) << 28, L, this))))
                        },
                        readVarint64: function() {
                            return this.readVarint(!0)
                        },
                        readSVarint: function() {
                            var L = this.readVarint();
                            return L % 2 == 1 ? (L + 1) / -2 : L / 2
                        },
                        readBoolean: function() {
                            return !!this.readVarint()
                        },
                        readString: function() {
                            var L = this.readVarint() + this.pos
                              , N = this.pos;
                            return this.pos = L,
                            L - N >= 12 && u ? u.decode(this.buf.subarray(N, L)) : function(G, X, _e) {
                                for (var me = "", pe = X; pe < _e; ) {
                                    var Ne, Pe, $e, We = G[pe], je = null, Ke = We > 239 ? 4 : We > 223 ? 3 : We > 191 ? 2 : 1;
                                    if (pe + Ke > _e)
                                        break;
                                    1 === Ke ? We < 128 && (je = We) : 2 === Ke ? 128 == (192 & (Ne = G[pe + 1])) && (je = (31 & We) << 6 | 63 & Ne) <= 127 && (je = null) : 3 === Ke ? (Pe = G[pe + 2],
                                    128 == (192 & (Ne = G[pe + 1])) && 128 == (192 & Pe) && ((je = (15 & We) << 12 | (63 & Ne) << 6 | 63 & Pe) <= 2047 || je >= 55296 && je <= 57343) && (je = null)) : 4 === Ke && (Pe = G[pe + 2],
                                    $e = G[pe + 3],
                                    128 == (192 & (Ne = G[pe + 1])) && 128 == (192 & Pe) && 128 == (192 & $e) && ((je = (15 & We) << 18 | (63 & Ne) << 12 | (63 & Pe) << 6 | 63 & $e) <= 65535 || je >= 1114112) && (je = null)),
                                    null === je ? (je = 65533,
                                    Ke = 1) : je > 65535 && (je -= 65536,
                                    me += String.fromCharCode(je >>> 10 & 1023 | 55296),
                                    je = 56320 | 1023 & je),
                                    me += String.fromCharCode(je),
                                    pe += Ke
                                }
                                return me
                            }(this.buf, N, L)
                        },
                        readBytes: function() {
                            var L = this.readVarint() + this.pos
                              , N = this.buf.subarray(this.pos, L);
                            return this.pos = L,
                            N
                        },
                        readPackedVarint: function(L, N) {
                            if (this.type !== e.Bytes)
                                return L.push(this.readVarint(N));
                            var G = l(this);
                            for (L = L || []; this.pos < G; )
                                L.push(this.readVarint(N));
                            return L
                        },
                        readPackedSVarint: function(L) {
                            if (this.type !== e.Bytes)
                                return L.push(this.readSVarint());
                            var N = l(this);
                            for (L = L || []; this.pos < N; )
                                L.push(this.readSVarint());
                            return L
                        },
                        readPackedBoolean: function(L) {
                            if (this.type !== e.Bytes)
                                return L.push(this.readBoolean());
                            var N = l(this);
                            for (L = L || []; this.pos < N; )
                                L.push(this.readBoolean());
                            return L
                        },
                        readPackedFloat: function(L) {
                            if (this.type !== e.Bytes)
                                return L.push(this.readFloat());
                            var N = l(this);
                            for (L = L || []; this.pos < N; )
                                L.push(this.readFloat());
                            return L
                        },
                        readPackedDouble: function(L) {
                            if (this.type !== e.Bytes)
                                return L.push(this.readDouble());
                            var N = l(this);
                            for (L = L || []; this.pos < N; )
                                L.push(this.readDouble());
                            return L
                        },
                        readPackedFixed32: function(L) {
                            if (this.type !== e.Bytes)
                                return L.push(this.readFixed32());
                            var N = l(this);
                            for (L = L || []; this.pos < N; )
                                L.push(this.readFixed32());
                            return L
                        },
                        readPackedSFixed32: function(L) {
                            if (this.type !== e.Bytes)
                                return L.push(this.readSFixed32());
                            var N = l(this);
                            for (L = L || []; this.pos < N; )
                                L.push(this.readSFixed32());
                            return L
                        },
                        readPackedFixed64: function(L) {
                            if (this.type !== e.Bytes)
                                return L.push(this.readFixed64());
                            var N = l(this);
                            for (L = L || []; this.pos < N; )
                                L.push(this.readFixed64());
                            return L
                        },
                        readPackedSFixed64: function(L) {
                            if (this.type !== e.Bytes)
                                return L.push(this.readSFixed64());
                            var N = l(this);
                            for (L = L || []; this.pos < N; )
                                L.push(this.readSFixed64());
                            return L
                        },
                        skip: function(L) {
                            var N = 7 & L;
                            if (N === e.Varint)
                                for (; this.buf[this.pos++] > 127; )
                                    ;
                            else if (N === e.Bytes)
                                this.pos = this.readVarint() + this.pos;
                            else if (N === e.Fixed32)
                                this.pos += 4;
                            else {
                                if (N !== e.Fixed64)
                                    throw new Error("Unimplemented type: " + N);
                                this.pos += 8
                            }
                        },
                        writeTag: function(L, N) {
                            this.writeVarint(L << 3 | N)
                        },
                        realloc: function(L) {
                            for (var N = this.length || 16; N < this.pos + L; )
                                N *= 2;
                            if (N !== this.length) {
                                var G = new Uint8Array(N);
                                G.set(this.buf),
                                this.buf = G,
                                this.length = N
                            }
                        },
                        finish: function() {
                            return this.length = this.pos,
                            this.pos = 0,
                            this.buf.subarray(0, this.length)
                        },
                        writeFixed32: function(L) {
                            this.realloc(4),
                            F(this.buf, L, this.pos),
                            this.pos += 4
                        },
                        writeSFixed32: function(L) {
                            this.realloc(4),
                            F(this.buf, L, this.pos),
                            this.pos += 4
                        },
                        writeFixed64: function(L) {
                            this.realloc(8),
                            F(this.buf, -1 & L, this.pos),
                            F(this.buf, Math.floor(L * a), this.pos + 4),
                            this.pos += 8
                        },
                        writeSFixed64: function(L) {
                            this.realloc(8),
                            F(this.buf, -1 & L, this.pos),
                            F(this.buf, Math.floor(L * a), this.pos + 4),
                            this.pos += 8
                        },
                        writeVarint: function(L) {
                            (L = +L || 0) > 268435455 || L < 0 ? function(N, G) {
                                var X, _e, me, Ne;
                                if (N >= 0 ? (X = N % 4294967296 | 0,
                                _e = N / 4294967296 | 0) : (_e = ~(-N / 4294967296),
                                4294967295 ^ (X = ~(-N % 4294967296)) ? X = X + 1 | 0 : (X = 0,
                                _e = _e + 1 | 0)),
                                N >= 0x10000000000000000 || N < -0x10000000000000000)
                                    throw new Error("Given varint doesn't fit into 10 bytes");
                                G.realloc(10),
                                me = X,
                                (Ne = G).buf[Ne.pos++] = 127 & me | 128,
                                me >>>= 7,
                                Ne.buf[Ne.pos++] = 127 & me | 128,
                                me >>>= 7,
                                Ne.buf[Ne.pos++] = 127 & me | 128,
                                me >>>= 7,
                                Ne.buf[Ne.pos++] = 127 & me | 128,
                                Ne.buf[Ne.pos] = 127 & (me >>>= 7),
                                function(me, pe) {
                                    var Ne = (7 & me) << 4;
                                    pe.buf[pe.pos++] |= Ne | ((me >>>= 3) ? 128 : 0),
                                    me && (pe.buf[pe.pos++] = 127 & me | ((me >>>= 7) ? 128 : 0),
                                    me && (pe.buf[pe.pos++] = 127 & me | ((me >>>= 7) ? 128 : 0),
                                    me && (pe.buf[pe.pos++] = 127 & me | ((me >>>= 7) ? 128 : 0),
                                    me && (pe.buf[pe.pos++] = 127 & me | ((me >>>= 7) ? 128 : 0),
                                    me && (pe.buf[pe.pos++] = 127 & me)))))
                                }(_e, G)
                            }(L, this) : (this.realloc(4),
                            this.buf[this.pos++] = 127 & L | (L > 127 ? 128 : 0),
                            L <= 127 || (this.buf[this.pos++] = 127 & (L >>>= 7) | (L > 127 ? 128 : 0),
                            L <= 127 || (this.buf[this.pos++] = 127 & (L >>>= 7) | (L > 127 ? 128 : 0),
                            L <= 127 || (this.buf[this.pos++] = L >>> 7 & 127))))
                        },
                        writeSVarint: function(L) {
                            this.writeVarint(L < 0 ? 2 * -L - 1 : 2 * L)
                        },
                        writeBoolean: function(L) {
                            this.writeVarint(!!L)
                        },
                        writeString: function(L) {
                            L = String(L),
                            this.realloc(4 * L.length),
                            this.pos++;
                            var N = this.pos;
                            this.pos = function(X, _e, me) {
                                for (var pe, Ne, Pe = 0; Pe < _e.length; Pe++) {
                                    if ((pe = _e.charCodeAt(Pe)) > 55295 && pe < 57344) {
                                        if (!Ne) {
                                            pe > 56319 || Pe + 1 === _e.length ? (X[me++] = 239,
                                            X[me++] = 191,
                                            X[me++] = 189) : Ne = pe;
                                            continue
                                        }
                                        if (pe < 56320) {
                                            X[me++] = 239,
                                            X[me++] = 191,
                                            X[me++] = 189,
                                            Ne = pe;
                                            continue
                                        }
                                        pe = Ne - 55296 << 10 | pe - 56320 | 65536,
                                        Ne = null
                                    } else
                                        Ne && (X[me++] = 239,
                                        X[me++] = 191,
                                        X[me++] = 189,
                                        Ne = null);
                                    pe < 128 ? X[me++] = pe : (pe < 2048 ? X[me++] = pe >> 6 | 192 : (pe < 65536 ? X[me++] = pe >> 12 | 224 : (X[me++] = pe >> 18 | 240,
                                    X[me++] = pe >> 12 & 63 | 128),
                                    X[me++] = pe >> 6 & 63 | 128),
                                    X[me++] = 63 & pe | 128)
                                }
                                return me
                            }(this.buf, L, this.pos);
                            var G = this.pos - N;
                            G >= 128 && g(N, G, this),
                            this.pos = N - 1,
                            this.writeVarint(G),
                            this.pos += G
                        },
                        writeFloat: function(L) {
                            this.realloc(4),
                            n.write(this.buf, L, this.pos, !0, 23, 4),
                            this.pos += 4
                        },
                        writeDouble: function(L) {
                            this.realloc(8),
                            n.write(this.buf, L, this.pos, !0, 52, 8),
                            this.pos += 8
                        },
                        writeBytes: function(L) {
                            var N = L.length;
                            this.writeVarint(N),
                            this.realloc(N);
                            for (var G = 0; G < N; G++)
                                this.buf[this.pos++] = L[G]
                        },
                        writeRawMessage: function(L, N) {
                            this.pos++;
                            var G = this.pos;
                            L(N, this);
                            var X = this.pos - G;
                            X >= 128 && g(G, X, this),
                            this.pos = G - 1,
                            this.writeVarint(X),
                            this.pos += X
                        },
                        writeMessage: function(L, N, G) {
                            this.writeTag(L, e.Bytes),
                            this.writeRawMessage(N, G)
                        },
                        writePackedVarint: function(L, N) {
                            N.length && this.writeMessage(L, x, N)
                        },
                        writePackedSVarint: function(L, N) {
                            N.length && this.writeMessage(L, T, N)
                        },
                        writePackedBoolean: function(L, N) {
                            N.length && this.writeMessage(L, P, N)
                        },
                        writePackedFloat: function(L, N) {
                            N.length && this.writeMessage(L, f, N)
                        },
                        writePackedDouble: function(L, N) {
                            N.length && this.writeMessage(L, b, N)
                        },
                        writePackedFixed32: function(L, N) {
                            N.length && this.writeMessage(L, v, N)
                        },
                        writePackedSFixed32: function(L, N) {
                            N.length && this.writeMessage(L, w, N)
                        },
                        writePackedFixed64: function(L, N) {
                            N.length && this.writeMessage(L, C, N)
                        },
                        writePackedSFixed64: function(L, N) {
                            N.length && this.writeMessage(L, A, N)
                        },
                        writeBytesField: function(L, N) {
                            this.writeTag(L, e.Bytes),
                            this.writeBytes(N)
                        },
                        writeFixed32Field: function(L, N) {
                            this.writeTag(L, e.Fixed32),
                            this.writeFixed32(N)
                        },
                        writeSFixed32Field: function(L, N) {
                            this.writeTag(L, e.Fixed32),
                            this.writeSFixed32(N)
                        },
                        writeFixed64Field: function(L, N) {
                            this.writeTag(L, e.Fixed64),
                            this.writeFixed64(N)
                        },
                        writeSFixed64Field: function(L, N) {
                            this.writeTag(L, e.Fixed64),
                            this.writeSFixed64(N)
                        },
                        writeVarintField: function(L, N) {
                            this.writeTag(L, e.Varint),
                            this.writeVarint(N)
                        },
                        writeSVarintField: function(L, N) {
                            this.writeTag(L, e.Varint),
                            this.writeSVarint(N)
                        },
                        writeStringField: function(L, N) {
                            this.writeTag(L, e.Bytes),
                            this.writeString(N)
                        },
                        writeFloatField: function(L, N) {
                            this.writeTag(L, e.Fixed32),
                            this.writeFloat(N)
                        },
                        writeDoubleField: function(L, N) {
                            this.writeTag(L, e.Fixed64),
                            this.writeDouble(N)
                        },
                        writeBooleanField: function(L, N) {
                            this.writeVarintField(L, !!N)
                        }
                    },
                    im
                }
                var Hp = so(m_());
                function C1(n, e, o) {
                    e.glyphs = [],
                    1 === n && o.readMessage(E1, e)
                }
                function E1(n, e, o) {
                    if (3 === n) {
                        const {id: a, bitmap: u, width: l, height: p, left: g, top: x, advance: T} = o.readMessage(S1, {});
                        e.glyphs.push({
                            id: a,
                            bitmap: new Al({
                                width: l + 6,
                                height: p + 6
                            },u),
                            metrics: {
                                width: l,
                                height: p,
                                left: g,
                                top: x,
                                advance: T
                            }
                        })
                    } else
                        4 === n ? e.ascender = o.readSVarint() : 5 === n && (e.descender = o.readSVarint())
                }
                function S1(n, e, o) {
                    1 === n ? e.id = o.readVarint() : 2 === n ? e.bitmap = o.readBytes() : 3 === n ? e.width = o.readVarint() : 4 === n ? e.height = o.readVarint() : 5 === n ? e.left = o.readSVarint() : 6 === n ? e.top = o.readSVarint() : 7 === n && (e.advance = o.readVarint())
                }
                const rs = {
                    horizontal: 1,
                    vertical: 2,
                    horizontalOnly: 3
                };
                class Hu {
                    constructor() {
                        this.scale = 1,
                        this.fontStack = "",
                        this.image = null
                    }
                    static forText(e, o) {
                        const a = new Hu;
                        return a.scale = e || 1,
                        a.fontStack = o,
                        a
                    }
                    static forImage(e) {
                        const o = new Hu;
                        return o.image = e,
                        o
                    }
                }
                class Gh {
                    constructor() {
                        this.text = "",
                        this.sectionIndex = [],
                        this.sections = [],
                        this.imageSectionID = null
                    }
                    static fromFeature(e, o) {
                        const a = new Gh;
                        for (let u = 0; u < e.sections.length; u++) {
                            const l = e.sections[u];
                            l.image ? a.addImageSection(l) : a.addTextSection(l, o)
                        }
                        return a
                    }
                    length() {
                        return this.text.length
                    }
                    getSection(e) {
                        return this.sections[this.sectionIndex[e]]
                    }
                    getSections() {
                        return this.sections
                    }
                    getSectionIndex(e) {
                        return this.sectionIndex[e]
                    }
                    getCodePoint(e) {
                        return this.text.codePointAt(e)
                    }
                    verticalizePunctuation(e) {
                        this.text = function(o, a) {
                            let u = "";
                            for (let l = 0; l < o.length; l++) {
                                const p = o.charCodeAt(l + 1) || null
                                  , g = o.charCodeAt(l - 1) || null;
                                u += !a && (p && oi(p) && !Vu[o[l + 1]] || g && oi(g) && !Vu[o[l - 1]]) || !Vu[o[l]] ? o[l] : Vu[o[l]]
                            }
                            return u
                        }(this.text, e)
                    }
                    trim() {
                        let e = 0;
                        for (let a = 0; a < this.text.length && Wp[this.text.charCodeAt(a)]; a++)
                            e++;
                        let o = this.text.length;
                        for (let a = this.text.length - 1; a >= 0 && a >= e && Wp[this.text.charCodeAt(a)]; a--)
                            o--;
                        this.text = this.text.substring(e, o),
                        this.sectionIndex = this.sectionIndex.slice(e, o)
                    }
                    substring(e, o) {
                        const a = new Gh;
                        return a.text = this.text.substring(e, o),
                        a.sectionIndex = this.sectionIndex.slice(e, o),
                        a.sections = this.sections,
                        a
                    }
                    toString() {
                        return this.text
                    }
                    getMaxScale() {
                        return this.sectionIndex.reduce( (e, o) => Math.max(e, this.sections[o].scale), 0)
                    }
                    addTextSection(e, o) {
                        this.text += e.text,
                        this.sections.push(Hu.forText(e.scale, e.fontStack || o));
                        const a = this.sections.length - 1;
                        for (let u = 0; u < e.text.length; ++u)
                            this.sectionIndex.push(a)
                    }
                    addImageSection(e) {
                        const o = e.image && e.image.namePrimary ? e.image.getPrimary() : null;
                        if (!o)
                            return void vo("Can't add FormattedSection with an empty image.");
                        const a = this.getNextImageSectionCharCode();
                        a ? (this.text += String.fromCodePoint(a),
                        this.sections.push(Hu.forImage(o)),
                        this.sectionIndex.push(this.sections.length - 1)) : vo("Reached maximum number of images 6401")
                    }
                    getNextImageSectionCharCode() {
                        return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344,
                        this.imageSectionID)
                    }
                }
                function sm(n, e, o, a, u, l, p, g, x, T, f, b, P, v, w) {
                    const C = Gh.fromFeature(n, u);
                    b === rs.vertical && C.verticalizePunctuation(P);
                    let A = [];
                    const O = function(G, X, _e, me, pe, Ne) {
                        if (!G)
                            return [];
                        const Pe = []
                          , $e = function(rt, at, ot, Ct, Zt, Ot) {
                            let lo = 0;
                            for (let io = 0; io < rt.length(); io++) {
                                const fo = rt.getSection(io);
                                lo += __(rt.getCodePoint(io), fo, Ct, Zt, at, Ot)
                            }
                            return lo / Math.max(1, Math.ceil(lo / ot))
                        }(G, X, _e, me, pe, Ne)
                          , We = G.text.indexOf("\u200b") >= 0;
                        let je = 0;
                        for (let rt = 0; rt < G.length(); rt++) {
                            const at = G.getSection(rt)
                              , ot = G.getCodePoint(rt);
                            if (Wp[ot] || (je += __(ot, at, me, pe, X, Ne)),
                            rt < G.length() - 1) {
                                const Ct = !((Ke = ot) < 11904 || !(kt_Bopomofo_Extended(Ke) || kt_Bopomofo(Ke) || kt_CJK_Compatibility_Forms(Ke) || kt_CJK_Compatibility_Ideographs(Ke) || kt_CJK_Compatibility(Ke) || kt_CJK_Radicals_Supplement(Ke) || kt_CJK_Strokes(Ke) || kt_CJK_Symbols_and_Punctuation(Ke) || kt_CJK_Unified_Ideographs_Extension_A(Ke) || kt_CJK_Unified_Ideographs(Ke) || kt_Enclosed_CJK_Letters_and_Months(Ke) || kt_Halfwidth_and_Fullwidth_Forms(Ke) || kt_Hiragana(Ke) || kt_Ideographic_Description_Characters(Ke) || kt_Kangxi_Radicals(Ke) || kt_Katakana_Phonetic_Extensions(Ke) || kt_Katakana(Ke) || kt_Vertical_Forms(Ke) || kt_Yi_Radicals(Ke) || kt_Yi_Syllables(Ke)));
                                (I1[ot] || Ct || at.image) && Pe.push(y_(rt + 1, je, $e, Pe, A1(ot, G.getCodePoint(rt + 1), Ct && We), !1))
                            }
                        }
                        var Ke;
                        return v_(y_(G.length(), je, $e, Pe, 0, !0))
                    }(C, T, l, e, a, v)
                      , {processBidirectionalText: F, processStyledBidirectionalText: z} = Qn;
                    if (F && 1 === C.sections.length) {
                        const G = F(C.toString(), O);
                        for (const X of G) {
                            const _e = new Gh;
                            _e.text = X,
                            _e.sections = C.sections;
                            for (let me = 0; me < X.length; me++)
                                _e.sectionIndex.push(0);
                            A.push(_e)
                        }
                    } else if (z) {
                        const G = z(C.text, C.sectionIndex, O);
                        for (const X of G) {
                            const _e = new Gh;
                            _e.text = X[0],
                            _e.sectionIndex = X[1],
                            _e.sections = C.sections,
                            A.push(_e)
                        }
                    } else
                        A = function(G, X) {
                            const _e = []
                              , me = G.text;
                            let pe = 0;
                            for (const Ne of X)
                                _e.push(G.substring(pe, Ne)),
                                pe = Ne;
                            return pe < me.length && _e.push(G.substring(pe, me.length)),
                            _e
                        }(C, O);
                    const L = []
                      , N = {
                        positionedLines: L,
                        text: C.toString(),
                        top: f[1],
                        bottom: f[1],
                        left: f[0],
                        right: f[0],
                        writingMode: b,
                        iconsInText: !1,
                        verticalizable: !1,
                        hasBaseline: !1
                    };
                    return function(G, X, _e, me, pe, Ne, Pe, $e, We, je, Ke, rt) {
                        let at = 0
                          , ot = 0
                          , Ct = 0;
                        const Zt = "right" === $e ? 1 : "left" === $e ? 0 : .5;
                        let Ot = !1;
                        for (const ho of pe) {
                            const Ao = ho.getSections();
                            for (const $o of Ao) {
                                if ($o.image)
                                    continue;
                                const Qo = X[$o.fontStack];
                                if (Qo && (Ot = void 0 !== Qo.ascender && void 0 !== Qo.descender,
                                !Ot))
                                    break
                            }
                            if (!Ot)
                                break
                        }
                        let lo = 0;
                        for (const ho of pe) {
                            ho.trim();
                            const Ao = ho.getMaxScale()
                              , $o = 24 * (Ao - 1)
                              , Qo = {
                                positionedGlyphs: [],
                                lineOffset: 0
                            };
                            G.positionedLines[lo] = Qo;
                            const ni = Qo.positionedGlyphs;
                            let di = 0;
                            if (!ho.length()) {
                                ot += Ne,
                                ++lo;
                                continue
                            }
                            let ri = 0
                              , gi = 0;
                            for (let $i = 0; $i < ho.length(); $i++) {
                                const Ko = ho.getSection($i)
                                  , Gi = ho.getSectionIndex($i)
                                  , ki = ho.getCodePoint($i);
                                let Ki = Ko.scale
                                  , Tn = null
                                  , Cn = null
                                  , gn = null
                                  , Er = 24
                                  , nn = 0;
                                const ln = !(We === rs.horizontal || !Ke && !ai(ki) || Ke && (Wp[ki] || (io = ki,
                                kt_Arabic(io) || kt_Arabic_Supplement(io) || kt_Arabic_Extended_A(io) || kt_Arabic_Presentation_Forms_A(io) || kt_Arabic_Presentation_Forms_B(io))));
                                if (Ko.image) {
                                    const mr = me[Ko.image.serialize()];
                                    if (!mr)
                                        continue;
                                    gn = Ko.image.id,
                                    G.iconsInText = G.iconsInText || !0,
                                    Cn = mr.paddedRect;
                                    const En = mr.displaySize;
                                    Ki = 24 * Ki / rt,
                                    Tn = {
                                        width: En[0],
                                        height: En[1],
                                        left: 0,
                                        top: -3,
                                        advance: ln ? En[1] : En[0],
                                        localGlyph: !1
                                    },
                                    nn = Ot ? -Tn.height * Ki : 24 * Ao - 17 - En[1] * Ki,
                                    Er = Tn.advance;
                                    const Rr = (ln ? En[0] : En[1]) * Ki - 24 * Ao;
                                    Rr > 0 && Rr > di && (di = Rr)
                                } else {
                                    const mr = _e[Ko.fontStack];
                                    if (!mr)
                                        continue;
                                    mr[ki] && (Cn = mr[ki]);
                                    const En = X[Ko.fontStack];
                                    if (!En)
                                        continue;
                                    const Rr = En.glyphs[ki];
                                    if (!Rr)
                                        continue;
                                    if (Tn = Rr.metrics,
                                    Er = 8203 !== ki ? 24 : 0,
                                    Ot) {
                                        const Dn = void 0 !== En.ascender ? Math.abs(En.ascender) : 0
                                          , xa = void 0 !== En.descender ? Math.abs(En.descender) : 0
                                          , zl = (Dn + xa) * Ki;
                                        ri < zl && (ri = zl,
                                        gi = (Dn - xa) / 2 * Ki),
                                        nn = -Dn * Ki
                                    } else
                                        nn = 24 * (Ao - Ki) - 17
                                }
                                ln ? (G.verticalizable = !0,
                                ni.push({
                                    glyph: ki,
                                    imageName: gn,
                                    x: at,
                                    y: ot + nn,
                                    vertical: ln,
                                    scale: Ki,
                                    localGlyph: Tn.localGlyph,
                                    fontStack: Ko.fontStack,
                                    sectionIndex: Gi,
                                    metrics: Tn,
                                    rect: Cn
                                }),
                                at += Er * Ki + je) : (ni.push({
                                    glyph: ki,
                                    imageName: gn,
                                    x: at,
                                    y: ot + nn,
                                    vertical: ln,
                                    scale: Ki,
                                    localGlyph: Tn.localGlyph,
                                    fontStack: Ko.fontStack,
                                    sectionIndex: Gi,
                                    metrics: Tn,
                                    rect: Cn
                                }),
                                at += Tn.advance * Ki + je)
                            }
                            0 !== ni.length && (Ct = Math.max(at - je, Ct),
                            Ot ? x_(ni, Zt, di, gi, Ne * Ao / 2) : x_(ni, Zt, di, 0, Ne / 2)),
                            at = 0;
                            const Zi = Ne * Ao + di;
                            Qo.lineOffset = Math.max(di, $o),
                            ot += Zi,
                            ++lo
                        }
                        var io;
                        const fo = ot
                          , {horizontalAlign: Bt, verticalAlign: Ro} = am(Pe);
                        (function(ho, Ao, $o, Qo, ni, di) {
                            const ri = (Ao - $o) * ni
                              , gi = -di * Qo;
                            for (const Zi of ho)
                                for (const $i of Zi.positionedGlyphs)
                                    $i.x += ri,
                                    $i.y += gi
                        }
                        )(G.positionedLines, Zt, Bt, Ro, Ct, fo),
                        G.top += -Ro * fo,
                        G.bottom = G.top + fo,
                        G.left += -Bt * Ct,
                        G.right = G.left + Ct,
                        G.hasBaseline = Ot
                    }(N, e, o, a, A, p, g, x, b, T, P, w),
                    !function(G) {
                        for (const X of G)
                            if (0 !== X.positionedGlyphs.length)
                                return !1;
                        return !0
                    }(L) && N
                }
                const Wp = {
                    9: !0,
                    10: !0,
                    11: !0,
                    12: !0,
                    13: !0,
                    32: !0
                }
                  , I1 = {
                    10: !0,
                    32: !0,
                    38: !0,
                    40: !0,
                    41: !0,
                    43: !0,
                    45: !0,
                    47: !0,
                    173: !0,
                    183: !0,
                    8203: !0,
                    8208: !0,
                    8211: !0,
                    8231: !0
                };
                function __(n, e, o, a, u, l) {
                    if (e.image) {
                        const p = a[e.image.serialize()];
                        return p ? p.displaySize[0] * e.scale * 24 / l + u : 0
                    }
                    {
                        const p = o[e.fontStack]
                          , g = p && p.glyphs[n];
                        return g ? g.metrics.advance * e.scale + u : 0
                    }
                }
                function g_(n, e, o, a) {
                    const u = Math.pow(n - e, 2);
                    return a ? n < e ? u / 2 : 2 * u : u + Math.abs(o) * o
                }
                function A1(n, e, o) {
                    let a = 0;
                    return 10 === n && (a -= 1e4),
                    o && (a += 150),
                    40 !== n && 65288 !== n || (a += 50),
                    41 !== e && 65289 !== e || (a += 50),
                    a
                }
                function y_(n, e, o, a, u, l) {
                    let p = null
                      , g = g_(e, o, u, l);
                    for (const x of a) {
                        const T = g_(e - x.x, o, u, l) + x.badness;
                        T <= g && (p = x,
                        g = T)
                    }
                    return {
                        index: n,
                        x: e,
                        priorBreak: p,
                        badness: g
                    }
                }
                function v_(n) {
                    return n ? v_(n.priorBreak).concat(n.index) : []
                }
                function am(n) {
                    let e = .5
                      , o = .5;
                    switch (n) {
                    case "right":
                    case "top-right":
                    case "bottom-right":
                        e = 1;
                        break;
                    case "left":
                    case "top-left":
                    case "bottom-left":
                        e = 0
                    }
                    switch (n) {
                    case "bottom":
                    case "bottom-right":
                    case "bottom-left":
                        o = 1;
                        break;
                    case "top":
                    case "top-right":
                    case "top-left":
                        o = 0
                    }
                    return {
                        horizontalAlign: e,
                        verticalAlign: o
                    }
                }
                function x_(n, e, o, a, u) {
                    if (!(e || o || a || u))
                        return;
                    const l = n.length - 1
                      , p = n[l]
                      , g = (p.x + p.metrics.advance * p.scale) * e;
                    for (let x = 0; x <= l; x++)
                        n[x].x -= g,
                        n[x].y += o + a + u
                }
                function O1(n, e, o, a) {
                    const {horizontalAlign: u, verticalAlign: l} = am(a)
                      , p = o[0] - n.displaySize[0] * u
                      , g = o[1] - n.displaySize[1] * l;
                    return {
                        imagePrimary: n,
                        imageSecondary: e,
                        top: g,
                        bottom: g + n.displaySize[1],
                        left: p,
                        right: p + n.displaySize[0]
                    }
                }
                function b_(n, e, o, a, u, l) {
                    const p = n.imagePrimary;
                    let g;
                    if (p.content) {
                        const A = p.content
                          , O = p.pixelRatio || 1;
                        g = [A[0] / O, A[1] / O, p.displaySize[0] - A[2] / O, p.displaySize[1] - A[3] / O]
                    }
                    const x = e.left * l
                      , T = e.right * l;
                    let f, b, P, v;
                    "width" === o || "both" === o ? (v = u[0] + x - a[3],
                    b = u[0] + T + a[1]) : (v = u[0] + (x + T - p.displaySize[0]) / 2,
                    b = v + p.displaySize[0]);
                    const w = e.top * l
                      , C = e.bottom * l;
                    return "height" === o || "both" === o ? (f = u[1] + w - a[0],
                    P = u[1] + C + a[2]) : (f = u[1] + (w + C - p.displaySize[1]) / 2,
                    P = f + p.displaySize[1]),
                    {
                        imagePrimary: p,
                        imageSecondary: void 0,
                        top: f,
                        right: b,
                        bottom: P,
                        left: v,
                        collisionPadding: g
                    }
                }
                class Ga extends tt {
                    constructor(e, o, a, u, l) {
                        super(e, o),
                        this.angle = u,
                        this.z = a,
                        void 0 !== l && (this.segment = l)
                    }
                    clone() {
                        return new Ga(this.x,this.y,this.z,this.angle,this.segment)
                    }
                }
                function w_(n, e, o, a, u) {
                    if (void 0 === e.segment)
                        return !0;
                    let l = e
                      , p = e.segment + 1
                      , g = 0;
                    for (; g > -o / 2; ) {
                        if (p--,
                        p < 0)
                            return !1;
                        g -= n[p].dist(l),
                        l = n[p]
                    }
                    g += n[p].dist(n[p + 1]),
                    p++;
                    const x = [];
                    let T = 0;
                    for (; g < o / 2; ) {
                        const f = n[p]
                          , b = n[p + 1];
                        if (!b)
                            return !1;
                        let P = n[p - 1].angleTo(f) - f.angleTo(b);
                        for (P = Math.abs((P + 3 * Math.PI) % (2 * Math.PI) - Math.PI),
                        x.push({
                            distance: g,
                            angleDelta: P
                        }),
                        T += P; g - x[0].distance > a; )
                            T -= x.shift().angleDelta;
                        if (T > u)
                            return !1;
                        p++,
                        g += f.dist(b)
                    }
                    return !0
                }
                function P_(n) {
                    let e = 0;
                    for (let o = 0; o < n.length - 1; o++)
                        e += n[o].dist(n[o + 1]);
                    return e
                }
                function M_(n, e, o) {
                    return n ? .6 * e * o : 0
                }
                function T_(n, e) {
                    return Math.max(n ? n.right - n.left : 0, e ? e.right - e.left : 0)
                }
                function R1(n, e, o, a, u, l) {
                    const p = M_(o, u, l)
                      , g = T_(o, a) * l;
                    let x = 0;
                    const T = P_(n) / 2;
                    for (let f = 0; f < n.length - 1; f++) {
                        const b = n[f]
                          , P = n[f + 1]
                          , v = b.dist(P);
                        if (x + v > T) {
                            const w = (T - x) / v
                              , C = jo(b.x, P.x, w)
                              , A = jo(b.y, P.y, w)
                              , O = new Ga(C,A,0,P.angleTo(b),f);
                            return !p || w_(n, O, g, p, e) ? O : void 0
                        }
                        x += v
                    }
                }
                function D1(n, e, o, a, u, l, p, g, x) {
                    const T = M_(a, l, p)
                      , f = T_(a, u)
                      , b = f * p
                      , P = 0 === n[0].x || n[0].x === x || 0 === n[0].y || n[0].y === x;
                    return e - b < e / 4 && (e = b + e / 4),
                    C_(n, P ? e / 2 * g % e : (f / 2 + 2 * l) * p * g % e, e, T, o, b, P, !1, x)
                }
                function C_(n, e, o, a, u, l, p, g, x) {
                    const T = l / 2
                      , f = P_(n);
                    let b = 0
                      , P = e - o
                      , v = [];
                    for (let w = 0; w < n.length - 1; w++) {
                        const C = n[w]
                          , A = n[w + 1]
                          , O = C.dist(A)
                          , F = A.angleTo(C);
                        for (; P + o < b + O; ) {
                            P += o;
                            const z = (P - b) / O
                              , L = jo(C.x, A.x, z)
                              , N = jo(C.y, A.y, z);
                            if (L >= 0 && L < x && N >= 0 && N < x && P - T >= 0 && P + T <= f) {
                                const G = new Ga(L,N,0,F,w);
                                a && !w_(n, G, l, a, u) || v.push(G)
                            }
                        }
                        b += O
                    }
                    return g || v.length || p || (v = C_(n, b / 2, o, a, u, l, p, !0, x)),
                    v
                }
                function E_(n, e, o, a, u) {
                    const l = [];
                    for (let p = 0; p < n.length; p++) {
                        const g = n[p];
                        let x;
                        for (let T = 0; T < g.length - 1; T++) {
                            let f = g[T]
                              , b = g[T + 1];
                            f.x < e && b.x < e || (f.x < e ? f = new tt(e,f.y + (e - f.x) / (b.x - f.x) * (b.y - f.y))._round() : b.x < e && (b = new tt(e,f.y + (e - f.x) / (b.x - f.x) * (b.y - f.y))._round()),
                            f.y < o && b.y < o || (f.y < o ? f = new tt(f.x + (o - f.y) / (b.y - f.y) * (b.x - f.x),o)._round() : b.y < o && (b = new tt(f.x + (o - f.y) / (b.y - f.y) * (b.x - f.x),o)._round()),
                            f.x >= a && b.x >= a || (f.x >= a ? f = new tt(a,f.y + (a - f.x) / (b.x - f.x) * (b.y - f.y))._round() : b.x >= a && (b = new tt(a,f.y + (a - f.x) / (b.x - f.x) * (b.y - f.y))._round()),
                            f.y >= u && b.y >= u || (f.y >= u ? f = new tt(f.x + (u - f.y) / (b.y - f.y) * (b.x - f.x),u)._round() : b.y >= u && (b = new tt(f.x + (u - f.y) / (b.y - f.y) * (b.x - f.x),u)._round()),
                            x && f.equals(x[x.length - 1]) || (x = [f],
                            l.push(x)),
                            x.push(b)))))
                        }
                    }
                    return l
                }
                function S_(n) {
                    let e = 0
                      , o = 0;
                    for (const p of n)
                        e += p.w * p.h,
                        o = Math.max(o, p.w);
                    n.sort( (p, g) => g.h - p.h);
                    const a = [{
                        x: 0,
                        y: 0,
                        w: Math.max(Math.ceil(Math.sqrt(e / .95)), o),
                        h: 1 / 0
                    }];
                    let u = 0
                      , l = 0;
                    for (const p of n)
                        for (let g = a.length - 1; g >= 0; g--) {
                            const x = a[g];
                            if (!(p.w > x.w || p.h > x.h)) {
                                if (p.x = x.x,
                                p.y = x.y,
                                l = Math.max(l, p.y + p.h),
                                u = Math.max(u, p.x + p.w),
                                p.w === x.w && p.h === x.h) {
                                    const T = a.pop();
                                    g < a.length && (a[g] = T)
                                } else
                                    p.h === x.h ? (x.x += p.w,
                                    x.w -= p.w) : p.w === x.w ? (x.y += p.h,
                                    x.h -= p.h) : (a.push({
                                        x: x.x + p.w,
                                        y: x.y,
                                        w: x.w - p.w,
                                        h: p.h
                                    }),
                                    x.y += p.h,
                                    x.h -= p.h);
                                break
                            }
                        }
                    return {
                        w: u,
                        h: l,
                        fill: e / (u * l) || 0
                    }
                }
                Fe(Ga, "Anchor");
                class lm {
                    constructor(e, {pixelRatio: o, version: a, stretchX: u, stretchY: l, content: p}, g) {
                        this.paddedRect = e,
                        this.pixelRatio = o,
                        this.stretchX = u,
                        this.stretchY = l,
                        this.content = p,
                        this.version = a,
                        this.padding = g
                    }
                    get tl() {
                        return [this.paddedRect.x + this.padding, this.paddedRect.y + this.padding]
                    }
                    get br() {
                        return [this.paddedRect.x + this.paddedRect.w - this.padding, this.paddedRect.y + this.paddedRect.h - this.padding]
                    }
                    get displaySize() {
                        return [(this.paddedRect.w - 2 * this.padding) / this.pixelRatio, (this.paddedRect.h - 2 * this.padding) / this.pixelRatio]
                    }
                }
                class I_ {
                    constructor(e, o, a) {
                        const u = {}
                          , l = {};
                        this.haveRenderCallbacks = [];
                        const p = [];
                        this.addImages(e, u, 1, p),
                        this.addImages(o, l, 2, p);
                        const {w: g, h: x} = S_(p)
                          , T = new hr({
                            width: g || 1,
                            height: x || 1
                        });
                        for (const f in e) {
                            const b = e[f]
                              , P = u[f].paddedRect;
                            hr.copy(b.data, T, {
                                x: 0,
                                y: 0
                            }, {
                                x: P.x + 1,
                                y: P.y + 1
                            }, b.data, a, b.sdf)
                        }
                        for (const f in o) {
                            const b = o[f]
                              , P = l[f].paddedRect;
                            let v = l[f].padding;
                            const w = P.x + v
                              , C = P.y + v
                              , A = b.data.width
                              , O = b.data.height;
                            v = v > 1 ? v - 1 : v,
                            hr.copy(b.data, T, {
                                x: 0,
                                y: 0
                            }, {
                                x: w,
                                y: C
                            }, b.data, a),
                            hr.copy(b.data, T, {
                                x: 0,
                                y: O - v
                            }, {
                                x: w,
                                y: C - v
                            }, {
                                width: A,
                                height: v
                            }, a),
                            hr.copy(b.data, T, {
                                x: 0,
                                y: 0
                            }, {
                                x: w,
                                y: C + O
                            }, {
                                width: A,
                                height: v
                            }, a),
                            hr.copy(b.data, T, {
                                x: A - v,
                                y: 0
                            }, {
                                x: w - v,
                                y: C
                            }, {
                                width: v,
                                height: O
                            }, a),
                            hr.copy(b.data, T, {
                                x: 0,
                                y: 0
                            }, {
                                x: w + A,
                                y: C
                            }, {
                                width: v,
                                height: O
                            }, a),
                            hr.copy(b.data, T, {
                                x: A - v,
                                y: O - v
                            }, {
                                x: w - v,
                                y: C - v
                            }, {
                                width: v,
                                height: v
                            }, a),
                            hr.copy(b.data, T, {
                                x: 0,
                                y: O - v
                            }, {
                                x: w + A,
                                y: C - v
                            }, {
                                width: v,
                                height: v
                            }, a),
                            hr.copy(b.data, T, {
                                x: 0,
                                y: 0
                            }, {
                                x: w + A,
                                y: C + O
                            }, {
                                width: v,
                                height: v
                            }, a),
                            hr.copy(b.data, T, {
                                x: A - v,
                                y: 0
                            }, {
                                x: w - v,
                                y: C + O
                            }, {
                                width: v,
                                height: v
                            }, a)
                        }
                        this.image = T,
                        this.iconPositions = u,
                        this.patternPositions = l
                    }
                    addImages(e, o, a, u) {
                        for (const l in e) {
                            const p = e[l]
                              , g = {
                                x: 0,
                                y: 0,
                                w: p.data.width + 2 * a,
                                h: p.data.height + 2 * a
                            };
                            u.push(g),
                            o[l] = new lm(g,p,a),
                            p.hasRenderCallback && this.haveRenderCallbacks.push(ir.deserializeId(l))
                        }
                    }
                    patchUpdatedImages(e, o, a) {
                        this.haveRenderCallbacks = this.haveRenderCallbacks.filter(u => e.hasImage(u, a)),
                        e.dispatchRenderCallbacks(this.haveRenderCallbacks, a);
                        for (const u in e.getUpdatedImages(a)) {
                            for (const l of Object.keys(this.iconPositions))
                                ir.deserializeId(l) === u && this.patchUpdatedImage(this.iconPositions[l], e.getImage(u, a), o);
                            for (const l of Object.keys(this.patternPositions))
                                ir.deserializeId(l) === u && this.patchUpdatedImage(this.patternPositions[l], e.getImage(u, a), o)
                        }
                    }
                    patchUpdatedImage(e, o, a) {
                        if (!e || !o || e.version === o.version)
                            return;
                        e.version = o.version;
                        const [u,l] = e.tl;
                        a.update(o.data, {
                            position: {
                                x: u,
                                y: l
                            }
                        })
                    }
                }
                Fe(lm, "ImagePosition"),
                Fe(I_, "ImageAtlas");
                const Xu = 1e20;
                function A_(n, e, o, a, u, l, p, g, x) {
                    for (let T = e; T < e + a; T++)
                        O_(n, o * l + T, l, u, p, g, x);
                    for (let T = o; T < o + u; T++)
                        O_(n, T * l + e, 1, a, p, g, x)
                }
                function O_(n, e, o, a, u, l, p) {
                    l[0] = 0,
                    p[0] = -Xu,
                    p[1] = Xu,
                    u[0] = n[e];
                    for (let g = 1, x = 0, T = 0; g < a; g++) {
                        u[g] = n[e + g * o];
                        const f = g * g;
                        do {
                            const b = l[x];
                            T = (u[g] - u[b] + f - b * b) / (g - b) / 2
                        } while (T <= p[x] && --x > -1);
                        x++,
                        l[x] = g,
                        p[x] = T,
                        p[x + 1] = Xu
                    }
                    for (let g = 0, x = 0; g < a; g++) {
                        for (; p[x + 1] < g; )
                            x++;
                        const T = l[x]
                          , f = g - T;
                        n[e + g * o] = u[T] + f * f
                    }
                }
                const cm = {
                    none: 0,
                    ideographs: 1,
                    all: 2
                };
                class jh {
                    constructor(e, o, a) {
                        this.requestManager = e,
                        this.localGlyphMode = o,
                        this.localFontFamily = a,
                        this.urls = {},
                        this.entries = {},
                        this.localGlyphs = {
                            200: {},
                            400: {},
                            500: {},
                            900: {}
                        }
                    }
                    setURL(e, o) {
                        this.urls[o] = e
                    }
                    getGlyphs(e, o, a) {
                        const u = []
                          , l = this.urls[o] || Ee.GLYPHS_URL;
                        for (const p in e)
                            for (const g of e[p])
                                u.push({
                                    stack: p,
                                    id: g
                                });
                        ee(u, ({stack: p, id: g}, x) => {
                            let T = this.entries[p];
                            T || (T = this.entries[p] = {
                                glyphs: {},
                                requests: {},
                                ranges: {},
                                ascender: void 0,
                                descender: void 0
                            });
                            let f = T.glyphs[g];
                            if (void 0 !== f)
                                return void x(null, {
                                    stack: p,
                                    id: g,
                                    glyph: f
                                });
                            if (f = this._tinySDF(T, p, g),
                            f)
                                return T.glyphs[g] = f,
                                void x(null, {
                                    stack: p,
                                    id: g,
                                    glyph: f
                                });
                            const b = Math.floor(g / 256);
                            if (256 * b > 65535)
                                return vo("glyphs > 65535 not supported"),
                                void x(null, {
                                    stack: p,
                                    id: g,
                                    glyph: f
                                });
                            if (T.ranges[b])
                                return void x(null, {
                                    stack: p,
                                    id: g,
                                    glyph: f
                                });
                            let P = T.requests[b];
                            P || (P = T.requests[b] = [],
                            jh.loadGlyphRange(p, b, l, this.requestManager, (v, w) => {
                                if (w) {
                                    T.ascender = w.ascender,
                                    T.descender = w.descender;
                                    for (const C in w.glyphs)
                                        this._doesCharSupportLocalGlyph(+C) || (T.glyphs[+C] = w.glyphs[+C]);
                                    T.ranges[b] = !0
                                }
                                for (const C of P)
                                    C(v, w);
                                delete T.requests[b]
                            }
                            )),
                            P.push( (v, w) => {
                                v ? x(v) : w && x(null, {
                                    stack: p,
                                    id: g,
                                    glyph: w.glyphs[g] || null
                                })
                            }
                            )
                        }
                        , (p, g) => {
                            if (p)
                                a(p);
                            else if (g) {
                                const x = {};
                                for (const {stack: T, id: f, glyph: b} of g)
                                    void 0 === x[T] && (x[T] = {}),
                                    void 0 === x[T].glyphs && (x[T].glyphs = {}),
                                    x[T].glyphs[f] = b && {
                                        id: b.id,
                                        bitmap: b.bitmap.clone(),
                                        metrics: b.metrics
                                    },
                                    x[T].ascender = this.entries[T].ascender,
                                    x[T].descender = this.entries[T].descender;
                                a(null, x)
                            }
                        }
                        )
                    }
                    _doesCharSupportLocalGlyph(e) {
                        return this.localGlyphMode !== cm.none && (this.localGlyphMode === cm.all ? !!this.localFontFamily : !!this.localFontFamily && (kt_CJK_Unified_Ideographs(e) || kt_Hangul_Syllables(e) || kt_Hiragana(e) || kt_Katakana(e) || kt_CJK_Symbols_and_Punctuation(e) || kt_CJK_Unified_Ideographs_Extension_A(e) || kt_CJK_Unified_Ideographs_Extension_B(e) || kt_Osage(e)))
                    }
                    _tinySDF(e, o, a) {
                        const u = this.localFontFamily;
                        if (!u || !this._doesCharSupportLocalGlyph(a))
                            return;
                        let l = e.tinySDF;
                        if (!l) {
                            let C = "400";
                            /bold/i.test(o) ? C = "900" : /medium/i.test(o) ? C = "500" : /light/i.test(o) && (C = "200"),
                            l = e.tinySDF = new jh.TinySDF({
                                fontFamily: u,
                                fontWeight: C,
                                fontSize: 48,
                                buffer: 6,
                                radius: 16
                            }),
                            l.fontWeight = C
                        }
                        if (this.localGlyphs[l.fontWeight][a])
                            return this.localGlyphs[l.fontWeight][a];
                        const p = String.fromCodePoint(a)
                          , {data: g, width: x, height: T, glyphWidth: f, glyphHeight: b, glyphLeft: P, glyphTop: v, glyphAdvance: w} = l.draw(p);
                        return this.localGlyphs[l.fontWeight][a] = {
                            id: a,
                            bitmap: new Al({
                                width: x,
                                height: T
                            },g),
                            metrics: {
                                width: f / 2,
                                height: b / 2,
                                left: P / 2,
                                top: v / 2 - 27,
                                advance: w / 2,
                                localGlyph: !0
                            }
                        }
                    }
                }
                jh.loadGlyphRange = function(n, e, o, a, u) {
                    const l = 256 * e
                      , p = l + 255
                      , g = a.transformRequest(a.normalizeGlyphsURL(o).replace("{fontstack}", n).replace("{range}", "".concat(l, "-").concat(p)), bs.Glyphs);
                    fr(g, (x, T) => {
                        if (x)
                            u(x);
                        else if (T) {
                            const f = {}
                              , b = new Hp(T).readFields(C1, {});
                            for (const P of b.glyphs)
                                f[P.id] = P;
                            u(null, {
                                glyphs: f,
                                ascender: b.ascender,
                                descender: b.descender
                            })
                        }
                    }
                    )
                }
                ,
                jh.TinySDF = class {
                    constructor({fontSize: n=24, buffer: e=3, radius: o=8, cutoff: a=.25, fontFamily: u="sans-serif", fontWeight: l="normal", fontStyle: p="normal"}={}) {
                        this.buffer = e,
                        this.cutoff = a,
                        this.radius = o;
                        const g = this.size = n + 4 * e
                          , x = this._createCanvas(g)
                          , T = this.ctx = x.getContext("2d", {
                            willReadFrequently: !0
                        });
                        T.font = "".concat(p, " ").concat(l, " ").concat(n, "px ").concat(u),
                        T.textBaseline = "alphabetic",
                        T.textAlign = "left",
                        T.fillStyle = "black",
                        this.gridOuter = new Float64Array(g * g),
                        this.gridInner = new Float64Array(g * g),
                        this.f = new Float64Array(g),
                        this.z = new Float64Array(g + 1),
                        this.v = new Uint16Array(g)
                    }
                    _createCanvas(n) {
                        const e = document.createElement("canvas");
                        return e.width = e.height = n,
                        e
                    }
                    draw(n) {
                        const {width: e, actualBoundingBoxAscent: o, actualBoundingBoxDescent: a, actualBoundingBoxLeft: u, actualBoundingBoxRight: l} = this.ctx.measureText(n)
                          , p = Math.ceil(o)
                          , g = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(l - u)))
                          , x = Math.min(this.size - this.buffer, p + Math.ceil(a))
                          , T = g + 2 * this.buffer
                          , f = x + 2 * this.buffer
                          , b = Math.max(T * f, 0)
                          , P = new Uint8ClampedArray(b)
                          , v = {
                            data: P,
                            width: T,
                            height: f,
                            glyphWidth: g,
                            glyphHeight: x,
                            glyphTop: p,
                            glyphLeft: 0,
                            glyphAdvance: e
                        };
                        if (0 === g || 0 === x)
                            return v;
                        const {ctx: w, buffer: C, gridInner: A, gridOuter: O} = this;
                        w.clearRect(C, C, g, x),
                        w.fillText(n, C, C + p);
                        const F = w.getImageData(C, C, g, x);
                        O.fill(Xu, 0, b),
                        A.fill(0, 0, b);
                        for (let z = 0; z < x; z++)
                            for (let L = 0; L < g; L++) {
                                const N = F.data[4 * (z * g + L) + 3] / 255;
                                if (0 === N)
                                    continue;
                                const G = (z + C) * T + L + C;
                                if (1 === N)
                                    O[G] = 0,
                                    A[G] = Xu;
                                else {
                                    const X = .5 - N;
                                    O[G] = X > 0 ? X * X : 0,
                                    A[G] = X < 0 ? X * X : 0
                                }
                            }
                        A_(O, 0, 0, T, f, T, this.f, this.v, this.z),
                        A_(A, C, C, g, x, T, this.f, this.v, this.z);
                        for (let z = 0; z < b; z++) {
                            const L = Math.sqrt(O[z]) - Math.sqrt(A[z]);
                            P[z] = Math.round(255 - 255 * (L / this.radius + this.cutoff))
                        }
                        return v
                    }
                }
                ;
                function R_(n, e) {
                    return n + e[1] - e[0]
                }
                function D_(n, e, o, a, u=1) {
                    const l = []
                      , p = n.imagePrimary
                      , g = p.pixelRatio
                      , x = p.paddedRect.w - 2
                      , T = p.paddedRect.h - 2
                      , f = (n.right - n.left) * u
                      , b = (n.bottom - n.top) * u
                      , P = p.stretchX || [[0, x]]
                      , v = p.stretchY || [[0, T]]
                      , w = P.reduce(R_, 0)
                      , C = v.reduce(R_, 0)
                      , A = x - w
                      , O = T - C;
                    let F = 0
                      , z = w
                      , L = 0
                      , N = C
                      , G = 0
                      , X = A
                      , _e = 0
                      , me = O;
                    if (p.content && a) {
                        const Ne = p.content;
                        F = Xp(P, 0, Ne[0]),
                        L = Xp(v, 0, Ne[1]),
                        z = Xp(P, Ne[0], Ne[2]),
                        N = Xp(v, Ne[1], Ne[3]),
                        G = Ne[0] - F,
                        _e = Ne[1] - L,
                        X = Ne[2] - Ne[0] - z,
                        me = Ne[3] - Ne[1] - N
                    }
                    const pe = (Ne, Pe, $e, We) => {
                        const je = Yp(Ne.stretch - F, z, f, n.left * u)
                          , Ke = Zp(Ne.fixed - G, X, Ne.stretch, w)
                          , rt = Yp(Pe.stretch - L, N, b, n.top * u)
                          , at = Zp(Pe.fixed - _e, me, Pe.stretch, C)
                          , ot = Yp($e.stretch - F, z, f, n.left * u)
                          , Ct = Zp($e.fixed - G, X, $e.stretch, w)
                          , Zt = Yp(We.stretch - L, N, b, n.top * u)
                          , Ot = Zp(We.fixed - _e, me, We.stretch, C)
                          , lo = new tt(je,rt)
                          , io = new tt(ot,rt)
                          , fo = new tt(ot,Zt)
                          , Bt = new tt(je,Zt)
                          , Ro = new tt(Ke / g,at / g)
                          , ho = new tt(Ct / g,Ot / g)
                          , Ao = e * Math.PI / 180;
                        if (Ao) {
                            const gi = Math.sin(Ao)
                              , Zi = Math.cos(Ao)
                              , $i = [Zi, -gi, gi, Zi];
                            lo._matMult($i),
                            io._matMult($i),
                            Bt._matMult($i),
                            fo._matMult($i)
                        }
                        const $o = Ne.stretch + Ne.fixed
                          , Qo = $e.stretch + $e.fixed
                          , ni = Pe.stretch + Pe.fixed
                          , di = We.stretch + We.fixed
                          , ri = n.imageSecondary;
                        return {
                            tl: lo,
                            tr: io,
                            bl: Bt,
                            br: fo,
                            texPrimary: {
                                x: p.paddedRect.x + 1 + $o,
                                y: p.paddedRect.y + 1 + ni,
                                w: Qo - $o,
                                h: di - ni
                            },
                            texSecondary: ri ? {
                                x: ri.paddedRect.x + 1 + $o,
                                y: ri.paddedRect.y + 1 + ni,
                                w: Qo - $o,
                                h: di - ni
                            } : void 0,
                            writingMode: void 0,
                            glyphOffset: [0, 0],
                            sectionIndex: 0,
                            pixelOffsetTL: Ro,
                            pixelOffsetBR: ho,
                            minFontScaleX: X / g / f,
                            minFontScaleY: me / g / b,
                            isSDF: o
                        }
                    }
                    ;
                    if (a && (p.stretchX || p.stretchY)) {
                        const Ne = L_(P, A, w)
                          , Pe = L_(v, O, C);
                        for (let $e = 0; $e < Ne.length - 1; $e++) {
                            const We = Ne[$e]
                              , je = Ne[$e + 1];
                            for (let Ke = 0; Ke < Pe.length - 1; Ke++)
                                l.push(pe(We, Pe[Ke], je, Pe[Ke + 1]))
                        }
                    } else
                        l.push(pe({
                            fixed: 0,
                            stretch: -1
                        }, {
                            fixed: 0,
                            stretch: -1
                        }, {
                            fixed: 0,
                            stretch: x + 1
                        }, {
                            fixed: 0,
                            stretch: T + 1
                        }));
                    return l
                }
                function Xp(n, e, o) {
                    let a = 0;
                    for (const u of n)
                        a += Math.max(e, Math.min(o, u[1])) - Math.max(e, Math.min(o, u[0]));
                    return a
                }
                function L_(n, e, o) {
                    const a = [{
                        fixed: -1,
                        stretch: 0
                    }];
                    for (const [u,l] of n) {
                        const p = a[a.length - 1];
                        a.push({
                            fixed: u - p.stretch,
                            stretch: p.stretch
                        }),
                        a.push({
                            fixed: u - p.stretch,
                            stretch: p.stretch + (l - u)
                        })
                    }
                    return a.push({
                        fixed: e + 1,
                        stretch: o
                    }),
                    a
                }
                function Yp(n, e, o, a) {
                    return n / e * o + a
                }
                function Zp(n, e, o, a) {
                    return n - e * o / a
                }
                function L1(n, e, o, a) {
                    const u = e + n.positionedLines[a].lineOffset;
                    return 0 === a ? o + u / 2 : o + (u + (e + n.positionedLines[a - 1].lineOffset)) / 2
                }
                function F1(n, e=1, o=!1) {
                    let a = 1 / 0
                      , u = 1 / 0
                      , l = -1 / 0
                      , p = -1 / 0;
                    const g = n[0];
                    for (let v = 0; v < g.length; v++) {
                        const w = g[v];
                        (!v || w.x < a) && (a = w.x),
                        (!v || w.y < u) && (u = w.y),
                        (!v || w.x > l) && (l = w.x),
                        (!v || w.y > p) && (p = w.y)
                    }
                    const x = Math.min(l - a, p - u);
                    let T = x / 2;
                    const f = new rl([],k1);
                    if (0 === x)
                        return new tt(a,u);
                    for (let v = a; v < l; v += x)
                        for (let w = u; w < p; w += x)
                            f.push(new Vh(v + T,w + T,T,n));
                    let b = function(v) {
                        let w = 0
                          , C = 0
                          , A = 0;
                        const O = v[0];
                        for (let F = 0, z = O.length, L = z - 1; F < z; L = F++) {
                            const N = O[F]
                              , G = O[L]
                              , X = N.x * G.y - G.x * N.y;
                            C += (N.x + G.x) * X,
                            A += (N.y + G.y) * X,
                            w += 3 * X
                        }
                        return new Vh(C / w,A / w,0,v)
                    }(n)
                      , P = f.length;
                    for (; f.length; ) {
                        const v = f.pop();
                        (v.d > b.d || !b.d) && (b = v,
                        o && console.log("found best %d after %d probes", Math.round(1e4 * v.d) / 1e4, P)),
                        v.max - b.d <= e || (T = v.h / 2,
                        f.push(new Vh(v.p.x - T,v.p.y - T,T,n)),
                        f.push(new Vh(v.p.x + T,v.p.y - T,T,n)),
                        f.push(new Vh(v.p.x - T,v.p.y + T,T,n)),
                        f.push(new Vh(v.p.x + T,v.p.y + T,T,n)),
                        P += 4)
                    }
                    return o && (console.log("num probes: ".concat(P)),
                    console.log("best distance: ".concat(b.d))),
                    b.p
                }
                function k1(n, e) {
                    return e.max - n.max
                }
                class Vh {
                    constructor(e, o, a, u) {
                        this.p = new tt(e,o),
                        this.h = a,
                        this.d = function(l, p) {
                            let g = !1
                              , x = 1 / 0;
                            for (let T = 0; T < p.length; T++) {
                                const f = p[T];
                                for (let b = 0, P = f.length, v = P - 1; b < P; v = b++) {
                                    const w = f[b]
                                      , C = f[v];
                                    w.y > l.y != C.y > l.y && l.x < (C.x - w.x) * (l.y - w.y) / (C.y - w.y) + w.x && (g = !g),
                                    x = Math.min(x, ke(l, w, C))
                                }
                            }
                            return (g ? 1 : -1) * Math.sqrt(x)
                        }(this.p, u),
                        this.max = this.d + this.h * Math.SQRT2
                    }
                }
                const hm = Number.POSITIVE_INFINITY
                  , z1 = Math.sqrt(2);
                function F_(n, [e,o]) {
                    let a = 0
                      , u = 0;
                    if (o === hm) {
                        e < 0 && (e = 0);
                        const l = e / z1;
                        switch (n) {
                        case "top-right":
                        case "top-left":
                            u = l - 7;
                            break;
                        case "bottom-right":
                        case "bottom-left":
                            u = 7 - l;
                            break;
                        case "bottom":
                            u = 7 - e;
                            break;
                        case "top":
                            u = e - 7
                        }
                        switch (n) {
                        case "top-right":
                        case "bottom-right":
                            a = -l;
                            break;
                        case "top-left":
                        case "bottom-left":
                            a = l;
                            break;
                        case "left":
                            a = e;
                            break;
                        case "right":
                            a = -e
                        }
                    } else {
                        switch (e = Math.abs(e),
                        o = Math.abs(o),
                        n) {
                        case "top-right":
                        case "top-left":
                        case "top":
                            u = o - 7;
                            break;
                        case "bottom-right":
                        case "bottom-left":
                        case "bottom":
                            u = 7 - o
                        }
                        switch (n) {
                        case "top-right":
                        case "bottom-right":
                        case "right":
                            a = -e;
                            break;
                        case "top-left":
                        case "bottom-left":
                        case "left":
                            a = e
                        }
                    }
                    return [a, u]
                }
                function um(n) {
                    switch (n) {
                    case "right":
                    case "top-right":
                    case "bottom-right":
                        return "right";
                    case "left":
                    case "top-left":
                    case "bottom-left":
                        return "left"
                    }
                    return "center"
                }
                function B1(n, e, o, a, u, l, p, g, x, T, f, b, P, v, w, C) {
                    let A = l.textMaxSize.evaluate(e, {}, P);
                    void 0 === A ? A = p * l.textScaleFactor : A *= l.textScaleFactor;
                    const O = n.layers[0].layout
                      , F = O.get("icon-offset").evaluate(e, {}, P)
                      , z = z_(o.horizontal) || o.vertical
                      , L = "globe" === v.name
                      , G = p * l.textScaleFactor / 24
                      , X = n.tilePixelRatio * A / 24
                      , _e = (Ke = n.overscaling,
                    n.zoom > 18 && Ke > 2 && (Ke >>= 1),
                    Math.max(uo / (512 * Ke), 1) * O.get("symbol-spacing"))
                      , me = O.get("text-padding") * n.tilePixelRatio
                      , pe = O.get("icon-padding") * n.tilePixelRatio
                      , Ne = _o(O.get("text-max-angle"))
                      , Pe = "map" === O.get("text-rotation-alignment") && "point" !== O.get("symbol-placement")
                      , $e = "map" === O.get("icon-rotation-alignment") && "point" !== O.get("symbol-placement")
                      , We = O.get("symbol-placement")
                      , je = _e / 2;
                    var Ke;
                    const rt = O.get("icon-text-fit").evaluate(e, {}, P)
                      , at = O.get("icon-text-fit-padding").evaluate(e, {}, P)
                      , ot = "none" !== rt;
                    let Ct;
                    !1 === n.hasAnyIconTextFit && ot && (n.hasAnyIconTextFit = !0),
                    a && ot && (n.allowVerticalPlacement && o.vertical && (Ct = b_(a, o.vertical, rt, at, F, G)),
                    z && (a = b_(a, z, rt, at, F, G)));
                    const Zt = (Ot, lo, io) => {
                        if (lo.x < 0 || lo.x >= uo || lo.y < 0 || lo.y >= uo)
                            return;
                        let fo = null;
                        if (L) {
                            const {x: Bt, y: Ro, z: ho} = v.projectTilePoint(lo.x, lo.y, io);
                            fo = {
                                anchor: new Ga(Bt,Ro,ho,0,void 0),
                                up: v.upVector(io, lo.x, lo.y)
                            }
                        }
                        !function(Bt, Ro, ho, Ao, $o, Qo, ni, di, ri, gi, Zi, $i, Ko, Gi, ki, Ki, Tn, Cn, gn, Er, nn, ln, mr, En, Rr, Dn, xa, zl) {
                            const Bl = Bt.addToLineVertexArray(Ro, Ao);
                            let ja, Ul, Nl, Pd, f0, _0, g0, y0 = 0, v0 = 0, x0 = 0, b0 = 0, Wm = -1, Xm = -1;
                            const ba = {};
                            let w0 = Xa("");
                            const $c = ho ? ho.anchor : Ro
                              , Ym = "none" !== ri.layout.get("icon-text-fit").evaluate(nn, {}, Dn);
                            let Zm = 0
                              , Km = 0;
                            if (void 0 === ri._unevaluatedLayout.getValue("text-radial-offset") ? [Zm,Km] = ri.layout.get("text-offset").evaluate(nn, {}, Dn).map(as => 24 * as) : (Zm = 24 * ri.layout.get("text-radial-offset").evaluate(nn, {}, Dn),
                            Km = hm),
                            Bt.allowVerticalPlacement && $o.vertical) {
                                const as = $o.vertical;
                                if (ki)
                                    _0 = pm(as),
                                    di && (g0 = pm(di));
                                else {
                                    const Vr = ri.layout.get("text-rotate").evaluate(nn, {}, Dn) + 90;
                                    Nl = Kp(gi, $c, Ro, Zi, $i, Ko, as, Gi, Vr, Ki),
                                    di && (Pd = Kp(gi, $c, Ro, Zi, $i, Ko, di, Cn, Vr))
                                }
                            }
                            if (Qo) {
                                const as = Bt.iconSizeData
                                  , Vr = En ? jp(Bt.iconSizeData, Bt.layers[0]._unevaluatedLayout._values["icon-size"], Dn, Bt.zoom, nn) : 1
                                  , tu = ri.layout.get("icon-rotate").evaluate(nn, {}, Dn)
                                  , P0 = D_(Qo, tu, mr, Ym, En ? 1 / Vr : ln.iconScaleFactor)
                                  , Jm = di ? D_(di, tu, mr, Ym, ln.iconScaleFactor) : void 0;
                                Ul = Kp(gi, $c, Ro, Zi, $i, Ko, Qo, Cn, tu, null, En ? ln.iconScaleFactor * Vr : 1),
                                y0 = 4 * P0.length;
                                let Gc = null;
                                "source" === as.kind ? (Gc = [Bs * ri.layout.get("icon-size").evaluate(nn, {}, Dn) * ln.iconScaleFactor],
                                Gc[0] > Dl && vo("".concat(Bt.layerIds[0], ': Value for "icon-size" is >= ').concat(Yu, '. Reduce your "icon-size".'))) : "composite" === as.kind && (Gc = [Bs * ln.compositeIconSizes[0].evaluate(nn, {}, Dn) * ln.iconScaleFactor, Bs * ln.compositeIconSizes[1].evaluate(nn, {}, Dn) * ln.iconScaleFactor],
                                (Gc[0] > Dl || Gc[1] > Dl) && vo("".concat(Bt.layerIds[0], ': Value for "icon-size" is >= ').concat(Yu, '. Reduce your "icon-size".'))),
                                Bt.addSymbols(Bt.icon, P0, Gc, Er, gn, nn, !1, ho, Ro, Bl.lineStartIndex, Bl.lineLength, -1, Rr, Dn, xa, zl),
                                Wm = Bt.icon.placedSymbolArray.length - 1,
                                Jm && (v0 = 4 * Jm.length,
                                Bt.addSymbols(Bt.icon, Jm, Gc, Er, gn, nn, rs.vertical, ho, Ro, Bl.lineStartIndex, Bl.lineLength, -1, Rr, Dn, xa, zl),
                                Xm = Bt.icon.placedSymbolArray.length - 1)
                            }
                            for (const as in $o.horizontal) {
                                const Vr = $o.horizontal[as];
                                ja || (w0 = Xa(Vr.text),
                                ki ? f0 = pm(Vr) : ja = Kp(gi, $c, Ro, Zi, $i, Ko, Vr, Gi, ri.layout.get("text-rotate").evaluate(nn, {}, Dn), Ki));
                                const tu = 1 === Vr.positionedLines.length;
                                if (x0 += k_(Bt, ho, Ro, Vr, ni, ri, ki, nn, Ki, Bl, $o.vertical ? rs.horizontal : rs.horizontalOnly, tu ? Object.keys($o.horizontal) : [as], ba, Wm, ln, Rr, Dn, xa),
                                tu)
                                    break
                            }
                            $o.vertical && (b0 += k_(Bt, ho, Ro, $o.vertical, ni, ri, ki, nn, Ki, Bl, rs.vertical, ["vertical"], ba, Xm, ln, Rr, Dn, xa));
                            let $l = -1;
                            const qm = (as, Vr) => as ? Math.max(as, Vr) : Vr;
                            $l = qm(f0, $l),
                            $l = qm(_0, $l),
                            $l = qm(g0, $l);
                            const gv = $l > -1 ? 1 : 0;
                            Bt.glyphOffsetArray.length >= 65535 && vo("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"),
                            void 0 !== nn.sortKey && Bt.addToSortKeyRanges(Bt.symbolInstances.length, nn.sortKey),
                            Bt.symbolInstances.emplaceBack(Ro.x, Ro.y, $c.x, $c.y, $c.z, ba.right >= 0 ? ba.right : -1, ba.center >= 0 ? ba.center : -1, ba.left >= 0 ? ba.left : -1, ba.vertical >= 0 ? ba.vertical : -1, Wm, Xm, w0, void 0 !== ja ? ja : Bt.collisionBoxArray.length, void 0 !== ja ? ja + 1 : Bt.collisionBoxArray.length, void 0 !== Nl ? Nl : Bt.collisionBoxArray.length, void 0 !== Nl ? Nl + 1 : Bt.collisionBoxArray.length, void 0 !== Ul ? Ul : Bt.collisionBoxArray.length, void 0 !== Ul ? Ul + 1 : Bt.collisionBoxArray.length, Pd || Bt.collisionBoxArray.length, Pd ? Pd + 1 : Bt.collisionBoxArray.length, Zi, x0, b0, y0, v0, gv, 0, Zm, Km, $l, 0, Ym ? 1 : 0)
                        }(n, lo, fo, Ot, o, a, u, Ct, n.layers[0], n.collisionBoxArray, e.index, e.sourceLayerIndex, n.index, me, Pe, x, 0, pe, $e, F, e, l, T, f, b, P, w, C)
                    }
                    ;
                    if ("line" === We)
                        for (const Ot of E_(e.geometry, 0, 0, uo, uo)) {
                            const lo = D1(Ot, _e, Ne, o.vertical || z, a, 24, X, n.overscaling, uo);
                            for (const io of lo)
                                z && U1(n, z.text, je, io) || Zt(Ot, io, P)
                        }
                    else if ("line-center" === We) {
                        for (const Ot of e.geometry)
                            if (Ot.length > 1) {
                                const lo = R1(Ot, Ne, o.vertical || z, a, 24, X);
                                lo && Zt(Ot, lo, P)
                            }
                    } else if ("Polygon" === e.type)
                        for (const Ot of kp(e.geometry, 0)) {
                            const lo = F1(Ot, 16);
                            Zt(Ot[0], new Ga(lo.x,lo.y,0,0,void 0), P)
                        }
                    else if ("LineString" === e.type)
                        for (const Ot of e.geometry)
                            Zt(Ot, new Ga(Ot[0].x,Ot[0].y,0,0,void 0), P);
                    else if ("Point" === e.type)
                        for (const Ot of e.geometry)
                            for (const lo of Ot)
                                Zt([lo], new Ga(lo.x,lo.y,0,0,void 0), P)
                }
                const Yu = 255
                  , Dl = Yu * Bs;
                function k_(n, e, o, a, u, l, p, g, x, T, f, b, P, v, w, C, A, O) {
                    const F = function(N, G, X, _e, me, pe, Ne, Pe) {
                        const $e = [];
                        if (0 === G.positionedLines.length)
                            return $e;
                        const We = _e.layout.get("text-rotate").evaluate(pe, {}) * Math.PI / 180
                          , je = function(Ct) {
                            const Zt = Ct[0]
                              , Ot = Ct[1]
                              , lo = Zt * Ot;
                            return lo > 0 ? [Zt, -Ot] : lo < 0 ? [-Zt, Ot] : 0 === Zt ? [Ot, Zt] : [Ot, -Zt]
                        }(X);
                        let Ke = Math.abs(G.top - G.bottom);
                        for (const Ct of G.positionedLines)
                            Ke -= Ct.lineOffset;
                        const rt = G.positionedLines.length
                          , at = Ke / rt;
                        let ot = G.top - X[1];
                        for (let Ct = 0; Ct < rt; ++Ct) {
                            const Zt = G.positionedLines[Ct];
                            ot = L1(G, at, ot, Ct);
                            for (const Ot of Zt.positionedGlyphs) {
                                if (!Ot.rect)
                                    continue;
                                const lo = Ot.rect || {};
                                let io = 4
                                  , fo = !0
                                  , Bt = 1
                                  , Ro = 0;
                                if (Ot.imageName) {
                                    const gn = Ne[In.build(Ot.imageName).getSerializedPrimary()];
                                    if (!gn)
                                        continue;
                                    if (gn.sdf) {
                                        vo("SDF images are not supported in formatted text and will be ignored.");
                                        continue
                                    }
                                    fo = !1,
                                    Bt = gn.pixelRatio,
                                    io = 1 / Bt
                                }
                                const ho = (me || Pe) && Ot.vertical
                                  , Ao = Ot.metrics.advance * Ot.scale / 2
                                  , $o = Ot.metrics
                                  , Qo = Ot.rect;
                                if (null === Qo)
                                    continue;
                                Pe && G.verticalizable && (Ro = Ot.imageName ? Ao - Ot.metrics.width * Ot.scale / 2 : 0);
                                const ni = me ? [Ot.x + Ao, Ot.y] : [0, 0];
                                let di = [0, 0]
                                  , ri = [0, 0]
                                  , gi = !1;
                                me || (ho ? (ri = [Ot.x + Ao + je[0], Ot.y + je[1] - Ro],
                                gi = !0) : di = [Ot.x + Ao + X[0], Ot.y + X[1] - Ro]);
                                const Zi = Qo.w * Ot.scale / (Bt * (Ot.localGlyph ? 2 : 1))
                                  , $i = Qo.h * Ot.scale / (Bt * (Ot.localGlyph ? 2 : 1));
                                let Ko, Gi, ki, Ki;
                                if (ho) {
                                    const gn = Ot.y - ot
                                      , Er = new tt(-Ao,Ao - gn)
                                      , nn = -Math.PI / 2
                                      , ln = new tt(...ri);
                                    Ko = new tt(-Ao + di[0],di[1]),
                                    Ko._rotateAround(nn, Er)._add(ln),
                                    Ko.x += -gn + Ao,
                                    Ko.y -= ($o.left - io) * Ot.scale;
                                    const mr = Ot.imageName ? $o.advance * Ot.scale : 24 * Ot.scale
                                      , En = String.fromCodePoint(Ot.glyph);
                                    P1(En) ? Ko.x += (1 - io) * Ot.scale : M1(En) ? Ko.x += mr - $o.height * Ot.scale + (-io - 1) * Ot.scale : Ko.x += Ot.imageName || $o.width + 2 * io === Qo.w && $o.height + 2 * io === Qo.h ? (mr - $i) / 2 : (mr - ($o.height + 2 * io) * Ot.scale) / 2,
                                    Gi = new tt(Ko.x,Ko.y - Zi),
                                    ki = new tt(Ko.x + $i,Ko.y),
                                    Ki = new tt(Ko.x + $i,Ko.y - Zi)
                                } else {
                                    const gn = ($o.left - io) * Ot.scale - Ao + di[0]
                                      , Er = (-$o.top - io) * Ot.scale + di[1]
                                      , nn = gn + Zi
                                      , ln = Er + $i;
                                    Ko = new tt(gn,Er),
                                    Gi = new tt(nn,Er),
                                    ki = new tt(gn,ln),
                                    Ki = new tt(nn,ln)
                                }
                                if (We) {
                                    let gn;
                                    gn = me ? new tt(0,0) : gi ? new tt(je[0],je[1]) : new tt(X[0],X[1]),
                                    Ko._rotateAround(We, gn),
                                    Gi._rotateAround(We, gn),
                                    ki._rotateAround(We, gn),
                                    Ki._rotateAround(We, gn)
                                }
                                const Tn = new tt(0,0)
                                  , Cn = new tt(0,0);
                                $e.push({
                                    tl: Ko,
                                    tr: Gi,
                                    bl: ki,
                                    br: Ki,
                                    texPrimary: lo,
                                    texSecondary: void 0,
                                    writingMode: G.writingMode,
                                    glyphOffset: ni,
                                    sectionIndex: Ot.sectionIndex,
                                    isSDF: fo,
                                    pixelOffsetTL: Tn,
                                    pixelOffsetBR: Cn,
                                    minFontScaleX: 0,
                                    minFontScaleY: 0
                                })
                            }
                        }
                        return $e
                    }(0, a, x, l, p, g, u, n.allowVerticalPlacement)
                      , z = n.textSizeData;
                    let L = null;
                    "source" === z.kind ? (L = [Bs * l.layout.get("text-size").evaluate(g, {}, A) * w.textScaleFactor],
                    L[0] > Dl && vo("".concat(n.layerIds[0], ': Value for "text-size" is >= ').concat(Yu, '. Reduce your "text-size".'))) : "composite" === z.kind && (L = [Bs * w.compositeTextSizes[0].evaluate(g, {}, A) * w.textScaleFactor, Bs * w.compositeTextSizes[1].evaluate(g, {}, A) * w.textScaleFactor],
                    (L[0] > Dl || L[1] > Dl) && vo("".concat(n.layerIds[0], ': Value for "text-size" is >= ').concat(Yu, '. Reduce your "text-size".'))),
                    n.addSymbols(n.text, F, L, x, p, g, f, e, o, T.lineStartIndex, T.lineLength, v, C, A, O, !1);
                    for (const N of b)
                        P[N] = n.text.placedSymbolArray.length - 1;
                    return 4 * F.length
                }
                function z_(n) {
                    for (const e in n)
                        return n[e];
                    return null
                }
                function Kp(n, e, o, a, u, l, p, g, x, T, f=1) {
                    let b = p.top / f
                      , P = p.bottom / f
                      , v = p.left / f
                      , w = p.right / f;
                    const C = p.collisionPadding;
                    if (C && (v -= C[0],
                    b -= C[1],
                    w += C[2],
                    P += C[3]),
                    x) {
                        const A = new tt(v,b)
                          , O = new tt(w,b)
                          , F = new tt(v,P)
                          , z = new tt(w,P)
                          , L = _o(x);
                        let N = new tt(0,0);
                        T && (N = new tt(T[0],T[1])),
                        A._rotateAround(L, N),
                        O._rotateAround(L, N),
                        F._rotateAround(L, N),
                        z._rotateAround(L, N),
                        v = Math.min(A.x, O.x, F.x, z.x),
                        w = Math.max(A.x, O.x, F.x, z.x),
                        b = Math.min(A.y, O.y, F.y, z.y),
                        P = Math.max(A.y, O.y, F.y, z.y)
                    }
                    return n.emplaceBack(e.x, e.y, e.z, o.x, o.y, v, b, w, P, g, a, u, l),
                    n.length - 1
                }
                function pm(n) {
                    n.collisionPadding && (n.top -= n.collisionPadding[1],
                    n.bottom += n.collisionPadding[3]);
                    const e = n.bottom - n.top;
                    return e > 0 ? Math.max(10, e) : null
                }
                function U1(n, e, o, a) {
                    const u = n.compareText;
                    if (e in u) {
                        const l = u[e];
                        for (let p = l.length - 1; p >= 0; p--)
                            if (a.dist(l[p]) < o)
                                return !0
                    } else
                        u[e] = [];
                    return u[e].push(a),
                    !1
                }
                function B_(n, e) {
                    const o = n.fovAboveCenter
                      , a = n.elevation ? n.elevation.getMinElevationBelowMSL() * e : 0
                      , u = (n._camera.position[2] * n.worldSize - a) / Math.cos(n._pitch)
                      , l = Math.sin(o) * u / Math.sin(Math.max(Math.PI / 2 - n._pitch - o, .01));
                    let p = Math.sin(n._pitch) * l + u;
                    const g = u * (1 / n._horizonShift);
                    return n.elevation && 0 !== n.elevation.exaggeration() || (p *= 1 + Math.max(n.zoom - 17, 0)),
                    Math.min(1.01 * p, g)
                }
                function Zu(n, e) {
                    if (!e.isReprojectedInTileSpace)
                        return {
                            scale: 1 << n.z,
                            x: n.x,
                            y: n.y,
                            x2: n.x + 1,
                            y2: n.y + 1,
                            projection: e
                        };
                    const o = Math.pow(2, -n.z)
                      , a = n.x * o
                      , u = (n.x + 1) * o
                      , l = n.y * o
                      , p = (n.y + 1) * o
                      , g = Mr(a)
                      , x = Mr(u)
                      , T = Gn(l)
                      , f = Gn(p)
                      , b = e.project(g, T)
                      , P = e.project(x, T)
                      , v = e.project(x, f)
                      , w = e.project(g, f);
                    let C = Math.min(b.x, P.x, v.x, w.x)
                      , A = Math.min(b.y, P.y, v.y, w.y)
                      , O = Math.max(b.x, P.x, v.x, w.x)
                      , F = Math.max(b.y, P.y, v.y, w.y);
                    const z = o / 16;
                    function L(G, X, _e, me, pe, Ne) {
                        const Pe = (_e + pe) / 2
                          , $e = (me + Ne) / 2
                          , We = e.project(Mr(Pe), Gn($e))
                          , je = Math.max(0, C - We.x, A - We.y, We.x - O, We.y - F);
                        C = Math.min(C, We.x),
                        O = Math.max(O, We.x),
                        A = Math.min(A, We.y),
                        F = Math.max(F, We.y),
                        je > z && (L(G, We, _e, me, Pe, $e),
                        L(We, X, Pe, $e, pe, Ne))
                    }
                    L(b, P, a, l, u, l),
                    L(P, v, u, l, u, p),
                    L(v, w, u, p, a, p),
                    L(w, b, a, p, a, l),
                    C -= z,
                    A -= z,
                    O += z,
                    F += z;
                    const N = 1 / Math.max(O - C, F - A);
                    return {
                        scale: N,
                        x: C * N,
                        y: A * N,
                        x2: O * N,
                        y2: F * N,
                        projection: e
                    }
                }
                function U_(n, {x: e, y: o}, a=0) {
                    return new tt(((e - a) * n.scale - n.x) * uo,(o * n.scale - n.y) * uo)
                }
                const N1 = B.mat4.identity(new Float32Array(16));
                class Ll {
                    constructor(e) {
                        this.spec = e,
                        this.name = e.name,
                        this.wrap = !1,
                        this.requiresDraping = !1,
                        this.supportsWorldCopies = !1,
                        this.supportsTerrain = !1,
                        this.supportsFog = !1,
                        this.supportsFreeCamera = !1,
                        this.zAxisUnit = "meters",
                        this.isReprojectedInTileSpace = !0,
                        this.unsupportedLayers = ["custom"],
                        this.center = [0, 0],
                        this.range = [3.5, 7]
                    }
                    project(e, o) {
                        return {
                            x: 0,
                            y: 0,
                            z: 0
                        }
                    }
                    unproject(e, o) {
                        return new Mi(0,0)
                    }
                    projectTilePoint(e, o, a) {
                        return {
                            x: e,
                            y: o,
                            z: 0
                        }
                    }
                    locationPoint(e, o, a=!0) {
                        return e._coordinatePoint(e.locationCoordinate(o), a)
                    }
                    pixelsPerMeter(e, o) {
                        return ar(1, e) * o
                    }
                    pixelSpaceConversion(e, o, a) {
                        return 1
                    }
                    farthestPixelDistance(e) {
                        return B_(e, e.pixelsPerMeter)
                    }
                    pointCoordinate(e, o, a, u) {
                        const l = e.horizonLineFromTop(!1)
                          , p = new tt(o,Math.max(l, a));
                        return e.rayIntersectionCoordinate(e.pointRayIntersection(p, u))
                    }
                    pointCoordinate3D(e, o, a) {
                        const u = new tt(o,a);
                        if (e.elevation)
                            return e.elevation.pointCoordinate(u);
                        {
                            const l = this.pointCoordinate(e, u.x, u.y, 0);
                            return [l.x, l.y, l.z]
                        }
                    }
                    isPointAboveHorizon(e, o) {
                        if (e.elevation && e.elevation.visibleDemTiles.length)
                            return !this.pointCoordinate3D(e, o.x, o.y);
                        const a = e.horizonLineFromTop();
                        return o.y < a
                    }
                    createInversionMatrix(e, o) {
                        return N1
                    }
                    createTileMatrix(e, o, a) {
                        let u, l, p;
                        const g = a.canonical
                          , x = B.mat4.identity(new Float64Array(16));
                        if (this.isReprojectedInTileSpace) {
                            const T = Zu(g, this);
                            u = 1,
                            l = T.x + a.wrap * T.scale,
                            p = T.y,
                            B.mat4.scale(x, x, [u / T.scale, u / T.scale, e.pixelsPerMeter / o])
                        } else
                            u = o / e.zoomScale(g.z),
                            l = (g.x + Math.pow(2, g.z) * a.wrap) * u,
                            p = g.y * u;
                        return B.mat4.translate(x, x, [l, p, 0]),
                        B.mat4.scale(x, x, [u / uo, u / uo, 1]),
                        x
                    }
                    upVector(e, o, a) {
                        return [0, 0, 1]
                    }
                    upVectorScale(e, o, a) {
                        return {
                            metersToTile: 1
                        }
                    }
                }
                class $1 extends Ll {
                    constructor(e) {
                        super(e),
                        this.range = [4, 7],
                        this.center = e.center || [-96, 37.5];
                        const [o,a] = this.parallels = e.parallels || [29.5, 45.5]
                          , u = Math.sin(_o(o));
                        this.n = (u + Math.sin(_o(a))) / 2,
                        this.c = 1 + u * (2 * this.n - u),
                        this.r0 = Math.sqrt(this.c) / this.n
                    }
                    project(e, o) {
                        const {n: a, c: u, r0: l} = this
                          , p = _o(e - this.center[0])
                          , g = _o(o)
                          , x = Math.sqrt(u - 2 * a * Math.sin(g)) / a;
                        return {
                            x: x * Math.sin(p * a),
                            y: x * Math.cos(p * a) - l,
                            z: 0
                        }
                    }
                    unproject(e, o) {
                        const {n: a, c: u, r0: l} = this
                          , p = l + o;
                        let g = Math.atan2(e, Math.abs(p)) * Math.sign(p);
                        p * a < 0 && (g -= Math.PI * Math.sign(e) * Math.sign(p));
                        const x = _o(this.center[0]) * a;
                        g = Oe(g, -Math.PI - x, Math.PI - x);
                        const T = ie(Lo(g / a) + this.center[0], -180, 180)
                          , f = Math.asin(ie((u - (e * e + p * p) * a * a) / (2 * a), -1, 1))
                          , b = ie(Lo(f), -un, un);
                        return new Mi(T,b)
                    }
                }
                const Ku = 1.340264
                  , qu = -.081106
                  , Ju = 893e-6
                  , Qu = .003796
                  , qp = Math.sqrt(3) / 2;
                class G1 extends Ll {
                    project(e, o) {
                        o = o / 180 * Math.PI,
                        e = e / 180 * Math.PI;
                        const a = Math.asin(qp * Math.sin(o))
                          , u = a * a
                          , l = u * u * u;
                        return {
                            x: .5 * (e * Math.cos(a) / (qp * (Ku + 3 * qu * u + l * (7 * Ju + 9 * Qu * u))) / Math.PI + .5),
                            y: 1 - .5 * (a * (Ku + qu * u + l * (Ju + Qu * u)) / Math.PI + 1),
                            z: 0
                        }
                    }
                    unproject(e, o) {
                        e = (2 * e - .5) * Math.PI;
                        let a = o = (2 * (1 - o) - 1) * Math.PI
                          , u = a * a
                          , l = u * u * u;
                        for (let f, b, P, v = 0; v < 12 && (b = a * (Ku + qu * u + l * (Ju + Qu * u)) - o,
                        P = Ku + 3 * qu * u + l * (7 * Ju + 9 * Qu * u),
                        f = b / P,
                        a = ie(a - f, -Math.PI / 3, Math.PI / 3),
                        u = a * a,
                        l = u * u * u,
                        !(Math.abs(f) < 1e-12)); ++v)
                            ;
                        const p = qp * e * (Ku + 3 * qu * u + l * (7 * Ju + 9 * Qu * u)) / Math.cos(a)
                          , g = Math.asin(Math.sin(a) / qp)
                          , x = ie(180 * p / Math.PI, -180, 180)
                          , T = ie(180 * g / Math.PI, -un, un);
                        return new Mi(x,T)
                    }
                }
                class j1 extends Ll {
                    constructor(e) {
                        super(e),
                        this.wrap = !0,
                        this.supportsWorldCopies = !0
                    }
                    project(e, o) {
                        return {
                            x: .5 + e / 360,
                            y: .5 - o / 360,
                            z: 0
                        }
                    }
                    unproject(e, o) {
                        const a = 360 * (e - .5)
                          , u = ie(360 * (.5 - o), -un, un);
                        return new Mi(a,u)
                    }
                }
                const Hh = Math.PI / 2;
                function Jp(n) {
                    return Math.tan((Hh + n) / 2)
                }
                class V1 extends Ll {
                    constructor(e) {
                        super(e),
                        this.center = e.center || [0, 30];
                        const [o,a] = this.parallels = e.parallels || [30, 30];
                        let u = _o(o)
                          , l = _o(a);
                        this.southernCenter = u + l < 0,
                        this.southernCenter && (u = -u,
                        l = -l);
                        const p = Math.cos(u)
                          , g = Jp(u);
                        this.n = u === l ? Math.sin(u) : Math.log(p / Math.cos(l)) / Math.log(Jp(l) / g),
                        this.f = p * Math.pow(Jp(u), this.n) / this.n
                    }
                    project(e, o) {
                        o = _o(o),
                        this.southernCenter && (o = -o),
                        e = _o(e - this.center[0]);
                        const a = 1e-6
                          , {n: u, f: l} = this;
                        l > 0 ? o < -Hh + a && (o = -Hh + a) : o > Hh - a && (o = Hh - a);
                        const p = l / Math.pow(Jp(o), u);
                        let g = p * Math.sin(u * e)
                          , x = l - p * Math.cos(u * e);
                        return g = .5 * (g / Math.PI + .5),
                        x = .5 * (x / Math.PI + .5),
                        {
                            x: g,
                            y: this.southernCenter ? x : 1 - x,
                            z: 0
                        }
                    }
                    unproject(e, o) {
                        e = (2 * e - .5) * Math.PI,
                        this.southernCenter && (o = 1 - o),
                        o = (2 * (1 - o) - .5) * Math.PI;
                        const {n: a, f: u} = this
                          , l = u - o
                          , p = Math.sign(l)
                          , g = Math.sign(a) * Math.sqrt(e * e + l * l);
                        let x = Math.atan2(e, Math.abs(l)) * p;
                        l * a < 0 && (x -= Math.PI * Math.sign(e) * p);
                        const T = ie(Lo(x / a) + this.center[0], -180, 180)
                          , f = ie(Lo(2 * Math.atan(Math.pow(u / g, 1 / a)) - Hh), -un, un);
                        return new Mi(T,this.southernCenter ? -f : f)
                    }
                }
                class N_ extends Ll {
                    constructor(e) {
                        super(e),
                        this.wrap = !0,
                        this.supportsWorldCopies = !0,
                        this.supportsTerrain = !0,
                        this.supportsFog = !0,
                        this.supportsFreeCamera = !0,
                        this.isReprojectedInTileSpace = !1,
                        this.unsupportedLayers = [],
                        this.range = null
                    }
                    project(e, o) {
                        return {
                            x: gs(e),
                            y: ks(o),
                            z: 0
                        }
                    }
                    unproject(e, o) {
                        const a = Mr(e)
                          , u = Gn(o);
                        return new Mi(a,u)
                    }
                }
                const $_ = _o(un);
                class H1 extends Ll {
                    project(e, o) {
                        const a = (o = _o(o)) * o
                          , u = a * a;
                        return {
                            x: .5 * ((e = _o(e)) * (.8707 - .131979 * a + u * (u * (.003971 * a - .001529 * u) - .013791)) / Math.PI + .5),
                            y: 1 - .5 * (o * (1.007226 + a * (.015085 + u * (.028874 * a - .044475 - .005916 * u))) / Math.PI + 1),
                            z: 0
                        }
                    }
                    unproject(e, o) {
                        e = (2 * e - .5) * Math.PI;
                        let a = o = (2 * (1 - o) - 1) * Math.PI
                          , u = 25
                          , l = 0
                          , p = a * a;
                        do {
                            p = a * a;
                            const T = p * p;
                            l = (a * (1.007226 + p * (.015085 + T * (.028874 * p - .044475 - .005916 * T))) - o) / (1.007226 + p * (.045255 + T * (.259866 * p - .311325 - .005916 * 11 * T))),
                            a = ie(a - l, -$_, $_)
                        } while (Math.abs(l) > 1e-6 && --u > 0);
                        p = a * a;
                        const g = ie(Lo(e / (.8707 + p * (p * (p * p * p * (.003971 - .001529 * p) - .013791) - .131979))), -180, 180)
                          , x = Lo(a);
                        return new Mi(g,x)
                    }
                }
                const G_ = _o(un);
                class W1 extends Ll {
                    project(e, o) {
                        o = _o(o),
                        e = _o(e);
                        const a = Math.cos(o)
                          , u = 2 / Math.PI
                          , l = Math.acos(a * Math.cos(e / 2))
                          , p = Math.sin(l) / l
                          , g = .5 * (e * u + 2 * a * Math.sin(e / 2) / p) || 0
                          , x = .5 * (o + Math.sin(o) / p) || 0;
                        return {
                            x: .5 * (g / Math.PI + .5),
                            y: 1 - .5 * (x / Math.PI + 1),
                            z: 0
                        }
                    }
                    unproject(e, o) {
                        let a = e = (2 * e - .5) * Math.PI
                          , u = o = (2 * (1 - o) - 1) * Math.PI
                          , l = 25;
                        const p = 1e-6;
                        let g = 0
                          , x = 0;
                        do {
                            const T = Math.cos(u)
                              , f = Math.sin(u)
                              , b = 2 * f * T
                              , P = f * f
                              , v = T * T
                              , w = Math.cos(a / 2)
                              , C = Math.sin(a / 2)
                              , A = 2 * w * C
                              , O = C * C
                              , F = 1 - v * w * w
                              , z = F ? 1 / F : 0
                              , L = F ? Math.acos(T * w) * Math.sqrt(1 / F) : 0
                              , N = .5 * (2 * L * T * C + 2 * a / Math.PI) - e
                              , G = .5 * (L * f + u) - o
                              , X = .5 * z * (v * O + L * T * w * P) + 1 / Math.PI
                              , _e = z * (A * b / 4 - L * f * C)
                              , me = .125 * z * (b * C - L * f * v * A)
                              , pe = .5 * z * (P * w + L * O * T) + .5
                              , Ne = _e * me - pe * X;
                            g = (G * _e - N * pe) / Ne,
                            x = (N * me - G * X) / Ne,
                            a = ie(a - g, -Math.PI, Math.PI),
                            u = ie(u - x, -G_, G_)
                        } while ((Math.abs(g) > p || Math.abs(x) > p) && --l > 0);
                        return new Mi(Lo(a),Lo(u))
                    }
                }
                class j_ extends Ll {
                    constructor(e) {
                        super(e),
                        this.center = e.center || [0, 0],
                        this.parallels = e.parallels || [0, 0],
                        this.cosPhi = Math.max(.01, Math.cos(_o(this.parallels[0]))),
                        this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)),
                        this.wrap = !0,
                        this.supportsWorldCopies = !0
                    }
                    project(e, o) {
                        const {scale: a, cosPhi: u} = this;
                        return {
                            x: _o(e) * u * a + .5,
                            y: -Math.sin(_o(o)) / u * a + .5,
                            z: 0
                        }
                    }
                    unproject(e, o) {
                        const {scale: a, cosPhi: u} = this
                          , l = -(o - .5) / a
                          , p = ie(Lo((e - .5) / a) / u, -180, 180)
                          , g = Math.asin(ie(l * u, -1, 1))
                          , x = ie(Lo(g), -un, un);
                        return new Mi(p,x)
                    }
                }
                class X1 extends N_ {
                    constructor(e) {
                        super(e),
                        this.requiresDraping = !0,
                        this.supportsWorldCopies = !1,
                        this.supportsFog = !0,
                        this.zAxisUnit = "pixels",
                        this.unsupportedLayers = ["debug"],
                        this.range = [3, 5]
                    }
                    projectTilePoint(e, o, a) {
                        const u = vi(e, o, a)
                          , l = Wi(bn(a));
                        return B.vec3.transformMat4(u, u, l),
                        {
                            x: u[0],
                            y: u[1],
                            z: u[2]
                        }
                    }
                    locationPoint(e, o) {
                        const a = _a(o.lat, o.lng)
                          , u = B.vec3.normalize([], a)
                          , l = e.elevation ? e.elevation.getAtPointOrZero(e.locationCoordinate(o), e._centerAltitude) : e._centerAltitude
                          , p = ar(1, 0) * uo * l;
                        B.vec3.scaleAndAdd(a, a, u, p);
                        const g = B.mat4.identity(new Float64Array(16));
                        return B.mat4.multiply(g, e.pixelMatrix, e.globeMatrix),
                        B.vec3.transformMat4(a, a, g),
                        new tt(a[0],a[1])
                    }
                    pixelsPerMeter(e, o) {
                        return ar(1, 0) * o
                    }
                    pixelSpaceConversion(e, o, a) {
                        const u = ar(1, e) * o
                          , l = jo(ar(1, 45) * o, u, a);
                        return this.pixelsPerMeter(e, o) / l
                    }
                    createTileMatrix(e, o, a) {
                        const u = tr(bn(a.canonical));
                        return B.mat4.multiply(new Float64Array(16), e.globeMatrix, u)
                    }
                    createInversionMatrix(e, o) {
                        const {center: a} = e
                          , u = Wi(bn(o));
                        return B.mat4.rotateY(u, u, _o(a.lng)),
                        B.mat4.rotateX(u, u, _o(a.lat)),
                        B.mat4.scale(u, u, [e._pixelsPerMercatorPixel, e._pixelsPerMercatorPixel, 1]),
                        Float32Array.from(u)
                    }
                    pointCoordinate(e, o, a, u) {
                        return an(e, o, a, !0) || new h(0,0)
                    }
                    pointCoordinate3D(e, o, a) {
                        const u = this.pointCoordinate(e, o, a, 0);
                        return [u.x, u.y, u.z]
                    }
                    isPointAboveHorizon(e, o) {
                        return !an(e, o.x, o.y, !1)
                    }
                    farthestPixelDistance(e) {
                        const o = function(u, l) {
                            const p = u.cameraToCenterDistance
                              , g = u._centerAltitude * l
                              , x = u._camera
                              , T = u._camera.forward()
                              , f = B.vec3.add([], B.vec3.scale([], T, -p), [0, 0, g])
                              , b = u.worldSize / (2 * Math.PI)
                              , P = [0, 0, -b]
                              , v = u.width / u.height
                              , w = Math.tan(u.fovAboveCenter)
                              , C = B.vec3.scale([], x.up(), w)
                              , A = B.vec3.scale([], x.right(), w * v)
                              , O = B.vec3.normalize([], B.vec3.add([], B.vec3.add([], T, C), A))
                              , F = [];
                            let z;
                            if (new yi(f,O).closestPointOnSphere(P, b, F)) {
                                const L = B.vec3.add([], F, P)
                                  , N = B.vec3.sub([], L, f);
                                z = Math.cos(u.fovAboveCenter) * B.vec3.length(N)
                            } else {
                                const L = B.vec3.sub([], f, P)
                                  , N = B.vec3.sub([], P, f);
                                B.vec3.normalize(N, N);
                                const G = B.vec3.length(L) - b;
                                z = Math.sqrt(G * (G + 2 * b));
                                const X = Math.acos(z / (b + G)) - Math.acos(B.vec3.dot(T, N));
                                z *= Math.cos(X)
                            }
                            return 1.01 * z
                        }(e, this.pixelsPerMeter(e.center.lat, e.worldSize))
                          , a = cr(e.zoom);
                        if (a > 0) {
                            const u = B_(e, ar(1, e.center.lat) * e.worldSize)
                              , l = e.worldSize / (2 * Math.PI)
                              , p = Math.max(e.width, e.height) / e.worldSize * Math.PI;
                            return jo(o, u + l * (1 - Math.cos(p)), Math.pow(a, 10))
                        }
                        return o
                    }
                    upVector(e, o, a) {
                        return vi(o, a, e, 1)
                    }
                    upVectorScale(e) {
                        return {
                            metersToTile: Ei(dn(bn(e)))
                        }
                    }
                }
                function V_(n) {
                    const e = n.parallels
                      , o = !!e && Math.abs(e[0] + e[1]) < .01;
                    switch (n.name) {
                    case "mercator":
                        return new N_(n);
                    case "equirectangular":
                        return new j1(n);
                    case "naturalEarth":
                        return new H1(n);
                    case "equalEarth":
                        return new G1(n);
                    case "winkelTripel":
                        return new W1(n);
                    case "albers":
                        return o ? new j_(n) : new $1(n);
                    case "lambertConformalConic":
                        return o ? new j_(n) : new V1(n);
                    case "globe":
                        return new X1(n)
                    }
                    throw new Error("Invalid projection name: ".concat(n.name))
                }
                const Y1 = Nh.VectorTileFeature.types
                  , Z1 = [{
                    name: "a_fade_opacity",
                    components: 1,
                    type: "Uint8",
                    offset: 0
                }];
                function Qp(n, e, o, a, u, l, p, g, x, T, f, b, P) {
                    const v = g ? Math.min(Dl, Math.round(g[0])) : 0
                      , w = g ? Math.min(Dl, Math.round(g[1])) : 0;
                    n.emplaceBack(e, o, Math.round(32 * a), Math.round(32 * u), l, p, (v << 1) + (x ? 1 : 0), w, 16 * T, 16 * f, 256 * b, 256 * P)
                }
                function ed(n, e, o) {
                    n.emplaceBack(e, o)
                }
                function td(n, e, o, a, u, l, p) {
                    n.emplaceBack(e, o, a, u, l, p)
                }
                function od(n, e, o, a, u) {
                    n.emplaceBack(e, o, a, u),
                    n.emplaceBack(e, o, a, u),
                    n.emplaceBack(e, o, a, u),
                    n.emplaceBack(e, o, a, u)
                }
                function K1(n) {
                    for (const e of n.sections)
                        if (_n(e.text))
                            return !0;
                    return !1
                }
                class dm {
                    constructor(e) {
                        this.layoutVertexArray = new vu,
                        this.indexArray = new Xn,
                        this.programConfigurations = e,
                        this.segments = new mn,
                        this.dynamicLayoutVertexArray = new ua,
                        this.opacityVertexArray = new bu,
                        this.placedSymbolArray = new bp,
                        this.iconTransitioningVertexArray = new da,
                        this.globeExtVertexArray = new xu,
                        this.zOffsetVertexArray = new Ml
                    }
                    isEmpty() {
                        return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length && 0 === this.iconTransitioningVertexArray.length
                    }
                    upload(e, o, a, u, l) {
                        this.isEmpty() || (a && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, d1.members),
                        this.indexBuffer = e.createIndexBuffer(this.indexArray, o),
                        this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, f1.members, !0),
                        this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, Z1, !0),
                        this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = e.createVertexBuffer(this.iconTransitioningVertexArray, g1.members, !0)),
                        this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = e.createVertexBuffer(this.globeExtVertexArray, m1.members, !0)),
                        !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || l) && (this.zOffsetVertexBuffer = e.createVertexBuffer(this.zOffsetVertexArray, _1.members, !0)),
                        this.opacityVertexBuffer.itemSize = 1),
                        (a || u) && this.programConfigurations.upload(e))
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy(),
                        this.dynamicLayoutVertexBuffer.destroy(),
                        this.opacityVertexBuffer.destroy(),
                        this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(),
                        this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(),
                        this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy())
                    }
                }
                Fe(dm, "SymbolBuffers");
                class mm {
                    constructor(e, o, a) {
                        this.layoutVertexArray = new e,
                        this.layoutAttributes = o,
                        this.indexArray = new a,
                        this.segments = new mn,
                        this.collisionVertexArray = new Pu,
                        this.collisionVertexArrayExt = new ua
                    }
                    upload(e) {
                        this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes),
                        this.indexBuffer = e.createIndexBuffer(this.indexArray),
                        this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, y1.members, !0),
                        this.collisionVertexBufferExt = e.createVertexBuffer(this.collisionVertexArrayExt, v1.members, !0)
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.segments.destroy(),
                        this.collisionVertexBuffer.destroy(),
                        this.collisionVertexBufferExt.destroy())
                    }
                }
                Fe(mm, "CollisionBuffers");
                class id {
                    constructor(e) {
                        this.collisionBoxArray = e.collisionBoxArray,
                        this.zoom = e.zoom,
                        this.lut = e.lut,
                        this.overscaling = e.overscaling,
                        this.layers = e.layers,
                        this.layerIds = this.layers.map(p => p.fqid),
                        this.index = e.index,
                        this.pixelRatio = e.pixelRatio,
                        this.sourceLayerIndex = e.sourceLayerIndex,
                        this.hasPattern = !1,
                        this.hasRTLText = !1,
                        this.fullyClipped = !1,
                        this.hasAnyIconTextFit = !1,
                        this.sortKeyRanges = [],
                        this.collisionCircleArray = [],
                        this.placementInvProjMatrix = B.mat4.identity([]),
                        this.placementViewportMatrix = B.mat4.identity([]);
                        const o = this.layers[0]._unevaluatedLayout._values;
                        this.textSizeData = om(this.zoom, o["text-size"]),
                        this.iconSizeData = om(this.zoom, o["icon-size"]);
                        const a = this.layers[0].layout
                          , u = a.get("symbol-sort-key")
                          , l = a.get("symbol-z-order");
                        this.canOverlap = a.get("text-allow-overlap") || a.get("icon-allow-overlap") || a.get("text-ignore-placement") || a.get("icon-ignore-placement"),
                        this.sortFeaturesByKey = "viewport-y" !== l && void 0 !== u.constantOr(1),
                        this.sortFeaturesByY = ("viewport-y" === l || "auto" === l && !this.sortFeaturesByKey) && this.canOverlap,
                        this.writingModes = a.get("text-writing-mode").map(p => rs[p]),
                        this.stateDependentLayerIds = this.layers.filter(p => p.isStateDependent()).map(p => p.id),
                        this.sourceID = e.sourceID,
                        this.projection = e.projection,
                        this.hasAnyZOffset = !1,
                        this.zOffsetSortDirty = !1,
                        this.zOffsetBuffersNeedUpload = a.get("symbol-z-elevate"),
                        this.activeReplacements = [],
                        this.replacementUpdateTime = 0
                    }
                    createArrays() {
                        this.text = new dm(new fa(this.layers,{
                            zoom: this.zoom,
                            lut: this.lut
                        },e => e.startsWith("text") || e.startsWith("symbol"))),
                        this.icon = new dm(new fa(this.layers,{
                            zoom: this.zoom,
                            lut: this.lut
                        },e => e.startsWith("icon") || e.startsWith("symbol"))),
                        this.glyphOffsetArray = new Ec,
                        this.lineVertexArray = new Sc,
                        this.symbolInstances = new Pp
                    }
                    calculateGlyphDependencies(e, o, a, u, l) {
                        for (const p of e) {
                            const g = p.codePointAt(0);
                            if (void 0 === g)
                                break;
                            if (o[g] = !0,
                            u && l && g <= 65535) {
                                const x = Vu[p];
                                x && (o[x.charCodeAt(0)] = !0)
                            }
                        }
                    }
                    updateFootprints(e, o) {}
                    updateReplacement(e, o) {
                        if (o.updateTime === this.replacementUpdateTime)
                            return !1;
                        this.replacementUpdateTime = o.updateTime;
                        const a = o.getReplacementRegionsForTile(e.toUnwrapped(), !0);
                        return !Zd(this.activeReplacements, a) && (this.activeReplacements = a,
                        !0)
                    }
                    populate(e, o, a, u) {
                        const l = this.layers[0]
                          , p = l.layout
                          , g = "globe" === this.projection.name
                          , x = p.get("text-font")
                          , T = p.get("text-field")
                          , f = p.get("icon-image")
                          , [b,P] = p.get("icon-size-scale-range")
                          , v = ie(o.scaleFactor || 1, b, P)
                          , w = ("constant" !== T.value.kind || T.value.value instanceof Nn && !T.value.value.isEmpty() || T.value.value.toString().length > 0) && ("constant" !== x.value.kind || x.value.value.length > 0)
                          , C = "constant" !== f.value.kind || !!f.value.value || Object.keys(f.parameters).length > 0
                          , A = p.get("symbol-sort-key");
                        if (this.features = [],
                        !w && !C)
                            return;
                        const O = o.iconDependencies
                          , F = o.glyphDependencies
                          , z = o.availableImages
                          , L = new Hi(this.zoom);
                        for (const {feature: N, id: G, index: X, sourceLayerIndex: _e} of e) {
                            const me = l._featureFilter.needGeometry
                              , pe = D(N, me);
                            if (!l._featureFilter.filter(L, pe, a))
                                continue;
                            if (me || (pe.geometry = R(N, a, u)),
                            g && 1 !== N.type && a.z <= 5) {
                                const je = pe.geometry
                                  , Ke = .98078528056
                                  , rt = (at, ot) => {
                                    const Ct = vi(at.x, at.y, a, 1)
                                      , Zt = vi(ot.x, ot.y, a, 1);
                                    return B.vec3.dot(Ct, Zt) < Ke
                                }
                                ;
                                for (let at = 0; at < je.length; at++)
                                    je[at] = M(je[at], rt)
                            }
                            let Ne, Pe;
                            if (w) {
                                const je = l.getValueAndResolveTokens("text-field", pe, a, z)
                                  , Ke = Nn.factory(je);
                                K1(Ke) && (this.hasRTLText = !0),
                                (!this.hasRTLText || "unavailable" === Nr() || this.hasRTLText && Qn.isParsed()) && (Ne = w1(Ke, l, pe))
                            }
                            if (C) {
                                const je = l.getValueAndResolveTokens("icon-image", pe, a, z);
                                Pe = je instanceof In ? je : In.build(je)
                            }
                            if (!Ne && !Pe)
                                continue;
                            const $e = this.sortFeaturesByKey ? A.evaluate(pe, {}, a) : void 0
                              , We = {
                                id: G,
                                text: Ne,
                                icon: Pe,
                                index: X,
                                sourceLayerIndex: _e,
                                geometry: pe.geometry,
                                properties: N.properties,
                                type: Y1[N.type],
                                sortKey: $e
                            };
                            if (this.features.push(We),
                            Pe) {
                                const je = jp(this.iconSizeData, this.layers[0]._unevaluatedLayout._values["icon-size"], a, this.zoom, We) * v * this.pixelRatio
                                  , Ke = Pe.getPrimary().scaleSelf(je);
                                if (O[Ke.id] = O[Ke.id] || [],
                                O[Ke.id].push(Ke),
                                Pe.nameSecondary) {
                                    const rt = Pe.getSecondary().scaleSelf(je);
                                    O[rt.id] = O[rt.id] || [],
                                    O[rt.id].push(rt)
                                }
                            }
                            if (Ne) {
                                const je = x.evaluate(pe, {}, a).join(",")
                                  , Ke = "map" === p.get("text-rotation-alignment") && "point" !== p.get("symbol-placement");
                                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(rs.vertical) >= 0;
                                for (const rt of Ne.sections)
                                    if (rt.image) {
                                        const at = rt.image.getPrimary().scaleSelf(this.pixelRatio);
                                        O[at.id] = O[at.id] || [],
                                        O[at.id].push(at)
                                    } else {
                                        const at = Wo(Ne.toString())
                                          , ot = rt.fontStack || je
                                          , Ct = F[ot] = F[ot] || {};
                                        this.calculateGlyphDependencies(rt.text, Ct, Ke, this.allowVerticalPlacement, at)
                                    }
                            }
                        }
                        "line" === p.get("symbol-placement") && (this.features = function(N) {
                            const G = {}
                              , X = {}
                              , _e = [];
                            let me = 0;
                            function pe(We) {
                                _e.push(N[We]),
                                me++
                            }
                            function Ne(We, je, Ke) {
                                const rt = X[We];
                                return delete X[We],
                                X[je] = rt,
                                _e[rt].geometry[0].pop(),
                                _e[rt].geometry[0] = _e[rt].geometry[0].concat(Ke[0]),
                                rt
                            }
                            function Pe(We, je, Ke) {
                                const rt = G[je];
                                return delete G[je],
                                G[We] = rt,
                                _e[rt].geometry[0].shift(),
                                _e[rt].geometry[0] = Ke[0].concat(_e[rt].geometry[0]),
                                rt
                            }
                            function $e(We, je, Ke) {
                                const rt = Ke ? je[0][je[0].length - 1] : je[0][0];
                                return "".concat(We, ":").concat(rt.x, ":").concat(rt.y)
                            }
                            for (let We = 0; We < N.length; We++) {
                                const je = N[We]
                                  , Ke = je.geometry
                                  , rt = je.text ? je.text.toString() : null;
                                if (!rt) {
                                    pe(We);
                                    continue
                                }
                                const at = $e(rt, Ke)
                                  , ot = $e(rt, Ke, !0);
                                if (at in X && ot in G && X[at] !== G[ot]) {
                                    const Ct = Pe(at, ot, Ke)
                                      , Zt = Ne(at, ot, _e[Ct].geometry);
                                    delete G[at],
                                    delete X[ot],
                                    X[$e(rt, _e[Zt].geometry, !0)] = Zt,
                                    _e[Ct].geometry = null
                                } else
                                    at in X ? Ne(at, ot, Ke) : ot in G ? Pe(at, ot, Ke) : (pe(We),
                                    G[at] = me - 1,
                                    X[ot] = me - 1)
                            }
                            return _e.filter(We => We.geometry)
                        }(this.features)),
                        this.sortFeaturesByKey && this.features.sort( (N, G) => N.sortKey - G.sortKey)
                    }
                    update(e, o, a, u, l, p, g) {
                        this.text.programConfigurations.updatePaintArrays(e, o, l, a, u, p, g),
                        this.icon.programConfigurations.updatePaintArrays(e, o, l, a, u, p, g)
                    }
                    updateZOffset() {
                        const e = (l, p, g) => {
                            a += p,
                            a > l.length && l.resize(a);
                            for (let x = -p; x < 0; x++)
                                l.emplace(x + a, g)
                        }
                          , o = (l, p, g) => {
                            u += p,
                            u > l.length && l.resize(u);
                            for (let x = -p; x < 0; x++)
                                l.emplace(x + u, g)
                        }
                        ;
                        if (!this.zOffsetBuffersNeedUpload)
                            return;
                        this.zOffsetBuffersNeedUpload = !1;
                        let a = 0
                          , u = 0;
                        for (let l = 0; l < this.symbolInstances.length; l++) {
                            const p = this.symbolInstances.get(l)
                              , {numHorizontalGlyphVertices: g, numVerticalGlyphVertices: x, numIconVertices: T} = p
                              , f = p.zOffset
                              , b = T > 0;
                            if ((g > 0 || x > 0) && (e(this.text.zOffsetVertexArray, g, f),
                            e(this.text.zOffsetVertexArray, x, f)),
                            b) {
                                const {placedIconSymbolIndex: P, verticalPlacedIconSymbolIndex: v} = p;
                                P >= 0 && o(this.icon.zOffsetVertexArray, T, f),
                                v >= 0 && o(this.icon.zOffsetVertexArray, p.numVerticalIconVertices, f)
                            }
                        }
                        this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray),
                        this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray)
                    }
                    isEmpty() {
                        return 0 === this.symbolInstances.length && !this.hasRTLText
                    }
                    uploadPending() {
                        return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
                    }
                    upload(e) {
                        !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e),
                        this.iconCollisionBox.upload(e)),
                        this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload),
                        this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload),
                        this.uploaded = !0
                    }
                    destroyDebugData() {
                        this.textCollisionBox.destroy(),
                        this.iconCollisionBox.destroy()
                    }
                    getProjection() {
                        return this.projectionInstance || (this.projectionInstance = V_(this.projection)),
                        this.projectionInstance
                    }
                    destroy() {
                        this.text.destroy(),
                        this.icon.destroy(),
                        this.hasDebugData() && this.destroyDebugData()
                    }
                    addToLineVertexArray(e, o) {
                        const a = this.lineVertexArray.length;
                        if (void 0 !== e.segment)
                            for (const {x: u, y: l} of o)
                                this.lineVertexArray.emplaceBack(u, l);
                        return {
                            lineStartIndex: a,
                            lineLength: this.lineVertexArray.length - a
                        }
                    }
                    addSymbols(e, o, a, u, l, p, g, x, T, f, b, P, v, w, C, A) {
                        const O = e.indexArray
                          , F = e.layoutVertexArray
                          , z = e.globeExtVertexArray
                          , L = e.segments.prepareSegment(4 * o.length, F, O, this.canOverlap ? p.sortKey : void 0)
                          , N = this.glyphOffsetArray.length
                          , G = L.vertexLength
                          , X = this.allowVerticalPlacement && g === rs.vertical ? Math.PI / 2 : 0
                          , _e = p.text && p.text.sections;
                        for (let pe = 0; pe < o.length; pe++) {
                            const {tl: Ne, tr: Pe, bl: $e, br: We, texPrimary: je, texSecondary: Ke, pixelOffsetTL: rt, pixelOffsetBR: at, minFontScaleX: ot, minFontScaleY: Ct, glyphOffset: Zt, isSDF: Ot, sectionIndex: lo} = o[pe]
                              , io = L.vertexLength
                              , fo = Zt[1];
                            if (Qp(F, T.x, T.y, Ne.x, fo + Ne.y, je.x, je.y, a, Ot, rt.x, rt.y, ot, Ct),
                            Qp(F, T.x, T.y, Pe.x, fo + Pe.y, je.x + je.w, je.y, a, Ot, at.x, rt.y, ot, Ct),
                            Qp(F, T.x, T.y, $e.x, fo + $e.y, je.x, je.y + je.h, a, Ot, rt.x, at.y, ot, Ct),
                            Qp(F, T.x, T.y, We.x, fo + We.y, je.x + je.w, je.y + je.h, a, Ot, at.x, at.y, ot, Ct),
                            x) {
                                const {x: Bt, y: Ro, z: ho} = x.anchor
                                  , [Ao,$o,Qo] = x.up;
                                td(z, Bt, Ro, ho, Ao, $o, Qo),
                                td(z, Bt, Ro, ho, Ao, $o, Qo),
                                td(z, Bt, Ro, ho, Ao, $o, Qo),
                                td(z, Bt, Ro, ho, Ao, $o, Qo),
                                od(e.dynamicLayoutVertexArray, Bt, Ro, ho, X)
                            } else
                                od(e.dynamicLayoutVertexArray, T.x, T.y, T.z, X);
                            if (A) {
                                const Bt = Ke || je;
                                ed(e.iconTransitioningVertexArray, Bt.x, Bt.y),
                                ed(e.iconTransitioningVertexArray, Bt.x + Bt.w, Bt.y),
                                ed(e.iconTransitioningVertexArray, Bt.x, Bt.y + Bt.h),
                                ed(e.iconTransitioningVertexArray, Bt.x + Bt.w, Bt.y + Bt.h)
                            }
                            O.emplaceBack(io, io + 1, io + 2),
                            O.emplaceBack(io + 1, io + 2, io + 3),
                            L.vertexLength += 4,
                            L.primitiveLength += 2,
                            this.glyphOffsetArray.emplaceBack(Zt[0]),
                            pe !== o.length - 1 && lo === o[pe + 1].sectionIndex || e.programConfigurations.populatePaintArrays(F.length, p, p.index, {}, v, w, C, _e && _e[lo])
                        }
                        const me = x ? x.anchor : T;
                        e.placedSymbolArray.emplaceBack(me.x, me.y, me.z, T.x, T.y, N, this.glyphOffsetArray.length - N, G, f, b, T.segment, a ? a[0] : 0, a ? a[1] : 0, u[0], u[1], g, 0, !1, 0, P, 0)
                    }
                    _commitLayoutVertex(e, o, a, u, l, p, g) {
                        e.emplaceBack(o, a, u, l, p, Math.round(g.x), Math.round(g.y))
                    }
                    _addCollisionDebugVertices(e, o, a, u, l, p, g) {
                        const x = a.segments.prepareSegment(4, a.layoutVertexArray, a.indexArray)
                          , T = x.vertexLength
                          , f = g.tileAnchorX
                          , b = g.tileAnchorY;
                        for (let v = 0; v < 4; v++)
                            a.collisionVertexArray.emplaceBack(0, 0, 0, 0, 0, 0);
                        this._commitDebugCollisionVertexUpdate(a.collisionVertexArrayExt, o, e.padding, g.zOffset),
                        this._commitLayoutVertex(a.layoutVertexArray, u, l, p, f, b, new tt(e.x1,e.y1)),
                        this._commitLayoutVertex(a.layoutVertexArray, u, l, p, f, b, new tt(e.x2,e.y1)),
                        this._commitLayoutVertex(a.layoutVertexArray, u, l, p, f, b, new tt(e.x2,e.y2)),
                        this._commitLayoutVertex(a.layoutVertexArray, u, l, p, f, b, new tt(e.x1,e.y2)),
                        x.vertexLength += 4;
                        const P = a.indexArray;
                        P.emplaceBack(T, T + 1),
                        P.emplaceBack(T + 1, T + 2),
                        P.emplaceBack(T + 2, T + 3),
                        P.emplaceBack(T + 3, T),
                        x.primitiveLength += 4
                    }
                    _addTextDebugCollisionBoxes(e, o, a, u, l, p) {
                        for (let g = u; g < l; g++) {
                            const x = a.get(g)
                              , T = this.getSymbolInstanceTextSize(e, p, o, g);
                            this._addCollisionDebugVertices(x, T, this.textCollisionBox, x.projectedAnchorX, x.projectedAnchorY, x.projectedAnchorZ, p)
                        }
                    }
                    _addIconDebugCollisionBoxes(e, o, a, u, l, p) {
                        for (let g = u; g < l; g++) {
                            const x = a.get(g)
                              , T = this.getSymbolInstanceIconSize(e, o, p.placedIconSymbolIndex);
                            this._addCollisionDebugVertices(x, T, this.iconCollisionBox, x.projectedAnchorX, x.projectedAnchorY, x.projectedAnchorZ, p)
                        }
                    }
                    generateCollisionDebugBuffers(e, o, a) {
                        this.hasDebugData() && this.destroyDebugData(),
                        this.textCollisionBox = new mm(Th,u_.members,da),
                        this.iconCollisionBox = new mm(Th,u_.members,da);
                        const u = $h(this.iconSizeData, e)
                          , l = $h(this.textSizeData, e, a);
                        for (let p = 0; p < this.symbolInstances.length; p++) {
                            const g = this.symbolInstances.get(p);
                            this._addTextDebugCollisionBoxes(l, e, o, g.textBoxStartIndex, g.textBoxEndIndex, g),
                            this._addTextDebugCollisionBoxes(l, e, o, g.verticalTextBoxStartIndex, g.verticalTextBoxEndIndex, g),
                            this._addIconDebugCollisionBoxes(u, e, o, g.iconBoxStartIndex, g.iconBoxEndIndex, g),
                            this._addIconDebugCollisionBoxes(u, e, o, g.verticalIconBoxStartIndex, g.verticalIconBoxEndIndex, g)
                        }
                    }
                    getSymbolInstanceTextSize(e, o, a, u) {
                        const l = this.text.placedSymbolArray.get(o.rightJustifiedTextSymbolIndex >= 0 ? o.rightJustifiedTextSymbolIndex : o.centerJustifiedTextSymbolIndex >= 0 ? o.centerJustifiedTextSymbolIndex : o.leftJustifiedTextSymbolIndex >= 0 ? o.leftJustifiedTextSymbolIndex : o.verticalPlacedTextSymbolIndex >= 0 ? o.verticalPlacedTextSymbolIndex : u)
                          , p = Vp(this.textSizeData, e, l) / 24;
                        return this.tilePixelRatio * p
                    }
                    getSymbolInstanceIconSize(e, o, a) {
                        const u = this.icon.placedSymbolArray.get(a)
                          , l = Vp(this.iconSizeData, e, u);
                        return this.tilePixelRatio * l
                    }
                    _commitDebugCollisionVertexUpdate(e, o, a, u) {
                        e.emplaceBack(o, -a, -a, u),
                        e.emplaceBack(o, a, -a, u),
                        e.emplaceBack(o, a, a, u),
                        e.emplaceBack(o, -a, a, u)
                    }
                    _updateTextDebugCollisionBoxes(e, o, a, u, l, p, g) {
                        for (let x = u; x < l; x++) {
                            const T = a.get(x)
                              , f = this.getSymbolInstanceTextSize(e, p, o, x);
                            this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, f, T.padding, p.zOffset)
                        }
                    }
                    _updateIconDebugCollisionBoxes(e, o, a, u, l, p, g) {
                        for (let x = u; x < l; x++) {
                            const T = a.get(x)
                              , f = this.getSymbolInstanceIconSize(e, o, p.placedIconSymbolIndex);
                            this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, f, T.padding, p.zOffset)
                        }
                    }
                    updateCollisionDebugBuffers(e, o, a, u) {
                        if (!this.hasDebugData())
                            return;
                        this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(),
                        this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
                        const l = $h(this.iconSizeData, e, u)
                          , p = $h(this.textSizeData, e, a);
                        for (let g = 0; g < this.symbolInstances.length; g++) {
                            const x = this.symbolInstances.get(g);
                            this._updateTextDebugCollisionBoxes(p, e, o, x.textBoxStartIndex, x.textBoxEndIndex, x, a),
                            this._updateTextDebugCollisionBoxes(p, e, o, x.verticalTextBoxStartIndex, x.verticalTextBoxEndIndex, x, a),
                            this._updateIconDebugCollisionBoxes(l, e, o, x.iconBoxStartIndex, x.iconBoxEndIndex, x, u),
                            this._updateIconDebugCollisionBoxes(l, e, o, x.verticalIconBoxStartIndex, x.verticalIconBoxEndIndex, x, u)
                        }
                        this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt),
                        this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt)
                    }
                    _deserializeCollisionBoxesForSymbol(e, o, a, u, l, p, g, x, T) {
                        const f = {};
                        if (o < a) {
                            const {x1: b, y1: P, x2: v, y2: w, padding: C, projectedAnchorX: A, projectedAnchorY: O, projectedAnchorZ: F, tileAnchorX: z, tileAnchorY: L, featureIndex: N} = e.get(o);
                            f.textBox = {
                                x1: b,
                                y1: P,
                                x2: v,
                                y2: w,
                                padding: C,
                                projectedAnchorX: A,
                                projectedAnchorY: O,
                                projectedAnchorZ: F,
                                tileAnchorX: z,
                                tileAnchorY: L
                            },
                            f.textFeatureIndex = N
                        }
                        if (u < l) {
                            const {x1: b, y1: P, x2: v, y2: w, padding: C, projectedAnchorX: A, projectedAnchorY: O, projectedAnchorZ: F, tileAnchorX: z, tileAnchorY: L, featureIndex: N} = e.get(u);
                            f.verticalTextBox = {
                                x1: b,
                                y1: P,
                                x2: v,
                                y2: w,
                                padding: C,
                                projectedAnchorX: A,
                                projectedAnchorY: O,
                                projectedAnchorZ: F,
                                tileAnchorX: z,
                                tileAnchorY: L
                            },
                            f.verticalTextFeatureIndex = N
                        }
                        if (p < g) {
                            const {x1: b, y1: P, x2: v, y2: w, padding: C, projectedAnchorX: A, projectedAnchorY: O, projectedAnchorZ: F, tileAnchorX: z, tileAnchorY: L, featureIndex: N} = e.get(p);
                            f.iconBox = {
                                x1: b,
                                y1: P,
                                x2: v,
                                y2: w,
                                padding: C,
                                projectedAnchorX: A,
                                projectedAnchorY: O,
                                projectedAnchorZ: F,
                                tileAnchorX: z,
                                tileAnchorY: L
                            },
                            f.iconFeatureIndex = N
                        }
                        if (x < T) {
                            const {x1: b, y1: P, x2: v, y2: w, padding: C, projectedAnchorX: A, projectedAnchorY: O, projectedAnchorZ: F, tileAnchorX: z, tileAnchorY: L, featureIndex: N} = e.get(x);
                            f.verticalIconBox = {
                                x1: b,
                                y1: P,
                                x2: v,
                                y2: w,
                                padding: C,
                                projectedAnchorX: A,
                                projectedAnchorY: O,
                                projectedAnchorZ: F,
                                tileAnchorX: z,
                                tileAnchorY: L
                            },
                            f.verticalIconFeatureIndex = N
                        }
                        return f
                    }
                    deserializeCollisionBoxes(e) {
                        this.collisionArrays = [];
                        for (let o = 0; o < this.symbolInstances.length; o++) {
                            const a = this.symbolInstances.get(o);
                            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e, a.textBoxStartIndex, a.textBoxEndIndex, a.verticalTextBoxStartIndex, a.verticalTextBoxEndIndex, a.iconBoxStartIndex, a.iconBoxEndIndex, a.verticalIconBoxStartIndex, a.verticalIconBoxEndIndex))
                        }
                    }
                    hasTextData() {
                        return this.text.segments.get().length > 0
                    }
                    hasIconData() {
                        return this.icon.segments.get().length > 0
                    }
                    hasDebugData() {
                        return this.textCollisionBox && this.iconCollisionBox
                    }
                    hasTextCollisionBoxData() {
                        return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
                    }
                    hasIconCollisionBoxData() {
                        return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
                    }
                    hasIconTextFit() {
                        return this.hasAnyIconTextFit
                    }
                    addIndicesForPlacedSymbol(e, o) {
                        const a = e.placedSymbolArray.get(o)
                          , u = a.vertexStartIndex + 4 * a.numGlyphs;
                        for (let l = a.vertexStartIndex; l < u; l += 4)
                            e.indexArray.emplaceBack(l, l + 1, l + 2),
                            e.indexArray.emplaceBack(l + 1, l + 2, l + 3)
                    }
                    getSortedSymbolIndexes(e) {
                        if (this.sortedAngle === e && void 0 !== this.symbolInstanceIndexes)
                            return this.symbolInstanceIndexes;
                        const o = Math.sin(e)
                          , a = Math.cos(e)
                          , u = []
                          , l = []
                          , p = [];
                        for (let g = 0; g < this.symbolInstances.length; ++g) {
                            p.push(g);
                            const x = this.symbolInstances.get(g);
                            u.push(0 | Math.round(o * x.tileAnchorX + a * x.tileAnchorY)),
                            l.push(x.featureIndex)
                        }
                        return p.sort( (g, x) => u[g] - u[x] || l[x] - l[g]),
                        p
                    }
                    getSortedIndexesByZOffset() {
                        if (!this.zOffsetSortDirty)
                            return this.symbolInstanceIndexesSortedZOffset;
                        if (!this.symbolInstanceIndexesSortedZOffset) {
                            this.symbolInstanceIndexesSortedZOffset = [];
                            for (let e = 0; e < this.symbolInstances.length; ++e)
                                this.symbolInstanceIndexesSortedZOffset.push(e)
                        }
                        return this.zOffsetSortDirty = !1,
                        this.symbolInstanceIndexesSortedZOffset.sort( (e, o) => this.symbolInstances.get(o).zOffset - this.symbolInstances.get(e).zOffset)
                    }
                    addToSortKeyRanges(e, o) {
                        const a = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                        a && a.sortKey === o ? a.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({
                            sortKey: o,
                            symbolInstanceStart: e,
                            symbolInstanceEnd: e + 1
                        })
                    }
                    sortFeatures(e) {
                        if (this.sortFeaturesByY && this.sortedAngle !== e && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e),
                            this.sortedAngle = e,
                            this.text.indexArray.clear(),
                            this.icon.indexArray.clear(),
                            this.featureSortOrder = [];
                            for (const o of this.symbolInstanceIndexes) {
                                const a = this.symbolInstances.get(o);
                                this.featureSortOrder.push(a.featureIndex);
                                const {rightJustifiedTextSymbolIndex: u, centerJustifiedTextSymbolIndex: l, leftJustifiedTextSymbolIndex: p, verticalPlacedTextSymbolIndex: g, placedIconSymbolIndex: x, verticalPlacedIconSymbolIndex: T} = a;
                                u >= 0 && this.addIndicesForPlacedSymbol(this.text, u),
                                l >= 0 && l !== u && this.addIndicesForPlacedSymbol(this.text, l),
                                p >= 0 && p !== l && p !== u && this.addIndicesForPlacedSymbol(this.text, p),
                                g >= 0 && this.addIndicesForPlacedSymbol(this.text, g),
                                x >= 0 && this.addIndicesForPlacedSymbol(this.icon, x),
                                T >= 0 && this.addIndicesForPlacedSymbol(this.icon, T)
                            }
                            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray),
                            this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray)
                        }
                    }
                }
                let H_, W_, fm;
                Fe(id, "SymbolBucket", {
                    omit: ["layers", "collisionBoxArray", "features", "compareText"]
                }),
                id.addDynamicAttributes = od;
                class X_ {
                    constructor(e) {
                        this.type = e.property.overrides ? e.property.overrides.runtimeType : Ws,
                        this.defaultValue = e
                    }
                    evaluate(e) {
                        if (e.formattedSection) {
                            const o = this.defaultValue.property.overrides;
                            if (o && o.hasOverride(e.formattedSection))
                                return o.getOverride(e.formattedSection)
                        }
                        return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default
                    }
                    eachChild(e) {
                        this.defaultValue.isConstant() || e(this.defaultValue.value._styleExpression.expression)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        return null
                    }
                }
                Fe(X_, "FormatSectionOverride", {
                    omit: ["defaultValue"]
                });
                const _m = () => fm || (fm = {
                    layout: H_ || (H_ = new cn({
                        "symbol-placement": new eo(ft.layout_symbol["symbol-placement"]),
                        "symbol-spacing": new eo(ft.layout_symbol["symbol-spacing"]),
                        "symbol-avoid-edges": new eo(ft.layout_symbol["symbol-avoid-edges"]),
                        "symbol-sort-key": new Mo(ft.layout_symbol["symbol-sort-key"]),
                        "symbol-z-order": new eo(ft.layout_symbol["symbol-z-order"]),
                        "symbol-z-elevate": new eo(ft.layout_symbol["symbol-z-elevate"]),
                        "symbol-elevation-reference": new eo(ft.layout_symbol["symbol-elevation-reference"]),
                        "icon-allow-overlap": new eo(ft.layout_symbol["icon-allow-overlap"]),
                        "icon-ignore-placement": new eo(ft.layout_symbol["icon-ignore-placement"]),
                        "icon-optional": new eo(ft.layout_symbol["icon-optional"]),
                        "icon-rotation-alignment": new eo(ft.layout_symbol["icon-rotation-alignment"]),
                        "icon-size": new Mo(ft.layout_symbol["icon-size"]),
                        "icon-size-scale-range": new eo(ft.layout_symbol["icon-size-scale-range"]),
                        "icon-text-fit": new Mo(ft.layout_symbol["icon-text-fit"]),
                        "icon-text-fit-padding": new Mo(ft.layout_symbol["icon-text-fit-padding"]),
                        "icon-image": new Mo(ft.layout_symbol["icon-image"]),
                        "icon-rotate": new Mo(ft.layout_symbol["icon-rotate"]),
                        "icon-padding": new eo(ft.layout_symbol["icon-padding"]),
                        "icon-keep-upright": new eo(ft.layout_symbol["icon-keep-upright"]),
                        "icon-offset": new Mo(ft.layout_symbol["icon-offset"]),
                        "icon-anchor": new Mo(ft.layout_symbol["icon-anchor"]),
                        "icon-pitch-alignment": new eo(ft.layout_symbol["icon-pitch-alignment"]),
                        "text-pitch-alignment": new eo(ft.layout_symbol["text-pitch-alignment"]),
                        "text-rotation-alignment": new eo(ft.layout_symbol["text-rotation-alignment"]),
                        "text-field": new Mo(ft.layout_symbol["text-field"]),
                        "text-font": new Mo(ft.layout_symbol["text-font"]),
                        "text-size": new Mo(ft.layout_symbol["text-size"]),
                        "text-size-scale-range": new eo(ft.layout_symbol["text-size-scale-range"]),
                        "text-max-width": new Mo(ft.layout_symbol["text-max-width"]),
                        "text-line-height": new Mo(ft.layout_symbol["text-line-height"]),
                        "text-letter-spacing": new Mo(ft.layout_symbol["text-letter-spacing"]),
                        "text-justify": new Mo(ft.layout_symbol["text-justify"]),
                        "text-radial-offset": new Mo(ft.layout_symbol["text-radial-offset"]),
                        "text-variable-anchor": new eo(ft.layout_symbol["text-variable-anchor"]),
                        "text-anchor": new Mo(ft.layout_symbol["text-anchor"]),
                        "text-max-angle": new eo(ft.layout_symbol["text-max-angle"]),
                        "text-writing-mode": new eo(ft.layout_symbol["text-writing-mode"]),
                        "text-rotate": new Mo(ft.layout_symbol["text-rotate"]),
                        "text-padding": new eo(ft.layout_symbol["text-padding"]),
                        "text-keep-upright": new eo(ft.layout_symbol["text-keep-upright"]),
                        "text-transform": new Mo(ft.layout_symbol["text-transform"]),
                        "text-offset": new Mo(ft.layout_symbol["text-offset"]),
                        "text-allow-overlap": new eo(ft.layout_symbol["text-allow-overlap"]),
                        "text-ignore-placement": new eo(ft.layout_symbol["text-ignore-placement"]),
                        "text-optional": new eo(ft.layout_symbol["text-optional"]),
                        visibility: new eo(ft.layout_symbol.visibility)
                    })),
                    paint: W_ || (W_ = new cn({
                        "icon-opacity": new Mo(ft.paint_symbol["icon-opacity"]),
                        "icon-occlusion-opacity": new Mo(ft.paint_symbol["icon-occlusion-opacity"]),
                        "icon-emissive-strength": new Mo(ft.paint_symbol["icon-emissive-strength"]),
                        "text-emissive-strength": new Mo(ft.paint_symbol["text-emissive-strength"]),
                        "icon-color": new Mo(ft.paint_symbol["icon-color"]),
                        "icon-halo-color": new Mo(ft.paint_symbol["icon-halo-color"]),
                        "icon-halo-width": new Mo(ft.paint_symbol["icon-halo-width"]),
                        "icon-halo-blur": new Mo(ft.paint_symbol["icon-halo-blur"]),
                        "icon-translate": new eo(ft.paint_symbol["icon-translate"]),
                        "icon-translate-anchor": new eo(ft.paint_symbol["icon-translate-anchor"]),
                        "icon-image-cross-fade": new Mo(ft.paint_symbol["icon-image-cross-fade"]),
                        "text-opacity": new Mo(ft.paint_symbol["text-opacity"]),
                        "text-occlusion-opacity": new Mo(ft.paint_symbol["text-occlusion-opacity"]),
                        "text-color": new Mo(ft.paint_symbol["text-color"],{
                            runtimeType: Hn,
                            getOverride: n => n.textColor,
                            hasOverride: n => !!n.textColor
                        }),
                        "text-halo-color": new Mo(ft.paint_symbol["text-halo-color"]),
                        "text-halo-width": new Mo(ft.paint_symbol["text-halo-width"]),
                        "text-halo-blur": new Mo(ft.paint_symbol["text-halo-blur"]),
                        "text-translate": new eo(ft.paint_symbol["text-translate"]),
                        "text-translate-anchor": new eo(ft.paint_symbol["text-translate-anchor"]),
                        "icon-color-saturation": new eo(ft.paint_symbol["icon-color-saturation"]),
                        "icon-color-contrast": new eo(ft.paint_symbol["icon-color-contrast"]),
                        "icon-color-brightness-min": new eo(ft.paint_symbol["icon-color-brightness-min"]),
                        "icon-color-brightness-max": new eo(ft.paint_symbol["icon-color-brightness-max"]),
                        "symbol-z-offset": new Mo(ft.paint_symbol["symbol-z-offset"]),
                        "icon-color-use-theme": new Mo({
                            type: "string",
                            default: "default",
                            "property-type": "data-driven"
                        }),
                        "icon-halo-color-use-theme": new Mo({
                            type: "string",
                            default: "default",
                            "property-type": "data-driven"
                        }),
                        "text-color-use-theme": new Mo({
                            type: "string",
                            default: "default",
                            "property-type": "data-driven"
                        }),
                        "text-halo-color-use-theme": new Mo({
                            type: "string",
                            default: "default",
                            "property-type": "data-driven"
                        })
                    }))
                },
                fm);
                class nd extends dr {
                    constructor(e, o, a, u) {
                        super(e, _m(), o, a, u),
                        this._colorAdjustmentMatrix = B.mat4.identity([]),
                        this.hasInitialOcclusionOpacityProperties = void 0 !== e.paint && ("icon-occlusion-opacity"in e.paint || "text-occlusion-opacity"in e.paint)
                    }
                    recalculate(e, o) {
                        super.recalculate(e, o),
                        "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"),
                        "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"),
                        "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")),
                        "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
                        const a = this.layout.get("text-writing-mode");
                        if (a) {
                            const u = [];
                            for (const l of a)
                                u.indexOf(l) < 0 && u.push(l);
                            this.layout._values["text-writing-mode"] = u
                        } else
                            this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
                        this._setPaintOverrides()
                    }
                    getColorAdjustmentMatrix(e, o, a, u) {
                        return this._saturation === e && this._contrast === o && this._brightnessMin === a && this._brightnessMax === u || (this._colorAdjustmentMatrix = function(l, p, g, x) {
                            l = se(l),
                            p = Z(p);
                            const T = B.mat4.create()
                              , f = l / 3
                              , b = 1 - 2 * f
                              , P = [b, f, f, 0, f, b, f, 0, f, f, b, 0, 0, 0, 0, 1]
                              , v = .5 - .5 * p
                              , w = x - g;
                            return B.mat4.multiply(T, [w, 0, 0, 0, 0, w, 0, 0, 0, 0, w, 0, g, g, g, 1], [p, 0, 0, 0, 0, p, 0, 0, 0, 0, p, 0, v, v, v, 1]),
                            B.mat4.multiply(T, T, P),
                            T
                        }(e, o, a, u),
                        this._saturation = e,
                        this._contrast = o,
                        this._brightnessMin = a,
                        this._brightnessMax = u),
                        this._colorAdjustmentMatrix
                    }
                    getValueAndResolveTokens(e, o, a, u) {
                        const l = this.layout.get(e).evaluate(o, {}, a, u)
                          , p = this._unevaluatedLayout._values[e];
                        return p.isDataDriven() || yl(p.value) || !l ? l : (g = o.properties,
                        l.replace(/{([^{}]+)}/g, (T, f) => f in g ? String(g[f]) : ""));
                        var g
                    }
                    createBucket(e) {
                        return new id(e)
                    }
                    queryRadius() {
                        return 0
                    }
                    queryIntersectsFeature() {
                        return !1
                    }
                    _setPaintOverrides() {
                        for (const e of _m().paint.overridableProperties) {
                            if (!nd.hasPaintOverride(this.layout, e))
                                continue;
                            const o = this.paint.get(e)
                              , a = new X_(o)
                              , u = new _c(a,o.property.specification,this.scope,this.options);
                            let l = null;
                            l = "constant" === o.value.kind || "source" === o.value.kind ? new gc("source",u) : new aa("composite",u,o.value.zoomStops,o.value._interpolationType),
                            this.paint._values[e] = new bl(o.property,l,o.parameters)
                        }
                    }
                    _handleOverridablePaintPropertyUpdate(e, o, a) {
                        return !(!this.layout || o.isDataDriven() || a.isDataDriven()) && nd.hasPaintOverride(this.layout, e)
                    }
                    static hasPaintOverride(e, o) {
                        const a = e.get("text-field")
                          , u = _m().paint.properties[o];
                        let l = !1;
                        const p = g => {
                            for (const x of g)
                                if (u.overrides && u.overrides.hasOverride(x))
                                    return void (l = !0)
                        }
                        ;
                        if ("constant" === a.value.kind && a.value.value instanceof Nn)
                            p(a.value.value.sections);
                        else if ("source" === a.value.kind) {
                            const g = T => {
                                l || (T instanceof Ar && en(T.value) === Xr ? p(T.value.sections) : T instanceof Yr ? p(T.sections) : T.eachChild(g))
                            }
                              , x = a.value;
                            x._styleExpression && g(x._styleExpression.expression)
                        }
                        return l
                    }
                    getProgramIds() {
                        return ["symbol"]
                    }
                    getDefaultProgramParams(e, o, a) {
                        return {
                            config: new Ua(this,{
                                zoom: o,
                                lut: a
                            }),
                            overrideFog: !1
                        }
                    }
                }
                let Y_, Z_, K_, q_;
                var gm = Si([{
                    name: "a_pos",
                    type: "Int16",
                    components: 2
                }, {
                    name: "a_texture_pos",
                    type: "Int16",
                    components: 2
                }]);
                function ym(n) {
                    switch (n) {
                    case WebGL2RenderingContext.RGBA8:
                        return WebGL2RenderingContext.RGBA;
                    case WebGL2RenderingContext.DEPTH_COMPONENT16:
                        return WebGL2RenderingContext.DEPTH_COMPONENT;
                    case WebGL2RenderingContext.DEPTH24_STENCIL8:
                        return WebGL2RenderingContext.DEPTH_STENCIL;
                    case WebGL2RenderingContext.R8:
                    case WebGL2RenderingContext.R32F:
                        return WebGL2RenderingContext.RED
                    }
                }
                function vm(n) {
                    switch (n) {
                    case WebGL2RenderingContext.RGBA8:
                        return WebGL2RenderingContext.UNSIGNED_BYTE;
                    case WebGL2RenderingContext.DEPTH_COMPONENT16:
                        return WebGL2RenderingContext.UNSIGNED_SHORT;
                    case WebGL2RenderingContext.DEPTH24_STENCIL8:
                        return WebGL2RenderingContext.UNSIGNED_INT_24_8;
                    case WebGL2RenderingContext.R8:
                        return WebGL2RenderingContext.UNSIGNED_BYTE;
                    case WebGL2RenderingContext.R32F:
                        return WebGL2RenderingContext.FLOAT
                    }
                }
                class xm {
                    constructor(e, o, a, u) {
                        this.context = e,
                        this.format = a,
                        this.useMipmap = u && u.useMipmap,
                        this.texture = e.gl.createTexture(),
                        this.update(o, {
                            premultiply: u && u.premultiply
                        })
                    }
                    update(e, o) {
                        const a = e && e instanceof HTMLVideoElement && 0 === e.width ? e.videoWidth : e.width
                          , u = e && e instanceof HTMLVideoElement && 0 === e.height ? e.videoHeight : e.height
                          , {context: l} = this
                          , {gl: p} = l
                          , {x: g, y: x} = o && o.position ? o.position : {
                            x: 0,
                            y: 0
                        }
                          , T = g + a
                          , f = x + u;
                        !this.size || this.size[0] === T && this.size[1] === f || (p.bindTexture(p.TEXTURE_2D, null),
                        p.deleteTexture(this.texture),
                        this.texture = p.createTexture(),
                        this.size = null),
                        p.bindTexture(p.TEXTURE_2D, this.texture),
                        l.pixelStoreUnpackFlipY.set(!1),
                        l.pixelStoreUnpack.set(1),
                        l.pixelStoreUnpackPremultiplyAlpha.set(this.format === p.RGBA8 && (!o || !1 !== o.premultiply));
                        const b = e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || ImageBitmap && e instanceof ImageBitmap;
                        if (!this.size && T > 0 && f > 0) {
                            const P = this.useMipmap ? Math.floor(Math.log2(Math.max(T, f))) + 1 : 1;
                            p.texStorage2D(p.TEXTURE_2D, P, this.format, T, f),
                            this.size = [T, f]
                        }
                        if (this.size)
                            if (b)
                                p.texSubImage2D(p.TEXTURE_2D, 0, g, x, ym(this.format), vm(this.format), e);
                            else {
                                const P = e.data;
                                P && p.texSubImage2D(p.TEXTURE_2D, 0, g, x, a, u, ym(this.format), vm(this.format), P)
                            }
                        this.useMipmap && p.generateMipmap(p.TEXTURE_2D)
                    }
                    bind(e, o, a=!1) {
                        const {context: u} = this
                          , {gl: l} = u;
                        l.bindTexture(l.TEXTURE_2D, this.texture),
                        e !== this.minFilter && (l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MAG_FILTER, e),
                        l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MIN_FILTER, this.useMipmap && !a ? e === l.NEAREST ? l.NEAREST_MIPMAP_NEAREST : l.LINEAR_MIPMAP_LINEAR : e),
                        this.minFilter = e),
                        o !== this.wrapS && (l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_S, o),
                        l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_T, o),
                        this.wrapS = o)
                    }
                    bindExtraParam(e, o, a, u) {
                        const {context: l} = this
                          , {gl: p} = l;
                        p.bindTexture(p.TEXTURE_2D, this.texture),
                        o !== this.magFilter && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, o),
                        this.magFilter = o),
                        e !== this.minFilter && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, this.useMipmap ? e === p.NEAREST ? p.NEAREST_MIPMAP_NEAREST : p.LINEAR_MIPMAP_LINEAR : e),
                        this.minFilter = e),
                        a !== this.wrapS && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, a),
                        this.wrapS = a),
                        u !== this.wrapT && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, u),
                        this.wrapT = u)
                    }
                    destroy() {
                        const {gl: e} = this.context;
                        e.deleteTexture(this.texture),
                        this.texture = null
                    }
                }
                class rd {
                    constructor(e, o) {
                        this.context = e,
                        this.texture = o
                    }
                    bind(e, o) {
                        const {context: a} = this
                          , {gl: u} = a;
                        u.bindTexture(u.TEXTURE_2D, this.texture),
                        e !== this.minFilter && (u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, e),
                        u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, e),
                        this.minFilter = e),
                        o !== this.wrapS && (u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, o),
                        u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, o),
                        this.wrapS = o)
                    }
                }
                function sd(n, e, o, a, u, l, p, g) {
                    const x = [n, e, 1, o, a, 1, u, l, 1]
                      , T = [p, g, 1]
                      , f = B.mat3.adjoint([], x)
                      , [b,P,v] = B.vec3.transformMat3(T, T, f);
                    return B.mat3.multiply(x, x, [b, 0, 0, 0, P, 0, 0, 0, v])
                }
                function J_(n, e, o, a, u, l, p, g) {
                    const x = function(T, f, b, P, v, w, C, A) {
                        const O = sd(0, 0, 1, 0, 1, 1, 0, 1)
                          , F = sd(T, f, b, P, v, w, C, A)
                          , z = B.mat3.adjoint([], O);
                        return B.mat3.multiply(F, F, z)
                    }(n, e, o, a, u, l, p, g);
                    return [x[2] / x[8] / uo, x[5] / x[8] / uo]
                }
                function ad(n) {
                    return [n[0], Math.min(Math.max(n[1], -un), un)]
                }
                class Q_ extends Hs {
                    constructor(e, o, a, u) {
                        super(),
                        this.id = e,
                        this.dispatcher = a,
                        this.coordinates = o.coordinates,
                        this.type = "image",
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.tileSize = 512,
                        this.tiles = {},
                        this._loaded = !1,
                        this.onNorthPole = !1,
                        this.onSouthPole = !1,
                        this.setEventedParent(u),
                        this.options = o,
                        this._dirty = !1
                    }
                    load(e, o) {
                        if (this._loaded = o || !1,
                        this.fire(new Wr("dataloading",{
                            dataType: "source"
                        })),
                        this.url = this.options.url,
                        !this.url)
                            return e && (this.coordinates = e),
                            this._loaded = !0,
                            void this._finishLoading();
                        this._imageRequest = Wa(this.map._requestManager.transformRequest(this.url, bs.Image), (a, u) => {
                            this._imageRequest = null,
                            this._loaded = !0,
                            a ? this.fire(new hs(a)) : u && (this.image = u instanceof HTMLImageElement ? Qt.getImageData(u) : u,
                            this._dirty = !0,
                            this.width = this.image.width,
                            this.height = this.image.height,
                            e && (this.coordinates = e),
                            this._finishLoading())
                        }
                        )
                    }
                    loaded() {
                        return this._loaded
                    }
                    updateImage(e) {
                        return e.url ? (this._imageRequest && e.url !== this.options.url && (this._imageRequest.cancel(),
                        this._imageRequest = null),
                        this.options.url = e.url,
                        this.load(e.coordinates, this._loaded),
                        this) : this
                    }
                    setTexture(e) {
                        if (!(e.handle instanceof WebGLTexture))
                            throw new Error("The provided handle is not a WebGLTexture instance");
                        return this.texture = new rd(this.map.painter.context,e.handle),
                        this.width = e.dimensions[0],
                        this.height = e.dimensions[1],
                        this._dirty = !1,
                        this._loaded = !0,
                        this._finishLoading(),
                        this
                    }
                    _finishLoading() {
                        this.map && (this.setCoordinates(this.coordinates),
                        this.fire(new Wr("data",{
                            dataType: "source",
                            sourceDataType: "metadata"
                        })))
                    }
                    onAdd(e) {
                        this.map = e,
                        this.load()
                    }
                    onRemove(e) {
                        this._imageRequest && (this._imageRequest.cancel(),
                        this._imageRequest = null),
                        !this.texture || this.texture instanceof rd || this.texture.destroy(),
                        this.boundsBuffer && (this.boundsBuffer.destroy(),
                        this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(),
                        this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy())
                    }
                    setCoordinates(e) {
                        if (this.coordinates = e,
                        this._boundsArray = void 0,
                        this._unsupportedCoords = !1,
                        !e.length)
                            return this;
                        this.onNorthPole = !1,
                        this.onSouthPole = !1;
                        let o = e[0][1]
                          , a = e[0][1];
                        for (const l of e)
                            l[1] > a && (a = l[1]),
                            l[1] < o && (o = l[1]);
                        const u = (a + o) / 2;
                        if (u > un ? this.onNorthPole = !0 : u < -un && (this.onSouthPole = !0),
                        !this.onNorthPole && !this.onSouthPole) {
                            const l = e.map(h.fromLngLat);
                            this.tileID = function(p) {
                                let g = 1 / 0
                                  , x = 1 / 0
                                  , T = -1 / 0
                                  , f = -1 / 0;
                                for (const C of p)
                                    g = Math.min(g, C.x),
                                    x = Math.min(x, C.y),
                                    T = Math.max(T, C.x),
                                    f = Math.max(f, C.y);
                                const b = Math.max(T - g, f - x)
                                  , P = Math.max(0, Math.floor(-Math.log(b) / Math.LN2))
                                  , v = Math.pow(2, P);
                                let w = Math.floor((g + T) / 2 * v);
                                return w > 1 && (w -= 1),
                                new Dt(P,w,Math.floor((x + f) / 2 * v))
                            }(l),
                            this.minzoom = this.maxzoom = this.tileID.z
                        }
                        return this.fire(new Wr("data",{
                            dataType: "source",
                            sourceDataType: "content"
                        })),
                        this
                    }
                    _clear() {
                        this._boundsArray = void 0,
                        this._unsupportedCoords = !1
                    }
                    _prepareData(e) {
                        for (const O in this.tiles) {
                            const F = this.tiles[O];
                            "loaded" !== F.state && (F.state = "loaded",
                            F.texture = this.texture)
                        }
                        if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords)
                            return;
                        const o = Zu(new Dt(0,0,0), this.map.transform.projection)
                          , a = [o.projection.project(this.coordinates[0][0], this.coordinates[0][1]), o.projection.project(this.coordinates[1][0], this.coordinates[1][1]), o.projection.project(this.coordinates[2][0], this.coordinates[2][1]), o.projection.project(this.coordinates[3][0], this.coordinates[3][1])];
                        if (!function(O) {
                            const F = O[1].x - O[0].x
                              , z = O[1].y - O[0].y
                              , L = O[2].x - O[1].x
                              , N = O[2].y - O[1].y
                              , G = O[3].x - O[2].x
                              , X = O[3].y - O[2].y
                              , _e = O[0].x - O[3].x
                              , me = O[0].y - O[3].y
                              , pe = F * N - L * z
                              , Ne = L * X - G * N
                              , Pe = G * me - _e * X
                              , $e = _e * z - F * me;
                            return pe > 0 && Ne > 0 && Pe > 0 && $e > 0 || pe < 0 && Ne < 0 && Pe < 0 && $e < 0
                        }(a))
                            return console.warn("Image source coordinates are defining non-convex area in the Mercator projection"),
                            void (this._unsupportedCoords = !0);
                        const u = Zu(this.tileID, this.map.transform.projection)
                          , [l,p,g,x] = this.coordinates.map(O => {
                            const F = u.projection.project(O[0], O[1]);
                            return U_(u, F)._round()
                        }
                        );
                        this.perspectiveTransform = J_(l.x, l.y, p.x, p.y, g.x, g.y, x.x, x.y);
                        const T = this._boundsArray = new ha;
                        T.emplaceBack(l.x, l.y, 0, 0),
                        T.emplaceBack(p.x, p.y, uo, 0),
                        T.emplaceBack(x.x, x.y, 0, uo),
                        T.emplaceBack(g.x, g.y, uo, uo),
                        this.boundsBuffer && (this.boundsBuffer.destroy(),
                        this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(),
                        this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()),
                        this.boundsBuffer = e.createVertexBuffer(T, gm.members),
                        this.boundsSegments = mn.simpleSegment(0, 0, 4, 2);
                        const f = []
                          , b = [ad((P = this.coordinates)[0]), ad(P[1]), ad(P[2]), ad(P[3])];
                        var P;
                        const [v,w,C,A] = function(O) {
                            let F = O[0][0]
                              , z = F
                              , L = O[0][1]
                              , N = L;
                            for (let G = 1; G < O.length; G++)
                                O[G][0] < F ? F = O[G][0] : O[G][0] > z && (z = O[G][0]),
                                O[G][1] < L ? L = O[G][1] : O[G][1] > N && (N = O[G][1]);
                            return [F, L, z - F, N - L]
                        }(b);
                        {
                            const O = new ha
                              , [F,z,L,N] = function(rt) {
                                let at = rt[0].x
                                  , ot = at
                                  , Ct = rt[0].y
                                  , Zt = Ct;
                                for (let Ot = 1; Ot < rt.length; Ot++)
                                    rt[Ot].x < at ? at = rt[Ot].x : rt[Ot].x > ot && (ot = rt[Ot].x),
                                    rt[Ot].y < Ct ? Ct = rt[Ot].y : rt[Ot].y > Zt && (Zt = rt[Ot].y);
                                return [at, Ct, ot - at, Zt - Ct]
                            }(a)
                              , G = rt => [(rt.x - F) / L, (rt.y - z) / N]
                              , [X,_e,me,pe] = a.map(G)
                              , Ne = function(rt, at, ot, Ct, Zt, Ot, lo, io) {
                                const fo = sd(0, 0, 1, 0, 1, 1, 0, 1)
                                  , Bt = sd(rt, at, ot, Ct, Zt, Ot, lo, io)
                                  , Ro = B.mat3.adjoint([], Bt);
                                return B.mat3.multiply(fo, fo, Ro)
                            }(X[0], X[1], _e[0], _e[1], me[0], me[1], pe[0], pe[1]);
                            this.elevatedGlobePerspectiveTransform = J_(X[0], X[1], _e[0], _e[1], me[0], me[1], pe[0], pe[1]);
                            const Pe = (rt, at) => {
                                f.push(rt.lng);
                                const ot = Math.round((rt.lng - v) / C * uo)
                                  , Ct = Math.round((rt.lat - w) / A * uo)
                                  , Zt = G(at)
                                  , Ot = B.vec3.transformMat3([], [Zt[0], Zt[1], 1], Ne)
                                  , lo = Math.round(Ot[0] / Ot[2] * uo)
                                  , io = Math.round(Ot[1] / Ot[2] * uo);
                                O.emplaceBack(ot, Ct, lo, io)
                            }
                              , $e = a[3].x - a[0].x
                              , We = a[3].y - a[0].y
                              , je = a[2].x - a[1].x
                              , Ke = a[2].y - a[1].y;
                            for (let rt = 0; rt < 65; rt++) {
                                const at = rt / 64
                                  , ot = [a[0].x + at * $e, a[0].y + at * We]
                                  , Ct = [a[1].x + at * je, a[1].y + at * Ke]
                                  , Zt = Ct[0] - ot[0]
                                  , Ot = Ct[1] - ot[1];
                                for (let lo = 0; lo < 65; lo++) {
                                    const io = lo / 64
                                      , fo = {
                                        x: ot[0] + Zt * io,
                                        y: ot[1] + Ot * io,
                                        z: 0
                                    };
                                    Pe(o.projection.unproject(fo.x, fo.y), fo)
                                }
                            }
                            this.elevatedGlobeVertexBuffer = e.createVertexBuffer(O, gm.members)
                        }
                        {
                            this.maxLongitudeTriangleSize = 0;
                            let O = []
                              , F = new Xn;
                            const z = (L, N, G) => {
                                F.emplaceBack(L, N, G);
                                const X = f[L]
                                  , _e = f[N]
                                  , me = f[G]
                                  , pe = Math.min(Math.min(X, _e), me)
                                  , Ne = Math.max(Math.max(X, _e), me) - pe;
                                Ne > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = Ne),
                                O.push(pe + Ne / 2)
                            }
                            ;
                            for (let L = 0; L < 64; L++)
                                for (let N = 0; N < 64; N++) {
                                    const G = 65 * L + N
                                      , X = G + 1
                                      , _e = G + 65
                                      , me = _e + 1;
                                    z(G, _e, X),
                                    z(X, _e, me)
                                }
                            [O,F] = function(L, N) {
                                const G = Array.from({
                                    length: L.length
                                }, (me, pe) => pe);
                                G.sort( (me, pe) => L[me] - L[pe]);
                                const X = []
                                  , _e = new Xn;
                                for (let me = 0; me < G.length; me++) {
                                    const pe = G[me];
                                    X.push(L[pe]);
                                    const Ne = 3 * pe
                                      , Pe = Ne + 1;
                                    _e.emplaceBack(N.uint16[Ne], N.uint16[Pe], N.uint16[Pe + 1])
                                }
                                return [X, _e]
                            }(O, F),
                            this.elevatedGlobeTrianglesCenterLongitudes = O,
                            this.elevatedGlobeIndexBuffer = e.createIndexBuffer(F)
                        }
                        this.elevatedGlobeSegments = mn.simpleSegment(0, 0, 4225, 8192),
                        this.elevatedGlobeGridMatrix = new Float32Array([0, C / uo, 0, A / uo, 0, 0, w, v, 0])
                    }
                    prepare() {
                        const e = 0 !== Object.keys(this.tiles).length;
                        if (this.tileID && !e)
                            return;
                        const o = this.map.painter.context
                          , a = o.gl;
                        !this._dirty || this.texture instanceof rd || (this.texture ? this.texture.update(this.image) : (this.texture = new xm(o,this.image,a.RGBA8),
                        this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE)),
                        this._dirty = !1),
                        e && this._prepareData(o)
                    }
                    loadTile(e, o) {
                        this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e,
                        e.buckets = {},
                        o(null)) : (e.state = "errored",
                        o(null))
                    }
                    serialize() {
                        return {
                            type: "image",
                            url: this.options.url,
                            coordinates: this.coordinates
                        }
                    }
                    hasTransition() {
                        return !1
                    }
                    getSegmentsForLongitude(e) {
                        const o = this.elevatedGlobeSegments;
                        if (!this.elevatedGlobeTrianglesCenterLongitudes || !o)
                            return null;
                        const a = this.elevatedGlobeTrianglesCenterLongitudes;
                        let u = (l = e + 180) + 360 * Math.round((a[0] - l) / 360);
                        var l;
                        const p = new mn
                          , g = (b, P) => {
                            p.segments.push({
                                vertexOffset: 0,
                                primitiveOffset: b,
                                vertexLength: o.segments[0].vertexLength,
                                primitiveLength: P,
                                sortKey: void 0,
                                vaos: {}
                            })
                        }
                          , x = .51 * this.maxLongitudeTriangleSize;
                        if (Math.abs(a[0] - u) <= x) {
                            const b = xt(a, 0, a.length, u + x);
                            return b === a.length || g(b, Lr(a, b + 1, a.length, u + 360 - x) - b),
                            p
                        }
                        u < a[0] && (u += 360);
                        const T = Lr(a, 0, a.length, u - x);
                        if (T === a.length)
                            return g(0, a.length),
                            p;
                        g(0, T - 0);
                        const f = xt(a, T + 1, a.length, u + x);
                        return f !== a.length && g(f, a.length - f),
                        p
                    }
                }
                const q1 = (Math.pow(256, 2) - 1) / 16907520;
                class eg extends dr {
                    constructor(e, o, a, u) {
                        super(e, {
                            layout: K_ || (K_ = new cn({
                                visibility: new eo(ft.layout_raster.visibility)
                            })),
                            paint: q_ || (q_ = new cn({
                                "raster-opacity": new eo(ft.paint_raster["raster-opacity"]),
                                "raster-color": new ca(ft.paint_raster["raster-color"]),
                                "raster-color-mix": new eo(ft.paint_raster["raster-color-mix"]),
                                "raster-color-range": new eo(ft.paint_raster["raster-color-range"]),
                                "raster-hue-rotate": new eo(ft.paint_raster["raster-hue-rotate"]),
                                "raster-brightness-min": new eo(ft.paint_raster["raster-brightness-min"]),
                                "raster-brightness-max": new eo(ft.paint_raster["raster-brightness-max"]),
                                "raster-saturation": new eo(ft.paint_raster["raster-saturation"]),
                                "raster-contrast": new eo(ft.paint_raster["raster-contrast"]),
                                "raster-resampling": new eo(ft.paint_raster["raster-resampling"]),
                                "raster-fade-duration": new eo(ft.paint_raster["raster-fade-duration"]),
                                "raster-emissive-strength": new eo(ft.paint_raster["raster-emissive-strength"]),
                                "raster-array-band": new eo(ft.paint_raster["raster-array-band"]),
                                "raster-elevation": new eo(ft.paint_raster["raster-elevation"]),
                                "raster-color-use-theme": new Mo({
                                    type: "string",
                                    default: "default",
                                    "property-type": "data-driven"
                                })
                            }))
                        }, o, a, u),
                        this.updateColorRamp(),
                        this._curRampRange = [NaN, NaN]
                    }
                    getProgramIds() {
                        return ["raster"]
                    }
                    hasColorMap() {
                        return !!this._transitionablePaint._values["raster-color"].value.value
                    }
                    tileCoverLift() {
                        return this.paint.get("raster-elevation")
                    }
                    isDraped(e) {
                        return !(e && e._source instanceof Q_ && (e._source.onNorthPole || e._source.onSouthPole)) && 0 === this.paint.get("raster-elevation")
                    }
                    _handleSpecialPaintPropertyUpdate(e) {
                        "raster-color" !== e && "raster-color-range" !== e || (this._curRampRange = [NaN, NaN],
                        this.updateColorRamp())
                    }
                    updateColorRamp(e) {
                        if (!this.hasColorMap() || !this._curRampRange)
                            return;
                        const o = this._transitionablePaint._values["raster-color"].value.expression
                          , [a,u] = e || this._transitionablePaint._values["raster-color-range"].value.expression.evaluate({
                            zoom: 0
                        }) || [NaN, NaN];
                        isNaN(a) && isNaN(u) || a === this._curRampRange[0] && u === this._curRampRange[1] || (this.colorRamp = Lu({
                            expression: o,
                            evaluationKey: "rasterValue",
                            image: this.colorRamp,
                            clips: [{
                                start: a,
                                end: u
                            }],
                            resolution: 256
                        }),
                        this.colorRampTexture = null,
                        this._curRampRange = [a, u])
                    }
                }
                let tg, og, ig, ng, rg;
                class sg extends dr {
                    constructor(e, o, a, u) {
                        super(e, {
                            layout: tg || (tg = new cn({
                                visibility: new eo(ft["layout_raster-particle"].visibility)
                            })),
                            paint: og || (og = new cn({
                                "raster-particle-array-band": new eo(ft["paint_raster-particle"]["raster-particle-array-band"]),
                                "raster-particle-count": new eo(ft["paint_raster-particle"]["raster-particle-count"]),
                                "raster-particle-color": new ca(ft["paint_raster-particle"]["raster-particle-color"]),
                                "raster-particle-max-speed": new eo(ft["paint_raster-particle"]["raster-particle-max-speed"]),
                                "raster-particle-speed-factor": new eo(ft["paint_raster-particle"]["raster-particle-speed-factor"]),
                                "raster-particle-fade-opacity-factor": new eo(ft["paint_raster-particle"]["raster-particle-fade-opacity-factor"]),
                                "raster-particle-reset-rate-factor": new eo(ft["paint_raster-particle"]["raster-particle-reset-rate-factor"]),
                                "raster-particle-elevation": new eo(ft["paint_raster-particle"]["raster-particle-elevation"]),
                                "raster-particle-color-use-theme": new Mo({
                                    type: "string",
                                    default: "default",
                                    "property-type": "data-driven"
                                })
                            }))
                        }, o, a, u),
                        this._updateColorRamp(),
                        this.lastInvalidatedAt = Qt.now()
                    }
                    onRemove(e) {
                        this.colorRampTexture && this.colorRampTexture.destroy(),
                        this.tileFramebuffer && this.tileFramebuffer.destroy(),
                        this.particleFramebuffer && this.particleFramebuffer.destroy()
                    }
                    hasColorMap() {
                        return !!this._transitionablePaint._values["raster-particle-color"].value.value
                    }
                    getProgramIds() {
                        return ["rasterParticle"]
                    }
                    hasOffscreenPass() {
                        return "none" !== this.visibility
                    }
                    isDraped(e) {
                        return !1
                    }
                    _handleSpecialPaintPropertyUpdate(e) {
                        "raster-particle-color" !== e && "raster-particle-max-speed" !== e || (this._updateColorRamp(),
                        this._invalidateAnimationState()),
                        "raster-particle-count" === e && this._invalidateAnimationState()
                    }
                    _updateColorRamp() {
                        if (!this.hasColorMap())
                            return;
                        const e = this._transitionablePaint._values["raster-particle-color"].value.expression
                          , o = this._transitionablePaint._values["raster-particle-max-speed"].value.expression.evaluate({
                            zoom: 0
                        });
                        this.colorRamp = Lu({
                            expression: e,
                            evaluationKey: "rasterParticleSpeed",
                            image: this.colorRamp,
                            clips: [{
                                start: 0,
                                end: o
                            }],
                            resolution: 256
                        }),
                        this.colorRampTexture = null
                    }
                    _invalidateAnimationState() {
                        this.lastInvalidatedAt = Qt.now()
                    }
                    tileCoverLift() {
                        return this.paint.get("raster-particle-elevation")
                    }
                }
                class J1 extends dr {
                    constructor(e, o) {
                        super(e, {}, o, null),
                        this.implementation = e,
                        e.slot && (this.slot = e.slot)
                    }
                    is3D() {
                        return "3d" === this.implementation.renderingMode
                    }
                    hasOffscreenPass() {
                        return void 0 !== this.implementation.prerender
                    }
                    isDraped(e) {
                        return void 0 !== this.implementation.renderToTile
                    }
                    shouldRedrape() {
                        return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles()
                    }
                    recalculate() {}
                    updateTransitions() {}
                    hasTransition() {
                        return !1
                    }
                    serialize() {}
                    onAdd(e) {
                        this.implementation.onAdd && this.implementation.onAdd(e, e.painter.context.gl)
                    }
                    onRemove(e) {
                        this.implementation.onRemove && this.implementation.onRemove(e, e.painter.context.gl)
                    }
                }
                function bm(n, e, o) {
                    const a = [0, 0, 1]
                      , u = B.quat.identity([]);
                    return B.quat.rotateY(u, u, o ? -_o(n) + Math.PI : _o(n)),
                    B.quat.rotateX(u, u, -_o(e)),
                    B.vec3.transformQuat(a, a, u),
                    B.vec3.normalize(a, a)
                }
                function ag(n, e) {
                    const o = ld(n.projection, n.zoom, n.width, n.height)
                      , a = function(l, p, g, x, T) {
                        const f = new Mi(g.lng - 180 * Fl,g.lat)
                          , b = new Mi(g.lng + 180 * Fl,g.lat)
                          , P = l.project(f.lng, f.lat)
                          , v = l.project(b.lng, b.lat)
                          , w = -Math.atan2(v.y - P.y, v.x - P.x)
                          , C = h.fromLngLat(g);
                        C.y = ie(C.y, -1 + Fl, 1 - Fl);
                        const A = C.toLngLat()
                          , O = l.project(A.lng, A.lat)
                          , F = h.fromLngLat(A);
                        F.x += Fl;
                        const z = F.toLngLat()
                          , L = l.project(z.lng, z.lat)
                          , N = cg(L.x - O.x, L.y - O.y, w)
                          , G = h.fromLngLat(A);
                        G.y += Fl;
                        const X = G.toLngLat()
                          , _e = l.project(X.lng, X.lat)
                          , me = cg(_e.x - O.x, _e.y - O.y, w)
                          , pe = Math.abs(N.x) / Math.abs(me.y)
                          , Ne = B.mat4.identity([]);
                        B.mat4.rotateZ(Ne, Ne, -w * (1 - (T ? 0 : x)));
                        const Pe = B.mat4.identity([]);
                        return B.mat4.scale(Pe, Pe, [1, 1 - (1 - pe) * x, 1]),
                        Pe[4] = -me.x / me.y * x,
                        B.mat4.rotateZ(Pe, Pe, w),
                        B.mat4.multiply(Pe, Ne, Pe),
                        Pe
                    }(n.projection, 0, n.center, o, e)
                      , u = lg(n);
                    return B.mat4.scale(a, a, [u, u, 1]),
                    a
                }
                function lg(n) {
                    const e = n.projection
                      , o = ld(n.projection, n.zoom, n.width, n.height)
                      , a = wm(e, n.center)
                      , u = wm(e, Mi.convert(e.center));
                    return Math.pow(2, a * o + (1 - o) * u)
                }
                function ld(n, e, o, a, u=1 / 0) {
                    const l = n.range;
                    if (!l)
                        return 0;
                    const p = Math.min(u, Math.max(o, a))
                      , g = Math.log(p / 1024) / Math.LN2;
                    return we(l[0] + g, l[1] + g, e)
                }
                const Fl = 1 / 4e4;
                function wm(n, e) {
                    const o = ie(e.lat, -un, un)
                      , a = new Mi(e.lng - 180 * Fl,o)
                      , u = new Mi(e.lng + 180 * Fl,o)
                      , l = n.project(a.lng, o)
                      , p = n.project(u.lng, o)
                      , g = h.fromLngLat(a)
                      , x = h.fromLngLat(u)
                      , T = p.x - l.x
                      , f = p.y - l.y
                      , b = x.x - g.x
                      , P = x.y - g.y
                      , v = Math.sqrt((b * b + P * P) / (T * T + f * f));
                    return Math.log(v) / Math.LN2
                }
                function cg(n, e, o) {
                    const a = Math.cos(o)
                      , u = Math.sin(o);
                    return {
                        x: n * a - e * u,
                        y: n * u + e * a
                    }
                }
                function hg(n, e, o) {
                    B.mat4.identity(n),
                    B.mat4.rotateZ(n, n, _o(e[2])),
                    B.mat4.rotateX(n, n, _o(e[0])),
                    B.mat4.rotateY(n, n, _o(e[1])),
                    B.mat4.scale(n, n, o),
                    B.mat4.multiply(n, n, [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1])
                }
                function cd(n, e, o, a, u, l, p, g) {
                    const x = [o[0] - e[0], o[1] - e[1], 0]
                      , T = [a[0] - e[0], a[1] - e[1], 0];
                    if (B.vec3.length(x) < 1e-12 || B.vec3.length(T) < 1e-12)
                        return B.quat.identity(n);
                    const f = B.vec3.cross([], x, T);
                    B.vec3.normalize(f, f),
                    B.vec3.subtract(T, a, e),
                    x[2] = (l - u) * g,
                    T[2] = (p - u) * g;
                    const b = x;
                    return B.vec3.cross(b, x, T),
                    B.vec3.normalize(b, b),
                    B.quat.rotationTo(n, f, b)
                }
                function Pm(n, e, o=!1) {
                    const a = cr(e.zoom)
                      , u = function(l, p, g) {
                        const x = p.worldSize
                          , T = [l[12], l[13], l[14]]
                          , f = Gn(T[1] / x)
                          , b = Mr(T[0] / x)
                          , P = B.mat4.identity([])
                          , v = ar(1, f) * x
                          , w = ar(1, 0) * x * c(f, p.zoom)
                          , C = 1 / Or(x);
                        let A = w * C;
                        if (g) {
                            const L = ld(p.projection, p.zoom, p.width, p.height, 1024);
                            A = C * p.projection.pixelSpaceConversion(p.center.lat, x, L)
                        }
                        const O = _a(f, b);
                        B.vec3.add(O, O, B.vec3.scale([], B.vec3.normalize([], O), v * A * T[2]));
                        const F = function(L) {
                            const N = [L[0], L[1], L[2]];
                            let G = [0, 1, 0];
                            const X = B.vec3.cross([], G, N);
                            return B.vec3.cross(G, N, X),
                            0 === B.vec3.squaredLength(G) && (G = [0, 1, 0],
                            B.vec3.cross(X, N, G)),
                            B.vec3.normalize(X, X),
                            B.vec3.normalize(G, G),
                            B.vec3.normalize(N, N),
                            [X[0], X[1], X[2], 0, G[0], G[1], G[2], 0, N[0], N[1], N[2], 0, L[0], L[1], L[2], 1]
                        }(O);
                        B.mat4.scale(P, P, [A, A, A * v]),
                        B.mat4.translate(P, P, [-T[0], -T[1], -T[2]]);
                        const z = B.mat4.multiply([], p.globeMatrix, F);
                        return B.mat4.multiply(z, z, P),
                        B.mat4.multiply(z, z, l),
                        z
                    }(n, e, o);
                    return a > 0 ? function(p, g, x) {
                        const T = (w, C, A) => {
                            const O = B.vec3.length(w)
                              , F = B.vec3.length(C)
                              , z = Un(w, C, A);
                            return B.vec3.scale(z, z, 1 / B.vec3.length(z) * jo(O, F, A))
                        }
                          , f = T([p[0], p[1], p[2]], [g[0], g[1], g[2]], x)
                          , b = T([p[4], p[5], p[6]], [g[4], g[5], g[6]], x)
                          , P = T([p[8], p[9], p[10]], [g[8], g[9], g[10]], x)
                          , v = Un([p[12], p[13], p[14]], [g[12], g[13], g[14]], x);
                        return [f[0], f[1], f[2], 0, b[0], b[1], b[2], 0, P[0], P[1], P[2], 0, v[0], v[1], v[2], 1]
                    }(u, function(p, g) {
                        const x = g.worldSize
                          , T = ar(1, 0) * x * c(g.center.lat, g.zoom) / Or(x)
                          , f = ar(1, g.center.lat) * x
                          , b = B.mat4.identity([]);
                        return B.mat4.rotateY(b, b, _o(g.center.lng)),
                        B.mat4.rotateX(b, b, _o(g.center.lat)),
                        B.mat4.translate(b, b, [0, 0, sr]),
                        B.mat4.scale(b, b, [T, T, T * f]),
                        B.mat4.translate(b, b, [g.point.x - .5 * x, g.point.y - .5 * x, 0]),
                        B.mat4.multiply(b, b, p),
                        B.mat4.multiply(b, g.globeMatrix, b)
                    }(n, e), a) : u
                }
                function ug(n, e, o, a) {
                    const u = No.projectAabbCorners(a, o);
                    let l = Number.MAX_VALUE
                      , p = -1;
                    for (let T = 0; T < u.length; ++T) {
                        const f = u[T];
                        f[0] = (.5 * f[0] + .5) * e.width,
                        f[1] = (.5 - .5 * f[1]) * e.height,
                        f[2] < l && (p = T,
                        l = f[2])
                    }
                    const g = T => new tt(u[T][0],u[T][1]);
                    let x;
                    switch (p) {
                    case 0:
                    case 6:
                        x = [g(1), g(5), g(4), g(7), g(3), g(2), g(1)];
                        break;
                    case 1:
                    case 7:
                        x = [g(0), g(4), g(5), g(6), g(2), g(3), g(0)];
                        break;
                    case 3:
                    case 5:
                        x = [g(1), g(0), g(4), g(7), g(6), g(2), g(1)];
                        break;
                    default:
                        x = [g(1), g(5), g(6), g(7), g(3), g(0), g(1)]
                    }
                    if (Y(n, x))
                        return l
                }
                const Q1 = Si([{
                    name: "a_pos_3f",
                    components: 3,
                    type: "Float32"
                }])
                  , ey = Si([{
                    name: "a_color_3f",
                    components: 3,
                    type: "Float32"
                }])
                  , ty = Si([{
                    name: "a_color_4f",
                    components: 4,
                    type: "Float32"
                }])
                  , oy = Si([{
                    name: "a_uv_2f",
                    components: 2,
                    type: "Float32"
                }])
                  , iy = Si([{
                    name: "a_normal_3f",
                    components: 3,
                    type: "Float32"
                }])
                  , ny = Si([{
                    name: "a_normal_matrix0",
                    components: 4,
                    type: "Float32"
                }, {
                    name: "a_normal_matrix1",
                    components: 4,
                    type: "Float32"
                }, {
                    name: "a_normal_matrix2",
                    components: 4,
                    type: "Float32"
                }, {
                    name: "a_normal_matrix3",
                    components: 4,
                    type: "Float32"
                }])
                  , ry = Si([{
                    name: "a_pbr",
                    components: 4,
                    type: "Uint16"
                }, {
                    name: "a_heightBasedEmissiveStrength",
                    components: 3,
                    type: "Float32"
                }])
                  , pg = {
                    None: 0,
                    Model: 1,
                    Symbol: 2,
                    FillExtrusion: 4,
                    All: 7
                };
                class hd {
                    constructor(e, o, a, u) {
                        this.message = (e ? "".concat(e, ": ") : "") + a,
                        u && (this.identifier = u),
                        null != o && o.__line__ && (this.line = o.__line__)
                    }
                }
                function dg(n, e) {
                    const o = -1 === n.indexOf("://");
                    try {
                        return new URL(n,o && e ? "http://example.com" : void 0),
                        !0
                    } catch {
                        return !1
                    }
                }
                class mg {
                    constructor(e, o) {
                        this.feature = e,
                        this.instancedDataOffset = o,
                        this.instancedDataCount = 0,
                        this.rotation = [0, 0, 0],
                        this.scale = [1, 1, 1],
                        this.translation = [0, 0, 0]
                    }
                }
                class fg {
                    constructor() {
                        this.instancedDataArray = new Eu,
                        this.instancesEvaluatedElevation = [],
                        this.features = [],
                        this.idToFeaturesIndex = {}
                    }
                }
                class Mm {
                    constructor(e) {
                        this.zoom = e.zoom,
                        this.canonical = e.canonical,
                        this.layers = e.layers,
                        this.layerIds = this.layers.map(o => o.fqid),
                        this.projection = e.projection,
                        this.index = e.index,
                        this.hasZoomDependentProperties = this.layers[0].isZoomDependent(),
                        this.stateDependentLayerIds = this.layers.filter(o => o.isStateDependent()).map(o => o.id),
                        this.hasPattern = !1,
                        this.instancesPerModel = {},
                        this.validForExaggeration = 0,
                        this.maxVerticalOffset = 0,
                        this.maxScale = 0,
                        this.maxHeight = 0,
                        this.lookupDim = this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100,
                        this.instanceCount = 0,
                        this.terrainElevationMin = 0,
                        this.terrainElevationMax = 0,
                        this.validForDEMTile = {
                            id: null,
                            timestamp: 0
                        },
                        this.modelUris = [],
                        this.modelsRequested = !1,
                        this.activeReplacements = [],
                        this.replacementUpdateTime = 0
                    }
                    updateFootprints(e, o) {}
                    populate(e, o, a, u) {
                        this.tileToMeter = i(a);
                        const l = this.layers[0]._featureFilter.needGeometry;
                        this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
                        for (const {feature: p, id: g, index: x, sourceLayerIndex: T} of e) {
                            const f = null != g ? g : p.properties && p.properties.hasOwnProperty("id") ? p.properties.id : void 0
                              , b = D(p, l);
                            if (!this.layers[0]._featureFilter.filter(new Hi(this.zoom), b, a))
                                continue;
                            const P = {
                                id: f,
                                sourceLayerIndex: T,
                                index: x,
                                geometry: l ? b.geometry : R(p, a, u),
                                properties: p.properties,
                                type: p.type,
                                patterns: {}
                            }
                              , v = this.addFeature(P, P.geometry, b);
                            v && o.featureIndex.insert(p, P.geometry, x, T, this.index, this.instancesPerModel[v].instancedDataArray.length, 256)
                        }
                        this.lookup = null
                    }
                    update(e, o, a, u) {
                        for (const l in this.instancesPerModel) {
                            const p = this.instancesPerModel[l];
                            for (const g in e)
                                p.idToFeaturesIndex.hasOwnProperty(g) && (this.evaluate(p.features[p.idToFeaturesIndex[g]], e[g], p, !0),
                                this.uploaded = !1)
                        }
                        this.maxHeight = 0
                    }
                    updateZoomBasedPaintProperties() {
                        if (!this.hasZoomDependentProperties)
                            return !1;
                        let e = !1;
                        for (const o in this.instancesPerModel) {
                            const a = this.instancesPerModel[o];
                            for (const u of a.features) {
                                const l = this.layers[0]
                                  , p = u.feature
                                  , g = this.canonical
                                  , x = l.paint.get("model-rotation").evaluate(p, {}, g)
                                  , T = l.paint.get("model-scale").evaluate(p, {}, g)
                                  , f = l.paint.get("model-translation").evaluate(p, {}, g);
                                B.vec3.exactEquals(u.rotation, x) && B.vec3.exactEquals(u.scale, T) && B.vec3.exactEquals(u.translation, f) || (this.evaluate(u, u.featureStates, a, !0),
                                e = !0)
                            }
                        }
                        return e
                    }
                    updateReplacement(e, o, a, u) {
                        if (o.updateTime === this.replacementUpdateTime)
                            return !1;
                        this.replacementUpdateTime = o.updateTime;
                        const l = o.getReplacementRegionsForTile(e.toUnwrapped(), !0);
                        if (Zd(this.activeReplacements, l))
                            return !1;
                        this.activeReplacements = l;
                        let p = !1;
                        for (const g in this.instancesPerModel) {
                            const x = this.instancesPerModel[g]
                              , T = x.instancedDataArray;
                            for (const f of x.features) {
                                const b = f.instancedDataOffset
                                  , P = f.instancedDataCount;
                                for (let v = 0; v < P; v++) {
                                    const w = 16 * (v + b);
                                    let C = T.float32[w + 0];
                                    const A = C > uo;
                                    C = A ? C - uo : C;
                                    const O = Math.floor(C)
                                      , F = T.float32[w + 1];
                                    let z = !1;
                                    for (const L of this.activeReplacements)
                                        if (!If(L, a, pg.Model, u) && !(L.min.x > O || O > L.max.x || L.min.y > F || F > L.max.y) && (z = Ff(Lf(O, F, e.canonical, L.footprintTileId.canonical), L.footprint),
                                        z))
                                            break;
                                    T.float32[w] = z ? C + uo : C,
                                    p = p || z !== A
                                }
                            }
                        }
                        return p
                    }
                    isEmpty() {
                        for (const e in this.instancesPerModel)
                            if (0 !== this.instancesPerModel[e].instancedDataArray.length)
                                return !1;
                        return !0
                    }
                    uploadPending() {
                        return !this.uploaded
                    }
                    upload(e) {
                        if (!this.uploaded)
                            for (const o in this.instancesPerModel) {
                                const a = this.instancesPerModel[o];
                                a.instancedDataArray.length < 0 || 0 === a.instancedDataArray.length || (a.instancedDataBuffer ? a.instancedDataBuffer.updateData(a.instancedDataArray) : a.instancedDataBuffer = e.createVertexBuffer(a.instancedDataArray, ny.members, !0, void 0, this.instanceCount))
                            }
                        this.uploaded = !0
                    }
                    destroy() {
                        for (const o in this.instancesPerModel) {
                            const a = this.instancesPerModel[o];
                            0 !== a.instancedDataArray.length && a.instancedDataBuffer && a.instancedDataBuffer.destroy()
                        }
                        const e = this.layers[0].modelManager;
                        if (e && this.modelUris)
                            for (const o of this.modelUris)
                                e.removeModel(o, "")
                    }
                    addFeature(e, o, a) {
                        const u = this.layers[0]
                          , l = u.layout.get("model-id").evaluate(a, {}, this.canonical);
                        if (!l)
                            return vo("modelId is not evaluated for layer ".concat(u.id, " and it is not going to get rendered.")),
                            l;
                        dg(l, !1) && (this.modelUris.includes(l) || this.modelUris.push(l)),
                        this.instancesPerModel[l] || (this.instancesPerModel[l] = new fg);
                        const p = this.instancesPerModel[l]
                          , g = p.instancedDataArray
                          , x = new mg(a,g.length);
                        for (const T of o)
                            for (const f of T) {
                                if (f.x < 0 || f.x >= uo || f.y < 0 || f.y >= uo)
                                    continue;
                                const b = (this.lookupDim - 1) / uo
                                  , P = this.lookupDim * (f.y * b | 0) + f.x * b | 0;
                                if (this.lookup) {
                                    if (0 !== this.lookup[P])
                                        continue;
                                    this.lookup[P] = 1
                                }
                                this.instanceCount++;
                                const v = g.length;
                                g.resize(v + 1),
                                p.instancesEvaluatedElevation.push(0),
                                g.float32[16 * v] = f.x,
                                g.float32[16 * v + 1] = f.y
                            }
                        return x.instancedDataCount = p.instancedDataArray.length - x.instancedDataOffset,
                        x.instancedDataCount > 0 && (e.id && (p.idToFeaturesIndex[e.id] = p.features.length),
                        p.features.push(x),
                        this.evaluate(x, {}, p, !1)),
                        l
                    }
                    getModelUris() {
                        return this.modelUris
                    }
                    evaluate(e, o, a, u) {
                        const l = this.layers[0]
                          , p = e.feature
                          , g = this.canonical
                          , x = e.rotation = l.paint.get("model-rotation").evaluate(p, o, g)
                          , T = e.scale = l.paint.get("model-scale").evaluate(p, o, g)
                          , f = e.translation = l.paint.get("model-translation").evaluate(p, o, g)
                          , b = l.paint.get("model-color").evaluate(p, o, g);
                        b.a = l.paint.get("model-color-mix-intensity").evaluate(p, o, g);
                        const P = [];
                        this.maxVerticalOffset < f[2] && (this.maxVerticalOffset = f[2]),
                        this.maxScale = Math.max(Math.max(this.maxScale, T[0]), Math.max(T[1], T[2])),
                        hg(P, x, T);
                        const v = Math.round(100 * b.a) + b.b / 1.05;
                        for (let w = 0; w < e.instancedDataCount; ++w) {
                            const C = e.instancedDataOffset + w
                              , A = 16 * C
                              , O = a.instancedDataArray.float32;
                            let F = 0;
                            u && (F = O[A + 6] - a.instancesEvaluatedElevation[C]);
                            const z = 0 | O[A + 1];
                            O[A] = (0 | O[A]) + b.r / 1.05,
                            O[A + 1] = z + b.g / 1.05,
                            O[A + 2] = v,
                            O[A + 3] = 1 / (g.z > 10 ? this.tileToMeter : i(g, z)),
                            O[A + 4] = f[0],
                            O[A + 5] = f[1],
                            O[A + 6] = f[2] + F,
                            O[A + 7] = P[0],
                            O[A + 8] = P[1],
                            O[A + 9] = P[2],
                            O[A + 10] = P[4],
                            O[A + 11] = P[5],
                            O[A + 12] = P[6],
                            O[A + 13] = P[8],
                            O[A + 14] = P[9],
                            O[A + 15] = P[10],
                            a.instancesEvaluatedElevation[C] = f[2]
                        }
                    }
                }
                let _g, gg;
                Fe(Mm, "ModelBucket", {
                    omit: ["layers"]
                }),
                Fe(fg, "PerModelAttributes"),
                Fe(mg, "ModelFeature");
                const Wh = {
                    CoordinateSpaceTile: 1,
                    CoordinateSpaceYUp: 2,
                    HasMapboxMeshFeatures: 4,
                    HasMeshoptCompression: 8
                };
                function yg(n, e, o, a, u, l, p, g, x, T=!1) {
                    const f = o.zoom
                      , b = o.project(a)
                      , P = c(a.lat, f)
                      , v = 1 / P;
                    B.mat4.identity(n),
                    B.mat4.translate(n, n, [b.x + p[0] * v, b.y + p[1] * v, p[2]]);
                    let w = 1
                      , C = 1;
                    const A = o.worldSize;
                    if (T) {
                        if ("mercator" === o.projection.name) {
                            let L = 0;
                            o.elevation && (L = o.elevation.getAtPointOrZero(new h(b.x / A,b.y / A), 0));
                            const N = B.vec4.transformMat4([], [b.x, b.y, L, 1], o.projMatrix)[3] / o.cameraToCenterDistance;
                            w = N,
                            C = N * c(o.center.lat, f)
                        } else if ("globe" === o.projection.name) {
                            const L = Pm(n, o)
                              , N = B.mat4.multiply([], o.projMatrix, L)
                              , G = [0, 0, 0, 1];
                            B.vec4.transformMat4(G, G, N);
                            const X = G[3] / o.cameraToCenterDistance
                              , _e = cr(f)
                              , me = o.projection.pixelsPerMeter(a.lat, A) * c(a.lat, f)
                              , pe = o.projection.pixelsPerMeter(o.center.lat, A) * c(o.center.lat, f);
                            w = X / jo(me, zd(o.center.lat), _e),
                            C = X * P / me,
                            w *= pe,
                            C *= pe
                        }
                    } else
                        w = v;
                    B.mat4.scale(n, n, [w, w, C]);
                    const O = [...n]
                      , F = e.orientation
                      , z = [];
                    if (hg(z, [F[0] + u[0], F[1] + u[1], F[2] + u[2]], l),
                    B.mat4.multiply(n, O, z),
                    g && o.elevation) {
                        let L = 0;
                        const N = [];
                        if (x && o.elevation) {
                            L = function(_e, me, pe, Ne, Pe) {
                                const $e = me.elevation;
                                if (!$e)
                                    return 0;
                                const We = No.projectAabbCorners(pe, Ne)
                                  , je = ar(1, Pe.lat) * me.worldSize
                                  , Ke = function(Ro, ho) {
                                    const Ao = [0, 0, 1]
                                      , $o = [{
                                        corners: [0, 1, 3, 2],
                                        dotProductWithUp: 0
                                    }, {
                                        corners: [1, 5, 2, 6],
                                        dotProductWithUp: 0
                                    }, {
                                        corners: [0, 4, 1, 5],
                                        dotProductWithUp: 0
                                    }, {
                                        corners: [2, 6, 3, 7],
                                        dotProductWithUp: 0
                                    }, {
                                        corners: [4, 7, 5, 6],
                                        dotProductWithUp: 0
                                    }, {
                                        corners: [0, 3, 4, 7],
                                        dotProductWithUp: 0
                                    }];
                                    for (const Qo of $o) {
                                        const ni = Ro[Qo.corners[0]]
                                          , di = Ro[Qo.corners[1]]
                                          , ri = Ro[Qo.corners[2]]
                                          , gi = [di[0] - ni[0], di[1] - ni[1], ho * (di[2] - ni[2])]
                                          , Zi = B.vec3.cross(gi, gi, [ri[0] - ni[0], ri[1] - ni[1], ho * (ri[2] - ni[2])]);
                                        B.vec3.normalize(Zi, Zi),
                                        Qo.dotProductWithUp = B.vec3.dot(Zi, Ao)
                                    }
                                    return $o.sort( (Qo, ni) => Qo.dotProductWithUp - ni.dotProductWithUp),
                                    $o[0].corners
                                }(We, je)
                                  , rt = We[Ke[0]]
                                  , at = We[Ke[1]]
                                  , ot = We[Ke[2]]
                                  , Ct = We[Ke[3]]
                                  , Zt = $e.getAtPointOrZero(new h(rt[0] / me.worldSize,rt[1] / me.worldSize), 0)
                                  , Ot = $e.getAtPointOrZero(new h(at[0] / me.worldSize,at[1] / me.worldSize), 0)
                                  , lo = $e.getAtPointOrZero(new h(ot[0] / me.worldSize,ot[1] / me.worldSize), 0)
                                  , io = $e.getAtPointOrZero(new h(Ct[0] / me.worldSize,Ct[1] / me.worldSize), 0)
                                  , fo = (Zt + io) / 2
                                  , Bt = (Ot + lo) / 2;
                                return fo > Bt ? Ot < lo ? cd(_e, at, Ct, rt, Ot, io, Zt, je) : cd(_e, ot, rt, Ct, lo, Zt, io, je) : Zt < io ? cd(_e, rt, at, ot, Zt, Ot, lo, je) : cd(_e, Ct, ot, at, io, lo, Ot, je),
                                Math.max(fo, Bt)
                            }(N, o, e.aabb, n, a);
                            const G = B.mat4.fromQuat([], N)
                              , X = B.mat4.multiply([], G, z);
                            B.mat4.multiply(n, O, X)
                        } else
                            L = o.elevation.getAtPointOrZero(new h(b.x / A,b.y / A), 0);
                        0 !== L && (n[14] += L)
                    }
                }
                function ep(n, e, o=!1) {
                    n.uploaded || (n.gfxTexture = new xm(e,n.image,o ? e.gl.R8 : e.gl.RGBA8,{
                        useMipmap: n.sampler.minFilter >= e.gl.NEAREST_MIPMAP_NEAREST
                    }),
                    n.uploaded = !0,
                    n.image = null)
                }
                function sy(n, e, o) {
                    n.indexBuffer = e.createIndexBuffer(n.indexArray, !1, !0),
                    n.vertexBuffer = e.createVertexBuffer(n.vertexArray, Q1.members, !1, !0),
                    n.normalArray && (n.normalBuffer = e.createVertexBuffer(n.normalArray, iy.members, !1, !0)),
                    n.texcoordArray && (n.texcoordBuffer = e.createVertexBuffer(n.texcoordArray, oy.members, !1, !0)),
                    n.colorArray && (n.colorBuffer = e.createVertexBuffer(n.colorArray, (12 === n.colorArray.bytesPerElement ? ey : ty).members, !1, !0)),
                    n.featureArray && (n.pbrBuffer = e.createVertexBuffer(n.featureArray, ry.members, !0)),
                    n.segments = mn.simpleSegment(0, 0, n.vertexArray.length, n.indexArray.length);
                    const a = n.material;
                    a.pbrMetallicRoughness.baseColorTexture && ep(a.pbrMetallicRoughness.baseColorTexture, e),
                    a.pbrMetallicRoughness.metallicRoughnessTexture && ep(a.pbrMetallicRoughness.metallicRoughnessTexture, e),
                    a.normalTexture && ep(a.normalTexture, e),
                    a.occlusionTexture && ep(a.occlusionTexture, e, o),
                    a.emissionTexture && ep(a.emissionTexture, e)
                }
                function Tm(n, e, o) {
                    if (n.meshes)
                        for (const a of n.meshes)
                            sy(a, e, o);
                    if (n.children)
                        for (const a of n.children)
                            Tm(a, e, o)
                }
                function ud(n) {
                    if (n.meshes)
                        for (const e of n.meshes)
                            e.indexArray.destroy(),
                            e.vertexArray.destroy(),
                            e.colorArray && e.colorArray.destroy(),
                            e.normalArray && e.normalArray.destroy(),
                            e.texcoordArray && e.texcoordArray.destroy(),
                            e.featureArray && e.featureArray.destroy();
                    if (n.children)
                        for (const e of n.children)
                            ud(e)
                }
                function Cm(n) {
                    if (n.meshes)
                        for (const o of n.meshes)
                            o.vertexBuffer && (o.vertexBuffer.destroy(),
                            o.indexBuffer.destroy(),
                            o.normalBuffer && o.normalBuffer.destroy(),
                            o.texcoordBuffer && o.texcoordBuffer.destroy(),
                            o.colorBuffer && o.colorBuffer.destroy(),
                            o.pbrBuffer && o.pbrBuffer.destroy(),
                            o.segments.destroy(),
                            o.material && ((e = o.material).pbrMetallicRoughness.baseColorTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(),
                            e.pbrMetallicRoughness.metallicRoughnessTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(),
                            e.normalTexture && e.normalTexture.gfxTexture && e.normalTexture.gfxTexture.destroy(),
                            e.emissionTexture && e.emissionTexture.gfxTexture && e.emissionTexture.gfxTexture.destroy(),
                            e.occlusionTexture && e.occlusionTexture.gfxTexture && e.occlusionTexture.gfxTexture.destroy()));
                    var e;
                    if (n.children)
                        for (const o of n.children)
                            Cm(o)
                }
                class Xh {
                    constructor(e, o, a) {
                        this._demTile = e,
                        this._dem = this._demTile.dem,
                        this._scale = o,
                        this._offset = a
                    }
                    static create(e, o, a) {
                        const u = a || e.findDEMTileFor(o);
                        if (!u || !u.dem)
                            return;
                        const l = u.dem
                          , p = u.tileID
                          , g = 1 << o.canonical.z - p.canonical.z;
                        return new Xh(u,l.dim / uo / g,[(o.canonical.x / g - p.canonical.x) * l.dim, (o.canonical.y / g - p.canonical.y) * l.dim])
                    }
                    tileCoordToPixel(e, o) {
                        const a = o * this._scale + this._offset[1]
                          , u = Math.floor(e * this._scale + this._offset[0])
                          , l = Math.floor(a);
                        return new tt(u,l)
                    }
                    getElevationAt(e, o, a, u) {
                        const l = e * this._scale + this._offset[0]
                          , p = o * this._scale + this._offset[1]
                          , g = Math.floor(l)
                          , x = Math.floor(p)
                          , T = this._dem;
                        return u = !!u,
                        a ? jo(jo(T.get(g, x, u), T.get(g, x + 1, u), p - x), jo(T.get(g + 1, x, u), T.get(g + 1, x + 1, u), p - x), l - g) : T.get(g, x, u)
                    }
                    getElevationAtPixel(e, o, a) {
                        return this._dem.get(e, o, !!a)
                    }
                    getMeterToDEM(e) {
                        return (1 << this._demTile.tileID.canonical.z) * ar(1, e) * this._dem.stride
                    }
                }
                const Em = new Float32Array(262144)
                  , Uc = new Uint8Array(262144);
                function vg(n) {
                    let e = 0;
                    if (n.meshes)
                        for (const o of n.meshes)
                            e = Math.max(e, o.aabb.max[2]);
                    if (n.children)
                        for (const o of n.children)
                            e = Math.max(e, vg(o));
                    return e
                }
                function xg(n, e, o) {
                    if (n.meshes)
                        for (const a of n.meshes) {
                            if (a.aabb.min[0] === 1 / 0)
                                continue;
                            const u = No.applyTransform(a.aabb, n.matrix);
                            o.insert(e, u.min[0], u.min[1], u.max[0], u.max[1])
                        }
                    if (n.children)
                        for (const a of n.children)
                            xg(a, e, o)
                }
                const bg = ["", "wall", "door", "roof", "window", "lamp", "logo"];
                class wg {
                    constructor(e) {
                        this.node = e,
                        this.evaluatedRMEA = [[1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [.4, 1, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1]],
                        this.hiddenByReplacement = !1,
                        this.evaluatedScale = [1, 1, 1],
                        this.evaluatedColor = [],
                        this.emissionHeightBasedParams = [],
                        this.cameraCollisionOpacity = 1,
                        this.feature = {
                            type: "Point",
                            id: e.id,
                            geometry: [],
                            properties: {
                                height: vg(e)
                            }
                        },
                        this.aabb = this._getLocalBounds(),
                        this.state = null
                    }
                    _getLocalBounds() {
                        if (!this.node.meshes)
                            return new No([1 / 0, 1 / 0, 1 / 0],[-1 / 0, -1 / 0, -1 / 0]);
                        if (!this.aabb) {
                            let e = 0;
                            const o = new No([1 / 0, 1 / 0, 1 / 0],[-1 / 0, -1 / 0, -1 / 0]);
                            for (const a of this.node.meshes)
                                this.node.lightMeshIndex !== e && (a.transformedAabb = No.applyTransformFast(a.aabb, this.node.matrix),
                                o.encapsulate(a.transformedAabb)),
                                e++;
                            this.aabb = o
                        }
                        return this.aabb
                    }
                }
                class pd {
                    constructor(e, o, a, u, l, p, g) {
                        this.id = a,
                        this.layers = e,
                        this.layerIds = this.layers.map(x => x.fqid),
                        this.stateDependentLayerIds = this.layers.filter(x => x.isStateDependent()).map(x => x.id),
                        this.modelTraits |= Wh.CoordinateSpaceTile,
                        this.uploaded = !1,
                        this.hasPattern = !1,
                        u && (this.modelTraits |= Wh.HasMapboxMeshFeatures),
                        l && (this.modelTraits |= Wh.HasMeshoptCompression),
                        this.zoom = -1,
                        this.terrainExaggeration = 1,
                        this.projection = {
                            name: "mercator"
                        },
                        this.replacementUpdateTime = 0,
                        this.elevationReadFromZ = 255,
                        this.brightness = p,
                        this.dirty = !0,
                        this.needsUpload = !1,
                        this.nodesInfo = [];
                        for (const x of o)
                            this.nodesInfo.push(new wg(x)),
                            xg(x, g.featureIndexArray.length, g.grid),
                            g.featureIndexArray.emplaceBack(this.nodesInfo.length - 1, 0, g.bucketLayerIDs.length - 1, 0);
                        this.states = {}
                    }
                    updateFootprints(e, o) {
                        for (const a of this.getNodesInfo()) {
                            const u = a.node;
                            u.footprint && o.push({
                                footprint: u.footprint,
                                id: e
                            })
                        }
                    }
                    update(e) {
                        const o = 0 !== Object.keys(e).length;
                        if (o && !this.stateDependentLayers.length)
                            return;
                        const a = o ? this.stateDependentLayers : this.layers;
                        if (!$t(e, this.states))
                            for (const u of a)
                                this.evaluate(u, e);
                        this.states = structuredClone(e)
                    }
                    populate() {
                        console.log("populate 3D model bucket")
                    }
                    uploadPending() {
                        return !this.uploaded || this.needsUpload
                    }
                    upload(e) {
                        if (!this.needsUpload)
                            return;
                        const o = this.getNodesInfo();
                        for (const a of o) {
                            const u = a.node;
                            this.uploaded ? this.updatePbrBuffer(u) : Tm(u, e, !0)
                        }
                        for (const a of o)
                            ud(a.node);
                        this.uploaded = !0,
                        this.needsUpload = !1
                    }
                    updatePbrBuffer(e) {
                        let o = !1;
                        if (!e.meshes)
                            return o;
                        for (const a of e.meshes)
                            a.pbrBuffer && (a.pbrBuffer.updateData(a.featureArray),
                            o = !0);
                        return o
                    }
                    needsReEvaluation(e, o, a) {
                        const u = e.transform.projectionOptions
                          , l = e.style.getBrightness()
                          , p = this.brightness !== l;
                        if (!this.uploaded || this.dirty || u.name !== this.projection.name || tp(a.paint.get("model-color").value, p) || tp(a.paint.get("model-color-mix-intensity").value, p) || tp(a.paint.get("model-roughness").value, p) || tp(a.paint.get("model-emissive-strength").value, p) || tp(a.paint.get("model-height-based-emissive-strength-multiplier").value, p)) {
                            this.projection = u,
                            this.brightness = l;
                            const g = this.getNodesInfo();
                            for (const x of g)
                                x.state = null;
                            return !0
                        }
                        return !1
                    }
                    evaluateScale(e, o) {
                        if (e.transform.zoom === this.zoom)
                            return;
                        this.zoom = e.transform.zoom;
                        const a = this.getNodesInfo()
                          , u = this.id.canonical;
                        for (const l of a) {
                            const p = l.feature;
                            l.evaluatedScale = o.paint.get("model-scale").evaluate(p, {}, u)
                        }
                    }
                    evaluate(e, o) {
                        const a = this.getNodesInfo();
                        for (const u of a) {
                            if (!u.node.meshes)
                                continue;
                            const l = u.feature
                              , p = o && o[l.id];
                            if ($t(p, u.state))
                                continue;
                            u.state = structuredClone(p);
                            const g = u.node.meshes && u.node.meshes[0].featureData
                              , x = u.evaluatedColor[2]
                              , T = u.evaluatedRMEA[2]
                              , f = this.id.canonical;
                            if (u.hasTranslucentParts = !1,
                            g) {
                                for (let b = 0; b < bg.length; b++) {
                                    const P = bg[b];
                                    P.length && (l.properties.part = P);
                                    const v = e.paint.get("model-color").evaluate(l, p, f).toRenderColor(null)
                                      , w = e.paint.get("model-color-mix-intensity").evaluate(l, p, f);
                                    u.evaluatedColor[b] = [v.r, v.g, v.b, w],
                                    u.evaluatedRMEA[b][0] = e.paint.get("model-roughness").evaluate(l, p, f),
                                    u.evaluatedRMEA[b][2] = e.paint.get("model-emissive-strength").evaluate(l, p, f),
                                    u.evaluatedRMEA[b][3] = v.a,
                                    u.emissionHeightBasedParams[b] = e.paint.get("model-height-based-emissive-strength-multiplier").evaluate(l, p, f),
                                    !u.hasTranslucentParts && v.a < 1 && (u.hasTranslucentParts = !0)
                                }
                                delete l.properties.part,
                                ly(u, x !== u.evaluatedColor[2] || T !== u.evaluatedRMEA[2], this.modelTraits)
                            } else
                                u.evaluatedRMEA[0][2] = e.paint.get("model-emissive-strength").evaluate(l, p, f);
                            u.evaluatedScale = e.paint.get("model-scale").evaluate(l, p, f),
                            this.updatePbrBuffer(u.node) || (this.needsUpload = !0)
                        }
                        this.dirty = !1
                    }
                    elevationUpdate(e, o, a, u) {
                        const l = e.findDEMTileFor(a);
                        if (l && (l.tileID.canonical !== this.terrainTile || o !== this.terrainExaggeration)) {
                            if (l.dem && l.tileID.overscaledZ !== this.elevationReadFromZ) {
                                this.elevationReadFromZ = l.tileID.overscaledZ;
                                const p = Xh.create(e, a, l);
                                if (!p)
                                    return;
                                this.modelTraits & Wh.HasMapboxMeshFeatures && this.updateDEM(e, p, a, u);
                                for (const g of this.getNodesInfo()) {
                                    const x = g.node;
                                    if (!x.footprint || !x.footprint.vertices || !x.footprint.vertices.length)
                                        continue;
                                    const T = x.footprint.vertices;
                                    let f = p.getElevationAt(T[0].x, T[0].y, !0, !0);
                                    for (let b = 1; b < T.length; b++)
                                        f = Math.min(f, p.getElevationAt(T[b].x, T[b].y, !0, !0));
                                    x.elevation = f
                                }
                            }
                            this.terrainTile = l.tileID.canonical,
                            this.terrainExaggeration = o
                        }
                    }
                    updateDEM(e, o, a, u) {
                        let l = o._dem._modifiedForSources[u];
                        if (void 0 === l && (o._dem._modifiedForSources[u] = [],
                        l = o._dem._modifiedForSources[u]),
                        l.includes(a.canonical))
                            return;
                        const p = o._dem.dim;
                        l.push(a.canonical);
                        let g = !1;
                        for (const x of this.getNodesInfo()) {
                            const T = x.node;
                            if (!T.footprint || !T.footprint.grid)
                                continue;
                            const f = T.footprint.grid
                              , b = o.tileCoordToPixel(f.min.x, f.min.y)
                              , P = o.tileCoordToPixel(f.max.x, f.max.y)
                              , v = Math.min(Math.min(p - P.y, b.x), Math.min(b.y, p - P.x));
                            if (v < 0)
                                continue;
                            const w = ie(v, 2, 5);
                            let C = Math.max(0, b.x - w)
                              , A = Math.max(0, b.y - w)
                              , O = Math.min(P.x + w, p - 1)
                              , F = Math.min(P.y + w, p - 1);
                            for (let G = A; G <= F; ++G)
                                for (let X = C; X <= O; ++X)
                                    Uc[G * p + X] = 255;
                            let z = 0
                              , L = 0;
                            for (let G = 0; G < f.cellsY; ++G)
                                for (let X = 0; X < f.cellsX; ++X) {
                                    if (!f.cells[G * f.cellsX + X])
                                        continue;
                                    const _e = o.tileCoordToPixel(f.min.x + X / f.xScale, f.min.y + G / f.yScale)
                                      , me = o.tileCoordToPixel(f.min.x + (X + 1) / f.xScale, f.min.y + (G + 1) / f.yScale);
                                    for (let pe = _e.y; pe <= Math.min(me.y + 1, p - 1); ++pe)
                                        for (let Ne = _e.x; Ne <= Math.min(me.x + 1, p - 1); ++Ne)
                                            255 === Uc[pe * p + Ne] && (Uc[pe * p + Ne] = 0,
                                            z += o.getElevationAtPixel(Ne, pe),
                                            L++)
                                }
                            const N = z / L;
                            C = Math.max(1, b.x - w),
                            A = Math.max(1, b.y - w),
                            O = Math.min(P.x + w, p - 2),
                            F = Math.min(P.y + w, p - 2),
                            g = !0;
                            for (let G = A; G <= F; ++G)
                                for (let X = C; X <= O; ++X)
                                    0 === Uc[G * p + X] && (Em[G * p + X] = o._dem.set(X, G, N));
                            for (let G = 1; G < w; ++G) {
                                C = Math.max(1, b.x - G),
                                A = Math.max(1, b.y - G),
                                O = Math.min(P.x + G, p - 2),
                                F = Math.min(P.y + G, p - 2);
                                for (let X = A; X <= F; ++X)
                                    for (let _e = C; _e <= O; ++_e) {
                                        const me = X * p + _e;
                                        if (255 === Uc[me]) {
                                            let pe = 0
                                              , Ne = 0
                                              , Pe = -1
                                              , $e = -1;
                                            for (let We = -1; We <= 1; ++We)
                                                for (let je = -1; je <= 1; ++je) {
                                                    const Ke = (X + We) * p + _e + je;
                                                    if (Uc[Ke] >= G)
                                                        continue;
                                                    const rt = Em[Ke]
                                                      , at = Math.abs(rt);
                                                    at > Ne && (pe = rt,
                                                    Ne = at,
                                                    Pe = je,
                                                    $e = We)
                                                }
                                            if (Ne > .1) {
                                                const We = 1 - (G + .5 * Math.abs(Pe * $e)) / w;
                                                let je = o._dem.get(_e, X) + pe * We;
                                                const Ke = o._dem.get(_e + Pe, X + $e)
                                                  , rt = o._dem.get(_e - Pe, X - $e, !0);
                                                (je - Ke) * (je - rt) > 0 && (je = (Ke + rt) / 2),
                                                Em[me] = o._dem.set(_e, X, je),
                                                Uc[me] = G
                                            }
                                        }
                                    }
                            }
                        }
                        g && (o._demTile.needsDEMTextureUpload = !0,
                        o._dem._timestamp = Qt.now())
                    }
                    getNodesInfo() {
                        return this.nodesInfo
                    }
                    destroy() {
                        const e = this.getNodesInfo();
                        for (const o of e)
                            ud(o.node),
                            Cm(o.node)
                    }
                    isEmpty() {
                        return !this.nodesInfo.length
                    }
                    updateReplacement(e, o) {
                        if (o.updateTime === this.replacementUpdateTime)
                            return;
                        this.replacementUpdateTime = o.updateTime;
                        const a = o.getReplacementRegionsForTile(e.toUnwrapped())
                          , u = this.getNodesInfo();
                        for (let l = 0; l < this.nodesInfo.length; l++) {
                            const p = u[l].node;
                            u[l].hiddenByReplacement = !!p.footprint && !a.find(g => g.footprint === p.footprint)
                        }
                    }
                    getHeightAtTileCoord(e, o) {
                        const a = this.getNodesInfo()
                          , u = []
                          , l = [0, 0, 0]
                          , p = B.mat4.identity([]);
                        for (let g = 0; g < this.nodesInfo.length; g++) {
                            const x = a[g]
                              , T = x.node.meshes[0]
                              , f = T.transformedAabb;
                            if (e < f.min[0] || o < f.min[1] || e > f.max[0] || o > f.max[1])
                                continue;
                            if (!0 === x.node.hidden)
                                return {
                                    height: 1 / 0,
                                    maxHeight: x.feature.properties.height,
                                    hidden: !1,
                                    verticalScale: x.evaluatedScale[2]
                                };
                            B.mat4.invert(p, x.node.matrix),
                            l[0] = e,
                            l[1] = o,
                            B.vec3.transformMat4(l, l, p);
                            const b = (l[0] - T.aabb.min[0]) / (T.aabb.max[0] - T.aabb.min[0]) * 64 | 0
                              , P = 64 * Math.min(63, (l[1] - T.aabb.min[1]) / (T.aabb.max[1] - T.aabb.min[1]) * 64 | 0) + Math.min(63, b)
                              , v = T.heightmap[P];
                            if (!(v < 0 && x.node.footprint))
                                return x.hiddenByReplacement ? void 0 : {
                                    height: v,
                                    maxHeight: x.feature.properties.height,
                                    hidden: !1,
                                    verticalScale: x.evaluatedScale[2]
                                };
                            if (x.node.footprint.grid.query(new tt(e,o), new tt(e,o), u),
                            u.length > 0)
                                return {
                                    height: void 0,
                                    maxHeight: x.feature.properties.height,
                                    hidden: x.hiddenByReplacement,
                                    verticalScale: x.evaluatedScale[2]
                                }
                        }
                    }
                }
                function tp(n, e) {
                    return !n.isLightConstant && e
                }
                function ay(n, e, o, a, u, l, p, g) {
                    let x = (61440 & e | (61440 & e) >> 4) >> 8
                      , T = (3840 & e | (3840 & e) >> 4) >> 4
                      , f = 240 & e | (240 & e) >> 4;
                    o[3] > 0 && (x = jo(x, 255 * o[0], o[3]),
                    T = jo(T, 255 * o[1], o[3]),
                    f = jo(f, 255 * o[2], o[3]));
                    const b = x << 8 | T
                      , P = f << 8 | Math.floor(255 * a[3])
                      , v = function(G) {
                        const X = ie(G, 0, 2);
                        return Math.min(Math.round(.5 * X * 255), 255)
                    }(a[2]) << 8 | 15 * a[0] << 4 | 15 * a[1]
                      , w = ie(u[0], 0, 1)
                      , C = ie(u[1], 0, 1)
                      , A = ie(u[2], 0, 1)
                      , O = ie(u[3], 0, 1);
                    let F, z, L, N;
                    if (w !== C && p !== l && C !== w) {
                        const G = p - l;
                        z = 1 / (G * (C - w)),
                        L = -(l + G * w) / (G * (C - w));
                        const X = ie(u[4], -1, 1);
                        N = Math.pow(10, X),
                        F = 255 * A << 8 | 255 * O
                    } else
                        F = 65535,
                        z = 0,
                        L = 1,
                        N = 1;
                    if (n.emplaceBack(b, P, v, F, z, L, N),
                    g) {
                        const G = g.length;
                        g.clear();
                        for (let X = 0; X < G; X++)
                            g.emplaceBack(b, P, v, F, z, L, N)
                    }
                }
                function ly(n, e, o) {
                    const a = n.node;
                    let u = 0;
                    const l = o & Wh.HasMeshoptCompression;
                    for (const p of a.meshes) {
                        if (a.lights && a.lightMeshIndex === u || !p.featureData)
                            continue;
                        p.featureArray = new Tc,
                        p.featureArray.reserve(p.featureData.length);
                        let g = e;
                        for (const x of p.featureData) {
                            const T = l ? 65535 & x : x >> 16 & 65535
                              , f = l ? x >> 16 & 65535 : 65535 & x
                              , b = (15 & f) < 8 ? 15 & f : 0
                              , P = n.evaluatedRMEA[b]
                              , v = n.evaluatedColor[b]
                              , w = n.emissionHeightBasedParams[b];
                            let C;
                            if (g && 2 === b && a.lights && (C = new Tc,
                            C.resize(10 * a.lights.length)),
                            ay(p.featureArray, T, v, P, w, p.aabb.min[2], p.aabb.max[2], C),
                            C && g) {
                                g = !1;
                                const A = a.meshes[a.lightMeshIndex];
                                A.featureArray = C,
                                A.featureArray._trim()
                            }
                        }
                        p.featureArray._trim(),
                        u++
                    }
                }
                function Pg(n, e, o, a) {
                    const u = 1 << n.z;
                    e.lat = Gn((a / uo + n.y) / u),
                    e.lng = Mr((o / uo + n.x) / u)
                }
                Fe(pd, "Tiled3dModelBucket", {
                    omit: ["layers"]
                }),
                Fe(wg, "Tiled3dModelFeature");
                const cy = {
                    circle: class extends dr {
                        constructor(n, e, o, a) {
                            super(n, {
                                layout: ut || (ut = new cn({
                                    "circle-sort-key": new Mo(ft.layout_circle["circle-sort-key"]),
                                    visibility: new eo(ft.layout_circle.visibility)
                                })),
                                paint: Gt || (Gt = new cn({
                                    "circle-radius": new Mo(ft.paint_circle["circle-radius"]),
                                    "circle-color": new Mo(ft.paint_circle["circle-color"]),
                                    "circle-blur": new Mo(ft.paint_circle["circle-blur"]),
                                    "circle-opacity": new Mo(ft.paint_circle["circle-opacity"]),
                                    "circle-translate": new eo(ft.paint_circle["circle-translate"]),
                                    "circle-translate-anchor": new eo(ft.paint_circle["circle-translate-anchor"]),
                                    "circle-pitch-scale": new eo(ft.paint_circle["circle-pitch-scale"]),
                                    "circle-pitch-alignment": new eo(ft.paint_circle["circle-pitch-alignment"]),
                                    "circle-stroke-width": new Mo(ft.paint_circle["circle-stroke-width"]),
                                    "circle-stroke-color": new Mo(ft.paint_circle["circle-stroke-color"]),
                                    "circle-stroke-opacity": new Mo(ft.paint_circle["circle-stroke-opacity"]),
                                    "circle-emissive-strength": new eo(ft.paint_circle["circle-emissive-strength"]),
                                    "circle-color-use-theme": new Mo({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    }),
                                    "circle-stroke-color-use-theme": new Mo({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    })
                                }))
                            }, e, o, a)
                        }
                        createBucket(n) {
                            return new j(n)
                        }
                        queryRadius(n) {
                            const e = n;
                            return nt("circle-radius", this, e) + nt("circle-stroke-width", this, e) + zt(this.paint.get("circle-translate"))
                        }
                        queryIntersectsFeature(n, e, o, a, u, l, p, g) {
                            const x = to(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), l.angle, n.pixelToTileUnitsFactor)
                              , T = this.paint.get("circle-radius").evaluate(e, o) + this.paint.get("circle-stroke-width").evaluate(e, o);
                            return Bh(n, a, l, p, g, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), x, T)
                        }
                        getProgramIds() {
                            return ["circle"]
                        }
                        getDefaultProgramParams(n, e, o) {
                            const a = zh(this);
                            return {
                                config: new Ua(this,{
                                    zoom: e,
                                    lut: o
                                }),
                                defines: a,
                                overrideFog: !1
                            }
                        }
                    }
                    ,
                    heatmap: class extends dr {
                        createBucket(n) {
                            return new ef(n)
                        }
                        constructor(n, e, o, a) {
                            super(n, {
                                layout: tf || (tf = new cn({
                                    visibility: new eo(ft.layout_heatmap.visibility)
                                })),
                                paint: of || (of = new cn({
                                    "heatmap-radius": new Mo(ft.paint_heatmap["heatmap-radius"]),
                                    "heatmap-weight": new Mo(ft.paint_heatmap["heatmap-weight"]),
                                    "heatmap-intensity": new eo(ft.paint_heatmap["heatmap-intensity"]),
                                    "heatmap-color": new ca(ft.paint_heatmap["heatmap-color"]),
                                    "heatmap-opacity": new eo(ft.paint_heatmap["heatmap-opacity"]),
                                    "heatmap-color-use-theme": new Mo({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    })
                                }))
                            }, e, o, a),
                            this._updateColorRamp()
                        }
                        _handleSpecialPaintPropertyUpdate(n) {
                            "heatmap-color" === n && this._updateColorRamp()
                        }
                        _updateColorRamp() {
                            this.colorRamp = Lu({
                                expression: this._transitionablePaint._values["heatmap-color"].value.expression,
                                evaluationKey: "heatmapDensity",
                                image: this.colorRamp
                            }),
                            this.colorRampTexture = null
                        }
                        resize() {
                            this.heatmapFbo && (this.heatmapFbo.destroy(),
                            this.heatmapFbo = null)
                        }
                        queryRadius(n) {
                            return nt("heatmap-radius", this, n)
                        }
                        queryIntersectsFeature(n, e, o, a, u, l, p, g) {
                            const x = this.paint.get("heatmap-radius").evaluate(e, o);
                            return Bh(n, a, l, p, g, !0, !0, new tt(0,0), x)
                        }
                        hasOffscreenPass() {
                            return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility
                        }
                        getProgramIds() {
                            return ["heatmap", "heatmapTexture"]
                        }
                        getDefaultProgramParams(n, e, o) {
                            return "heatmap" === n ? {
                                config: new Ua(this,{
                                    zoom: e,
                                    lut: o
                                }),
                                overrideFog: !1
                            } : {}
                        }
                    }
                    ,
                    hillshade: class extends dr {
                        constructor(n, e, o, a) {
                            super(n, {
                                layout: nf || (nf = new cn({
                                    visibility: new eo(ft.layout_hillshade.visibility)
                                })),
                                paint: rf || (rf = new cn({
                                    "hillshade-illumination-direction": new eo(ft.paint_hillshade["hillshade-illumination-direction"]),
                                    "hillshade-illumination-anchor": new eo(ft.paint_hillshade["hillshade-illumination-anchor"]),
                                    "hillshade-exaggeration": new eo(ft.paint_hillshade["hillshade-exaggeration"]),
                                    "hillshade-shadow-color": new eo(ft.paint_hillshade["hillshade-shadow-color"]),
                                    "hillshade-highlight-color": new eo(ft.paint_hillshade["hillshade-highlight-color"]),
                                    "hillshade-accent-color": new eo(ft.paint_hillshade["hillshade-accent-color"]),
                                    "hillshade-emissive-strength": new eo(ft.paint_hillshade["hillshade-emissive-strength"]),
                                    "hillshade-shadow-color-use-theme": new Mo({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    }),
                                    "hillshade-highlight-color-use-theme": new Mo({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    }),
                                    "hillshade-accent-color-use-theme": new Mo({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    })
                                }))
                            }, e, o, a)
                        }
                        shouldRedrape() {
                            return this.hasOffscreenPass() && "viewport" === this.paint.get("hillshade-illumination-anchor")
                        }
                        hasOffscreenPass() {
                            return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility
                        }
                        getProgramIds() {
                            return ["hillshade", "hillshadePrepare"]
                        }
                        getDefaultProgramParams(n, e, o) {
                            return {
                                overrideFog: !1
                            }
                        }
                    }
                    ,
                    fill: class extends dr {
                        constructor(n, e, o, a) {
                            super(n, {
                                layout: mf || (mf = new cn({
                                    "fill-sort-key": new Mo(ft.layout_fill["fill-sort-key"]),
                                    visibility: new eo(ft.layout_fill.visibility),
                                    "fill-elevation-reference": new eo(ft.layout_fill["fill-elevation-reference"])
                                })),
                                paint: ff || (ff = new cn({
                                    "fill-antialias": new eo(ft.paint_fill["fill-antialias"]),
                                    "fill-opacity": new Mo(ft.paint_fill["fill-opacity"]),
                                    "fill-color": new Mo(ft.paint_fill["fill-color"]),
                                    "fill-outline-color": new Mo(ft.paint_fill["fill-outline-color"]),
                                    "fill-translate": new eo(ft.paint_fill["fill-translate"]),
                                    "fill-translate-anchor": new eo(ft.paint_fill["fill-translate-anchor"]),
                                    "fill-pattern": new Mo(ft.paint_fill["fill-pattern"]),
                                    "fill-emissive-strength": new eo(ft.paint_fill["fill-emissive-strength"]),
                                    "fill-z-offset": new Mo(ft.paint_fill["fill-z-offset"]),
                                    "fill-color-use-theme": new Mo({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    }),
                                    "fill-outline-color-use-theme": new Mo({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    })
                                }))
                            }, e, o, a)
                        }
                        getProgramIds() {
                            const n = this.paint.get("fill-pattern")
                              , e = n && n.constantOr(1)
                              , o = [e ? "fillPattern" : "fill"];
                            return this.paint.get("fill-antialias") && o.push(e && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"),
                            o
                        }
                        getDefaultProgramParams(n, e, o) {
                            return {
                                config: new Ua(this,{
                                    zoom: e,
                                    lut: o
                                }),
                                overrideFog: !1
                            }
                        }
                        recalculate(n, e) {
                            super.recalculate(n, e);
                            const o = this.paint._values["fill-outline-color"];
                            "constant" === o.value.kind && void 0 === o.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"])
                        }
                        createBucket(n) {
                            return new jd(n)
                        }
                        queryRadius() {
                            return zt(this.paint.get("fill-translate"))
                        }
                        queryIntersectsFeature(n, e, o, a, u, l) {
                            return !n.queryGeometry.isAboveHorizon && he(Yt(n.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), l.angle, n.pixelToTileUnitsFactor), a)
                        }
                        isTileClipped() {
                            return !0
                        }
                        is3D() {
                            return 0 !== this.paint.get("fill-z-offset").constantOr(1)
                        }
                    }
                    ,
                    "fill-extrusion": class extends dr {
                        constructor(n, e, o, a) {
                            super(n, {
                                layout: Kf || (Kf = new cn({
                                    visibility: new eo(ft["layout_fill-extrusion"].visibility),
                                    "fill-extrusion-edge-radius": new eo(ft["layout_fill-extrusion"]["fill-extrusion-edge-radius"])
                                })),
                                paint: qf || (qf = new cn({
                                    "fill-extrusion-opacity": new eo(ft["paint_fill-extrusion"]["fill-extrusion-opacity"]),
                                    "fill-extrusion-color": new Mo(ft["paint_fill-extrusion"]["fill-extrusion-color"]),
                                    "fill-extrusion-translate": new eo(ft["paint_fill-extrusion"]["fill-extrusion-translate"]),
                                    "fill-extrusion-translate-anchor": new eo(ft["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
                                    "fill-extrusion-pattern": new Mo(ft["paint_fill-extrusion"]["fill-extrusion-pattern"]),
                                    "fill-extrusion-height": new Mo(ft["paint_fill-extrusion"]["fill-extrusion-height"]),
                                    "fill-extrusion-base": new Mo(ft["paint_fill-extrusion"]["fill-extrusion-base"]),
                                    "fill-extrusion-height-alignment": new eo(ft["paint_fill-extrusion"]["fill-extrusion-height-alignment"]),
                                    "fill-extrusion-base-alignment": new eo(ft["paint_fill-extrusion"]["fill-extrusion-base-alignment"]),
                                    "fill-extrusion-vertical-gradient": new eo(ft["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]),
                                    "fill-extrusion-ambient-occlusion-intensity": new eo(ft["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]),
                                    "fill-extrusion-ambient-occlusion-radius": new eo(ft["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]),
                                    "fill-extrusion-ambient-occlusion-wall-radius": new eo(ft["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-wall-radius"]),
                                    "fill-extrusion-ambient-occlusion-ground-radius": new eo(ft["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-radius"]),
                                    "fill-extrusion-ambient-occlusion-ground-attenuation": new eo(ft["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-attenuation"]),
                                    "fill-extrusion-flood-light-color": new eo(ft["paint_fill-extrusion"]["fill-extrusion-flood-light-color"]),
                                    "fill-extrusion-flood-light-intensity": new eo(ft["paint_fill-extrusion"]["fill-extrusion-flood-light-intensity"]),
                                    "fill-extrusion-flood-light-wall-radius": new Mo(ft["paint_fill-extrusion"]["fill-extrusion-flood-light-wall-radius"]),
                                    "fill-extrusion-flood-light-ground-radius": new Mo(ft["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-radius"]),
                                    "fill-extrusion-flood-light-ground-attenuation": new eo(ft["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-attenuation"]),
                                    "fill-extrusion-vertical-scale": new eo(ft["paint_fill-extrusion"]["fill-extrusion-vertical-scale"]),
                                    "fill-extrusion-rounded-roof": new eo(ft["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]),
                                    "fill-extrusion-cutoff-fade-range": new eo(ft["paint_fill-extrusion"]["fill-extrusion-cutoff-fade-range"]),
                                    "fill-extrusion-emissive-strength": new Mo(ft["paint_fill-extrusion"]["fill-extrusion-emissive-strength"]),
                                    "fill-extrusion-line-width": new Mo(ft["paint_fill-extrusion"]["fill-extrusion-line-width"]),
                                    "fill-extrusion-cast-shadows": new eo(ft["paint_fill-extrusion"]["fill-extrusion-cast-shadows"]),
                                    "fill-extrusion-color-use-theme": new Mo({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    }),
                                    "fill-extrusion-flood-light-color-use-theme": new Mo({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    })
                                }))
                            }, e, o, a),
                            this._stats = {
                                numRenderedVerticesInShadowPass: 0,
                                numRenderedVerticesInTransparentPass: 0
                            }
                        }
                        createBucket(n) {
                            return new Gp(n)
                        }
                        queryRadius() {
                            return zt(this.paint.get("fill-extrusion-translate"))
                        }
                        is3D() {
                            return !0
                        }
                        hasShadowPass() {
                            return this.paint.get("fill-extrusion-cast-shadows")
                        }
                        cutoffRange() {
                            return this.paint.get("fill-extrusion-cutoff-fade-range")
                        }
                        canCastShadows() {
                            return !0
                        }
                        getProgramIds() {
                            return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"]
                        }
                        queryIntersectsFeature(n, e, o, a, u, l, p, g, x) {
                            const T = to(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), l.angle, n.pixelToTileUnitsFactor)
                              , f = this.paint.get("fill-extrusion-height").evaluate(e, o)
                              , b = this.paint.get("fill-extrusion-base").evaluate(e, o)
                              , P = [0, 0]
                              , v = g && l.elevation
                              , w = l.elevation ? l.elevation.exaggeration() : 1
                              , C = n.tile.getBucket(this);
                            if (v && C instanceof Gp) {
                                const L = C.centroidVertexArray
                                  , N = x + 1;
                                N < L.length && (P[0] = L.geta_centroid_pos0(N),
                                P[1] = L.geta_centroid_pos1(N))
                            }
                            if (0 === P[0] && 1 === P[1])
                                return !1;
                            "globe" === l.projection.name && (a = Zf([a], [new tt(0,0), new tt(uo,uo)], n.tileID.canonical).map(L => L.polygon).flat());
                            const A = v ? g : null
                              , [O,F] = (N = a,
                            G = b,
                            X = f,
                            _e = T,
                            me = p,
                            pe = A,
                            Ne = P,
                            Pe = w,
                            $e = l.center.lat,
                            "globe" === (L = l).projection.name ? function(je, Ke, rt, at, ot, Ct, Zt, Ot, lo, io, fo) {
                                const Bt = []
                                  , Ro = []
                                  , ho = je.projection.upVectorScale(fo, je.center.lat, je.worldSize).metersToTile
                                  , Ao = [0, 0, 0, 1]
                                  , $o = [0, 0, 0, 1]
                                  , Qo = (di, ri, gi, Zi) => {
                                    di[0] = ri,
                                    di[1] = gi,
                                    di[2] = Zi,
                                    di[3] = 1
                                }
                                  , ni = Yf();
                                rt > 0 && (rt += ni),
                                at += ni;
                                for (const di of Ke) {
                                    const ri = []
                                      , gi = [];
                                    for (const Zi of di) {
                                        const $i = Zi.x + ot.x
                                          , Ko = Zi.y + ot.y
                                          , Gi = je.projection.projectTilePoint($i, Ko, fo)
                                          , ki = je.projection.upVector(fo, Zi.x, Zi.y);
                                        let Ki = rt
                                          , Tn = at;
                                        if (Zt) {
                                            const Cn = Qf($i, Ko, rt, at, Zt, Ot, lo, io);
                                            Ki += Cn.base,
                                            Tn += Cn.top
                                        }
                                        0 !== rt ? Qo(Ao, Gi.x + ki[0] * ho * Ki, Gi.y + ki[1] * ho * Ki, Gi.z + ki[2] * ho * Ki) : Qo(Ao, Gi.x, Gi.y, Gi.z),
                                        Qo($o, Gi.x + ki[0] * ho * Tn, Gi.y + ki[1] * ho * Tn, Gi.z + ki[2] * ho * Tn),
                                        B.vec3.transformMat4(Ao, Ao, Ct),
                                        B.vec3.transformMat4($o, $o, Ct),
                                        ri.push(new zc(Ao[0],Ao[1],Ao[2])),
                                        gi.push(new zc($o[0],$o[1],$o[2]))
                                    }
                                    Bt.push(ri),
                                    Ro.push(gi)
                                }
                                return [Bt, Ro]
                            }(L, N, G, X, _e, me, pe, Ne, Pe, $e, n.tileID.canonical) : pe ? function(je, Ke, rt, at, ot, Ct, Zt, Ot, lo) {
                                const io = []
                                  , fo = []
                                  , Bt = [0, 0, 0, 1];
                                for (const Ro of je) {
                                    const ho = []
                                      , Ao = [];
                                    for (const $o of Ro) {
                                        const Qo = $o.x + at.x
                                          , ni = $o.y + at.y
                                          , di = Qf(Qo, ni, Ke, rt, Ct, Zt, Ot, lo);
                                        Bt[0] = Qo,
                                        Bt[1] = ni,
                                        Bt[2] = di.base,
                                        Bt[3] = 1,
                                        B.vec4.transformMat4(Bt, Bt, ot),
                                        Bt[3] = Math.max(Bt[3], 1e-5);
                                        const ri = new zc(Bt[0] / Bt[3],Bt[1] / Bt[3],Bt[2] / Bt[3]);
                                        Bt[0] = Qo,
                                        Bt[1] = ni,
                                        Bt[2] = di.top,
                                        Bt[3] = 1,
                                        B.vec4.transformMat4(Bt, Bt, ot),
                                        Bt[3] = Math.max(Bt[3], 1e-5);
                                        const gi = new zc(Bt[0] / Bt[3],Bt[1] / Bt[3],Bt[2] / Bt[3]);
                                        ho.push(ri),
                                        Ao.push(gi)
                                    }
                                    io.push(ho),
                                    fo.push(Ao)
                                }
                                return [io, fo]
                            }(N, G, X, _e, me, pe, Ne, Pe, $e) : function(je, Ke, rt, at, ot) {
                                const Ct = []
                                  , Zt = []
                                  , Ot = ot[8] * Ke
                                  , lo = ot[9] * Ke
                                  , io = ot[10] * Ke
                                  , fo = ot[11] * Ke
                                  , Bt = ot[8] * rt
                                  , Ro = ot[9] * rt
                                  , ho = ot[10] * rt
                                  , Ao = ot[11] * rt;
                                for (const $o of je) {
                                    const Qo = []
                                      , ni = [];
                                    for (const di of $o) {
                                        const ri = di.x + at.x
                                          , gi = di.y + at.y
                                          , Zi = ot[0] * ri + ot[4] * gi + ot[12]
                                          , $i = ot[1] * ri + ot[5] * gi + ot[13]
                                          , Ko = ot[2] * ri + ot[6] * gi + ot[14]
                                          , Gi = ot[3] * ri + ot[7] * gi + ot[15]
                                          , ki = Zi + Ot
                                          , Ki = $i + lo
                                          , Tn = Ko + io
                                          , Cn = Math.max(Gi + fo, 1e-5)
                                          , gn = Zi + Bt
                                          , Er = $i + Ro
                                          , nn = Ko + ho
                                          , ln = Math.max(Gi + Ao, 1e-5);
                                        Qo.push(new zc(ki / Cn,Ki / Cn,Tn / Cn)),
                                        ni.push(new zc(gn / ln,Er / ln,nn / ln))
                                    }
                                    Ct.push(Qo),
                                    Zt.push(ni)
                                }
                                return [Ct, Zt]
                            }(N, G, X, _e, me))
                              , z = n.queryGeometry;
                            var L, N, G, X, _e, me, pe, Ne, Pe, $e;
                            return function(L, N, G) {
                                let X = 1 / 0;
                                he(G, N) && (X = Jf(G, N[0]));
                                for (let _e = 0; _e < N.length; _e++) {
                                    const me = N[_e]
                                      , pe = L[_e];
                                    for (let Ne = 0; Ne < me.length - 1; Ne++) {
                                        const Pe = me[Ne]
                                          , $e = [Pe, me[Ne + 1], pe[Ne + 1], pe[Ne], Pe];
                                        Y(G, $e) && (X = Math.min(X, Jf(G, $e)))
                                    }
                                }
                                return X !== 1 / 0 && X
                            }(O, F, z.isPointQuery() ? z.screenBounds : z.screenGeometry)
                        }
                    }
                    ,
                    line: class extends dr {
                        constructor(n, e, o, a) {
                            const u = c_();
                            super(n, u, e, o, a),
                            u.layout && (this.layout = new wl(u.layout)),
                            this.gradientVersion = 0
                        }
                        _handleSpecialPaintPropertyUpdate(n) {
                            if ("line-gradient" === n) {
                                const e = this._transitionablePaint._values["line-gradient"].value.expression;
                                this.stepInterpolant = e._styleExpression && e._styleExpression.expression instanceof mi,
                                this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER
                            }
                        }
                        gradientExpression() {
                            return this._transitionablePaint._values["line-gradient"].value.expression
                        }
                        widthExpression() {
                            return this._transitionablePaint._values["line-width"].value.expression
                        }
                        recalculate(n, e) {
                            super.recalculate(n, e),
                            this.paint._values["line-floorwidth"] = ( () => {
                                if (ju)
                                    return ju;
                                const o = c_();
                                return ju = new p1(o.paint.properties["line-width"].specification),
                                ju.useIntegerZoom = !0,
                                ju
                            }
                            )().possiblyEvaluate(this._transitioningPaint._values["line-width"].value, n)
                        }
                        createBucket(n) {
                            return new Qd(n)
                        }
                        getProgramIds() {
                            return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"]
                        }
                        getDefaultProgramParams(n, e, o) {
                            const a = a_(this);
                            return {
                                config: new Ua(this,{
                                    zoom: e,
                                    lut: o
                                }),
                                defines: a,
                                overrideFog: !1
                            }
                        }
                        queryRadius(n) {
                            const e = n
                              , o = h_(nt("line-width", this, e), nt("line-gap-width", this, e))
                              , a = nt("line-offset", this, e);
                            return o / 2 + Math.abs(a) + zt(this.paint.get("line-translate"))
                        }
                        queryIntersectsFeature(n, e, o, a, u, l) {
                            if (n.queryGeometry.isAboveHorizon)
                                return !1;
                            const p = Yt(n.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), l.angle, n.pixelToTileUnitsFactor)
                              , g = n.pixelToTileUnitsFactor / 2 * h_(this.paint.get("line-width").evaluate(e, o), this.paint.get("line-gap-width").evaluate(e, o))
                              , x = this.paint.get("line-offset").evaluate(e, o);
                            return x && (a = function(T, f) {
                                const b = []
                                  , P = new tt(0,0);
                                for (let v = 0; v < T.length; v++) {
                                    const w = T[v]
                                      , C = [];
                                    for (let A = 0; A < w.length; A++) {
                                        const O = w[A]
                                          , F = w[A + 1]
                                          , z = 0 === A ? P : O.sub(w[A - 1])._unit()._perp()
                                          , L = A === w.length - 1 ? P : F.sub(O)._unit()._perp()
                                          , N = z._add(L)._unit();
                                        N._mult(1 / (N.x * L.x + N.y * L.y)),
                                        C.push(N._mult(f)._add(O))
                                    }
                                    b.push(C)
                                }
                                return b
                            }(a, x * n.pixelToTileUnitsFactor)),
                            function(T, f, b) {
                                for (let P = 0; P < f.length; P++) {
                                    const v = f[P];
                                    if (T.length >= 3)
                                        for (let w = 0; w < v.length; w++)
                                            if (Ge(T, v[w]))
                                                return !0;
                                    if (Te(T, v, b))
                                        return !0
                                }
                                return !1
                            }(p, a, g)
                        }
                        isTileClipped() {
                            return !0
                        }
                        isDraped(n) {
                            const e = this.layout.get("line-z-offset")
                              , o = e.isConstant() && !e.constantOr(0)
                              , a = this.layout.get("line-elevation-reference");
                            return !("sea" === a || "ground" === a) && (o || "none" !== a)
                        }
                    }
                    ,
                    symbol: nd,
                    background: class extends dr {
                        constructor(n, e, o, a) {
                            super(n, {
                                layout: Y_ || (Y_ = new cn({
                                    visibility: new eo(ft.layout_background.visibility)
                                })),
                                paint: Z_ || (Z_ = new cn({
                                    "background-pitch-alignment": new eo(ft.paint_background["background-pitch-alignment"]),
                                    "background-color": new eo(ft.paint_background["background-color"]),
                                    "background-pattern": new eo(ft.paint_background["background-pattern"]),
                                    "background-opacity": new eo(ft.paint_background["background-opacity"]),
                                    "background-emissive-strength": new eo(ft.paint_background["background-emissive-strength"]),
                                    "background-color-use-theme": new Mo({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    })
                                }))
                            }, e, o, a)
                        }
                        getProgramIds() {
                            return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"]
                        }
                        getDefaultProgramParams(n, e, o) {
                            return {
                                overrideFog: !1
                            }
                        }
                        is3D() {
                            return "viewport" === this.paint.get("background-pitch-alignment")
                        }
                    }
                    ,
                    raster: eg,
                    "raster-particle": sg,
                    sky: class extends dr {
                        constructor(n, e, o, a) {
                            super(n, {
                                layout: ig || (ig = new cn({
                                    visibility: new eo(ft.layout_sky.visibility)
                                })),
                                paint: ng || (ng = new cn({
                                    "sky-type": new eo(ft.paint_sky["sky-type"]),
                                    "sky-atmosphere-sun": new eo(ft.paint_sky["sky-atmosphere-sun"]),
                                    "sky-atmosphere-sun-intensity": new eo(ft.paint_sky["sky-atmosphere-sun-intensity"]),
                                    "sky-gradient-center": new eo(ft.paint_sky["sky-gradient-center"]),
                                    "sky-gradient-radius": new eo(ft.paint_sky["sky-gradient-radius"]),
                                    "sky-gradient": new ca(ft.paint_sky["sky-gradient"]),
                                    "sky-atmosphere-halo-color": new eo(ft.paint_sky["sky-atmosphere-halo-color"]),
                                    "sky-atmosphere-color": new eo(ft.paint_sky["sky-atmosphere-color"]),
                                    "sky-opacity": new eo(ft.paint_sky["sky-opacity"]),
                                    "sky-gradient-use-theme": new Mo({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    }),
                                    "sky-atmosphere-halo-color-use-theme": new Mo({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    }),
                                    "sky-atmosphere-color-use-theme": new Mo({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    })
                                }))
                            }, e, o, a),
                            this._updateColorRamp()
                        }
                        _handleSpecialPaintPropertyUpdate(n) {
                            "sky-gradient" === n ? this._updateColorRamp() : "sky-atmosphere-sun" !== n && "sky-atmosphere-halo-color" !== n && "sky-atmosphere-color" !== n && "sky-atmosphere-sun-intensity" !== n || (this._skyboxInvalidated = !0)
                        }
                        _updateColorRamp() {
                            this.colorRamp = Lu({
                                expression: this._transitionablePaint._values["sky-gradient"].value.expression,
                                evaluationKey: "skyRadialProgress"
                            }),
                            this.colorRampTexture && (this.colorRampTexture.destroy(),
                            this.colorRampTexture = null)
                        }
                        needsSkyboxCapture(n) {
                            if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry)
                                return !0;
                            if (!this.paint.get("sky-atmosphere-sun")) {
                                const e = n.style.light.properties.get("position");
                                return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar
                            }
                            return !1
                        }
                        getCenter(n, e) {
                            if ("atmosphere" === this.paint.get("sky-type")) {
                                const a = this.paint.get("sky-atmosphere-sun")
                                  , u = !a
                                  , l = n.style.light
                                  , p = l.properties.get("position");
                                return u && "viewport" === l.properties.get("anchor") && vo("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."),
                                u ? bm(p.azimuthal, 90 - p.polar, e) : bm(a[0], 90 - a[1], e)
                            }
                            const o = this.paint.get("sky-gradient-center");
                            return bm(o[0], 90 - o[1], e)
                        }
                        isSky() {
                            return !0
                        }
                        markSkyboxValid(n) {
                            this._skyboxInvalidated = !1,
                            this._lightPosition = n.style.light.properties.get("position")
                        }
                        hasOffscreenPass() {
                            return !0
                        }
                        getProgramIds() {
                            const n = this.paint.get("sky-type");
                            return "atmosphere" === n ? ["skyboxCapture", "skybox"] : "gradient" === n ? ["skyboxGradient"] : null
                        }
                    }
                    ,
                    slot: class extends dr {
                        constructor(n, e, o, a) {
                            super(n, {
                                paint: rg || (rg = new cn({}))
                            }, e, null)
                        }
                    }
                    ,
                    model: class extends dr {
                        constructor(n, e, o, a) {
                            super(n, {
                                layout: _g || (_g = new cn({
                                    visibility: new eo(ft.layout_model.visibility),
                                    "model-id": new Mo(ft.layout_model["model-id"])
                                })),
                                paint: gg || (gg = new cn({
                                    "model-opacity": new Mo(ft.paint_model["model-opacity"]),
                                    "model-rotation": new Mo(ft.paint_model["model-rotation"]),
                                    "model-scale": new Mo(ft.paint_model["model-scale"]),
                                    "model-translation": new Mo(ft.paint_model["model-translation"]),
                                    "model-color": new Mo(ft.paint_model["model-color"]),
                                    "model-color-mix-intensity": new Mo(ft.paint_model["model-color-mix-intensity"]),
                                    "model-type": new eo(ft.paint_model["model-type"]),
                                    "model-cast-shadows": new eo(ft.paint_model["model-cast-shadows"]),
                                    "model-receive-shadows": new eo(ft.paint_model["model-receive-shadows"]),
                                    "model-ambient-occlusion-intensity": new eo(ft.paint_model["model-ambient-occlusion-intensity"]),
                                    "model-emissive-strength": new Mo(ft.paint_model["model-emissive-strength"]),
                                    "model-roughness": new Mo(ft.paint_model["model-roughness"]),
                                    "model-height-based-emissive-strength-multiplier": new Mo(ft.paint_model["model-height-based-emissive-strength-multiplier"]),
                                    "model-cutoff-fade-range": new eo(ft.paint_model["model-cutoff-fade-range"]),
                                    "model-front-cutoff": new eo(ft.paint_model["model-front-cutoff"]),
                                    "model-color-use-theme": new Mo({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    })
                                }))
                            }, e, o, a),
                            this._stats = {
                                numRenderedVerticesInShadowPass: 0,
                                numRenderedVerticesInTransparentPass: 0
                            }
                        }
                        createBucket(n) {
                            return new Mm(n)
                        }
                        getProgramIds() {
                            return ["model"]
                        }
                        is3D() {
                            return !0
                        }
                        hasShadowPass() {
                            return !0
                        }
                        canCastShadows() {
                            return !0
                        }
                        hasLightBeamPass() {
                            return !0
                        }
                        cutoffRange() {
                            return this.paint.get("model-cutoff-fade-range")
                        }
                        queryRadius(n) {
                            return n instanceof pd ? 8191 : 0
                        }
                        queryIntersectsFeature(n, e, o, a, u, l) {
                            if (!this.modelManager)
                                return !1;
                            const p = this.modelManager
                              , g = n.tile.getBucket(this);
                            if (!(g && g instanceof Mm))
                                return !1;
                            for (const x in g.instancesPerModel) {
                                const T = g.instancesPerModel[x]
                                  , f = void 0 !== e.id ? e.id : e.properties && e.properties.hasOwnProperty("id") ? e.properties.id : void 0;
                                if (T.idToFeaturesIndex.hasOwnProperty(f)) {
                                    const b = T.features[T.idToFeaturesIndex[f]]
                                      , P = p.getModel(x, this.scope);
                                    if (!P)
                                        return !1;
                                    let v = B.mat4.create();
                                    const w = new Mi(0,0)
                                      , C = g.canonical;
                                    let A = Number.MAX_VALUE;
                                    for (let O = 0; O < b.instancedDataCount; ++O) {
                                        const F = 16 * (b.instancedDataOffset + O)
                                          , z = T.instancedDataArray.float32
                                          , L = [z[F + 4], z[F + 5], z[F + 6]];
                                        Pg(C, w, z[F], 0 | z[F + 1]),
                                        yg(v, P, l, w, b.rotation, b.scale, L, !1, !1, !1),
                                        "globe" === l.projection.name && (v = Pm(v, l));
                                        const N = B.mat4.multiply([], l.projMatrix, v)
                                          , G = n.queryGeometry
                                          , X = ug(G.isPointQuery() ? G.screenBounds : G.screenGeometry, l, N, P.aabb);
                                        null != X && (A = Math.min(X, A))
                                    }
                                    return A !== Number.MAX_VALUE && A
                                }
                            }
                            return !1
                        }
                        _handleOverridablePaintPropertyUpdate(n, e, o) {
                            return !(!this.layout || e.isDataDriven() || o.isDataDriven() || "model-color" !== n && "model-color-mix-intensity" !== n && "model-rotation" !== n && "model-scale" !== n && "model-translation" !== n && "model-emissive-strength" !== n)
                        }
                        _isPropertyZoomDependent(n) {
                            const e = this._transitionablePaint._values[n];
                            return null != e && null != e.value && null != e.value.expression && e.value.expression instanceof aa
                        }
                        isZoomDependent() {
                            return this._isPropertyZoomDependent("model-scale") || this._isPropertyZoomDependent("model-rotation") || this._isPropertyZoomDependent("model-translation")
                        }
                    }
                    ,
                    clip: class extends dr {
                        constructor(n, e, o, a) {
                            super(n, {
                                layout: _f || (_f = new cn({
                                    "clip-layer-types": new eo(ft.layout_clip["clip-layer-types"]),
                                    "clip-layer-scope": new eo(ft.layout_clip["clip-layer-scope"])
                                })),
                                paint: gf || (gf = new cn({}))
                            }, e, o, a)
                        }
                        recalculate(n, e) {
                            super.recalculate(n, e)
                        }
                        createBucket(n) {
                            return new yf(n)
                        }
                        isTileClipped() {
                            return !0
                        }
                        is3D() {
                            return !0
                        }
                    }
                };
                class hy {
                    constructor(e) {
                        this._callback = e,
                        this._triggered = !1,
                        typeof MessageChannel < "u" && (this._channel = new MessageChannel,
                        this._channel.port2.onmessage = () => {
                            this._triggered = !1,
                            this._callback()
                        }
                        )
                    }
                    trigger() {
                        this._triggered || (this._triggered = !0,
                        this._channel ? this._channel.port1.postMessage(!0) : setTimeout( () => {
                            this._triggered = !1,
                            this._callback()
                        }
                        , 0))
                    }
                    remove() {
                        this._channel = void 0,
                        this._callback = () => {}
                    }
                }
                class uy {
                    constructor() {
                        this.tasks = {},
                        this.taskQueue = [],
                        Pt(["process"], this),
                        this.invoker = new hy(this.process),
                        this.nextId = 0
                    }
                    add(e, o) {
                        const a = this.nextId++
                          , u = function({type: l, isSymbolTile: p, zoom: g}) {
                            return g = g || 0,
                            "message" === l ? 0 : "maybePrepare" !== l || p ? "parseTile" !== l || p ? "parseTile" === l && p ? 300 - g : "maybePrepare" === l && p ? 400 - g : 500 : 200 - g : 100 - g
                        }(o);
                        if (0 === u) {
                            try {
                                e()
                            } finally {}
                            return null
                        }
                        return this.tasks[a] = {
                            fn: e,
                            metadata: o,
                            priority: u,
                            id: a
                        },
                        this.taskQueue.push(a),
                        this.invoker.trigger(),
                        {
                            cancel: () => {
                                delete this.tasks[a]
                            }
                        }
                    }
                    process() {
                        try {
                            if (this.taskQueue = this.taskQueue.filter(a => !!this.tasks[a]),
                            !this.taskQueue.length)
                                return;
                            const e = this.pick();
                            if (null === e)
                                return;
                            const o = this.tasks[e];
                            if (delete this.tasks[e],
                            this.taskQueue.length && this.invoker.trigger(),
                            !o)
                                return;
                            o.fn()
                        } finally {}
                    }
                    pick() {
                        let e = null
                          , o = 1 / 0;
                        for (let u = 0; u < this.taskQueue.length; u++) {
                            const l = this.tasks[this.taskQueue[u]];
                            l.priority < o && (o = l.priority,
                            e = u)
                        }
                        if (null === e)
                            return null;
                        const a = this.taskQueue[e];
                        return this.taskQueue.splice(e, 1),
                        a
                    }
                    remove() {
                        this.invoker.remove()
                    }
                }
                class Mg {
                    constructor(e, o, a) {
                        this.target = e,
                        this.parent = o,
                        this.mapId = a,
                        this.callbacks = {},
                        this.cancelCallbacks = {},
                        Pt(["receive"], this),
                        this.target.addEventListener("message", this.receive, !1),
                        this.scheduler = new uy
                    }
                    send(e, o, a, u, l=!1, p) {
                        const g = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
                        a && (a.metadata = p,
                        this.callbacks[g] = a);
                        const x = new Set;
                        return this.target.postMessage({
                            id: g,
                            type: e,
                            hasCallback: !!a,
                            targetMapId: u,
                            mustQueue: l,
                            sourceMapId: this.mapId,
                            data: yo(o, x)
                        }, x),
                        {
                            cancel: () => {
                                a && delete this.callbacks[g],
                                this.target.postMessage({
                                    id: g,
                                    type: "<cancel>",
                                    targetMapId: u,
                                    sourceMapId: this.mapId
                                })
                            }
                        }
                    }
                    receive(e) {
                        const o = e.data
                          , a = o.id;
                        if (a && (!o.targetMapId || this.mapId === o.targetMapId))
                            if ("<cancel>" === o.type) {
                                const u = this.cancelCallbacks[a];
                                delete this.cancelCallbacks[a],
                                u && u.cancel()
                            } else if (o.mustQueue || ji()) {
                                const u = this.callbacks[a]
                                  , l = this.scheduler.add( () => this.processTask(a, o), u && u.metadata || {
                                    type: "message"
                                });
                                l && (this.cancelCallbacks[a] = l)
                            } else
                                this.processTask(a, o)
                    }
                    processTask(e, o) {
                        if (delete this.cancelCallbacks[e],
                        "<response>" === o.type) {
                            const a = this.callbacks[e];
                            delete this.callbacks[e],
                            a && (o.error ? a(Io(o.error)) : a(null, Io(o.data)))
                        } else {
                            const a = new Set
                              , u = o.hasCallback ? (p, g) => {
                                this.target.postMessage({
                                    id: e,
                                    type: "<response>",
                                    sourceMapId: this.mapId,
                                    error: p ? yo(p) : null,
                                    data: yo(g, a)
                                }, a)
                            }
                            : () => {}
                              , l = Io(o.data);
                            if (this.parent[o.type])
                                this.parent[o.type](o.sourceMapId, l, u);
                            else if (this.parent.getWorkerSource) {
                                const p = o.type.split(".");
                                this.parent.getWorkerSource(o.sourceMapId, p[0], l.source, l.scope)[p[1]](l, u)
                            } else
                                u(new Error("Could not find function ".concat(o.type)))
                        }
                    }
                    remove() {
                        this.scheduler.remove(),
                        this.target.removeEventListener("message", this.receive, !1)
                    }
                }
                var op = {
                    workerUrl: "",
                    workerClass: null,
                    workerParams: void 0
                };
                const Sm = "mapboxgl_preloaded_worker_pool";
                let ip, Im, dd = ( () => {
                    class n {
                        constructor() {
                            this.active = {}
                        }
                        acquire(o, a=n.workerCount) {
                            if (!this.workers)
                                for (this.workers = []; this.workers.length < a; )
                                    this.workers.push(null != op.workerClass ? new op.workerClass : new self.Worker(op.workerUrl,op.workerParams));
                            return this.active[o] = !0,
                            this.workers.slice()
                        }
                        release(o) {
                            delete this.active[o],
                            this.workers && 0 === this.numActive() && (this.workers.forEach(a => {
                                a.terminate()
                            }
                            ),
                            this.workers = null)
                        }
                        isPreloaded() {
                            return !!this.active[Sm]
                        }
                        numActive() {
                            return Object.keys(this.active).length
                        }
                    }
                    return n.workerCount = 2,
                    n
                }
                )();
                class Yh {
                    constructor(e, o, a="Worker", u=dd.workerCount) {
                        this.workerPool = e,
                        this.actors = [],
                        this.currentActor = 0,
                        this.id = Ve();
                        const l = this.workerPool.acquire(this.id, u);
                        for (let p = 0; p < l.length; p++) {
                            const g = new Yh.Actor(l[p],o,this.id);
                            g.name = "".concat(a, " ").concat(p),
                            this.actors.push(g)
                        }
                        this.ready = !1,
                        this.broadcast("checkIfReady", null, () => {
                            this.ready = !0
                        }
                        )
                    }
                    broadcast(e, o, a) {
                        ee(this.actors, (u, l) => {
                            u.send(e, o, l)
                        }
                        , a = a || function() {}
                        )
                    }
                    getActor() {
                        return this.currentActor = (this.currentActor + 1) % this.actors.length,
                        this.actors[this.currentActor]
                    }
                    remove() {
                        this.actors.forEach(e => {
                            e.remove()
                        }
                        ),
                        this.actors = [],
                        this.workerPool.release(this.id)
                    }
                }
                function md() {
                    return ip || (ip = new dd),
                    ip
                }
                Yh.Actor = Mg;
                const Am = new wi(0,0,0);
                var n, fd = ((n = fd || {})[n.PATH_RULE_UNSPECIFIED = 0] = "PATH_RULE_UNSPECIFIED",
                n[n.PATH_RULE_NON_ZERO = 1] = "PATH_RULE_NON_ZERO",
                n[n.PATH_RULE_EVEN_ODD = 2] = "PATH_RULE_EVEN_ODD",
                n), _d = (n => (n[n.LINE_CAP_UNSPECIFIED = 0] = "LINE_CAP_UNSPECIFIED",
                n[n.LINE_CAP_BUTT = 1] = "LINE_CAP_BUTT",
                n[n.LINE_CAP_ROUND = 2] = "LINE_CAP_ROUND",
                n[n.LINE_CAP_SQUARE = 3] = "LINE_CAP_SQUARE",
                n))(_d || {}), np = (n => (n[n.LINE_JOIN_UNSPECIFIED = 0] = "LINE_JOIN_UNSPECIFIED",
                n[n.LINE_JOIN_MITER = 1] = "LINE_JOIN_MITER",
                n[n.LINE_JOIN_MITER_CLIP = 2] = "LINE_JOIN_MITER_CLIP",
                n[n.LINE_JOIN_ROUND = 3] = "LINE_JOIN_ROUND",
                n[n.LINE_JOIN_BEVEL = 4] = "LINE_JOIN_BEVEL",
                n))(np || {}), Tg = (n => (n[n.PAINT_ORDER_UNSPECIFIED = 0] = "PAINT_ORDER_UNSPECIFIED",
                n[n.PAINT_ORDER_FILL_AND_STROKE = 1] = "PAINT_ORDER_FILL_AND_STROKE",
                n[n.PAINT_ORDER_STROKE_AND_FILL = 2] = "PAINT_ORDER_STROKE_AND_FILL",
                n))(Tg || {}), Zh = (n => (n[n.PATH_COMMAND_UNSPECIFIED = 0] = "PATH_COMMAND_UNSPECIFIED",
                n[n.PATH_COMMAND_MOVE = 1] = "PATH_COMMAND_MOVE",
                n[n.PATH_COMMAND_LINE = 2] = "PATH_COMMAND_LINE",
                n[n.PATH_COMMAND_QUAD = 3] = "PATH_COMMAND_QUAD",
                n[n.PATH_COMMAND_CUBIC = 4] = "PATH_COMMAND_CUBIC",
                n[n.PATH_COMMAND_CLOSE = 5] = "PATH_COMMAND_CLOSE",
                n))(Zh || {}), Cg = (n => (n[n.MASK_TYPE_UNSPECIFIED = 0] = "MASK_TYPE_UNSPECIFIED",
                n[n.MASK_TYPE_LUMINANCE = 1] = "MASK_TYPE_LUMINANCE",
                n[n.MASK_TYPE_ALPHA = 2] = "MASK_TYPE_ALPHA",
                n))(Cg || {});
                function py(n, e, o) {
                    var a, u;
                    1 === n && e.icons.push((a = o,
                    u = o.readVarint() + o.pos,
                    function(l) {
                        if (l.usvg_tree.height || (l.usvg_tree.height = l.usvg_tree.width),
                        !l.metadata)
                            return l;
                        const {metadata: p} = l;
                        if (p.content_area) {
                            const {content_area: g} = p;
                            null == g.top && (g.top = g.left),
                            null == g.width && (g.width = l.usvg_tree.width),
                            null == g.height && (g.height = g.width)
                        }
                        return p.stretch_x && p.stretch_x.length && Eg(p, "x"),
                        p.stretch_y && p.stretch_y.length && Eg(p, "y"),
                        l
                    }(a.readFields(dy, {
                        name: void 0
                    }, u))))
                }
                function Eg(n, e) {
                    const o = []
                      , a = n["stretch_".concat(e)];
                    let u = null;
                    for (let l = 0; l < a.length; l++)
                        null === u ? u = 0 === o.length ? a[0] : o[o.length - 1][1] + a[l] : (o.push([u, u + a[l]]),
                        u = null);
                    n["stretch_".concat(e, "_areas")] = o
                }
                function dy(n, e, o) {
                    var a, u;
                    1 === n ? e.name = o.readString() : 2 === n ? e.metadata = (a = o,
                    u = o.readVarint() + o.pos,
                    a.readFields(my, {
                        stretch_x: null,
                        stretch_y: null,
                        stretch_x_areas: null,
                        stretch_y_areas: null,
                        variables: []
                    }, u)) : 3 === n && (e.usvg_tree = function(a, u) {
                        return a.readFields(gy, {
                            width: 20,
                            children: [],
                            linear_gradients: [],
                            radial_gradients: [],
                            clip_paths: [],
                            masks: []
                        }, u)
                    }(o, o.readVarint() + o.pos),
                    e.data = "usvg_tree")
                }
                function my(n, e, o) {
                    var a, u;
                    1 === n ? e.stretch_x = o.readPackedVarint() : 2 === n ? e.stretch_y = o.readPackedVarint() : 3 === n ? e.content_area = (a = o,
                    u = o.readVarint() + o.pos,
                    a.readFields(fy, {
                        left: 0
                    }, u)) : 4 === n && e.variables.push(function(a, u) {
                        return a.readFields(_y, {
                            name: void 0
                        }, u)
                    }(o, o.readVarint() + o.pos))
                }
                function fy(n, e, o) {
                    1 === n ? e.left = o.readVarint() : 2 === n ? e.width = o.readVarint() : 3 === n ? e.top = o.readVarint() : 4 === n && (e.height = o.readVarint())
                }
                function _y(n, e, o) {
                    1 === n ? e.name = o.readString() : 2 === n && (e.rgb_color = vd(o.readVarint()),
                    e.value = "rgb_color")
                }
                function gy(n, e, o) {
                    var a, u;
                    1 === n ? e.width = e.height = o.readVarint() : 2 === n ? e.height = o.readVarint() : 3 === n ? e.children.push(gd(o, o.readVarint() + o.pos)) : 4 === n ? e.linear_gradients.push((a = o,
                    u = o.readVarint() + o.pos,
                    a.readFields(My, {
                        spread_method: 1,
                        stops: [],
                        x1: 0,
                        y1: 0,
                        x2: 1,
                        y2: 0
                    }, u))) : 5 === n ? e.radial_gradients.push(function(a, u) {
                        return a.readFields(Cy, {
                            spread_method: 1,
                            stops: [],
                            cx: .5,
                            cy: .5,
                            r: .5,
                            fx: .5,
                            fy: .5,
                            fr: 0
                        }, u)
                    }(o, o.readVarint() + o.pos)) : 7 === n ? e.clip_paths.push(function(a, u) {
                        return a.readFields(Ey, {
                            children: []
                        }, u)
                    }(o, o.readVarint() + o.pos)) : 8 === n && e.masks.push(function(a, u) {
                        const l = a.readFields(Sy, {
                            left: 0,
                            width: 20,
                            mask_type: 1,
                            children: []
                        }, u);
                        return null == l.height && (l.height = l.width),
                        null == l.top && (l.top = l.left),
                        l
                    }(o, o.readVarint() + o.pos))
                }
                function gd(n, e) {
                    return n.readFields(yy, {}, e)
                }
                function yy(n, e, o) {
                    var a, u;
                    1 === n ? (e.group = (a = o,
                    u = o.readVarint() + o.pos,
                    a.readFields(vy, {
                        opacity: 255,
                        children: []
                    }, u)),
                    e.node = "group") : 2 === n && (e.path = function(a, u) {
                        return a.readFields(by, {
                            paint_order: 1,
                            commands: [],
                            step: 1,
                            diffs: [],
                            rule: 1
                        }, u)
                    }(o, o.readVarint() + o.pos),
                    e.node = "path")
                }
                function vy(n, e, o) {
                    1 === n ? e.transform = yd(o, o.readVarint() + o.pos) : 2 === n ? e.opacity = o.readVarint() : 5 === n ? e.clip_path_idx = o.readVarint() : 6 === n ? e.mask_idx = o.readVarint() : 7 === n && e.children.push(gd(o, o.readVarint() + o.pos))
                }
                function yd(n, e) {
                    return n.readFields(xy, {
                        sx: 1,
                        ky: 0,
                        kx: 0,
                        sy: 1,
                        tx: 0,
                        ty: 0
                    }, e)
                }
                function xy(n, e, o) {
                    1 === n ? e.sx = o.readFloat() : 2 === n ? e.ky = o.readFloat() : 3 === n ? e.kx = o.readFloat() : 4 === n ? e.sy = o.readFloat() : 5 === n ? e.tx = o.readFloat() : 6 === n && (e.ty = o.readFloat())
                }
                function by(n, e, o) {
                    var a, u;
                    1 === n ? e.fill = (a = o,
                    u = o.readVarint() + o.pos,
                    a.readFields(wy, {
                        rgb_color: Am,
                        paint: "rgb_color",
                        opacity: 255
                    }, u)) : 2 === n ? e.stroke = function(a, u) {
                        return a.readFields(Py, {
                            rgb_color: Am,
                            paint: "rgb_color",
                            dasharray: [],
                            dashoffset: 0,
                            miterlimit: 4,
                            opacity: 255,
                            width: 1,
                            linecap: 1,
                            linejoin: 1
                        }, u)
                    }(o, o.readVarint() + o.pos) : 3 === n ? e.paint_order = o.readVarint() : 5 === n ? o.readPackedVarint(e.commands) : 6 === n ? e.step = o.readFloat() : 7 === n ? o.readPackedSVarint(e.diffs) : 8 === n && (e.rule = o.readVarint())
                }
                function wy(n, e, o) {
                    1 === n ? (e.rgb_color = vd(o.readVarint()),
                    e.paint = "rgb_color") : 2 === n ? (e.linear_gradient_idx = o.readVarint(),
                    e.paint = "linear_gradient_idx") : 3 === n ? (e.radial_gradient_idx = o.readVarint(),
                    e.paint = "radial_gradient_idx") : 5 === n && (e.opacity = o.readVarint())
                }
                function vd(n) {
                    return new wi((n >> 16 & 255) / 255,(n >> 8 & 255) / 255,(255 & n) / 255,1)
                }
                function Py(n, e, o) {
                    1 === n ? (e.rgb_color = vd(o.readVarint()),
                    e.paint = "rgb_color") : 2 === n ? (e.linear_gradient_idx = o.readVarint(),
                    e.paint = "linear_gradient_idx") : 3 === n ? (e.radial_gradient_idx = o.readVarint(),
                    e.paint = "radial_gradient_idx") : 5 === n ? o.readPackedFloat(e.dasharray) : 6 === n ? e.dashoffset = o.readFloat() : 7 === n ? e.miterlimit = o.readFloat() : 8 === n ? e.opacity = o.readVarint() : 9 === n ? e.width = o.readFloat() : 10 === n ? e.linecap = o.readVarint() : 11 === n && (e.linejoin = o.readVarint())
                }
                function My(n, e, o) {
                    1 === n ? e.transform = yd(o, o.readVarint() + o.pos) : 2 === n ? e.spread_method = o.readVarint() : 3 === n ? e.stops.push(Sg(o, o.readVarint() + o.pos)) : 4 === n ? e.x1 = o.readFloat() : 5 === n ? e.y1 = o.readFloat() : 6 === n ? e.x2 = o.readFloat() : 7 === n && (e.y2 = o.readFloat())
                }
                function Sg(n, e) {
                    return n.readFields(Ty, {
                        offset: 0,
                        opacity: 255,
                        rgb_color: Am
                    }, e)
                }
                function Ty(n, e, o) {
                    1 === n ? e.offset = o.readFloat() : 2 === n ? e.opacity = o.readVarint() : 3 === n && (e.rgb_color = vd(o.readVarint()))
                }
                function Cy(n, e, o) {
                    1 === n ? e.transform = yd(o, o.readVarint() + o.pos) : 2 === n ? e.spread_method = o.readVarint() : 3 === n ? e.stops.push(Sg(o, o.readVarint() + o.pos)) : 4 === n ? e.cx = o.readFloat() : 5 === n ? e.cy = o.readFloat() : 6 === n ? e.r = o.readFloat() : 7 === n ? e.fx = o.readFloat() : 8 === n ? e.fy = o.readFloat() : 9 === n && (e.fr = o.readFloat())
                }
                function Ey(n, e, o) {
                    1 === n ? e.transform = yd(o, o.readVarint() + o.pos) : 2 === n ? e.clip_path_idx = o.readVarint() : 3 === n && e.children.push(gd(o, o.readVarint() + o.pos))
                }
                function Sy(n, e, o) {
                    1 === n ? e.left = e.top = o.readFloat() : 2 === n ? e.width = e.height = o.readFloat() : 3 === n ? e.top = o.readFloat() : 4 === n ? e.height = o.readFloat() : 5 === n ? e.mask_type = o.readVarint() : 6 === n ? e.mask_idx = o.readVarint() : 7 === n && e.children.push(gd(o, o.readVarint() + o.pos))
                }
                class Iy {
                    static calculate(e, o) {
                        const a = new Map
                          , u = new Map;
                        if (0 === Object.keys(e).length)
                            return a;
                        o.forEach(l => {
                            u.set(l.name, l.rgb_color || new wi(0,0,0))
                        }
                        );
                        for (const [l,p] of Object.entries(e))
                            u.has(l) ? a.set(u.get(l).toStringPremultipliedAlpha(), p) : console.warn('Ignoring unknown image variable "'.concat(l, '"'));
                        return a
                    }
                }
                function Kh(n, e=255, o) {
                    const a = e / 255
                      , u = n.toStringPremultipliedAlpha()
                      , l = o.has(u) ? o.get(u).clone() : n.clone();
                    return l.a = a,
                    l.toString()
                }
                function Om(n, e) {
                    if (!Rt()) {
                        const o = document.createElement("canvas");
                        return o.width = n,
                        o.height = e,
                        o
                    }
                    return new OffscreenCanvas(n,e)
                }
                function Ay(n, e) {
                    const o = Iy.calculate(e.params, n.metadata ? n.metadata.variables : [])
                      , a = n.usvg_tree
                      , u = a.width
                      , l = a.height
                      , p = e.transform ? e.transform : new DOMMatrix
                      , g = Math.max(1, Math.round(u * p.a))
                      , x = Math.max(1, Math.round(l * p.d))
                      , T = new DOMMatrix([g / u, 0, 0, x / l, 0, 0])
                      , f = Om(g, x).getContext("2d");
                    return Rm(f, T, a, a, o),
                    f.getImageData(0, 0, g, x)
                }
                function Rm(n, e, o, a, u) {
                    for (const l of a.children)
                        Ig(n, e, o, l, u)
                }
                function Ig(n, e, o, a, u) {
                    a.group ? (n.save(),
                    function(l, p, g, x, T) {
                        const f = null != x.mask_idx ? g.masks[x.mask_idx] : null
                          , b = null != x.clip_path_idx ? g.clip_paths[x.clip_path_idx] : null;
                        if (x.transform && (p = rp(x.transform).preMultiplySelf(p)),
                        255 === x.opacity && !(null != b) && !(null != f))
                            return void Rm(l, p, g, x, T);
                        const P = Om(l.canvas.width, l.canvas.height)
                          , v = P.getContext("2d");
                        b && Lg(v, p, g, b),
                        Rm(v, p, g, x, T),
                        f && Fg(v, p, g, f, T),
                        l.globalAlpha = x.opacity / 255,
                        l.drawImage(P, 0, 0)
                    }(n, e, o, a.group, u),
                    n.restore()) : a.path && (n.save(),
                    function(l, p, g, x, T) {
                        const f = kg(x);
                        l.setTransform(p),
                        x.paint_order === Tg.PAINT_ORDER_FILL_AND_STROKE ? (Ag(l, g, x, f, T),
                        Og(l, g, x, f, T)) : (Og(l, g, x, f, T),
                        Ag(l, g, x, f, T))
                    }(n, e, o, a.path, u),
                    n.restore())
                }
                function Ag(n, e, o, a, u) {
                    const l = o.fill;
                    if (!l)
                        return;
                    const p = l.opacity / 255;
                    switch (l.paint) {
                    case "rgb_color":
                        n.fillStyle = Kh(l.rgb_color, l.opacity, u);
                        break;
                    case "linear_gradient_idx":
                        n.fillStyle = Rg(n, e.linear_gradients[l.linear_gradient_idx], p, u);
                        break;
                    case "radial_gradient_idx":
                        n.fillStyle = Dg(n, e.radial_gradients[l.radial_gradient_idx], p, u)
                    }
                    let g;
                    switch (o.rule) {
                    case fd.PATH_RULE_NON_ZERO:
                        g = "nonzero";
                        break;
                    case fd.PATH_RULE_EVEN_ODD:
                        g = "evenodd"
                    }
                    n.fill(a, g)
                }
                function Og(n, e, o, a, u) {
                    const l = o.stroke;
                    if (!l)
                        return;
                    n.lineWidth = l.width,
                    n.miterLimit = l.miterlimit,
                    n.setLineDash(l.dasharray),
                    n.lineDashOffset = l.dashoffset;
                    const p = l.opacity / 255;
                    switch (l.paint) {
                    case "rgb_color":
                        n.strokeStyle = Kh(l.rgb_color, l.opacity, u);
                        break;
                    case "linear_gradient_idx":
                        n.strokeStyle = Rg(n, e.linear_gradients[l.linear_gradient_idx], p, u);
                        break;
                    case "radial_gradient_idx":
                        n.strokeStyle = Dg(n, e.radial_gradients[l.radial_gradient_idx], p, u)
                    }
                    switch (l.linejoin) {
                    case np.LINE_JOIN_MITER_CLIP:
                    case np.LINE_JOIN_MITER:
                        n.lineJoin = "miter";
                        break;
                    case np.LINE_JOIN_ROUND:
                        n.lineJoin = "round";
                        break;
                    case np.LINE_JOIN_BEVEL:
                        n.lineJoin = "bevel"
                    }
                    switch (l.linecap) {
                    case _d.LINE_CAP_BUTT:
                        n.lineCap = "butt";
                        break;
                    case _d.LINE_CAP_ROUND:
                        n.lineCap = "round";
                        break;
                    case _d.LINE_CAP_SQUARE:
                        n.lineCap = "square"
                    }
                    n.stroke(a)
                }
                function Rg(n, e, o, a) {
                    if (1 === e.stops.length) {
                        const P = e.stops[0];
                        return Kh(P.rgb_color, P.opacity * o, a)
                    }
                    const u = rp(e.transform)
                      , {x1: l, y1: p, x2: g, y2: x} = e
                      , T = u.transformPoint(new DOMPoint(l,p))
                      , f = u.transformPoint(new DOMPoint(g,x))
                      , b = n.createLinearGradient(T.x, T.y, f.x, f.y);
                    for (const P of e.stops)
                        b.addColorStop(P.offset, Kh(P.rgb_color, P.opacity * o, a));
                    return b
                }
                function Dg(n, e, o, a) {
                    if (1 === e.stops.length) {
                        const P = e.stops[0];
                        return Kh(P.rgb_color, P.opacity * o, a)
                    }
                    const u = rp(e.transform)
                      , {fx: l, fy: p, cx: g, cy: x} = e
                      , T = u.transformPoint(new DOMPoint(l,p))
                      , f = u.transformPoint(new DOMPoint(g,x))
                      , b = n.createRadialGradient(T.x, T.y, 0, f.x, f.y, e.r * ((u.a + u.d) / 2));
                    for (const P of e.stops)
                        b.addColorStop(P.offset, Kh(P.rgb_color, P.opacity * o, a));
                    return b
                }
                function Lg(n, e, o, a) {
                    const u = rp(a.transform).preMultiplySelf(e)
                      , l = null != a.clip_path_idx ? o.clip_paths[a.clip_path_idx] : null;
                    l && Lg(n, u, o, l);
                    const p = new Path2D;
                    let g;
                    function x(T, f) {
                        if (T.path) {
                            const b = T.path;
                            p.addPath(kg(b), f),
                            b.rule === fd.PATH_RULE_EVEN_ODD && (g = "evenodd")
                        } else if (T.group) {
                            const b = T.group.transform ? rp(T.group.transform).preMultiplySelf(f) : f;
                            for (const P of T.group.children)
                                x(P, b)
                        }
                    }
                    for (const T of a.children)
                        x(T, u);
                    n.clip(p, g)
                }
                function Fg(n, e, o, a, u) {
                    if (0 === a.children.length)
                        return;
                    const l = null != a.mask_idx ? o.masks[a.mask_idx] : null;
                    l && Fg(n, e, o, l, u);
                    const p = n.canvas.width
                      , g = n.canvas.height
                      , x = Om(p, g)
                      , T = x.getContext("2d")
                      , f = a.width
                      , b = a.height
                      , P = a.left
                      , v = a.top
                      , w = new Path2D
                      , C = new Path2D;
                    C.rect(P, v, f, b),
                    w.addPath(C, e),
                    T.clip(w);
                    for (const F of a.children)
                        Ig(T, e, o, F, u);
                    const A = T.getImageData(0, 0, p, g)
                      , O = A.data;
                    if (a.mask_type === Cg.MASK_TYPE_LUMINANCE)
                        for (let F = 0; F < O.length; F += 4)
                            O[F + 3] = O[F + 3] / 255 * (.2126 * O[F] + .7152 * O[F + 1] + .0722 * O[F + 2]);
                    T.putImageData(A, 0, 0),
                    n.globalCompositeOperation = "destination-in",
                    n.drawImage(x, 0, 0)
                }
                function rp(n) {
                    return n ? new DOMMatrix([n.sx, n.ky, n.kx, n.sy, n.tx, n.ty]) : new DOMMatrix
                }
                function kg(n) {
                    const e = new Path2D
                      , o = n.step;
                    let a = n.diffs[0] * o
                      , u = n.diffs[1] * o;
                    e.moveTo(a, u);
                    for (let l = 0, p = 2; l < n.commands.length; l++)
                        switch (n.commands[l]) {
                        case Zh.PATH_COMMAND_MOVE:
                            a += n.diffs[p++] * o,
                            u += n.diffs[p++] * o,
                            e.moveTo(a, u);
                            break;
                        case Zh.PATH_COMMAND_LINE:
                            a += n.diffs[p++] * o,
                            u += n.diffs[p++] * o,
                            e.lineTo(a, u);
                            break;
                        case Zh.PATH_COMMAND_QUAD:
                            {
                                const g = a + n.diffs[p++] * o
                                  , x = u + n.diffs[p++] * o;
                                a = g + n.diffs[p++] * o,
                                u = x + n.diffs[p++] * o,
                                e.quadraticCurveTo(g, x, a, u);
                                break
                            }
                        case Zh.PATH_COMMAND_CUBIC:
                            {
                                const g = a + n.diffs[p++] * o
                                  , x = u + n.diffs[p++] * o
                                  , T = g + n.diffs[p++] * o
                                  , f = x + n.diffs[p++] * o;
                                a = T + n.diffs[p++] * o,
                                u = f + n.diffs[p++] * o,
                                e.bezierCurveTo(g, x, T, f, a, u);
                                break
                            }
                        case Zh.PATH_COMMAND_CLOSE:
                            e.closePath()
                        }
                    return e
                }
                class Dm {
                    constructor(e) {
                        this.capacity = e,
                        this.cache = new Map
                    }
                    get(e) {
                        if (!this.cache.has(e))
                            return;
                        const o = this.cache.get(e);
                        return this.cache.delete(e),
                        this.cache.set(e, o),
                        o
                    }
                    put(e, o) {
                        this.cache.has(e) ? this.cache.delete(e) : this.cache.size === this.capacity && this.cache.delete(this.cache.keys().next().value),
                        this.cache.set(e, o)
                    }
                    delete(e) {
                        this.cache.delete(e)
                    }
                }
                class Lm {
                    constructor() {
                        this.cacheMap = new Map,
                        this.cacheDependenciesMap = new Map
                    }
                    static _getImage(e) {
                        return new hr(e,e.data)
                    }
                    getFromCache(e, o, a) {
                        return this.cacheMap.has(a) || this.cacheMap.set(a, new Dm(150)),
                        this.cacheMap.get(a).get(es(e.serialize(), o))
                    }
                    setInCache(e, o, a, u) {
                        this.cacheDependenciesMap.has(u) || this.cacheDependenciesMap.set(u, new Map),
                        this.cacheMap.has(u) || this.cacheMap.set(u, new Dm(150));
                        const l = this.cacheDependenciesMap.get(u);
                        l.get(es(e.id, a)) || l.set(es(e.id, a), new Set);
                        const p = this.cacheMap.get(u)
                          , g = e.serialize();
                        l.get(es(e.id, a)).add(g),
                        p.put(es(e.serialize(), a), o)
                    }
                    removeImagesFromCacheByIds(e, o, a="") {
                        if (!this.cacheMap.has(a) || !this.cacheDependenciesMap.has(a))
                            return;
                        const u = this.cacheMap.get(a)
                          , l = this.cacheDependenciesMap.get(a);
                        for (const p of e)
                            if (l.has(es(p, o))) {
                                for (const g of l.get(es(p, o)))
                                    u.delete(g);
                                l.delete(es(p, o))
                            }
                    }
                    rasterize(e, o, a, u, l=Ay) {
                        const p = this.getFromCache(e, a, u);
                        if (p)
                            return p.clone();
                        const g = l(o.icon, e.options)
                          , x = Lm._getImage(g);
                        return this.setInCache(e, x, a, u),
                        x.clone()
                    }
                }
                class zg {
                    constructor(e) {
                        this.size = e,
                        this.minimums = [],
                        this.maximums = [],
                        this.leaves = []
                    }
                    getElevation(e, o) {
                        const a = this.toIdx(e, o);
                        return {
                            min: this.minimums[a],
                            max: this.maximums[a]
                        }
                    }
                    isLeaf(e, o) {
                        return this.leaves[this.toIdx(e, o)]
                    }
                    toIdx(e, o) {
                        return o * this.size + e
                    }
                }
                function Bg(n, e, o, a) {
                    let u = 0
                      , l = Number.MAX_VALUE;
                    for (let p = 0; p < 3; p++)
                        if (Math.abs(a[p]) < 1e-15) {
                            if (o[p] < n[p] || o[p] > e[p])
                                return null
                        } else {
                            const g = 1 / a[p];
                            let x = (n[p] - o[p]) * g
                              , T = (e[p] - o[p]) * g;
                            if (x > T) {
                                const f = x;
                                x = T,
                                T = f
                            }
                            if (x > u && (u = x),
                            T < l && (l = T),
                            u > l)
                                return null
                        }
                    return u
                }
                function Ug(n, e, o, a, u, l, p, g, x, T, f) {
                    const b = a - n
                      , P = u - e
                      , v = l - o
                      , w = p - n
                      , C = g - e
                      , A = x - o
                      , O = f[1] * A - f[2] * C
                      , F = f[2] * w - f[0] * A
                      , z = f[0] * C - f[1] * w
                      , L = b * O + P * F + v * z;
                    if (Math.abs(L) < 1e-15)
                        return null;
                    const N = 1 / L
                      , G = T[0] - n
                      , X = T[1] - e
                      , _e = T[2] - o
                      , me = (G * O + X * F + _e * z) * N;
                    if (me < 0 || me > 1)
                        return null;
                    const pe = X * v - _e * P
                      , Ne = _e * b - G * v
                      , Pe = G * P - X * b
                      , $e = (f[0] * pe + f[1] * Ne + f[2] * Pe) * N;
                    return $e < 0 || me + $e > 1 ? null : (w * pe + C * Ne + A * Pe) * N
                }
                function Ng(n, e, o) {
                    return (n - e) / (o - e)
                }
                function $g(n, e, o, a, u, l, p, g, x) {
                    const T = 1 << o
                      , f = l - a
                      , b = p - u
                      , P = (n + 1) / T * f + a
                      , v = (e + 0) / T * b + u
                      , w = (e + 1) / T * b + u;
                    g[0] = (n + 0) / T * f + a,
                    g[1] = v,
                    x[0] = P,
                    x[1] = w
                }
                class Gg {
                    constructor(e) {
                        if (this.maximums = [],
                        this.minimums = [],
                        this.leaves = [],
                        this.childOffsets = [],
                        this.nodeCount = 0,
                        this.dem = e,
                        this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]],
                        !this.dem)
                            return;
                        const o = function(l) {
                            const p = Math.ceil(Math.log2(l.dim / 8))
                              , g = [];
                            let x = Math.ceil(Math.pow(2, p));
                            const T = 1 / x
                              , f = (v, w, C, A, O) => {
                                const F = A ? 1 : 0
                                  , z = (v + 1) * C - F
                                  , L = w * C
                                  , N = (w + 1) * C - F;
                                O[0] = v * C,
                                O[1] = L,
                                O[2] = z,
                                O[3] = N
                            }
                            ;
                            let b = new zg(x);
                            const P = [];
                            for (let v = 0; v < x * x; v++) {
                                f(v % x, Math.floor(v / x), T, !1, P);
                                const w = kl(P[0], P[1], l)
                                  , C = kl(P[2], P[1], l)
                                  , A = kl(P[2], P[3], l)
                                  , O = kl(P[0], P[3], l);
                                b.minimums.push(Math.min(w, C, A, O)),
                                b.maximums.push(Math.max(w, C, A, O)),
                                b.leaves.push(1)
                            }
                            for (g.push(b),
                            x /= 2; x >= 1; x /= 2) {
                                const v = g[g.length - 1];
                                b = new zg(x);
                                for (let w = 0; w < x * x; w++) {
                                    f(w % x, Math.floor(w / x), 2, !0, P);
                                    const C = v.getElevation(P[0], P[1])
                                      , A = v.getElevation(P[2], P[1])
                                      , O = v.getElevation(P[2], P[3])
                                      , F = v.getElevation(P[0], P[3])
                                      , z = v.isLeaf(P[0], P[1])
                                      , L = v.isLeaf(P[2], P[1])
                                      , N = v.isLeaf(P[2], P[3])
                                      , G = v.isLeaf(P[0], P[3])
                                      , X = Math.min(C.min, A.min, O.min, F.min)
                                      , _e = Math.max(C.max, A.max, O.max, F.max)
                                      , me = z && L && N && G;
                                    b.maximums.push(_e),
                                    b.minimums.push(X),
                                    b.leaves.push(_e - X <= 5 && me ? 1 : 0)
                                }
                                g.push(b)
                            }
                            return g
                        }(this.dem)
                          , a = o.length - 1
                          , u = o[a];
                        this._addNode(u.minimums[0], u.maximums[0], u.leaves[0]),
                        this._construct(o, 0, 0, a, 0)
                    }
                    raycastRoot(e, o, a, u, l, p, g=1) {
                        return Bg([e, o, -100], [a, u, this.maximums[0] * g], l, p)
                    }
                    raycast(e, o, a, u, l, p, g=1) {
                        if (!this.nodeCount)
                            return null;
                        const x = this.raycastRoot(e, o, a, u, l, p, g);
                        if (null == x)
                            return null;
                        const T = []
                          , f = []
                          , b = []
                          , P = []
                          , v = [{
                            idx: 0,
                            t: x,
                            nodex: 0,
                            nodey: 0,
                            depth: 0
                        }];
                        for (; v.length > 0; ) {
                            const {idx: w, t: C, nodex: A, nodey: O, depth: F} = v.pop();
                            if (this.leaves[w]) {
                                $g(A, O, F, e, o, a, u, b, P);
                                const L = 1 << F
                                  , N = (A + 0) / L
                                  , G = (A + 1) / L
                                  , X = (O + 0) / L
                                  , _e = (O + 1) / L
                                  , me = kl(N, X, this.dem) * g
                                  , pe = kl(G, X, this.dem) * g
                                  , Ne = kl(G, _e, this.dem) * g
                                  , Pe = kl(N, _e, this.dem) * g
                                  , $e = Ug(b[0], b[1], me, P[0], b[1], pe, P[0], P[1], Ne, l, p)
                                  , We = Ug(P[0], P[1], Ne, b[0], P[1], Pe, b[0], b[1], me, l, p)
                                  , je = Math.min(null !== $e ? $e : Number.MAX_VALUE, null !== We ? We : Number.MAX_VALUE);
                                if (je !== Number.MAX_VALUE)
                                    return je;
                                {
                                    const Ke = B.vec3.scaleAndAdd([], l, p, C);
                                    if (jg(me, pe, Pe, Ne, Ng(Ke[0], b[0], P[0]), Ng(Ke[1], b[1], P[1])) >= Ke[2])
                                        return C
                                }
                                continue
                            }
                            let z = 0;
                            for (let L = 0; L < this._siblingOffset.length; L++) {
                                $g((A << 1) + this._siblingOffset[L][0], (O << 1) + this._siblingOffset[L][1], F + 1, e, o, a, u, b, P),
                                b[2] = -100,
                                P[2] = this.maximums[this.childOffsets[w] + L] * g;
                                const N = Bg(b, P, l, p);
                                if (null != N) {
                                    const G = N;
                                    T[L] = G;
                                    let X = !1;
                                    for (let _e = 0; _e < z && !X; _e++)
                                        G >= T[f[_e]] && (f.splice(_e, 0, L),
                                        X = !0);
                                    X || (f[z] = L),
                                    z++
                                }
                            }
                            for (let L = 0; L < z; L++) {
                                const N = f[L];
                                v.push({
                                    idx: this.childOffsets[w] + N,
                                    t: T[N],
                                    nodex: (A << 1) + this._siblingOffset[N][0],
                                    nodey: (O << 1) + this._siblingOffset[N][1],
                                    depth: F + 1
                                })
                            }
                        }
                        return null
                    }
                    _addNode(e, o, a) {
                        return this.minimums.push(e),
                        this.maximums.push(o),
                        this.leaves.push(a),
                        this.childOffsets.push(0),
                        this.nodeCount++
                    }
                    _construct(e, o, a, u, l) {
                        if (1 === e[u].isLeaf(o, a))
                            return;
                        this.childOffsets[l] || (this.childOffsets[l] = this.nodeCount);
                        const p = u - 1
                          , g = e[p];
                        let x = 0
                          , T = 0;
                        for (let f = 0; f < this._siblingOffset.length; f++) {
                            const b = 2 * o + this._siblingOffset[f][0]
                              , P = 2 * a + this._siblingOffset[f][1]
                              , v = g.getElevation(b, P)
                              , w = g.isLeaf(b, P)
                              , C = this._addNode(v.min, v.max, w);
                            w && (x |= 1 << f),
                            T || (T = C)
                        }
                        for (let f = 0; f < this._siblingOffset.length; f++)
                            x & 1 << f || this._construct(e, 2 * o + this._siblingOffset[f][0], 2 * a + this._siblingOffset[f][1], p, T + f)
                    }
                }
                function jg(n, e, o, a, u, l) {
                    return jo(jo(n, o, l), jo(e, a, l), u)
                }
                function kl(n, e, o) {
                    const a = o.dim
                      , u = ie(n * a - .5, 0, a - 1)
                      , l = ie(e * a - .5, 0, a - 1)
                      , p = Math.floor(u)
                      , g = Math.floor(l)
                      , x = Math.min(p + 1, a - 1)
                      , T = Math.min(g + 1, a - 1);
                    return jg(o.get(p, g), o.get(x, g), o.get(p, T), o.get(x, T), u - p, l - g)
                }
                const Oy = {
                    mapbox: [6553.6, 25.6, .1, 1e4],
                    terrarium: [256, 1, 1 / 256, 32768]
                };
                function Ry(n, e, o) {
                    return (256 * n * 256 + 256 * e + o) / 10 - 1e4
                }
                function Dy(n, e, o) {
                    return 256 * n + e + o / 256 - 32768
                }
                class xd {
                    get tree() {
                        return this._tree || this._buildQuadTree(),
                        this._tree
                    }
                    constructor(e, o, a, u=!1) {
                        if (this.uid = e,
                        o.height !== o.width)
                            throw new RangeError("DEM tiles must be square");
                        if (a && "mapbox" !== a && "terrarium" !== a)
                            return void vo('"'.concat(a, '" is not a valid encoding type. Valid types include "mapbox" and "terrarium".'));
                        this.stride = o.height;
                        const l = this.dim = o.height - 2
                          , p = new Uint32Array(o.data.buffer);
                        if (this.pixels = new Uint8Array(o.data.buffer),
                        this.floatView = new Float32Array(o.data.buffer),
                        this.borderReady = u,
                        this._modifiedForSources = {},
                        !u) {
                            for (let x = 0; x < l; x++)
                                p[this._idx(-1, x)] = p[this._idx(0, x)],
                                p[this._idx(l, x)] = p[this._idx(l - 1, x)],
                                p[this._idx(x, -1)] = p[this._idx(x, 0)],
                                p[this._idx(x, l)] = p[this._idx(x, l - 1)];
                            p[this._idx(-1, -1)] = p[this._idx(0, 0)],
                            p[this._idx(l, -1)] = p[this._idx(l - 1, 0)],
                            p[this._idx(-1, l)] = p[this._idx(0, l - 1)],
                            p[this._idx(l, l)] = p[this._idx(l - 1, l - 1)]
                        }
                        const g = "terrarium" === a ? Dy : Ry;
                        for (let x = 0; x < p.length; ++x) {
                            const T = 4 * x;
                            this.floatView[x] = g(this.pixels[T], this.pixels[T + 1], this.pixels[T + 2])
                        }
                        this._timestamp = Qt.now()
                    }
                    _buildQuadTree() {
                        this._tree = new Gg(this)
                    }
                    get(e, o, a=!1) {
                        a && (e = ie(e, -1, this.dim),
                        o = ie(o, -1, this.dim));
                        const u = this._idx(e, o);
                        return this.floatView[u]
                    }
                    set(e, o, a) {
                        const u = this._idx(e, o)
                          , l = this.floatView[u];
                        return this.floatView[u] = a,
                        a - l
                    }
                    static getUnpackVector(e) {
                        return Oy[e]
                    }
                    _idx(e, o) {
                        if (e < -1 || e >= this.dim + 1 || o < -1 || o >= this.dim + 1)
                            throw new RangeError("out of range source coordinates for DEM data");
                        return (o + 1) * this.stride + (e + 1)
                    }
                    static pack(e, o) {
                        const a = [0, 0, 0, 0]
                          , u = xd.getUnpackVector(o);
                        let l = Math.floor((e + u[3]) / u[2]);
                        return a[2] = l % 256,
                        l = Math.floor(l / 256),
                        a[1] = l % 256,
                        l = Math.floor(l / 256),
                        a[0] = l,
                        a
                    }
                    getPixels() {
                        return new lf({
                            width: this.stride,
                            height: this.stride
                        },this.pixels)
                    }
                    backfillBorder(e, o, a) {
                        if (this.dim !== e.dim)
                            throw new Error("dem dimension mismatch");
                        let u = o * this.dim
                          , l = o * this.dim + this.dim
                          , p = a * this.dim
                          , g = a * this.dim + this.dim;
                        switch (o) {
                        case -1:
                            u = l - 1;
                            break;
                        case 1:
                            l = u + 1
                        }
                        switch (a) {
                        case -1:
                            p = g - 1;
                            break;
                        case 1:
                            g = p + 1
                        }
                        const x = -o * this.dim
                          , T = -a * this.dim;
                        for (let f = p; f < g; f++)
                            for (let b = u; b < l; b++) {
                                const P = 4 * this._idx(b, f)
                                  , v = 4 * this._idx(b + x, f + T);
                                this.pixels[P + 0] = e.pixels[v + 0],
                                this.pixels[P + 1] = e.pixels[v + 1],
                                this.pixels[P + 2] = e.pixels[v + 2],
                                this.pixels[P + 3] = e.pixels[v + 3]
                            }
                    }
                    onDeserialize() {
                        this._tree && (this._tree.dem = this)
                    }
                }
                function Ly(n, e, o) {
                    var a, u;
                    1 === n ? e.headerLength = o.readFixed32() : 2 === n ? e.x = o.readVarint() : 3 === n ? e.y = o.readVarint() : 4 === n ? e.z = o.readVarint() : 5 === n && e.layers.push((a = o,
                    u = o.readVarint() + o.pos,
                    a.readFields(Uy, {
                        version: 0,
                        name: "",
                        units: "",
                        tileSize: 0,
                        buffer: 0,
                        pixelFormat: 0,
                        dataIndex: []
                    }, u)))
                }
                function Fy(n, e, o) {
                    var a, u;
                    1 === n ? (e.delta_filter = (a = o,
                    u = o.readVarint() + o.pos,
                    a.readFields(ky, {
                        blockSize: 0
                    }, u)),
                    e.filter = "delta_filter") : 2 === n ? (o.readVarint(),
                    e.filter = "zigzag_filter") : 3 === n ? (o.readVarint(),
                    e.filter = "bitshuffle_filter") : 4 === n && (o.readVarint(),
                    e.filter = "byteshuffle_filter")
                }
                function ky(n, e, o) {
                    1 === n && (e.blockSize = o.readVarint())
                }
                function zy(n, e, o) {
                    1 === n ? (o.readVarint(),
                    e.codec = "gzip_data") : 2 === n ? (o.readVarint(),
                    e.codec = "jpeg_image") : 3 === n ? (o.readVarint(),
                    e.codec = "webp_image") : 4 === n && (o.readVarint(),
                    e.codec = "png_image")
                }
                function By(n, e, o) {
                    let a = 0
                      , u = 0;
                    var l, p;
                    1 === n ? e.firstByte = o.readFixed64() : 2 === n ? e.lastByte = o.readFixed64() : 3 === n ? e.filters.push((l = o,
                    p = o.readVarint() + o.pos,
                    l.readFields(Fy, {}, p))) : 4 === n ? e.codec = function(l, p) {
                        return l.readFields(zy, {}, p)
                    }(o, o.readVarint() + o.pos) : 5 === n ? u = o.readFloat() : 6 === n ? a = o.readFloat() : 7 === n ? e.bands.push(o.readString()) : 8 === n ? e.offset = o.readDouble() : 9 === n && (e.scale = o.readDouble()),
                    0 === e.offset && (e.offset = u),
                    0 === e.scale && (e.scale = a)
                }
                function Uy(n, e, o) {
                    var a, u;
                    1 === n ? e.version = o.readVarint() : 2 === n ? e.name = o.readString() : 3 === n ? e.units = o.readString() : 4 === n ? e.tileSize = o.readVarint() : 5 === n ? e.buffer = o.readVarint() : 6 === n ? e.pixelFormat = o.readVarint() : 7 === n && e.dataIndex.push((a = o,
                    u = o.readVarint() + o.pos,
                    a.readFields(By, {
                        firstByte: 0,
                        lastByte: 0,
                        filters: [],
                        codec: null,
                        offset: 0,
                        scale: 0,
                        bands: []
                    }, u)))
                }
                function Ny(n, e, o) {
                    if (2 === n)
                        a = o,
                        u = o.readVarint() + o.pos,
                        a.readFields($y, e, u);
                    else if (3 === n)
                        throw new Error("Not implemented");
                    var a, u
                }
                function $y(n, e, o) {
                    if (1 === n) {
                        let a = 0;
                        const u = o.readVarint() + o.pos;
                        for (; o.pos < u; )
                            e[a++] = o.readVarint()
                    }
                }
                function Gy(n, e) {
                    if (4 !== e.length)
                        throw new Error("Expected data of dimension 4 but got ".concat(e.length, "."));
                    let o = e[3];
                    for (let a = 2; a >= 1; a--) {
                        const u = 1 === a ? 1 : 0
                          , l = 2 === a ? 1 : 0;
                        for (let p = 0; p < e[0]; p++) {
                            const g = e[1] * p;
                            for (let x = u; x < e[1]; x++) {
                                const T = e[2] * (x + g);
                                for (let f = l; f < e[2]; f++) {
                                    const b = e[3] * (f + T);
                                    for (let P = 0; P < e[3]; P++) {
                                        const v = b + P;
                                        n[v] += n[v - o]
                                    }
                                }
                            }
                        }
                        o *= e[a]
                    }
                    return n
                }
                function jy(n) {
                    for (let e = 0, o = n.length; e < o; e++)
                        n[e] = n[e] >>> 1 ^ -(1 & n[e]);
                    return n
                }
                function Vy(n, e) {
                    switch (e) {
                    case "uint32":
                        return n;
                    case "uint16":
                        for (let o = 0; o < n.length; o += 2) {
                            const a = n[o]
                              , u = n[o + 1];
                            n[o] = (240 & a) >> 4 | (61440 & a) >> 8 | (240 & u) << 4 | 61440 & u,
                            n[o + 1] = 15 & a | (3840 & a) >> 4 | (15 & u) << 8 | (3840 & u) << 4
                        }
                        return n;
                    case "uint8":
                        for (let o = 0; o < n.length; o += 4) {
                            const a = n[o]
                              , u = n[o + 1]
                              , l = n[o + 2]
                              , p = n[o + 3];
                            n[o + 0] = (192 & a) >> 6 | (192 & u) >> 4 | (192 & l) >> 2 | 192 & p,
                            n[o + 1] = (48 & a) >> 4 | (48 & u) >> 2 | 48 & l | (48 & p) << 2,
                            n[o + 2] = (12 & a) >> 2 | 12 & u | (12 & l) << 2 | (12 & p) << 4,
                            n[o + 3] = 3 & a | (3 & u) << 2 | (3 & l) << 4 | (3 & p) << 6
                        }
                        return n;
                    default:
                        throw new Error('Invalid pixel format, "'.concat(e, '"'))
                    }
                }
                Fe(xd, "DEMData"),
                Fe(Gg, "DemMinMaxQuadTree", {
                    omit: ["dem"]
                });
                var ss = Uint8Array
                  , sp = Uint16Array
                  , Hy = Int32Array
                  , Vg = new ss([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0])
                  , Hg = new ss([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0])
                  , Wy = new ss([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
                  , Wg = function(n, e) {
                    for (var o = new sp(31), a = 0; a < 31; ++a)
                        o[a] = e += 1 << n[a - 1];
                    var u = new Hy(o[30]);
                    for (a = 1; a < 30; ++a)
                        for (var l = o[a]; l < o[a + 1]; ++l)
                            u[l] = l - o[a] << 5 | a;
                    return {
                        b: o,
                        r: u
                    }
                }
                  , Xg = Wg(Vg, 2)
                  , Yg = Xg.b
                  , Xy = Xg.r;
                Yg[28] = 258,
                Xy[258] = 28;
                for (var Yy = Wg(Hg, 0).b, Zg = new sp(32768), Mn = 0; Mn < 32768; ++Mn) {
                    var qh = (43690 & Mn) >> 1 | (21845 & Mn) << 1;
                    Zg[Mn] = ((65280 & (qh = (61680 & (qh = (52428 & qh) >> 2 | (13107 & qh) << 2)) >> 4 | (3855 & qh) << 4)) >> 8 | (255 & qh) << 8) >> 1
                }
                var ap = function(n, e, o) {
                    for (var a = n.length, u = 0, l = new sp(e); u < a; ++u)
                        n[u] && ++l[n[u] - 1];
                    var p, g = new sp(e);
                    for (u = 1; u < e; ++u)
                        g[u] = g[u - 1] + l[u - 1] << 1;
                    p = new sp(1 << e);
                    var x = 15 - e;
                    for (u = 0; u < a; ++u)
                        if (n[u])
                            for (var T = u << 4 | n[u], f = e - n[u], b = g[n[u] - 1]++ << f, P = b | (1 << f) - 1; b <= P; ++b)
                                p[Zg[b] >> x] = T;
                    return p
                }
                  , lp = new ss(288);
                for (Mn = 0; Mn < 144; ++Mn)
                    lp[Mn] = 8;
                for (Mn = 144; Mn < 256; ++Mn)
                    lp[Mn] = 9;
                for (Mn = 256; Mn < 280; ++Mn)
                    lp[Mn] = 7;
                for (Mn = 280; Mn < 288; ++Mn)
                    lp[Mn] = 8;
                var Kg = new ss(32);
                for (Mn = 0; Mn < 32; ++Mn)
                    Kg[Mn] = 5;
                var Zy = ap(lp, 9)
                  , Ky = ap(Kg, 5)
                  , Fm = function(n) {
                    for (var e = n[0], o = 1; o < n.length; ++o)
                        n[o] > e && (e = n[o]);
                    return e
                }
                  , Ns = function(n, e, o) {
                    var a = e / 8 | 0;
                    return (n[a] | n[a + 1] << 8) >> (7 & e) & o
                }
                  , km = function(n, e) {
                    var o = e / 8 | 0;
                    return (n[o] | n[o + 1] << 8 | n[o + 2] << 16) >> (7 & e)
                }
                  , qy = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"]
                  , $s = function(n, e, o) {
                    var a = new Error(e || qy[n]);
                    if (a.code = n,
                    Error.captureStackTrace && Error.captureStackTrace(a, $s),
                    !o)
                        throw a;
                    return a
                }
                  , Jy = new ss(0)
                  , Qy = typeof TextDecoder < "u" && new TextDecoder;
                try {
                    Qy.decode(Jy, {
                        stream: !0
                    })
                } catch {}
                const ev = {
                    gzip_data: "gzip"
                };
                class vs extends Error {
                    constructor(e) {
                        super(e),
                        this.name = "MRTError"
                    }
                }
                const tv = {
                    0: "uint32",
                    1: "uint32",
                    2: "uint16",
                    3: "uint8"
                }
                  , qg = {
                    uint32: 1,
                    uint16: 2,
                    uint8: 4
                }
                  , ov = {
                    uint32: Uint32Array,
                    uint16: Uint16Array,
                    uint8: Uint8Array
                };
                let zm;
                class Bm {
                    constructor(e=5) {
                        this.x = NaN,
                        this.y = NaN,
                        this.z = NaN,
                        this.layers = {},
                        this._cacheSize = e
                    }
                    getLayer(e) {
                        const o = this.layers[e];
                        if (!o)
                            throw new vs("Layer '".concat(e, "' not found"));
                        return o
                    }
                    getHeaderLength(e) {
                        const o = new Uint8Array(e)
                          , a = new DataView(e);
                        if (13 !== o[0])
                            throw new vs("File is not a valid MRT.");
                        return a.getUint32(1, !0)
                    }
                    parseHeader(e) {
                        const o = new Uint8Array(e)
                          , a = this.getHeaderLength(e);
                        if (o.length < a)
                            throw new vs("Expected header with length >= ".concat(a, " but got buffer of length ").concat(o.length));
                        const u = new zm(o.subarray(0, a)).readFields(Ly, {
                            headerLength: 0,
                            x: 0,
                            y: 0,
                            z: 0,
                            layers: []
                        }, void 0);
                        if (!isNaN(this.x) && (this.x !== u.x || this.y !== u.y || this.z !== u.z))
                            throw new vs("Invalid attempt to parse header ".concat(u.z, "/").concat(u.x, "/").concat(u.y, " for tile ").concat(this.z, "/").concat(this.x, "/").concat(this.y));
                        this.x = u.x,
                        this.y = u.y,
                        this.z = u.z;
                        for (const l of u.layers)
                            this.layers[l.name] = new iv(l,{
                                cacheSize: this._cacheSize
                            });
                        return this
                    }
                    createDecodingTask(e) {
                        const o = []
                          , a = this.getLayer(e.layerName);
                        for (let u of e.blockIndices) {
                            const l = a.dataIndex[u]
                              , p = l.firstByte - e.firstByte
                              , g = l.lastByte - e.firstByte;
                            if (a._blocksInProgress.has(u))
                                continue;
                            const x = {
                                layerName: a.name,
                                firstByte: p,
                                lastByte: g,
                                pixelFormat: a.pixelFormat,
                                blockIndex: u,
                                blockShape: [l.bands.length].concat(a.bandShape),
                                buffer: a.buffer,
                                codec: l.codec.codec,
                                filters: l.filters.map(T => T.filter)
                            };
                            a._blocksInProgress.add(u),
                            o.push(x)
                        }
                        return new Jg(o, () => {
                            o.forEach(u => a._blocksInProgress.delete(u.blockIndex))
                        }
                        , (u, l) => {
                            if (o.forEach(p => a._blocksInProgress.delete(p.blockIndex)),
                            u)
                                throw u;
                            l.forEach(p => {
                                this.getLayer(p.layerName).processDecodedData(p)
                            }
                            )
                        }
                        )
                    }
                }
                class iv {
                    constructor({version: e, name: o, units: a, tileSize: u, pixelFormat: l, buffer: p, dataIndex: g}, x) {
                        if (this.version = e,
                        1 !== this.version)
                            throw new vs("Cannot parse raster layer encoded with MRT version ".concat(e));
                        this.name = o,
                        this.units = a,
                        this.tileSize = u,
                        this.buffer = p,
                        this.pixelFormat = tv[l],
                        this.dataIndex = g,
                        this.bandShape = [u + 2 * p, u + 2 * p, qg[this.pixelFormat]],
                        this._decodedBlocks = new Dm(x ? x.cacheSize : 5),
                        this._blocksInProgress = new Set
                    }
                    get dimension() {
                        return qg[this.pixelFormat]
                    }
                    get cacheSize() {
                        return this._decodedBlocks.capacity
                    }
                    getBandList() {
                        return this.dataIndex.map( ({bands: e}) => e).flat()
                    }
                    processDecodedData(e) {
                        const o = e.blockIndex.toString();
                        this._decodedBlocks.get(o) || this._decodedBlocks.put(o, e.data)
                    }
                    getBlockForBand(e) {
                        let o = 0;
                        switch (typeof e) {
                        case "string":
                            for (const [a,u] of this.dataIndex.entries()) {
                                for (const [l,p] of u.bands.entries())
                                    if (p === e)
                                        return {
                                            bandIndex: o + l,
                                            blockIndex: a,
                                            blockBandIndex: l
                                        };
                                o += u.bands.length
                            }
                            break;
                        case "number":
                            for (const [a,u] of this.dataIndex.entries()) {
                                if (e >= o && e < o + u.bands.length)
                                    return {
                                        bandIndex: e,
                                        blockIndex: a,
                                        blockBandIndex: e - o
                                    };
                                o += u.bands.length
                            }
                            break;
                        default:
                            throw new vs("Invalid band `".concat(JSON.stringify(e), "`. Expected string or integer."))
                        }
                        throw new vs("Band not found: ".concat(JSON.stringify(e)))
                    }
                    getDataRange(e) {
                        let o = 1 / 0
                          , a = -1 / 0;
                        const u = []
                          , l = new Set;
                        for (const p of e) {
                            const {blockIndex: g} = this.getBlockForBand(p);
                            if (g < 0)
                                throw new vs("Invalid band: ".concat(JSON.stringify(p)));
                            const x = this.dataIndex[g];
                            u.includes(g) || u.push(g),
                            l.add(g),
                            o = Math.min(o, x.firstByte),
                            a = Math.max(a, x.lastByte)
                        }
                        if (l.size > this.cacheSize)
                            throw new vs("Number of blocks to decode (".concat(l.size, ") exceeds cache size (").concat(this.cacheSize, ")."));
                        return {
                            layerName: this.name,
                            firstByte: o,
                            lastByte: a,
                            blockIndices: u
                        }
                    }
                    hasBand(e) {
                        const {blockIndex: o} = this.getBlockForBand(e);
                        return o >= 0
                    }
                    hasDataForBand(e) {
                        const {blockIndex: o} = this.getBlockForBand(e);
                        return o >= 0 && !!this._decodedBlocks.get(o.toString())
                    }
                    getBandView(e) {
                        const {blockIndex: o, blockBandIndex: a} = this.getBlockForBand(e)
                          , u = this._decodedBlocks.get(o.toString());
                        if (!u)
                            throw new vs("Data for band ".concat(JSON.stringify(e), ' of layer "').concat(this.name, '" not decoded.'));
                        const l = this.dataIndex[o]
                          , p = this.bandShape.reduce( (T, f) => T * f, 1)
                          , g = a * p
                          , x = u.subarray(g, g + p);
                        return {
                            data: x,
                            bytes: new Uint8Array(x.buffer).subarray(x.byteOffset, x.byteOffset + x.byteLength),
                            tileSize: this.tileSize,
                            buffer: this.buffer,
                            pixelFormat: this.pixelFormat,
                            dimension: this.dimension,
                            offset: l.offset,
                            scale: l.scale
                        }
                    }
                }
                Bm.setPbf = function(n) {
                    zm = n
                }
                ;
                class Jg {
                    constructor(e, o, a) {
                        this.tasks = e,
                        this._onCancel = o,
                        this._onComplete = a,
                        this._finalized = !1
                    }
                    cancel() {
                        this._finalized || (this._onCancel(),
                        this._finalized = !0)
                    }
                    complete(e, o) {
                        this._finalized || (this._onComplete(e, o),
                        this._finalized = !0)
                    }
                }
                Bm.performDecoding = function(n, e) {
                    const o = new Uint8Array(n);
                    return Promise.all(e.tasks.map(a => {
                        const {layerName: u, firstByte: l, lastByte: p, pixelFormat: g, blockShape: x, blockIndex: T, filters: f, codec: b} = a
                          , P = o.subarray(l, p + 1)
                          , v = new Uint32Array(x[0] * x[1] * x[2]);
                        let w;
                        if ("gzip_data" !== b)
                            throw new vs("Unhandled codec: ".concat(b));
                        return w = function(C, A) {
                            if (!globalThis.DecompressionStream && "gzip_data" === A)
                                return Promise.resolve(((L = function(X) {
                                    31 == X[0] && 139 == X[1] && 8 == X[2] || $s(6, "invalid gzip data");
                                    var _e = X[3]
                                      , me = 10;
                                    4 & _e && (me += 2 + (X[10] | X[11] << 8));
                                    for (var pe = (_e >> 3 & 1) + (_e >> 4 & 1); pe > 0; pe -= !X[me++])
                                        ;
                                    return me + (2 & _e)
                                }(z = C)) + 8 > z.length && $s(6, "invalid gzip data"),
                                function(X, _e, me) {
                                    var Ne = X.length;
                                    if (!Ne || _e.f && !_e.l)
                                        return me || new ss(0);
                                    var Pe = !me
                                      , $e = Pe || 2 != _e.i
                                      , We = _e.i;
                                    Pe && (me = new ss(3 * Ne));
                                    var je, Ke, rt = function(ja) {
                                        var Ul = me.length;
                                        if (ja > Ul) {
                                            var Nl = new ss(Math.max(2 * Ul, ja));
                                            Nl.set(me),
                                            me = Nl
                                        }
                                    }, at = _e.f || 0, ot = _e.p || 0, Ct = _e.b || 0, Zt = _e.l, Ot = _e.d, lo = _e.m, io = _e.n, fo = 8 * Ne;
                                    do {
                                        if (!Zt) {
                                            at = Ns(X, ot, 1);
                                            var Bt = Ns(X, ot + 1, 3);
                                            if (ot += 3,
                                            !Bt) {
                                                var Ro = X[(Ko = 4 + ((ot + 7) / 8 | 0)) - 4] | X[Ko - 3] << 8
                                                  , ho = Ko + Ro;
                                                if (ho > Ne) {
                                                    We && $s(0);
                                                    break
                                                }
                                                $e && rt(Ct + Ro),
                                                me.set(X.subarray(Ko, ho), Ct),
                                                _e.b = Ct += Ro,
                                                _e.p = ot = 8 * ho,
                                                _e.f = at;
                                                continue
                                            }
                                            if (1 == Bt)
                                                Zt = Zy,
                                                Ot = Ky,
                                                lo = 9,
                                                io = 5;
                                            else if (2 == Bt) {
                                                var Ao = Ns(X, ot, 31) + 257
                                                  , $o = Ns(X, ot + 10, 15) + 4
                                                  , Qo = Ao + Ns(X, ot + 5, 31) + 1;
                                                ot += 14;
                                                for (var ni = new ss(Qo), di = new ss(19), ri = 0; ri < $o; ++ri)
                                                    di[Wy[ri]] = Ns(X, ot + 3 * ri, 7);
                                                ot += 3 * $o;
                                                var gi = Fm(di)
                                                  , Zi = (1 << gi) - 1
                                                  , $i = ap(di, gi);
                                                for (ri = 0; ri < Qo; ) {
                                                    var Ko, Gi = $i[Ns(X, ot, Zi)];
                                                    if (ot += 15 & Gi,
                                                    (Ko = Gi >> 4) < 16)
                                                        ni[ri++] = Ko;
                                                    else {
                                                        var ki = 0
                                                          , Ki = 0;
                                                        for (16 == Ko ? (Ki = 3 + Ns(X, ot, 3),
                                                        ot += 2,
                                                        ki = ni[ri - 1]) : 17 == Ko ? (Ki = 3 + Ns(X, ot, 7),
                                                        ot += 3) : 18 == Ko && (Ki = 11 + Ns(X, ot, 127),
                                                        ot += 7); Ki--; )
                                                            ni[ri++] = ki
                                                    }
                                                }
                                                var Tn = ni.subarray(0, Ao)
                                                  , Cn = ni.subarray(Ao);
                                                lo = Fm(Tn),
                                                io = Fm(Cn),
                                                Zt = ap(Tn, lo),
                                                Ot = ap(Cn, io)
                                            } else
                                                $s(1);
                                            if (ot > fo) {
                                                We && $s(0);
                                                break
                                            }
                                        }
                                        $e && rt(Ct + 131072);
                                        for (var gn = (1 << lo) - 1, Er = (1 << io) - 1, nn = ot; ; nn = ot) {
                                            var ln = (ki = Zt[km(X, ot) & gn]) >> 4;
                                            if ((ot += 15 & ki) > fo) {
                                                We && $s(0);
                                                break
                                            }
                                            if (ki || $s(2),
                                            ln < 256)
                                                me[Ct++] = ln;
                                            else {
                                                if (256 == ln) {
                                                    nn = ot,
                                                    Zt = null;
                                                    break
                                                }
                                                var mr = ln - 254;
                                                ln > 264 && (mr = Ns(X, ot, (1 << (Dn = Vg[ri = ln - 257])) - 1) + Yg[ri],
                                                ot += Dn);
                                                var En = Ot[km(X, ot) & Er]
                                                  , Rr = En >> 4;
                                                if (En || $s(3),
                                                ot += 15 & En,
                                                Cn = Yy[Rr],
                                                Rr > 3) {
                                                    var Dn = Hg[Rr];
                                                    Cn += km(X, ot) & (1 << Dn) - 1,
                                                    ot += Dn
                                                }
                                                if (ot > fo) {
                                                    We && $s(0);
                                                    break
                                                }
                                                $e && rt(Ct + 131072);
                                                var xa = Ct + mr;
                                                if (Ct < Cn) {
                                                    var zl = 0 - Cn
                                                      , Bl = Math.min(Cn, xa);
                                                    for (zl + Ct < 0 && $s(3); Ct < Bl; ++Ct)
                                                        me[Ct] = (void 0)[zl + Ct]
                                                }
                                                for (; Ct < xa; ++Ct)
                                                    me[Ct] = me[Ct - Cn]
                                            }
                                        }
                                        _e.l = Zt,
                                        _e.p = nn,
                                        _e.b = Ct,
                                        _e.f = at,
                                        Zt && (at = 1,
                                        _e.m = lo,
                                        _e.d = Ot,
                                        _e.n = io)
                                    } while (!at);
                                    return Ct != me.length && Pe ? (je = me,
                                    (null == (Ke = Ct) || Ke > je.length) && (Ke = je.length),
                                    new ss(je.subarray(0, Ke))) : me.subarray(0, Ct)
                                }(z.subarray(L, -8), {
                                    i: 2
                                }, new ss(((O = z)[(F = O.length) - 4] | O[F - 3] << 8 | O[F - 2] << 16 | O[F - 1] << 24) >>> 0))));
                            var O, F, z, L;
                            const N = ev[A];
                            if (!N)
                                throw new Error("Unhandled codec: ".concat(A));
                            const G = new globalThis.DecompressionStream(N);
                            return new Response(new Blob([C]).stream().pipeThrough(G)).arrayBuffer().then(X => new Uint8Array(X))
                        }(P, b).then(C => (new zm(C).readFields(Ny, v),
                        new ov[g](v.buffer))),
                        w.then(C => {
                            for (let A = f.length - 1; A >= 0; A--)
                                switch (f[A]) {
                                case "delta_filter":
                                    Gy(C, x);
                                    break;
                                case "zigzag_filter":
                                    jy(C);
                                    break;
                                case "bitshuffle_filter":
                                    Vy(C, g);
                                    break;
                                default:
                                    throw new vs('Unhandled filter "'.concat(f[A], '"'))
                                }
                            return {
                                layerName: u,
                                blockIndex: T,
                                data: C
                            }
                        }
                        ).catch(C => {
                            throw C
                        }
                        )
                    }
                    ))
                }
                ,
                Fe(Jg, "MRTDecodingBatch", {
                    omit: ["_onCancel", "_onComplete"]
                });
                let cp, Um, Gs, Jh, Nm, Qh = null;
                function Qg() {
                    return ji() && self.worker && self.worker.dracoUrl ? self.worker.dracoUrl : Um || Ee.DRACO_URL
                }
                function e0() {
                    if (ji() && self.worker && self.worker.meshoptUrl)
                        return self.worker.meshoptUrl;
                    if (Jh)
                        return Jh;
                    const n = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
                    if ("object" != typeof WebAssembly)
                        throw new Error("WebAssembly not supported, cannot instantiate meshoptimizer");
                    return Jh = WebAssembly.validate(n) ? Ee.MESHOPT_SIMD_URL : Ee.MESHOPT_URL,
                    Jh
                }
                const bd = {
                    5120: Int8Array,
                    5121: Uint8Array,
                    5122: Int16Array,
                    5123: Uint16Array,
                    5125: Uint32Array,
                    5126: Float32Array
                }
                  , nv = {
                    5120: "DT_INT8",
                    5121: "DT_UINT8",
                    5122: "DT_INT16",
                    5123: "DT_UINT16",
                    5125: "DT_UINT32",
                    5126: "DT_FLOAT32"
                }
                  , hp = {
                    SCALAR: 1,
                    VEC2: 2,
                    VEC3: 3,
                    VEC4: 4,
                    MAT2: 4,
                    MAT3: 9,
                    MAT4: 16
                };
                function t0(n, e, o) {
                    const a = o.json.bufferViews.length
                      , u = o.buffers.length;
                    e.bufferView = a,
                    o.json.bufferViews[a] = {
                        buffer: u,
                        byteLength: n.byteLength
                    },
                    o.buffers[u] = n
                }
                const $m = "KHR_draco_mesh_compression";
                function rv(n, e) {
                    const o = n.extensions && n.extensions[$m];
                    if (!o)
                        return;
                    const a = new Gs.Decoder
                      , u = r0(e, o.bufferView)
                      , l = new Gs.Mesh;
                    if (!a.DecodeArrayToMesh(u, u.byteLength, l))
                        throw new Error("Failed to decode Draco mesh");
                    const p = e.json.accessors[n.indices]
                      , g = bd[p.componentType]
                      , x = p.count * g.BYTES_PER_ELEMENT
                      , T = Gs._malloc(x);
                    g === Uint16Array ? a.GetTrianglesUInt16Array(l, x, T) : a.GetTrianglesUInt32Array(l, x, T),
                    t0(Gs.memory.buffer.slice(T, T + x), p, e),
                    Gs._free(T);
                    for (const f of Object.keys(o.attributes)) {
                        const b = a.GetAttributeByUniqueId(l, o.attributes[f])
                          , P = e.json.accessors[n.attributes[f]]
                          , v = nv[P.componentType]
                          , w = P.count * hp[P.type] * bd[P.componentType].BYTES_PER_ELEMENT
                          , C = Gs._malloc(w);
                        a.GetAttributeDataArrayForAllPoints(l, b, Gs[v], w, C),
                        t0(Gs.memory.buffer.slice(C, C + w), P, e),
                        Gs._free(C)
                    }
                    a.destroy(),
                    l.destroy(),
                    delete n.extensions[$m]
                }
                const wd = "EXT_meshopt_compression";
                function sv(n, e) {
                    if (!n.extensions || !n.extensions[wd])
                        return;
                    const o = n.extensions[wd]
                      , a = new Uint8Array(e.buffers[o.buffer],o.byteOffset || 0,o.byteLength || 0)
                      , u = new Uint8Array(o.count * o.byteStride);
                    Nm.decodeGltfBuffer(u, o.count, o.byteStride, a, o.mode, o.filter),
                    n.buffer = e.buffers.length,
                    n.byteOffset = 0,
                    e.buffers[n.buffer] = u.buffer,
                    delete n.extensions[wd]
                }
                const o0 = 1179937895
                  , i0 = new TextDecoder("utf8");
                function n0(n, e) {
                    return new URL(n,e).href
                }
                function av(n, e, o, a) {
                    return fetch(n0(n.uri, a)).then(u => u.arrayBuffer()).then(u => {
                        e.buffers[o] = u
                    }
                    )
                }
                function r0(n, e) {
                    const o = n.json.bufferViews[e];
                    return new Uint8Array(n.buffers[o.buffer],o.byteOffset || 0,o.byteLength)
                }
                function lv(n, e, o, a) {
                    if (n.uri) {
                        const u = n0(n.uri, a);
                        return fetch(u).then(l => l.blob()).then(l => createImageBitmap(l)).then(l => {
                            e.images[o] = l
                        }
                        )
                    }
                    if (void 0 !== n.bufferView) {
                        const u = r0(e, n.bufferView)
                          , l = new Blob([u],{
                            type: n.mimeType
                        });
                        return createImageBitmap(l).then(p => {
                            e.images[o] = p
                        }
                        )
                    }
                }
                function s0(n, e=0, o) {
                    const a = {
                        json: null,
                        images: [],
                        buffers: []
                    };
                    if (new Uint32Array(n,e,1)[0] === o0) {
                        const f = new Uint32Array(n,e);
                        let b = 2;
                        const P = (f[b++] >> 2) - 3
                          , v = f[b++] >> 2;
                        if (b++,
                        a.json = JSON.parse(i0.decode(f.subarray(b, b + v))),
                        b += v,
                        b < P) {
                            const w = f[b++];
                            b++;
                            const C = e + (b << 2);
                            a.buffers[0] = n.slice(C, C + w)
                        }
                    } else
                        a.json = JSON.parse(i0.decode(new Uint8Array(n,e)));
                    const {buffers: u, images: l, meshes: p, extensionsUsed: g, bufferViews: x} = a.json;
                    let T = Promise.resolve();
                    if (u) {
                        const f = [];
                        for (let b = 0; b < u.length; b++) {
                            const P = u[b];
                            P.uri ? f.push(av(P, a, b, o)) : a.buffers[b] || (a.buffers[b] = null)
                        }
                        T = Promise.all(f)
                    }
                    return T.then( () => {
                        const f = []
                          , b = g && g.includes($m)
                          , P = g && g.includes(wd);
                        if (b && f.push(function() {
                            if (!Gs)
                                return null != cp ? cp : (cp = function(v) {
                                    let w, C = null;
                                    function A() {
                                        w = new Uint8Array(C.buffer)
                                    }
                                    function O() {
                                        throw new Error("Unexpected Draco error.")
                                    }
                                    const F = {
                                        a: {
                                            a: O,
                                            d: function(z, L, N) {
                                                return w.copyWithin(z, L, L + N)
                                            },
                                            c: function(z) {
                                                const L = w.length
                                                  , N = Math.max(z >>> 0, Math.ceil(1.2 * L))
                                                  , G = Math.ceil((N - L) / 65536);
                                                try {
                                                    return C.grow(G),
                                                    A(),
                                                    !0
                                                } catch {
                                                    return !1
                                                }
                                            },
                                            b: O
                                        }
                                    };
                                    return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(v, F) : v.then(z => z.arrayBuffer()).then(z => WebAssembly.instantiate(z, F))).then(z => {
                                        const {Rb: L, Qb: N, P: G, T: X, X: _e, Ja: me, La: pe, Qa: Ne, Va: Pe, Wa: $e, eb: We, jb: je, f: Ke, e: rt, yb: at, zb: ot, Ab: Ct, Bb: Zt, Db: Ot, Gb: lo} = z.instance.exports;
                                        C = rt;
                                        const io = ( () => {
                                            let fo = 0
                                              , Bt = 0
                                              , Ro = 0
                                              , ho = 0;
                                            return Ao => {
                                                Ro && (L(ho),
                                                L(fo),
                                                Bt += Ro,
                                                Ro = fo = 0),
                                                fo || (Bt += 128,
                                                fo = N(Bt));
                                                const $o = Ao.length + 7 & -8;
                                                let Qo = fo;
                                                $o >= Bt && (Ro = $o,
                                                Qo = ho = N($o));
                                                for (let ni = 0; ni < Ao.length; ni++)
                                                    w[Qo + ni] = Ao[ni];
                                                return Qo
                                            }
                                        }
                                        )();
                                        return A(),
                                        Ke(),
                                        {
                                            memory: rt,
                                            _free: L,
                                            _malloc: N,
                                            Mesh: class {
                                                constructor() {
                                                    this.ptr = G()
                                                }
                                                destroy() {
                                                    X(this.ptr)
                                                }
                                            }
                                            ,
                                            Decoder: class {
                                                constructor() {
                                                    this.ptr = me()
                                                }
                                                destroy() {
                                                    je(this.ptr)
                                                }
                                                DecodeArrayToMesh(fo, Bt, Ro) {
                                                    const ho = io(fo)
                                                      , Ao = pe(this.ptr, ho, Bt, Ro.ptr);
                                                    return !!_e(Ao)
                                                }
                                                GetAttributeByUniqueId(fo, Bt) {
                                                    return {
                                                        ptr: Ne(this.ptr, fo.ptr, Bt)
                                                    }
                                                }
                                                GetTrianglesUInt16Array(fo, Bt, Ro) {
                                                    Pe(this.ptr, fo.ptr, Bt, Ro)
                                                }
                                                GetTrianglesUInt32Array(fo, Bt, Ro) {
                                                    $e(this.ptr, fo.ptr, Bt, Ro)
                                                }
                                                GetAttributeDataArrayForAllPoints(fo, Bt, Ro, ho, Ao) {
                                                    We(this.ptr, fo.ptr, Bt.ptr, Ro, ho, Ao)
                                                }
                                            }
                                            ,
                                            DT_INT8: at(),
                                            DT_UINT8: ot(),
                                            DT_INT16: Ct(),
                                            DT_UINT16: Zt(),
                                            DT_UINT32: Ot(),
                                            DT_FLOAT32: lo()
                                        }
                                    }
                                    )
                                }(fetch(Qg())),
                                cp.then(v => {
                                    Gs = v,
                                    cp = void 0
                                }
                                ))
                        }()),
                        P && f.push(function() {
                            if (Nm)
                                return;
                            const v = function(w) {
                                let C;
                                const A = WebAssembly.instantiateStreaming(w, {}).then(z => {
                                    C = z.instance,
                                    C.exports.__wasm_call_ctors()
                                }
                                )
                                  , O = {
                                    NONE: "",
                                    OCTAHEDRAL: "meshopt_decodeFilterOct",
                                    QUATERNION: "meshopt_decodeFilterQuat",
                                    EXPONENTIAL: "meshopt_decodeFilterExp"
                                }
                                  , F = {
                                    ATTRIBUTES: "meshopt_decodeVertexBuffer",
                                    TRIANGLES: "meshopt_decodeIndexBuffer",
                                    INDICES: "meshopt_decodeIndexSequence"
                                };
                                return {
                                    ready: A,
                                    supported: !0,
                                    decodeGltfBuffer(z, L, N, G, X, _e) {
                                        !function(me, pe, Ne, Pe, $e, We, je) {
                                            const Ke = me.exports.sbrk
                                              , rt = Pe + 3 & -4
                                              , at = Ke(rt * $e)
                                              , ot = Ke(We.length)
                                              , Ct = new Uint8Array(me.exports.memory.buffer);
                                            Ct.set(We, ot);
                                            const Zt = pe(at, Pe, $e, ot, We.length);
                                            if (0 === Zt && je && je(at, rt, $e),
                                            Ne.set(Ct.subarray(at, at + Pe * $e)),
                                            Ke(at - Ke(0)),
                                            0 !== Zt)
                                                throw new Error("Malformed buffer data: ".concat(Zt))
                                        }(C, C.exports[F[X]], z, L, N, G, C.exports[O[_e]])
                                    }
                                }
                            }(fetch(e0()));
                            return v.ready.then( () => {
                                Nm = v
                            }
                            )
                        }()),
                        l)
                            for (let v = 0; v < l.length; v++)
                                f.push(lv(l[v], a, v, o));
                        return (f.length ? Promise.all(f) : Promise.resolve()).then( () => {
                            if (b && p)
                                for (const {primitives: v} of p)
                                    for (const w of v)
                                        rv(w, a);
                            if (P && p && x)
                                for (const v of x)
                                    sv(v, a);
                            return a
                        }
                        )
                    }
                    )
                }
                function Nc(n, e) {
                    const o = n.json.bufferViews[e.bufferView]
                      , a = bd[e.componentType];
                    return new a(n.buffers[o.buffer],(e.byteOffset || 0) + (o.byteOffset || 0),e.count * (o.byteStride && o.byteStride !== hp[e.type] * a.BYTES_PER_ELEMENT ? o.byteStride / a.BYTES_PER_ELEMENT : hp[e.type]))
                }
                function Gm(n, e, o, a) {
                    const u = bd[e.componentType]
                      , l = function(f) {
                        switch (f) {
                        case Int8Array:
                            return 1 / 127;
                        case Uint8Array:
                            return 1 / 255;
                        case Int16Array:
                            return 1 / 32767;
                        case Uint16Array:
                            return 1 / 65535;
                        default:
                            return 1
                        }
                    }(u)
                      , p = n.json.bufferViews[e.bufferView]
                      , g = p.byteStride ? p.byteStride / u.BYTES_PER_ELEMENT : hp[e.type]
                      , x = o.float32
                      , T = x.length / o.capacity;
                    for (let f = 0, b = 0; f < e.count * g; f += g,
                    b += T)
                        for (let P = 0; P < T; P++)
                            x[b + P] = a[f + P] * l;
                    o._trim()
                }
                function cv(n, e, o) {
                    const a = n.indices
                      , u = n.attributes
                      , l = {};
                    l.indexArray = new Xn;
                    const p = e.json.accessors[a]
                      , g = p.count / 3;
                    l.indexArray.reserve(g);
                    const x = Nc(e, p);
                    for (let P = 0; P < g; P++)
                        l.indexArray.emplaceBack(x[3 * P], x[3 * P + 1], x[3 * P + 2]);
                    l.indexArray._trim(),
                    l.vertexArray = new Ds;
                    const T = e.json.accessors[u.POSITION];
                    l.vertexArray.reserve(T.count);
                    const f = Nc(e, T);
                    for (let P = 0; P < T.count; P++)
                        l.vertexArray.emplaceBack(f[3 * P], f[3 * P + 1], f[3 * P + 2]);
                    if (l.vertexArray._trim(),
                    l.aabb = new No(T.min,T.max),
                    l.centroid = function(P, v) {
                        const w = [0, 0, 0]
                          , C = P.length;
                        if (C > 0) {
                            for (let A = 0; A < C; A++) {
                                const O = 3 * P[A];
                                w[0] += v[O],
                                w[1] += v[O + 1],
                                w[2] += v[O + 2]
                            }
                            w[0] /= C,
                            w[1] /= C,
                            w[2] /= C
                        }
                        return w
                    }(x, f),
                    void 0 !== u.COLOR_0) {
                        const P = e.json.accessors[u.COLOR_0]
                          , v = hp[P.type]
                          , w = Nc(e, P);
                        l.colorArray = 3 === v ? new Ds : new ua,
                        l.colorArray.resize(P.count),
                        Gm(e, P, l.colorArray, w)
                    }
                    if (void 0 !== u.NORMAL) {
                        l.normalArray = new Ds;
                        const P = e.json.accessors[u.NORMAL];
                        l.normalArray.resize(P.count);
                        const v = Nc(e, P);
                        Gm(e, P, l.normalArray, v)
                    }
                    if (void 0 !== u.TEXCOORD_0 && o.length > 0) {
                        l.texcoordArray = new za;
                        const P = e.json.accessors[u.TEXCOORD_0];
                        l.texcoordArray.resize(P.count);
                        const v = Nc(e, P);
                        Gm(e, P, l.texcoordArray, v)
                    }
                    if (void 0 !== u._FEATURE_ID_RGBA4444) {
                        const P = e.json.accessors[u._FEATURE_ID_RGBA4444];
                        e.json.extensionsUsed && e.json.extensionsUsed.includes("EXT_meshopt_compression") && (l.featureData = Nc(e, P))
                    }
                    void 0 !== u._FEATURE_RGBA4444 && (l.featureData = new Uint32Array(Nc(e, e.json.accessors[u._FEATURE_RGBA4444]).buffer));
                    const b = n.material;
                    return l.material = function(P, v) {
                        const {emissiveFactor: w=[0, 0, 0], alphaMode: C="OPAQUE", alphaCutoff: A=.5, normalTexture: O, occlusionTexture: F, emissiveTexture: z, doubleSided: L} = P
                          , {baseColorFactor: N=[1, 1, 1, 1], metallicFactor: G=1, roughnessFactor: X=1, baseColorTexture: _e, metallicRoughnessTexture: me} = P.pbrMetallicRoughness || {}
                          , pe = F ? v[F.index] : void 0;
                        if (F && F.extensions && F.extensions.KHR_texture_transform && pe) {
                            const Ne = F.extensions.KHR_texture_transform;
                            pe.offsetScale = [Ne.offset[0], Ne.offset[1], Ne.scale[0], Ne.scale[1]]
                        }
                        return {
                            pbrMetallicRoughness: {
                                baseColorFactor: new wi(...N),
                                metallicFactor: G,
                                roughnessFactor: X,
                                baseColorTexture: _e ? v[_e.index] : void 0,
                                metallicRoughnessTexture: me ? v[me.index] : void 0
                            },
                            doubleSided: L,
                            emissiveFactor: w,
                            alphaMode: C,
                            alphaCutoff: A,
                            normalTexture: O ? v[O.index] : void 0,
                            occlusionTexture: pe,
                            emissionTexture: z ? v[z.index] : void 0,
                            defined: void 0 === P.defined
                        }
                    }(void 0 !== b ? e.json.materials[b] : {
                        defined: !1
                    }, o),
                    l
                }
                function a0(n, e, o) {
                    const {matrix: a, rotation: u, translation: l, scale: p, mesh: g, extras: x, children: T} = n
                      , f = {};
                    if (f.matrix = a || B.mat4.fromRotationTranslationScale([], u || [0, 0, 0, 1], l || [0, 0, 0], p || [1, 1, 1]),
                    void 0 !== g) {
                        f.meshes = o[g];
                        const b = f.anchor = [0, 0];
                        for (const P of f.meshes) {
                            const {min: v, max: w} = P.aabb;
                            b[0] += v[0] + w[0],
                            b[1] += v[1] + w[1]
                        }
                        b[0] = Math.floor(b[0] / f.meshes.length / 2),
                        b[1] = Math.floor(b[1] / f.meshes.length / 2)
                    }
                    if (x && (x.id && (f.id = x.id),
                    x.lights && (f.lights = function(b) {
                        if (!b.length)
                            return [];
                        const P = function(O) {
                            const F = atob(O)
                              , z = new Uint8Array(F.length);
                            for (let L = 0; L < F.length; L++)
                                z[L] = F.codePointAt(L);
                            return z
                        }(b)
                          , v = []
                          , w = P.length / 24
                          , C = new Uint16Array(P.buffer)
                          , A = new Float32Array(P.buffer);
                        for (let O = 0; O < w; O++) {
                            const F = C[2 * O * 6] / 30
                              , z = C[2 * O * 6 + 1] / 30
                              , L = C[2 * O * 6 + 10] / 100
                              , N = A[6 * O + 1]
                              , G = A[6 * O + 2]
                              , X = A[6 * O + 3]
                              , _e = A[6 * O + 4]
                              , me = X - N
                              , pe = _e - G
                              , Ne = Math.hypot(me, pe);
                            v.push({
                                pos: [N + .5 * me, G + .5 * pe, z],
                                normal: [pe / Ne, -me / Ne, 0],
                                width: Ne,
                                height: F,
                                depth: L,
                                points: [N, G, X, _e]
                            })
                        }
                        return v
                    }(x.lights))),
                    T) {
                        const b = [];
                        for (const P of T)
                            b.push(a0(e.json.nodes[P], e, o));
                        f.children = b
                    }
                    return f
                }
                function hv(n) {
                    if (0 === n.vertices.length || 0 === n.indices.length)
                        return null;
                    const e = new Vd(n.vertices,n.indices,8,256)
                      , [o,a] = [e.min.clone(), e.max.clone()];
                    return {
                        vertices: n.vertices,
                        indices: n.indices,
                        grid: e,
                        min: o,
                        max: a
                    }
                }
                function uv(n) {
                    if (!n.extras || !n.extras.ground)
                        return null;
                    const e = n.extras.ground;
                    if (!e || !Array.isArray(e) || 0 === e.length)
                        return null;
                    const o = e[0];
                    if (!o || !Array.isArray(o) || 0 === o.length)
                        return null;
                    const a = [];
                    for (const p of o) {
                        if (!Array.isArray(p) || 2 !== p.length)
                            continue;
                        const g = p[0]
                          , x = p[1];
                        "number" == typeof g && "number" == typeof x && a.push(new tt(g,x))
                    }
                    if (a.length < 3)
                        return null;
                    a.length > 1 && a[a.length - 1].equals(a[0]) && a.pop();
                    let u = 0;
                    for (let p = 0; p < a.length; p++) {
                        const g = a[p]
                          , x = a[(p + 1) % a.length]
                          , T = a[(p + 2) % a.length];
                        u += (g.x - x.x) * (T.y - x.y) - (T.x - x.x) * (g.y - x.y)
                    }
                    u > 0 && a.reverse();
                    const l = Fu(a.flatMap(p => [p.x, p.y]), []);
                    return 0 === l.length ? null : {
                        vertices: a,
                        indices: l
                    }
                }
                function pv(n, e) {
                    const o = []
                      , a = [];
                    let u = 0;
                    const l = [];
                    for (const p of n) {
                        u = o.length;
                        const g = p.vertexArray.float32
                          , x = p.indexArray.uint16;
                        for (let T = 0; T < p.vertexArray.length; T++)
                            l[0] = g[3 * T + 0],
                            l[1] = g[3 * T + 1],
                            l[2] = g[3 * T + 2],
                            B.vec3.transformMat4(l, l, e),
                            o.push(new tt(l[0],l[1]));
                        for (let T = 0; T < 3 * p.indexArray.length; T++)
                            a.push(x[T] + u)
                    }
                    if (a.length % 3 != 0)
                        return null;
                    for (let p = 0; p < a.length; p += 3) {
                        const g = o[a[p + 0]]
                          , x = o[a[p + 1]]
                          , T = o[a[p + 2]];
                        (g.x - x.x) * (T.y - x.y) - (T.x - x.x) * (g.y - x.y) > 0 && ([a[p + 1],a[p + 2]] = [a[p + 2], a[p + 1]])
                    }
                    return {
                        vertices: o,
                        indices: a
                    }
                }
                function l0(n) {
                    const o = function(x, T) {
                        const f = [];
                        for (const b of x.json.meshes) {
                            const P = [];
                            for (const v of b.primitives)
                                P.push(cv(v, x, T));
                            f.push(P)
                        }
                        return f
                    }(n, function(x, T) {
                        const f = []
                          , b = WebGL2RenderingContext;
                        if (x.json.textures)
                            for (const P of x.json.textures) {
                                const v = {
                                    magFilter: b.LINEAR,
                                    minFilter: b.NEAREST,
                                    wrapS: b.REPEAT,
                                    wrapT: b.REPEAT
                                };
                                void 0 !== P.sampler && Object.assign(v, x.json.samplers[P.sampler]),
                                f.push({
                                    image: T[P.source],
                                    sampler: v,
                                    uploaded: !1
                                })
                            }
                        return f
                    }(n, n.images))
                      , {scenes: a, scene: u, nodes: l} = n.json
                      , p = a ? a[u || 0].nodes : l
                      , g = [];
                    for (const x of p)
                        g.push(a0(l[x], n, o));
                    return function(x, T, f) {
                        const b = {}
                          , P = new Set;
                        for (let v = 0; v < x.length; v++) {
                            const w = f[T[v]];
                            if (!w.extras)
                                continue;
                            const C = w.extras["mapbox:footprint:version"]
                              , A = w.extras["mapbox:footprint:id"];
                            (C || A) && P.add(v),
                            "1.0.0" === C && A && (b[A] = v)
                        }
                        for (let v = 0; v < x.length; v++) {
                            if (P.has(v))
                                continue;
                            const w = x[v]
                              , C = f[T[v]];
                            if (!C.extras)
                                continue;
                            let A = null;
                            w.id in b && (A = pv(x[b[w.id]].meshes, w.matrix)),
                            A || (A = uv(C)),
                            A && (w.footprint = hv(A))
                        }
                        if (P.size > 0) {
                            const v = Array.from(P.values()).sort( (w, C) => w - C);
                            for (let w = v.length - 1; w >= 0; w--)
                                x.splice(v[w], 1)
                        }
                    }(g, p, n.json.nodes),
                    g
                }
                function dv(n) {
                    n.heightmap = new Float32Array(4096),
                    n.heightmap.fill(-1);
                    const e = n.vertexArray.float32
                      , o = n.aabb.min[0] - 1
                      , a = n.aabb.min[1] - 1
                      , u = 64 / (n.aabb.max[0] - o + 2)
                      , l = 64 / (n.aabb.max[1] - a + 2);
                    for (let p = 0; p < e.length; p += 3) {
                        const g = e[p + 2]
                          , x = (e[p + 0] - o) * u | 0
                          , T = (e[p + 1] - a) * l | 0;
                        g > n.heightmap[64 * T + x] && (n.heightmap[64 * T + x] = g)
                    }
                }
                function mv(n, e) {
                    const o = {};
                    o.indexArray = new Xn,
                    o.indexArray.reserve(4 * n.length),
                    o.vertexArray = new Ds,
                    o.vertexArray.reserve(10 * n.length),
                    o.colorArray = new ua,
                    o.vertexArray.reserve(10 * n.length);
                    let a = 0;
                    for (const p of n) {
                        const g = Math.min(10, Math.max(4, 1.3 * p.height)) * e
                          , x = [-p.normal[1], p.normal[0], 0]
                          , T = Math.min(.29, .1 * p.width / p.depth)
                          , f = p.width - 2 * p.depth * e * (T + .01)
                          , b = B.vec3.scaleAndAdd([], p.pos, x, f / 2)
                          , P = B.vec3.scaleAndAdd([], p.pos, x, -f / 2)
                          , v = [b[0], b[1], b[2] + p.height]
                          , w = [P[0], P[1], P[2] + p.height]
                          , C = B.vec3.scaleAndAdd([], p.normal, x, T);
                        B.vec3.scale(C, C, g);
                        const A = B.vec3.scaleAndAdd([], p.normal, x, -T);
                        B.vec3.scale(A, A, g),
                        B.vec3.add(C, b, C),
                        B.vec3.add(A, P, A),
                        b[2] += .1,
                        P[2] += .1,
                        o.vertexArray.emplaceBack(C[0], C[1], C[2]),
                        o.vertexArray.emplaceBack(A[0], A[1], A[2]),
                        o.vertexArray.emplaceBack(b[0], b[1], b[2]),
                        o.vertexArray.emplaceBack(P[0], P[1], P[2]),
                        o.vertexArray.emplaceBack(v[0], v[1], v[2]),
                        o.vertexArray.emplaceBack(w[0], w[1], w[2]),
                        o.vertexArray.emplaceBack(b[0], b[1], b[2]),
                        o.vertexArray.emplaceBack(P[0], P[1], P[2]),
                        o.vertexArray.emplaceBack(C[0], C[1], C[2]),
                        o.vertexArray.emplaceBack(A[0], A[1], A[2]);
                        const O = f / g / 2;
                        o.colorArray.emplaceBack(-O - T, -1, O, .8),
                        o.colorArray.emplaceBack(O + T, -1, O, .8),
                        o.colorArray.emplaceBack(-O, 0, O, 1.3),
                        o.colorArray.emplaceBack(O, 0, O, 1.3),
                        o.colorArray.emplaceBack(O + T, -.8, O, .7),
                        o.colorArray.emplaceBack(O + T, -.8, O, .7),
                        o.colorArray.emplaceBack(0, 0, O, 1.3),
                        o.colorArray.emplaceBack(0, 0, O, 1.3),
                        o.colorArray.emplaceBack(O + T, -1.2, O, .8),
                        o.colorArray.emplaceBack(O + T, -1.2, O, .8),
                        o.indexArray.emplaceBack(6 + a, 4 + a, 8 + a),
                        o.indexArray.emplaceBack(7 + a, 9 + a, 5 + a),
                        o.indexArray.emplaceBack(0 + a, 1 + a, 2 + a),
                        o.indexArray.emplaceBack(1 + a, 3 + a, 2 + a),
                        a += 10
                    }
                    const u = {
                        defined: !0,
                        emissiveFactor: [0, 0, 0]
                    }
                      , l = {};
                    return l.baseColorFactor = wi.white,
                    u.pbrMetallicRoughness = l,
                    o.material = u,
                    o.aabb = new No([1 / 0, 1 / 0, 1 / 0],[-1 / 0, -1 / 0, -1 / 0]),
                    o
                }
                class c0 {
                    constructor(e) {
                        this._stringToNumber = {},
                        this._numberToString = [];
                        for (let o = 0; o < e.length; o++) {
                            const a = e[o];
                            this._stringToNumber[a] = o,
                            this._numberToString[o] = a
                        }
                    }
                    encode(e) {
                        return this._stringToNumber[e]
                    }
                    decode(e) {
                        return this._numberToString[e]
                    }
                }
                const fv = ["id", "tile", "layer", "source", "sourceLayer", "state"];
                class eu {
                    constructor(e, o, a, u, l) {
                        this.type = "Feature",
                        this._vectorTileFeature = e,
                        this._z = o,
                        this._x = a,
                        this._y = u,
                        this.properties = e.properties,
                        this.id = l
                    }
                    clone() {
                        const e = new eu(this._vectorTileFeature,this._z,this._x,this._y,this.id);
                        return this.state && (e.state = {
                            ...this.state
                        }),
                        this.layer && (e.layer = {
                            ...this.layer
                        }),
                        this.source && (e.source = this.source),
                        this.sourceLayer && (e.sourceLayer = this.sourceLayer),
                        e
                    }
                    get geometry() {
                        return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry),
                        this._geometry
                    }
                    set geometry(e) {
                        this._geometry = e
                    }
                    toJSON() {
                        const e = {
                            type: "Feature",
                            state: void 0,
                            geometry: this.geometry,
                            properties: this.properties
                        };
                        for (const o of fv)
                            void 0 !== this[o] && (e[o] = this[o]);
                        return e
                    }
                }
                class h0 {
                    constructor(e, o) {
                        this.tileID = e,
                        this.x = e.canonical.x,
                        this.y = e.canonical.y,
                        this.z = e.canonical.z,
                        this.grid = new xe(uo,16,0),
                        this.featureIndexArray = new Ic,
                        this.promoteId = o,
                        this.is3DTile = !1,
                        this.serializedLayersCache = new Map
                    }
                    insert(e, o, a, u, l, p=0, g=0) {
                        const x = this.featureIndexArray.length;
                        this.featureIndexArray.emplaceBack(a, u, l, p);
                        const T = this.grid;
                        for (let f = 0; f < o.length; f++) {
                            const b = o[f]
                              , P = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                            for (let v = 0; v < b.length; v++) {
                                const w = b[v];
                                P[0] = Math.min(P[0], w.x),
                                P[1] = Math.min(P[1], w.y),
                                P[2] = Math.max(P[2], w.x),
                                P[3] = Math.max(P[3], w.y)
                            }
                            0 !== g && (P[0] -= g,
                            P[1] -= g,
                            P[2] += g,
                            P[3] += g),
                            P[0] < uo && P[1] < uo && P[2] >= 0 && P[3] >= 0 && T.insert(x, P[0], P[1], P[2], P[3])
                        }
                    }
                    loadVTLayers() {
                        if (!this.vtLayers) {
                            this.vtLayers = new Nh.VectorTile(new Hp(this.rawTileData)).layers,
                            this.sourceLayerCoder = new c0(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]),
                            this.vtFeatures = {};
                            for (const e in this.vtLayers)
                                this.vtFeatures[e] = []
                        }
                        return this.vtLayers
                    }
                    query(e, o) {
                        const {tilespaceGeometry: a, transform: u, tileTransform: l, pixelPosMatrix: p, availableImages: g} = o;
                        this.loadVTLayers(),
                        this.serializedLayersCache.clear();
                        const x = a.bufferedTilespaceBounds
                          , T = this.grid.query(x.min.x, x.min.y, x.max.x, x.max.y, (v, w, C, A) => qe(a.bufferedTilespaceGeometry, v, w, C, A));
                        T.sort(_v);
                        let f = null;
                        u.elevation && T.length > 0 && (f = Xh.create(u.elevation, this.tileID));
                        const b = {};
                        let P;
                        for (let v = 0; v < T.length; v++) {
                            const w = T[v];
                            if (w === P)
                                continue;
                            P = w;
                            const C = this.featureIndexArray.get(w);
                            let A = null;
                            this.is3DTile ? this.loadMatchingModelFeature(b, C, e, a, u) : this.loadMatchingFeature(b, C, e, g, (O, F, z, L=0) => (A || (A = R(O, this.tileID.canonical, l)),
                            F.queryIntersectsFeature(a, O, z, A, this.z, u, p, f, L)))
                        }
                        return b
                    }
                    loadMatchingFeature(e, o, a, u, l) {
                        const {featureIndex: p, bucketIndex: g, sourceLayerIndex: x, layoutVertexArrayOffset: T} = o
                          , f = this.bucketLayerIDs[g]
                          , b = a.layers
                          , P = Object.keys(b);
                        if (P.length && !function(O, F) {
                            for (let z = 0; z < O.length; z++)
                                if (F.indexOf(O[z]) >= 0)
                                    return !0;
                            return !1
                        }(P, f))
                            return;
                        const v = a.sourceCache
                          , w = this.sourceLayerCoder.decode(x)
                          , C = this.vtLayers[w].feature(p)
                          , A = this.getId(C, w);
                        for (let O = 0; O < f.length; O++) {
                            const F = f[O];
                            if (!b[F])
                                continue;
                            const {styleLayer: z, targets: L} = b[F];
                            let N = {};
                            void 0 !== A && (N = v.getFeatureState(z.sourceLayer, A));
                            const G = !l || l(C, z, N, T);
                            if (!G)
                                continue;
                            const X = new eu(C,this.z,this.x,this.y,A);
                            X.tile = this.tileID.canonical,
                            X.state = N;
                            let _e = this.serializedLayersCache.get(F);
                            _e || (_e = z.serialize(),
                            _e.id = F,
                            this.serializedLayersCache.set(F, _e)),
                            X.source = _e.source,
                            X.sourceLayer = _e["source-layer"],
                            X.layer = W({}, _e),
                            X.layer.paint = u0(_e.paint, z.paint, C, N, u),
                            X.layer.layout = u0(_e.layout, z.layout, C, N, u);
                            let me = !1;
                            for (const pe of L) {
                                this.updateFeatureProperties(X, pe);
                                const {filter: Ne} = pe;
                                if (Ne)
                                    if (C.properties = X.properties,
                                    Ne.needGeometry) {
                                        const Pe = D(C, !0);
                                        if (!Ne.filter(new Hi(this.tileID.overscaledZ), Pe, this.tileID.canonical))
                                            continue
                                    } else if (!Ne.filter(new Hi(this.tileID.overscaledZ), C))
                                        continue;
                                me = !0,
                                pe.targetId && this.addFeatureVariant(X, pe)
                            }
                            me && this.appendToResult(e, F, p, X, G)
                        }
                    }
                    loadMatchingModelFeature(e, o, a, u, l) {
                        const p = this.bucketLayerIDs[0][0]
                          , g = a.layers;
                        if (!g[p])
                            return;
                        const {styleLayer: x, targets: T} = g[p];
                        if ("model" !== x.type)
                            return;
                        const f = u.tile
                          , b = o.featureIndex
                          , P = f.getBucket(x);
                        if (!(P && P instanceof pd))
                            return;
                        const v = function(_e, me, pe, Ne) {
                            const Pe = _e.getNodesInfo()[me];
                            if (Pe.hiddenByReplacement || !Pe.node.meshes)
                                return;
                            let $e = Number.MAX_VALUE;
                            const We = Pe.node
                              , je = pe.tile
                              , Ke = Ne.calculatePosMatrix(je.tileID.toUnwrapped(), Ne.worldSize)
                              , rt = Pe.evaluatedScale;
                            let at = 0;
                            Ne.elevation && We.elevation && (at = We.elevation * Ne.elevation.exaggeration()),
                            B.mat4.translate(Ke, Ke, [(We.anchor ? We.anchor[0] : 0) * (rt[0] - 1), (We.anchor ? We.anchor[1] : 0) * (rt[1] - 1), at]),
                            B.mat4.scale(Ke, Ke, rt);
                            const ot = pe.queryGeometry
                              , Ct = ot.isPointQuery() ? ot.screenBounds : ot.screenGeometry
                              , Zt = function(lo) {
                                const io = B.mat4.multiply([], Ke, lo.matrix);
                                B.mat4.multiply(io, Ne.expandedFarZProjMatrix, io);
                                for (let fo = 0; fo < lo.meshes.length; ++fo) {
                                    const Bt = lo.meshes[fo];
                                    if (fo === lo.lightMeshIndex)
                                        continue;
                                    const Ro = ug(Ct, Ne, io, Bt.aabb);
                                    null != Ro && ($e = Math.min(Ro, $e))
                                }
                                if (lo.children)
                                    for (const fo of lo.children)
                                        Zt(fo)
                            };
                            if (Zt(We),
                            $e === Number.MAX_VALUE)
                                return;
                            const Ot = new Mi(0,0);
                            return Pg(je.tileID.canonical, Ot, Pe.node.anchor[0], Pe.node.anchor[1]),
                            {
                                intersectionZ: $e,
                                position: Ot,
                                feature: Pe.feature
                            }
                        }(P, b, u, l);
                        if (!v)
                            return;
                        const {z: w, x: C, y: A} = f.tileID.canonical
                          , {feature: O, intersectionZ: F, position: z} = v;
                        let L = {};
                        void 0 !== O.id && (L = a.sourceCache.getFeatureState(x.sourceLayer, O.id));
                        const N = new eu({},w,C,A,O.id);
                        N.tile = this.tileID.canonical,
                        N.state = L,
                        N.properties = O.properties,
                        N.geometry = {
                            type: "Point",
                            coordinates: [z.lng, z.lat]
                        };
                        let G = this.serializedLayersCache.get(p);
                        G || (G = x.serialize(),
                        G.id = p,
                        this.serializedLayersCache.set(p, G)),
                        N.source = G.source,
                        N.sourceLayer = G["source-layer"],
                        N.layer = W({}, G);
                        let X = !1;
                        for (const _e of T) {
                            this.updateFeatureProperties(N, _e);
                            const {filter: me} = _e;
                            if (me)
                                if (O.properties = N.properties,
                                me.needGeometry) {
                                    if (!me.filter(new Hi(this.tileID.overscaledZ), O, this.tileID.canonical))
                                        continue
                                } else if (!me.filter(new Hi(this.tileID.overscaledZ), O))
                                    continue;
                            X = !0,
                            _e.targetId && this.addFeatureVariant(N, _e)
                        }
                        X && this.appendToResult(e, p, b, N, F)
                    }
                    updateFeatureProperties(e, o, a) {
                        if (o.properties) {
                            const u = {};
                            for (const l in o.properties) {
                                const p = o.properties[l].evaluate({
                                    zoom: this.z
                                }, e._vectorTileFeature, e.state, e.tile, a);
                                null != p && (u[l] = p)
                            }
                            e.properties = u
                        }
                    }
                    addFeatureVariant(e, o, a) {
                        const u = {
                            target: o.target,
                            namespace: o.namespace
                        };
                        o.properties && (u.properties = e.properties),
                        e.variants = e.variants || {},
                        e.variants[o.targetId] = e.variants[o.targetId] || [],
                        e.variants[o.targetId].push(u)
                    }
                    appendToResult(e, o, a, u, l) {
                        let p = e[o];
                        void 0 === p && (p = e[o] = []),
                        p.push({
                            featureIndex: a,
                            feature: u,
                            intersectionZ: l
                        })
                    }
                    lookupSymbolFeatures(e, o, a, u, l) {
                        const p = {};
                        this.loadVTLayers();
                        for (const g of e)
                            this.loadMatchingFeature(p, {
                                bucketIndex: o,
                                sourceLayerIndex: a,
                                featureIndex: g,
                                layoutVertexArrayOffset: 0
                            }, u, l);
                        return p
                    }
                    loadFeature(e) {
                        const {featureIndex: o, sourceLayerIndex: a} = e;
                        this.loadVTLayers();
                        const u = this.sourceLayerCoder.decode(a)
                          , l = this.vtFeatures[u];
                        if (l[o])
                            return l[o];
                        const p = this.vtLayers[u].feature(o);
                        return l[o] = p,
                        p
                    }
                    hasLayer(e) {
                        for (const o of this.bucketLayerIDs)
                            for (const a of o)
                                if (e === a)
                                    return !0;
                        return !1
                    }
                    getId(e, o) {
                        let a = e.id;
                        if (this.promoteId) {
                            const u = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[o];
                            null != u && (a = e.properties[u]),
                            "boolean" == typeof a && (a = Number(a))
                        }
                        return a
                    }
                }
                function u0(n, e, o, a, u) {
                    return xo(n, (l, p) => {
                        const g = e instanceof wl ? e.get(p) : null;
                        return g && g.evaluate ? g.evaluate(o, a, u) : g
                    }
                    )
                }
                function _v(n, e) {
                    return e - n
                }
                Fe(h0, "FeatureIndex", {
                    omit: ["rawTileData", "sourceLayerCoder"]
                });
                const p0 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
                class jm {
                    static from(e) {
                        if (!(e instanceof ArrayBuffer))
                            throw new Error("Data must be an instance of ArrayBuffer.");
                        const [o,a] = new Uint8Array(e,0,2);
                        if (219 !== o)
                            throw new Error("Data does not appear to be in a KDBush format.");
                        const u = a >> 4;
                        if (1 !== u)
                            throw new Error("Got v".concat(u, " data when expected v1."));
                        const l = p0[15 & a];
                        if (!l)
                            throw new Error("Unrecognized array type.");
                        const [p] = new Uint16Array(e,2,1)
                          , [g] = new Uint32Array(e,4,1);
                        return new jm(g,p,l,e)
                    }
                    constructor(e, o=64, a=Float64Array, u) {
                        if (isNaN(e) || e < 0)
                            throw new Error("Unpexpected numItems value: ".concat(e, "."));
                        this.numItems = +e,
                        this.nodeSize = Math.min(Math.max(+o, 2), 65535),
                        this.ArrayType = a,
                        this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
                        const l = p0.indexOf(this.ArrayType)
                          , p = 2 * e * this.ArrayType.BYTES_PER_ELEMENT
                          , g = e * this.IndexArrayType.BYTES_PER_ELEMENT
                          , x = (8 - g % 8) % 8;
                        if (l < 0)
                            throw new Error("Unexpected typed array class: ".concat(a, "."));
                        u && u instanceof ArrayBuffer ? (this.data = u,
                        this.ids = new this.IndexArrayType(this.data,8,e),
                        this.coords = new this.ArrayType(this.data,8 + g + x,2 * e),
                        this._pos = 2 * e,
                        this._finished = !0) : (this.data = new ArrayBuffer(8 + p + g + x),
                        this.ids = new this.IndexArrayType(this.data,8,e),
                        this.coords = new this.ArrayType(this.data,8 + g + x,2 * e),
                        this._pos = 0,
                        this._finished = !1,
                        new Uint8Array(this.data,0,2).set([219, 16 + l]),
                        new Uint16Array(this.data,2,1)[0] = o,
                        new Uint32Array(this.data,4,1)[0] = e)
                    }
                    add(e, o) {
                        const a = this._pos >> 1;
                        return this.ids[a] = a,
                        this.coords[this._pos++] = e,
                        this.coords[this._pos++] = o,
                        a
                    }
                    finish() {
                        const e = this._pos >> 1;
                        if (e !== this.numItems)
                            throw new Error("Added ".concat(e, " items when expected ").concat(this.numItems, "."));
                        return Vm(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0),
                        this._finished = !0,
                        this
                    }
                    range(e, o, a, u) {
                        if (!this._finished)
                            throw new Error("Data not yet indexed - call index.finish().");
                        const {ids: l, coords: p, nodeSize: g} = this
                          , x = [0, l.length - 1, 0]
                          , T = [];
                        for (; x.length; ) {
                            const f = x.pop() || 0
                              , b = x.pop() || 0
                              , P = x.pop() || 0;
                            if (b - P <= g) {
                                for (let A = P; A <= b; A++) {
                                    const O = p[2 * A]
                                      , F = p[2 * A + 1];
                                    O >= e && O <= a && F >= o && F <= u && T.push(l[A])
                                }
                                continue
                            }
                            const v = P + b >> 1
                              , w = p[2 * v]
                              , C = p[2 * v + 1];
                            w >= e && w <= a && C >= o && C <= u && T.push(l[v]),
                            (0 === f ? e <= w : o <= C) && (x.push(P),
                            x.push(v - 1),
                            x.push(1 - f)),
                            (0 === f ? a >= w : u >= C) && (x.push(v + 1),
                            x.push(b),
                            x.push(1 - f))
                        }
                        return T
                    }
                    within(e, o, a) {
                        if (!this._finished)
                            throw new Error("Data not yet indexed - call index.finish().");
                        const {ids: u, coords: l, nodeSize: p} = this
                          , g = [0, u.length - 1, 0]
                          , x = []
                          , T = a * a;
                        for (; g.length; ) {
                            const f = g.pop() || 0
                              , b = g.pop() || 0
                              , P = g.pop() || 0;
                            if (b - P <= p) {
                                for (let A = P; A <= b; A++)
                                    m0(l[2 * A], l[2 * A + 1], e, o) <= T && x.push(u[A]);
                                continue
                            }
                            const v = P + b >> 1
                              , w = l[2 * v]
                              , C = l[2 * v + 1];
                            m0(w, C, e, o) <= T && x.push(u[v]),
                            (0 === f ? e - a <= w : o - a <= C) && (g.push(P),
                            g.push(v - 1),
                            g.push(1 - f)),
                            (0 === f ? e + a >= w : o + a >= C) && (g.push(v + 1),
                            g.push(b),
                            g.push(1 - f))
                        }
                        return x
                    }
                }
                function Vm(n, e, o, a, u, l) {
                    if (u - a <= o)
                        return;
                    const p = a + u >> 1;
                    d0(n, e, p, a, u, l),
                    Vm(n, e, o, a, p - 1, 1 - l),
                    Vm(n, e, o, p + 1, u, 1 - l)
                }
                function d0(n, e, o, a, u, l) {
                    for (; u > a; ) {
                        if (u - a > 600) {
                            const T = u - a + 1
                              , f = o - a + 1
                              , b = Math.log(T)
                              , P = .5 * Math.exp(2 * b / 3)
                              , v = .5 * Math.sqrt(b * P * (T - P) / T) * (f - T / 2 < 0 ? -1 : 1);
                            d0(n, e, o, Math.max(a, Math.floor(o - f * P / T + v)), Math.min(u, Math.floor(o + (T - f) * P / T + v)), l)
                        }
                        const p = e[2 * o + l];
                        let g = a
                          , x = u;
                        for (up(n, e, a, o),
                        e[2 * u + l] > p && up(n, e, a, u); g < x; ) {
                            for (up(n, e, g, x),
                            g++,
                            x--; e[2 * g + l] < p; )
                                g++;
                            for (; e[2 * x + l] > p; )
                                x--
                        }
                        e[2 * a + l] === p ? up(n, e, a, x) : (x++,
                        up(n, e, x, u)),
                        x <= o && (a = x + 1),
                        o <= x && (u = x - 1)
                    }
                }
                function up(n, e, o, a) {
                    Hm(n, o, a),
                    Hm(e, 2 * o, 2 * a),
                    Hm(e, 2 * o + 1, 2 * a + 1)
                }
                function Hm(n, e, o) {
                    const a = n[e];
                    n[e] = n[o],
                    n[o] = a
                }
                function m0(n, e, o, a) {
                    const u = n - o
                      , l = e - a;
                    return u * u + l * l
                }
                s.$ = gu,
                s.A = In,
                s.B = 2,
                s.C = S_,
                s.D = Yh,
                s.E = Hs,
                s.F = lm,
                s.G = class extends hd {
                }
                ,
                s.H = Ms,
                s.I = Lm,
                s.J = Hl,
                s.K = mp,
                s.L = mc,
                s.M = sa,
                s.N = mh,
                s.O = yl,
                s.P = tt,
                s.Q = vh,
                s.R = bs,
                s.S = yc,
                s.T = xm,
                s.U = La,
                s.V = hd,
                s.W = ps,
                s.X = rr,
                s.Y = Wn,
                s.Z = nr,
                s._ = Ka,
                s.a = function(n) {
                    return Ee.API_CDN_URL_REGEX.test(n)
                }
                ,
                s.a$ = eu,
                s.a0 = _l,
                s.a1 = fl,
                s.a2 = function(n) {
                    const e = n.value;
                    let o = [];
                    if (!e)
                        return o;
                    const a = Ms(e);
                    return "string" !== a ? (o = o.concat([new hd(n.key,e,'string expected, "'.concat(a, '" found'))]),
                    o) : (dg(e, !0) || (o = o.concat([new hd(n.key,e,'invalid url "'.concat(e, '"'))])),
                    o)
                }
                ,
                s.a3 = ft,
                s.a4 = xl,
                s.a5 = cn,
                s.a6 = eo,
                s.a7 = class {
                    constructor(n) {
                        this.specification = n
                    }
                    possiblyEvaluate(n, e) {
                        return ci(n.expression.evaluate(e))
                    }
                    interpolate(n, e, o) {
                        return {
                            x: jo(n.x, e.x, o),
                            y: jo(n.y, e.y, o),
                            z: jo(n.z, e.z, o),
                            azimuthal: jo(n.azimuthal, e.azimuthal, o),
                            polar: jo(n.polar, e.polar, o)
                        }
                    }
                }
                ,
                s.a8 = Hi,
                s.a9 = aa,
                s.aA = ks,
                s.aB = class {
                    constructor(n) {
                        this.entries = {},
                        this.scheduler = n
                    }
                    request(n, e, o, a) {
                        const u = this.entries[n] = this.entries[n] || {
                            callbacks: []
                        };
                        if (u.result) {
                            const [l,p] = u.result;
                            return this.scheduler ? this.scheduler.add( () => {
                                a(l, p)
                            }
                            , e) : a(l, p),
                            () => {}
                        }
                        return u.callbacks.push(a),
                        u.cancel || (u.cancel = o( (l, p) => {
                            u.result = [l, p];
                            for (const g of u.callbacks)
                                this.scheduler ? this.scheduler.add( () => {
                                    g(l, p)
                                }
                                , e) : g(l, p);
                            setTimeout( () => delete this.entries[n], 3e3)
                        }
                        )),
                        () => {
                            u.result || (u.callbacks = u.callbacks.filter(l => l !== a),
                            u.callbacks.length || (u.cancel(),
                            delete this.entries[n]))
                        }
                    }
                }
                ,
                s.aC = es,
                s.aD = function(n, e, o) {
                    const a = JSON.stringify(n.request);
                    return n.data && (this.deduped.entries[a] = {
                        result: [null, n.data]
                    }),
                    this.deduped.request(a, {
                        type: "parseTile",
                        isSymbolTile: n.isSymbolTile,
                        zoom: n.tileZoom
                    }, u => {
                        const l = fr(n.request, (p, g, x, T) => {
                            p ? u(p) : g && u(null, {
                                vectorTile: o ? void 0 : new Nh.VectorTile(new Hp(g)),
                                rawData: g,
                                cacheControl: x,
                                expires: T
                            })
                        }
                        );
                        return () => {
                            l.cancel(),
                            u()
                        }
                    }
                    , e)
                }
                ,
                s.aE = function(n) {
                    fn++,
                    fn > Go && (n.getActor().send("enforceCacheSizeLimit", qo),
                    fn = 0)
                }
                ,
                s.aF = function(n) {
                    return n <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(n) / Math.LN2))
                }
                ,
                s.aG = oo,
                s.aH = eg,
                s.aI = sg,
                s.aJ = Q_,
                s.aK = function(n, e) {
                    const o = document.createElement("video");
                    o.muted = !0,
                    o.onloadstart = function() {
                        e(null, o)
                    }
                    ;
                    for (let a = 0; a < n.length; a++) {
                        const u = document.createElement("source");
                        jc(n[a]) || (o.crossOrigin = "Anonymous"),
                        u.src = n[a],
                        o.appendChild(u)
                    }
                    return {
                        cancel: () => {}
                    }
                }
                ,
                s.aL = rd,
                s.aM = function(n) {
                    return fetch(n).then(e => e.arrayBuffer()).then(e => s0(e, 0, n))
                }
                ,
                s.aN = l0,
                s.aO = class {
                    constructor(n, e, o, a) {
                        this.id = n,
                        this.position = null != e ? new Mi(e[0],e[1]) : new Mi(0,0),
                        this.orientation = null != o ? o : [0, 0, 0],
                        this.nodes = a,
                        this.uploaded = !1,
                        this.aabb = new No([1 / 0, 1 / 0, 1 / 0],[-1 / 0, -1 / 0, -1 / 0]),
                        this.matrix = []
                    }
                    _applyTransformations(n, e) {
                        if (B.mat4.multiply(n.matrix, e, n.matrix),
                        n.meshes)
                            for (const o of n.meshes) {
                                const a = No.applyTransformFast(o.aabb, n.matrix);
                                this.aabb.encapsulate(a)
                            }
                        if (n.children)
                            for (const o of n.children)
                                this._applyTransformations(o, n.matrix)
                    }
                    computeBoundsAndApplyParent() {
                        const n = B.mat4.identity([]);
                        for (const e of this.nodes)
                            this._applyTransformations(e, n)
                    }
                    computeModelMatrix(n, e, o, a, u, l, p=!1) {
                        yg(this.matrix, this, n.transform, this.position, e, o, a, u, l, p)
                    }
                    upload(n) {
                        if (!this.uploaded) {
                            for (const e of this.nodes)
                                Tm(e, n);
                            for (const e of this.nodes)
                                ud(e);
                            this.uploaded = !0
                        }
                    }
                    destroy() {
                        for (const n of this.nodes)
                            Cm(n)
                    }
                }
                ,
                s.aP = Pt,
                s.aQ = Zu,
                s.aR = Mr,
                s.aS = Gn,
                s.aT = ha,
                s.aU = Xn,
                s.aV = Ve,
                s.aW = vp,
                s.aX = id,
                s.aY = function() {
                    Qn.isLoading() || Qn.isLoaded() || "deferred" !== Nr() || la()
                }
                ,
                s.aZ = fp,
                s.a_ = D,
                s.aa = h,
                s.ab = B,
                s.ac = we,
                s.ad = wl,
                s.ae = cr,
                s.af = jo,
                s.ag = uo,
                s.ah = Vl,
                s.ai = _o,
                s.aj = wi,
                s.ak = class {
                    constructor(n) {
                        this.specification = n
                    }
                    possiblyEvaluate(n, e) {
                        return function([o,a]) {
                            const u = ci([1, o, a]);
                            return {
                                x: u.x,
                                y: u.y,
                                z: u.z
                            }
                        }(n.expression.evaluate(e))
                    }
                    interpolate(n, e, o) {
                        return {
                            x: jo(n.x, e.x, o),
                            y: jo(n.y, e.y, o),
                            z: jo(n.z, e.z, o)
                        }
                    }
                }
                ,
                s.al = function(n, e, o=0, a=!0) {
                    const u = new tt(o,o)
                      , l = n.sub(u)
                      , p = e.add(u)
                      , g = [l, new tt(p.x,l.y), p, new tt(l.x,p.y)];
                    return a && g.push(l.clone()),
                    g
                }
                ,
                s.am = function(n, e) {
                    const o = [];
                    for (let a = 0; a < n.length; a++) {
                        const u = Oe(a - 1, -1, n.length - 1)
                          , l = Oe(a + 1, -1, n.length - 1)
                          , p = n[a]
                          , g = n[l]
                          , x = n[u].sub(p).unit()
                          , T = g.sub(p).unit()
                          , f = T.angleWithSep(x.x, x.y)
                          , b = x.add(T).unit().mult(-1 * e / Math.sin(f / 2));
                        o.push(p.add(b))
                    }
                    return o
                }
                ,
                s.an = U_,
                s.ao = qe,
                s.ap = function(n, e, o=0) {
                    return B.vec3.fromValues(((e.x - o) * n.scale - n.x) * uo, (e.y * n.scale - n.y) * uo, Rp(e.z, e.y))
                }
                ,
                s.aq = yi,
                s.ar = i_,
                s.as = function(n) {
                    let e = 1 / 0
                      , o = 1 / 0
                      , a = -1 / 0
                      , u = -1 / 0;
                    for (const l of n)
                        e = Math.min(e, l.x),
                        o = Math.min(o, l.y),
                        a = Math.max(a, l.x),
                        u = Math.max(u, l.y);
                    return {
                        min: new tt(e,o),
                        max: new tt(a,u)
                    }
                }
                ,
                s.at = gs,
                s.au = Ge,
                s.av = m,
                s.aw = ie,
                s.ax = sr,
                s.ay = function(n, e) {
                    const o = {};
                    for (let a = 0; a < e.length; a++) {
                        const u = e[a];
                        u in n && (o[u] = n[u])
                    }
                    return o
                }
                ,
                s.az = ga,
                s.b = function(n) {
                    return Ee.API_FONTS_REGEX.test(n)
                }
                ,
                s.b$ = ld,
                s.b0 = yn,
                s.b1 = Qd,
                s.b2 = jd,
                s.b3 = R,
                s.b4 = ts,
                s.b5 = Ih,
                s.b6 = Zo,
                s.b7 = mn,
                s.b8 = Fu,
                s.b9 = gm,
                s.bA = Ff,
                s.bB = um,
                s.bC = F_,
                s.bD = am,
                s.bE = jm,
                s.bF = Oe,
                s.bG = Ln,
                s.bH = ar,
                s.bI = function(n, e, o) {
                    n[4 * e + 0] = o[0],
                    n[4 * e + 1] = o[1],
                    n[4 * e + 2] = o[2],
                    n[4 * e + 3] = o[3]
                }
                ,
                s.bJ = Rc,
                s.bK = os,
                s.bL = Au,
                s.bM = hn,
                s.bN = Tl,
                s.bO = Mi,
                s.bP = V_,
                s.bQ = bo,
                s.bR = ii,
                s.bS = lg,
                s.bT = Dt,
                s.bU = pn,
                s.bV = function(n, e, o, a, u, l, p, g, x) {
                    if ("globe" === x.name)
                        return pn(n, e, new Dt(o,a,u), !1);
                    const T = Zu({
                        z: o,
                        x: a,
                        y: u
                    }, x);
                    return new No([(l + T.x / T.scale) * e, e * (T.y / T.scale), p],[(l + T.x2 / T.scale) * e, e * (T.y2 / T.scale), g])
                }
                ,
                s.bW = function(n, e, o) {
                    let a = 0;
                    for (let u = 0; u < 2; ++u)
                        n[u] > 0 && (a += (n[u] - 0) * (n[u] - 0)),
                        e[u] < 0 && (a += (0 - e[u]) * (0 - e[u]));
                    return a
                }
                ,
                s.bX = un,
                s.bY = 6,
                s.bZ = function(n) {
                    const e = B.mat4.identity(new Float64Array(16));
                    B.mat4.multiply(e, n.pixelMatrix, n.globeMatrix);
                    const o = [0, Gr, 0]
                      , a = [0, jr, 0];
                    return B.vec3.transformMat4(o, o, e),
                    B.vec3.transformMat4(a, a, e),
                    [o[0] > 0 && o[0] <= n.width && o[1] > 0 && o[1] <= n.height && !Cr(n, new Mi(n.center.lat,90)), a[0] > 0 && a[0] <= n.width && a[1] > 0 && a[1] <= n.height && !Cr(n, new Mi(n.center.lat,-90))]
                }
                ,
                s.b_ = function(n, e) {
                    const {scale: o} = n.tileTransform
                      , a = o * uo / (n.tileSize * Math.pow(2, e.zoom - n.tileID.overscaledZ + n.tileID.canonical.z));
                    return B.mat2.scale(new Float32Array(4), e.inverseAdjustmentMatrix, [a, a])
                }
                ,
                s.ba = function(n, e) {
                    const o = cr(e.zoom);
                    if (0 === o)
                        return bn(n);
                    const a = Yi(n)
                      , u = Qi(a)
                      , l = gs(a.getWest()) * e.worldSize
                      , p = gs(a.getEast()) * e.worldSize
                      , g = ks(a.getNorth()) * e.worldSize
                      , x = ks(a.getSouth()) * e.worldSize
                      , T = [l, g, 0]
                      , f = [p, g, 0]
                      , b = [l, x, 0]
                      , P = [p, x, 0]
                      , v = B.mat4.invert([], e.globeMatrix);
                    return B.vec3.transformMat4(T, T, v),
                    B.vec3.transformMat4(f, f, v),
                    B.vec3.transformMat4(b, b, v),
                    B.vec3.transformMat4(P, P, v),
                    u[0] = Un(u[0], b, o),
                    u[1] = Un(u[1], P, o),
                    u[2] = Un(u[2], f, o),
                    u[3] = Un(u[3], T, o),
                    No.fromPoints(u)
                }
                ,
                s.bb = Wi,
                s.bc = vi,
                s.bd = Un,
                s.be = Pc,
                s.bf = Uo,
                s.bg = Bm,
                s.bh = Hp,
                s.bi = fr,
                s.bj = function(n) {
                    const e = [];
                    for (const o in n)
                        e.push(n[o]);
                    return e
                }
                ,
                s.bk = function(n, e) {
                    const o = [];
                    for (const a in n)
                        a in e || o.push(a);
                    return o
                }
                ,
                s.bl = ee,
                s.bm = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"],
                s.bn = $t,
                s.bo = function(n, e) {
                    const {x: o, y: a} = n.point
                      , u = zs(o, a, n.worldSize / n._pixelsPerMercatorPixel, 0, 0);
                    return B.mat4.multiply(u, u, tr(bn(e)))
                }
                ,
                s.bp = $h,
                s.bq = rs,
                s.br = Vp,
                s.bs = function(n, e, o, a, u) {
                    const l = 5 * e + 2;
                    n.float32[l + 0] = o,
                    n.float32[l + 1] = a,
                    n.float32[l + 2] = u
                }
                ,
                s.bt = od,
                s.bu = E_,
                s.bv = Y,
                s.bw = 24,
                s.bx = If,
                s.by = pg,
                s.bz = Lf,
                s.c = oe,
                s.c$ = (n, e, o, a, u, l, p, g) => {
                    const x = n.transform
                      , T = x.pitch < 15 ? n_(.07, .7, ie((14 - x.zoom) / 5, 0, 1)) : .07
                      , f = "none" === o.paint.get("line-trim-color-use-theme").constantOr("default");
                    return {
                        u_matrix: s_(n, e, o, a),
                        u_texsize: e.imageAtlasTexture ? e.imageAtlasTexture.size : [0, 0],
                        u_pixels_to_tile_units: x.calculatePixelsToTileUnitsMatrix(e),
                        u_device_pixel_ratio: u,
                        u_width_scale: l,
                        u_floor_width_scale: p,
                        u_image: 0,
                        u_tile_units_to_pixels: r_(e, x),
                        u_units_to_pixels: [1 / x.pixelsToGLUnits[0], 1 / x.pixelsToGLUnits[1]],
                        u_alpha_discard_threshold: 0,
                        u_trim_offset: g,
                        u_trim_fade_range: o.paint.get("line-trim-fade-range"),
                        u_trim_color: o.paint.get("line-trim-color").toRenderColor(f ? null : o.lut).toArray01(),
                        u_emissive_strength: o.paint.get("line-emissive-strength"),
                        u_zbias_factor: T,
                        u_tile_to_meter: i(e.tileID.canonical, 0)
                    }
                }
                ,
                s.c0 = ag,
                s.c1 = function(n) {
                    const e = ag(n, !0);
                    return B.mat2.invert([], [e[0], e[1], e[4], e[5]])
                }
                ,
                s.c2 = li,
                s.c3 = function(n) {
                    const {x: e, y: o} = n.point
                      , {lng: a, lat: u} = n._center;
                    return zs(e, o, n.worldSize, a, u)
                }
                ,
                s.c4 = Lo,
                s.c5 = Po,
                s.c6 = 5,
                s.c7 = function(n) {
                    const e = Math.round((n + 45 + 360) % 360 / 90) % 4;
                    return ao[e]
                }
                ,
                s.c8 = 45,
                s.c9 = Lc,
                s.cA = class extends Ls {
                    constructor(n) {
                        super(n),
                        this.current = Od
                    }
                    set(n, e, o) {
                        if (this.fetchUniformLocation(n, e))
                            for (let a = 0; a < 9; a++)
                                if (o[a] !== this.current[a]) {
                                    this.current = o,
                                    this.gl.uniformMatrix3fv(this.location, !1, o);
                                    break
                                }
                    }
                }
                ,
                s.cB = bt,
                s.cC = function(n, e, o) {
                    const a = cr(o.zoom)
                      , u = n.style.map._antialias
                      , l = e.options.extStandardDerivativesForceOff || n.terrain && n.terrain.exaggeration() > 0;
                    return 0 === a && !u && !l
                }
                ,
                s.cD = function(n) {
                    const e = n.pixelsPerMeter
                      , o = e / ar(1, n.center.lat)
                      , a = B.mat4.identity(new Float64Array(16));
                    return B.mat4.translate(a, a, [n.point.x, n.point.y, 0]),
                    B.mat4.scale(a, a, [o, o, e]),
                    Float32Array.from(a)
                }
                ,
                s.cE = Yi,
                s.cF = function(n) {
                    const e = un - 5;
                    n = ie(n, -e, e) / e * 90;
                    const o = Math.pow(Math.abs(Math.sin(_o(n))), 3);
                    return Math.round(o * (kh.length - 1))
                }
                ,
                s.cG = function(n, e, o, a) {
                    const u = e.getNorth()
                      , l = e.getSouth()
                      , p = e.getWest()
                      , g = e.getEast()
                      , x = 1 << n.z
                      , T = g - p
                      , f = u - l
                      , b = T / 64
                      , P = -f / kh[o]
                      , v = [0, b, 0, P, 0, 0, u, p, 0];
                    if (n.z > 0) {
                        const w = 180 / a;
                        B.mat3.multiply(v, v, [w / T + 1, 0, 0, 0, w / f + 1, 0, -.5 * w / b, .5 * w / P, 1])
                    }
                    return v[2] = x,
                    v[5] = n.x,
                    v[8] = n.y,
                    v
                }
                ,
                s.cH = bn,
                s.cI = function(n, e, o) {
                    const a = B.mat4.identity(new Float64Array(16))
                      , u = (e / (1 << n) - .5) * Math.PI * 2;
                    return B.mat4.rotateY(a, o.globeMatrix, u),
                    Float32Array.from(a)
                }
                ,
                s.cJ = class {
                    isDataAvailableAtPoint(n) {
                        const e = this._source();
                        if (this.isUsingMockSource() || !e || n.y < 0 || n.y > 1)
                            return !1;
                        const o = e.getSource().maxzoom
                          , a = 1 << o
                          , u = Math.floor(n.x)
                          , l = Math.floor((n.x - u) * a)
                          , p = Math.floor(n.y * a)
                          , g = this.findDEMTileFor(new oo(o,u,o,l,p));
                        return !(!g || !g.dem)
                    }
                    getAtPointOrZero(n, e=0) {
                        return this.getAtPoint(n, e) || 0
                    }
                    getAtPoint(n, e, o=!0) {
                        if (this.isUsingMockSource())
                            return null;
                        null == e && (e = null);
                        const a = this._source();
                        if (!a || n.y < 0 || n.y > 1)
                            return e;
                        const u = a.getSource().maxzoom
                          , l = 1 << u
                          , p = Math.floor(n.x)
                          , g = n.x - p
                          , x = new oo(u,p,u,Math.floor(g * l),Math.floor(n.y * l))
                          , T = this.findDEMTileFor(x);
                        if (!T || !T.dem)
                            return e;
                        const f = T.dem
                          , b = 1 << T.tileID.canonical.z
                          , P = (g * b - T.tileID.canonical.x) * f.dim
                          , v = (n.y * b - T.tileID.canonical.y) * f.dim
                          , w = Math.floor(P)
                          , C = Math.floor(v);
                        return (o ? this.exaggeration() : 1) * jo(jo(f.get(w, C), f.get(w, C + 1), v - C), jo(f.get(w + 1, C), f.get(w + 1, C + 1), v - C), P - w)
                    }
                    getAtTileOffset(n, e, o) {
                        const a = 1 << n.canonical.z;
                        return this.getAtPointOrZero(new h(n.wrap + (n.canonical.x + e / uo) / a,(n.canonical.y + o / uo) / a))
                    }
                    getAtTileOffsetFunc(n, e, o, a) {
                        return u => {
                            const l = this.getAtTileOffset(n, u.x, u.y)
                              , p = a.upVector(n.canonical, u.x, u.y)
                              , g = a.upVectorScale(n.canonical, e, o).metersToTile;
                            return B.vec3.scale(p, p, l * g),
                            p
                        }
                    }
                    getForTilePoints(n, e, o, a) {
                        if (this.isUsingMockSource())
                            return !1;
                        const u = Xh.create(this, n, a);
                        return !!u && (e.forEach(l => {
                            l[2] = this.exaggeration() * u.getElevationAt(l[0], l[1], o)
                        }
                        ),
                        !0)
                    }
                    getMinMaxForTile(n) {
                        if (this.isUsingMockSource())
                            return null;
                        const e = this.findDEMTileFor(n);
                        if (!e || !e.dem)
                            return null;
                        const o = e.dem.tree
                          , a = e.tileID
                          , u = 1 << n.canonical.z - a.canonical.z;
                        let l = n.canonical.x / u - a.canonical.x
                          , p = n.canonical.y / u - a.canonical.y
                          , g = 0;
                        for (let x = 0; x < n.canonical.z - a.canonical.z && !o.leaves[g]; x++) {
                            l *= 2,
                            p *= 2;
                            const T = 2 * Math.floor(p) + Math.floor(l);
                            g = o.childOffsets[g] + T,
                            l %= 1,
                            p %= 1
                        }
                        return {
                            min: this.exaggeration() * o.minimums[g],
                            max: this.exaggeration() * o.maximums[g]
                        }
                    }
                    getMinElevationBelowMSL() {
                        throw new Error("Pure virtual method called.")
                    }
                    raycast(n, e, o) {
                        throw new Error("Pure virtual method called.")
                    }
                    pointCoordinate(n) {
                        throw new Error("Pure virtual method called.")
                    }
                    _source() {
                        throw new Error("Pure virtual method called.")
                    }
                    isUsingMockSource() {
                        throw new Error("Pure virtual method called.")
                    }
                    exaggeration() {
                        throw new Error("Pure virtual method called.")
                    }
                    findDEMTileFor(n) {
                        throw new Error("Pure virtual method called.")
                    }
                    get visibleDemTiles() {
                        throw new Error("Getter must be implemented in subclass.")
                    }
                    getMinMaxForVisibleTiles() {
                        const n = this.visibleDemTiles;
                        if (0 === n.length)
                            return null;
                        let e = !1
                          , o = Number.MAX_VALUE
                          , a = Number.MIN_VALUE;
                        for (const u of n) {
                            const l = this.getMinMaxForTile(u.tileID);
                            l && (o = Math.min(o, l.min),
                            a = Math.max(a, l.max),
                            e = !0)
                        }
                        return e ? {
                            min: o,
                            max: a
                        } : null
                    }
                }
                ,
                s.cK = lf,
                s.cL = Ei,
                s.cM = function(n, e) {
                    return [Math.pow(n[0], 2.2) * e, Math.pow(n[1], 2.2) * e, Math.pow(n[2], 2.2) * e]
                }
                ,
                s.cN = Tr,
                s.cO = se,
                s.cP = Z,
                s.cQ = 256,
                s.cR = function(n, e) {
                    const o = [0, 0, 0]
                      , a = Wi(bn(e.canonical));
                    return B.vec3.transformMat4(o, o, a),
                    B.vec3.transformMat4(o, o, n),
                    o
                }
                ,
                s.cS = n => ({
                    u_camera_to_center_distance: new hn(n),
                    u_extrude_scale: new Ru(n),
                    u_device_pixel_ratio: new hn(n),
                    u_matrix: new Rc(n),
                    u_inv_rot_matrix: new Rc(n),
                    u_merc_center: new os(n),
                    u_tile_id: new Au(n),
                    u_zoom_transition: new hn(n),
                    u_up_dir: new Au(n),
                    u_emissive_strength: new hn(n)
                }),
                s.cT = n => ({
                    u_matrix: new Rc(n),
                    u_pixels_to_tile_units: new Ru(n),
                    u_device_pixel_ratio: new hn(n),
                    u_width_scale: new hn(n),
                    u_floor_width_scale: new hn(n),
                    u_units_to_pixels: new os(n),
                    u_dash_image: new Tl(n),
                    u_gradient_image: new Tl(n),
                    u_image_height: new hn(n),
                    u_texsize: new os(n),
                    u_tile_units_to_pixels: new hn(n),
                    u_alpha_discard_threshold: new hn(n),
                    u_trim_offset: new os(n),
                    u_trim_fade_range: new os(n),
                    u_trim_color: new Oc(n),
                    u_emissive_strength: new hn(n),
                    u_zbias_factor: new hn(n),
                    u_tile_to_meter: new hn(n)
                }),
                s.cU = n => ({
                    u_matrix: new Rc(n),
                    u_texsize: new os(n),
                    u_pixels_to_tile_units: new Ru(n),
                    u_device_pixel_ratio: new hn(n),
                    u_width_scale: new hn(n),
                    u_floor_width_scale: new hn(n),
                    u_image: new Tl(n),
                    u_units_to_pixels: new os(n),
                    u_tile_units_to_pixels: new hn(n),
                    u_alpha_discard_threshold: new hn(n),
                    u_trim_offset: new os(n),
                    u_trim_fade_range: new os(n),
                    u_trim_color: new Oc(n),
                    u_emissive_strength: new hn(n),
                    u_zbias_factor: new hn(n),
                    u_tile_to_meter: new hn(n)
                }),
                s.cV = Ch,
                s.cW = x1,
                s.cX = b1,
                s.cY = zh,
                s.cZ = (n, e, o, a, u, l) => {
                    const p = n.transform
                      , g = "globe" === p.projection.name;
                    let x;
                    if ("map" === l.paint.get("circle-pitch-alignment"))
                        if (g) {
                            const f = Tr(p.zoom, e.canonical) * p._pixelsPerMercatorPixel;
                            x = Float32Array.from([f, 0, 0, f])
                        } else
                            x = p.calculatePixelsToTileUnitsMatrix(o);
                    else
                        x = new Float32Array([p.pixelsToGLUnits[0], 0, 0, p.pixelsToGLUnits[1]]);
                    const T = {
                        u_camera_to_center_distance: n.transform.getCameraToCenterDistance(p.projection),
                        u_matrix: n.translatePosMatrix(e.projMatrix, o, l.paint.get("circle-translate"), l.paint.get("circle-translate-anchor")),
                        u_device_pixel_ratio: Qt.devicePixelRatio,
                        u_extrude_scale: x,
                        u_inv_rot_matrix: Fc,
                        u_merc_center: [0, 0],
                        u_tile_id: [0, 0, 0],
                        u_zoom_transition: 0,
                        u_up_dir: [0, 0, 0],
                        u_emissive_strength: l.paint.get("circle-emissive-strength")
                    };
                    if (g) {
                        T.u_inv_rot_matrix = a,
                        T.u_merc_center = u,
                        T.u_tile_id = [e.canonical.x, e.canonical.y, 1 << e.canonical.z],
                        T.u_zoom_transition = cr(p.zoom);
                        const f = u[0] * uo
                          , b = u[1] * uo;
                        T.u_up_dir = p.projection.upVector(new Dt(0,0,0), f, b)
                    }
                    return T
                }
                ,
                s.c_ = a_,
                s.ca = Oc,
                s.cb = function(n, e, o) {
                    const a = Math.sqrt(n * n + e * e + o * o)
                      , u = a > 0 ? Math.acos(o / a) * Vt : 0;
                    let l = 0 !== n || 0 !== e ? Math.atan2(-e, -n) * Vt + 90 : 0;
                    return l < 0 && (l += 360),
                    [a, l, u]
                }
                ,
                s.cc = i,
                s.cd = No,
                s.ce = ci,
                s.cf = function(n) {
                    return [Math.pow(n[0], 1 / 2.2), Math.pow(n[1], 1 / 2.2), Math.pow(n[2], 1 / 2.2)]
                }
                ,
                s.cg = function(n, e) {
                    return n.readFields(py, {
                        icons: []
                    }, e)
                }
                ,
                s.ch = function(n) {
                    return n({
                        pluginStatus: hi,
                        pluginURL: pi
                    }),
                    sn.on("pluginStateChange", n),
                    n
                }
                ,
                s.ci = md,
                s.cj = jh,
                s.ck = cm,
                s.cl = js,
                s.cm = Ui,
                s.cn = Ho,
                s.co = Xa,
                s.cp = ro,
                s.cq = function(n) {
                    const e = n.indexOf("\x1f");
                    return e >= 0 ? n.slice(0, e) : n
                }
                ,
                s.cr = function(n) {
                    return n.indexOf("\x1f") >= 0
                }
                ,
                s.cs = function(n) {
                    const e = n.indexOf("\x1f");
                    return e >= 0 ? n.slice(e + 1) : ""
                }
                ,
                s.ct = function(n) {
                    const e = []
                      , o = n.id;
                    return void 0 === o && e.push({
                        message: "layers.".concat(o, ': missing required property "id"')
                    }),
                    void 0 === n.render && e.push({
                        message: "layers.".concat(o, ': missing required method "render"')
                    }),
                    n.renderingMode && "2d" !== n.renderingMode && "3d" !== n.renderingMode && e.push({
                        message: "layers.".concat(o, ': property "renderingMode" must be either "2d" or "3d"')
                    }),
                    e
                }
                ,
                s.cu = function(n, e, o, a) {
                    return "custom" === n.type ? new J1(n,e) : new cy[n.type](n,e,o,a)
                }
                ,
                s.cv = So,
                s.cw = class extends eu {
                    constructor(n, e) {
                        super(n._vectorTileFeature, n._z, n._x, n._y, n.id),
                        n.state && (this.state = {
                            ...n.state
                        }),
                        this.target = e.target,
                        this.namespace = e.namespace,
                        e.properties && (this.properties = e.properties),
                        this.target && ("featuresetId"in this.target && !this.target.importId || "layerId"in this.target) && (this.source = n.source,
                        this.sourceLayer = n.sourceLayer,
                        this.layer = n.layer)
                    }
                    toJSON() {
                        const n = super.toJSON();
                        return n.target = this.target,
                        n.namespace = this.namespace,
                        n
                    }
                }
                ,
                s.cx = sn,
                s.cy = ls,
                s.cz = Sp,
                s.d = function(n) {
                    return Ee.API_TILEJSON_REGEX.test(n)
                }
                ,
                s.d$ = xo,
                s.d0 = (n, e, o, a, u, l, p, g, x) => {
                    const T = n.transform
                      , f = T.calculatePixelsToTileUnitsMatrix(e)
                      , b = "none" === o.paint.get("line-trim-color-use-theme").constantOr("default")
                      , P = T.pitch < 15 ? n_(.07, .7, ie((14 - T.zoom) / 5, 0, 1)) : .07;
                    return {
                        u_matrix: s_(n, e, o, a),
                        u_pixels_to_tile_units: f,
                        u_device_pixel_ratio: l,
                        u_width_scale: p,
                        u_floor_width_scale: g,
                        u_units_to_pixels: [1 / T.pixelsToGLUnits[0], 1 / T.pixelsToGLUnits[1]],
                        u_dash_image: 0,
                        u_gradient_image: 1,
                        u_image_height: u,
                        u_texsize: l_(o) && e.lineAtlasTexture ? e.lineAtlasTexture.size : [0, 0],
                        u_tile_units_to_pixels: r_(e, n.transform),
                        u_alpha_discard_threshold: 0,
                        u_trim_offset: x,
                        u_trim_fade_range: o.paint.get("line-trim-fade-range"),
                        u_trim_color: o.paint.get("line-trim-color").toRenderColor(b ? null : o.lut).toArray01(),
                        u_emissive_strength: o.paint.get("line-emissive-strength"),
                        u_zbias_factor: P,
                        u_tile_to_meter: i(e.tileID.canonical, 0)
                    }
                }
                ,
                s.d1 = fe,
                s.d2 = Lu,
                s.d3 = Yf,
                s.d4 = Eo,
                s.d5 = Gp,
                s.d6 = Ol,
                s.d7 = 450,
                s.d8 = 7,
                s.d9 = q1,
                s.dA = Xt,
                s.dB = t,
                s.dC = _a,
                s.dD = function([n,e,o]) {
                    const a = Math.hypot(n, e, o)
                      , u = Math.atan2(n, o)
                      , l = .5 * Math.PI - Math.acos(-e / a);
                    return new Mi(Lo(u),Lo(l))
                }
                ,
                s.dE = wm,
                s.dF = function(n) {
                    const e = n.navigator ? n.navigator.userAgent : null;
                    return !!function(o) {
                        if (null == Dr) {
                            const a = o.navigator ? o.navigator.userAgent : null;
                            Dr = !!o.safari || !(!a || !(/\b(iPad|iPhone|iPod)\b/.test(a) || a.match("Safari") && !a.match("Chrome")))
                        }
                        return Dr
                    }(n) && e && (e.match("Version/15.4") || e.match("Version/15.5") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/))
                }
                ,
                s.dG = function(n, e) {
                    qo = n,
                    Go = e
                }
                ,
                s.dH = Cr,
                s.dI = ns,
                s.dJ = function(n) {
                    const e = [0, 0, 0]
                      , o = B.mat4.identity(new Float64Array(16));
                    return B.mat4.multiply(o, n.pixelMatrix, n.globeMatrix),
                    B.vec3.transformMat4(e, e, o),
                    new tt(e[0],e[1])
                }
                ,
                s.dK = function(n, e, o=!1) {
                    if (hi === Bn || hi === Oi || hi === Oo)
                        throw new Error("setRTLTextPlugin cannot be called multiple times.");
                    pi = Qt.resolveURL(n),
                    hi = Bn,
                    ui = e,
                    Li(),
                    o || la()
                }
                ,
                s.dL = Nr,
                s.dM = function() {
                    md().acquire(Sm)
                }
                ,
                s.dN = function() {
                    const n = ip;
                    n && (n.isPreloaded() && 1 === n.numActive() ? (n.release(Sm),
                    ip = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"))
                }
                ,
                s.dO = dd,
                s.dP = function(n) {
                    const e = Ai();
                    if (!e)
                        return;
                    const o = e.delete(Jo);
                    n && o.catch(n).then( () => n())
                }
                ,
                s.dQ = op,
                s.dR = Qg,
                s.dS = function(n) {
                    Um = Qt.resolveURL(n),
                    Qh || (Qh = new Yh(md(),new Hs)),
                    Qh.broadcast("setDracoUrl", Um)
                }
                ,
                s.dT = e0,
                s.dU = function(n) {
                    Jh = Qt.resolveURL(n),
                    Qh || (Qh = new Yh(md(),new Hs)),
                    Qh.broadcast("setMeshoptUrl", Jh)
                }
                ,
                s.dV = Fe,
                s.dW = Al,
                s.dX = 2,
                s.dY = c0,
                s.dZ = h0,
                s.d_ = e_,
                s.da = Si,
                s.db = Su,
                s.dc = 256,
                s.dd = tr,
                s.de = Ds,
                s.df = wr,
                s.dg = Sh,
                s.dh = function(n, e, o, a, u) {
                    return ie((n - e) / (o - e) * (u - a) + a, a, u)
                }
                ,
                s.di = uc,
                s.dj = c,
                s.dk = class {
                    constructor(n, e, o, a) {
                        this.context = n,
                        this.format = a,
                        this.size = o,
                        this.texture = n.gl.createTexture();
                        const [u,l,p] = this.size
                          , {gl: g} = n;
                        g.bindTexture(g.TEXTURE_3D, this.texture),
                        n.pixelStoreUnpackFlipY.set(!1),
                        n.pixelStoreUnpack.set(1),
                        n.pixelStoreUnpackPremultiplyAlpha.set(!1),
                        g.texImage3D(g.TEXTURE_3D, 0, this.format, u, l, p, 0, ym(this.format), vm(this.format), e.data)
                    }
                    bind(n, e) {
                        const {context: o} = this
                          , {gl: a} = o;
                        a.bindTexture(a.TEXTURE_3D, this.texture),
                        n !== this.minFilter && (a.texParameteri(a.TEXTURE_3D, a.TEXTURE_MAG_FILTER, n),
                        a.texParameteri(a.TEXTURE_3D, a.TEXTURE_MIN_FILTER, n),
                        this.minFilter = n),
                        e !== this.wrapS && (a.texParameteri(a.TEXTURE_3D, a.TEXTURE_WRAP_S, e),
                        a.texParameteri(a.TEXTURE_3D, a.TEXTURE_WRAP_T, e),
                        this.wrapS = e)
                    }
                    destroy() {
                        const {gl: n} = this.context;
                        n.deleteTexture(this.texture),
                        this.texture = null
                    }
                }
                ,
                s.dl = Pm,
                s.dm = [1, 1, 1],
                s.dn = Xh,
                s.dp = Wh,
                s.dq = da,
                s.dr = za,
                s.ds = Il,
                s.dt = Cu,
                s.du = Tu,
                s.dv = class {
                    constructor() {
                        this._updateTime = 0,
                        this._sourceIds = [],
                        this._activeRegions = [],
                        this._prevRegions = [],
                        this._globalClipBounds = {
                            min: new tt(1 / 0,1 / 0),
                            max: new tt(-1 / 0,-1 / 0)
                        }
                    }
                    clear() {
                        this._activeRegions.length > 0 && ++this._updateTime,
                        this._activeRegions = [],
                        this._prevRegions = []
                    }
                    get updateTime() {
                        return this._updateTime
                    }
                    getReplacementRegionsForTile(n, e=!1) {
                        const o = Of(new tt(0,0), new tt(uo,uo), n)
                          , a = [];
                        if (e && !Yd(o, this._globalClipBounds))
                            return a;
                        for (const u of this._activeRegions) {
                            if (u.hiddenByOverlap || !Yd(o, u))
                                continue;
                            const l = X0(u.min, u.max, n);
                            a.push({
                                min: l.min,
                                max: l.max,
                                sourceId: this._sourceIds[u.priority],
                                footprint: u.footprint,
                                footprintTileId: u.tileId,
                                order: u.order,
                                clipMask: u.clipMask,
                                clipScope: u.clipScope
                            })
                        }
                        return a
                    }
                    setSources(n) {
                        this._setSources(n.map(e => ({
                            getSourceId: () => e.cache.id,
                            getFootprints: () => {
                                const o = [];
                                for (const a of e.cache.getVisibleCoordinates()) {
                                    const u = e.cache.getTile(a).buckets[e.layer];
                                    u && u.updateFootprints(a.toUnwrapped(), o)
                                }
                                return o
                            }
                            ,
                            getOrder: () => e.order,
                            getClipMask: () => e.clipMask,
                            getClipScope: () => e.clipScope
                        })))
                    }
                    _addSource(n) {
                        const e = n.getFootprints();
                        if (0 === e.length)
                            return;
                        const o = n.getOrder()
                          , a = n.getClipMask()
                          , u = n.getClipScope();
                        for (const l of e) {
                            if (!l.footprint)
                                continue;
                            const p = Of(l.footprint.min, l.footprint.max, l.id);
                            this._activeRegions.push({
                                min: p.min,
                                max: p.max,
                                hiddenByOverlap: !1,
                                priority: this._sourceIds.length,
                                tileId: l.id,
                                footprint: l.footprint,
                                order: o,
                                clipMask: a,
                                clipScope: u
                            })
                        }
                        this._sourceIds.push(n.getSourceId())
                    }
                    _computeReplacement() {
                        this._activeRegions.sort( (e, o) => e.priority - o.priority || Np(e.min, o.min) || Np(e.max, o.max) || e.order - o.order || e.clipMask - o.clipMask || function(a, u) {
                            const l = (p, g) => p + g;
                            return a.length - u.length || a.reduce(l, "").localeCompare(u.reduce(l, ""))
                        }(e.clipScope, o.clipScope));
                        let n = this._activeRegions.length !== this._prevRegions.length;
                        if (!n) {
                            let e = 0;
                            for (; !n && e !== this._activeRegions.length; ) {
                                const o = this._activeRegions[e]
                                  , a = this._prevRegions[e];
                                n = o.priority !== a.priority || !Af(o, a) || o.order !== a.order || o.clipMask !== a.clipMask || !$t(o.clipScope, a.clipScope),
                                ++e
                            }
                        }
                        if (n) {
                            ++this._updateTime;
                            for (const o of this._activeRegions)
                                o.order !== Up && (this._globalClipBounds.min.x = Math.min(this._globalClipBounds.min.x, o.min.x),
                                this._globalClipBounds.min.y = Math.min(this._globalClipBounds.min.y, o.min.y),
                                this._globalClipBounds.max.x = Math.max(this._globalClipBounds.max.x, o.max.x),
                                this._globalClipBounds.max.y = Math.max(this._globalClipBounds.max.y, o.max.y));
                            const e = o => {
                                const a = this._activeRegions;
                                if (o >= a.length)
                                    return o;
                                const u = a[o].priority;
                                for (; o < a.length && a[o].priority === u; )
                                    ++o;
                                return o
                            }
                            ;
                            if (this._sourceIds.length > 1) {
                                let o = 0
                                  , a = e(o);
                                for (; o !== a; ) {
                                    let u = o;
                                    const l = o;
                                    for (; u !== a; ) {
                                        const p = this._activeRegions[u];
                                        p.hiddenByOverlap = !1;
                                        for (let g = 0; g < l; g++) {
                                            const x = this._activeRegions[g];
                                            if (!x.hiddenByOverlap && p.order === Up && Yd(p, x) && (p.hiddenByOverlap = Df(p.footprint, p.tileId, x.footprint, x.tileId),
                                            p.hiddenByOverlap))
                                                break
                                        }
                                        ++u
                                    }
                                    o = a,
                                    a = e(o)
                                }
                            }
                        }
                    }
                    _setSources(n) {
                        [this._prevRegions,this._activeRegions] = [this._activeRegions, []],
                        this._sourceIds = [];
                        for (let e = n.length - 1; e >= 0; e--)
                            this._addSource(n[e]);
                        this._computeReplacement()
                    }
                }
                ,
                s.dw = class {
                    constructor(n) {
                        this._createGrid(n),
                        this._createPoles(n)
                    }
                    destroy() {
                        this._poleIndexBuffer.destroy(),
                        this._gridBuffer.destroy(),
                        this._gridIndexBuffer.destroy(),
                        this._poleNorthVertexBuffer.destroy(),
                        this._poleSouthVertexBuffer.destroy();
                        for (const n of this._poleSegments)
                            n.destroy();
                        for (const n of this._gridSegments)
                            n.withSkirts.destroy(),
                            n.withoutSkirts.destroy()
                    }
                    _fillGridMeshWithLods(n, e) {
                        const o = new ts
                          , a = new Xn
                          , u = []
                          , l = n + 1 + 2
                          , p = e[0] + 1
                          , g = e[0] + 1 + (1 + e.length)
                          , x = (T, f, b) => {
                            let P = T === l - 1 ? T - 2 : 0 === T ? T : T - 1;
                            return P += b ? 24575 : 0,
                            [P, f]
                        }
                        ;
                        for (let T = 0; T < l; ++T)
                            o.emplaceBack(...x(T, 0, !0));
                        for (let T = 0; T < p; ++T)
                            for (let f = 0; f < l; ++f)
                                o.emplaceBack(...x(f, T, (0 === f || f === l - 1) && !0));
                        for (let T = 0; T < e.length; ++T) {
                            const f = e[T];
                            for (let b = 0; b < l; ++b)
                                o.emplaceBack(...x(b, f, !0))
                        }
                        for (let T = 0; T < e.length; ++T) {
                            const f = a.length
                              , b = e[T] + 1 + 2
                              , P = new Xn;
                            for (let C = 0; C < b - 1; C++) {
                                const A = C === b - 2
                                  , O = A ? l * (g - e.length + T - C) : l;
                                for (let F = 0; F < l - 1; F++) {
                                    const z = C * l + F;
                                    0 === C || A || 0 === F || F === l - 2 ? (P.emplaceBack(z + 1, z, z + O),
                                    P.emplaceBack(z + O, z + O + 1, z + 1)) : (a.emplaceBack(z + 1, z, z + O),
                                    a.emplaceBack(z + O, z + O + 1, z + 1))
                                }
                            }
                            const v = mn.simpleSegment(0, f, o.length, a.length - f);
                            for (let C = 0; C < P.uint16.length; C += 3)
                                a.emplaceBack(P.uint16[C], P.uint16[C + 1], P.uint16[C + 2]);
                            const w = mn.simpleSegment(0, f, o.length, a.length - f);
                            u.push({
                                withoutSkirts: v,
                                withSkirts: w
                            })
                        }
                        return {
                            vertices: o,
                            indices: a,
                            segments: u
                        }
                    }
                    _createGrid(n) {
                        const e = this._fillGridMeshWithLods(64, kh);
                        this._gridSegments = e.segments,
                        this._gridBuffer = n.createVertexBuffer(e.vertices, Zo.members),
                        this._gridIndexBuffer = n.createIndexBuffer(e.indices, !0)
                    }
                    _createPoles(n) {
                        const e = new Xn;
                        for (let p = 0; p <= 64; p++)
                            e.emplaceBack(0, p + 1, p + 2);
                        this._poleIndexBuffer = n.createIndexBuffer(e, !0);
                        const o = new wr
                          , a = new wr
                          , u = new wr
                          , l = new wr;
                        this._poleSegments = [];
                        for (let p = 0, g = 0; p < 5; p++) {
                            const x = 360 / (1 << p);
                            o.emplaceBack(0, -sr, 0, .5, 0),
                            a.emplaceBack(0, -sr, 0, .5, 1),
                            u.emplaceBack(0, -sr, 0, .5, .5),
                            l.emplaceBack(0, -sr, 0, .5, .5);
                            for (let T = 0; T <= 64; T++) {
                                let f = T / 64
                                  , b = 0;
                                const P = jo(0, x, f)
                                  , [v,w,C] = Sl(ys, $a, P, sr);
                                o.emplaceBack(v, w, C, f, b),
                                a.emplaceBack(v, w, C, f, 1 - b);
                                const A = _o(P);
                                f = .5 + .5 * Math.sin(A),
                                b = .5 + .5 * Math.cos(A),
                                u.emplaceBack(v, w, C, f, b),
                                l.emplaceBack(v, w, C, f, 1 - b)
                            }
                            this._poleSegments.push(mn.simpleSegment(g, 0, 66, 64)),
                            g += 66
                        }
                        this._poleNorthVertexBuffer = n.createVertexBuffer(o, ko, !1),
                        this._poleSouthVertexBuffer = n.createVertexBuffer(a, ko, !1),
                        this._texturedPoleNorthVertexBuffer = n.createVertexBuffer(u, ko, !1),
                        this._texturedPoleSouthVertexBuffer = n.createVertexBuffer(l, ko, !1)
                    }
                    getGridBuffers(n, e) {
                        return [this._gridBuffer, this._gridIndexBuffer, e ? this._gridSegments[n].withSkirts : this._gridSegments[n].withoutSkirts]
                    }
                    getPoleBuffers(n, e) {
                        return [e ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer, e ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[n]]
                    }
                }
                ,
                s.dx = Up,
                s.dy = Do,
                s.dz = function() {
                    return !!document.fullscreenElement || !!document.webkitFullscreenElement
                }
                ,
                s.e = Ee,
                s.e0 = ir,
                s.e1 = I_,
                s.e2 = function(n, e, o, a, u, l, p, g, x, T, f=1, b, P) {
                    n.createArrays(),
                    n.tilePixelRatio = uo / (512 * n.overscaling),
                    n.compareText = {},
                    n.iconsNeedLinear = !1;
                    const v = n.layers[0].layout
                      , w = n.layers[0]._unevaluatedLayout._values
                      , C = {};
                    C.scaleFactor = f,
                    C.textSizeScaleRange = v.get("text-size-scale-range"),
                    C.iconSizeScaleRange = v.get("icon-size-scale-range");
                    const [A,O] = C.textSizeScaleRange
                      , [F,z] = C.iconSizeScaleRange;
                    if (C.textScaleFactor = ie(C.scaleFactor, A, O),
                    C.iconScaleFactor = ie(C.scaleFactor, F, z),
                    "composite" === n.textSizeData.kind) {
                        const {minZoom: X, maxZoom: _e} = n.textSizeData;
                        C.compositeTextSizes = [w["text-size"].possiblyEvaluate(new Hi(X), g), w["text-size"].possiblyEvaluate(new Hi(_e), g)]
                    }
                    if ("composite" === n.iconSizeData.kind) {
                        const {minZoom: X, maxZoom: _e} = n.iconSizeData;
                        C.compositeIconSizes = [w["icon-size"].possiblyEvaluate(new Hi(X), g), w["icon-size"].possiblyEvaluate(new Hi(_e), g)]
                    }
                    C.layoutTextSize = w["text-size"].possiblyEvaluate(new Hi(x + 1), g),
                    C.layoutIconSize = w["icon-size"].possiblyEvaluate(new Hi(x + 1), g),
                    C.textMaxSize = w["text-size"].possiblyEvaluate(new Hi(18), g);
                    const L = "map" === v.get("text-rotation-alignment") && "point" !== v.get("symbol-placement")
                      , N = v.get("text-size");
                    let G = !1;
                    for (const X of n.features)
                        if (X.icon && X.icon.nameSecondary) {
                            G = !0;
                            break
                        }
                    for (const X of n.features) {
                        const _e = v.get("text-font").evaluate(X, {}, g).join(",")
                          , me = N.evaluate(X, {}, g) * C.textScaleFactor
                          , pe = C.layoutTextSize.evaluate(X, {}, g) * C.textScaleFactor
                          , Ne = (C.layoutIconSize.evaluate(X, {}, g),
                        {
                            horizontal: {},
                            vertical: void 0
                        })
                          , Pe = X.text;
                        let $e, We = [0, 0];
                        if (Pe) {
                            const at = Pe.toString()
                              , ot = 24 * v.get("text-letter-spacing").evaluate(X, {}, g)
                              , Ct = 24 * v.get("text-line-height").evaluate(X, {}, g)
                              , Zt = ti(at) ? ot : 0
                              , Ot = v.get("text-anchor").evaluate(X, {}, g)
                              , lo = v.get("text-variable-anchor");
                            if (!lo) {
                                const ho = v.get("text-radial-offset").evaluate(X, {}, g);
                                We = ho ? F_(Ot, [24 * ho, hm]) : v.get("text-offset").evaluate(X, {}, g).map(Ao => 24 * Ao)
                            }
                            let io = L ? "center" : v.get("text-justify").evaluate(X, {}, g);
                            const fo = "point" === v.get("symbol-placement")
                              , Bt = fo ? 24 * v.get("text-max-width").evaluate(X, {}, g) : 1 / 0
                              , Ro = ho => {
                                n.allowVerticalPlacement && Wo(at) && (Ne.vertical = sm(Pe, e, o, u, _e, Bt, Ct, Ot, ho, Zt, We, rs.vertical, !0, pe, me))
                            }
                            ;
                            if (!L && lo) {
                                const ho = "auto" === io ? lo.map($o => um($o)) : [io];
                                let Ao = !1;
                                for (let $o = 0; $o < ho.length; $o++) {
                                    const Qo = ho[$o];
                                    if (!Ne.horizontal[Qo])
                                        if (Ao)
                                            Ne.horizontal[Qo] = Ne.horizontal[0];
                                        else {
                                            const ni = sm(Pe, e, o, u, _e, Bt, Ct, "center", Qo, Zt, We, rs.horizontal, !1, pe, me);
                                            ni && (Ne.horizontal[Qo] = ni,
                                            Ao = 1 === ni.positionedLines.length)
                                        }
                                }
                                Ro("left")
                            } else {
                                if ("auto" === io && (io = um(Ot)),
                                fo || v.get("text-writing-mode").indexOf("horizontal") >= 0 || !Wo(at)) {
                                    const ho = sm(Pe, e, o, u, _e, Bt, Ct, Ot, io, Zt, We, rs.horizontal, !1, pe, me);
                                    ho && (Ne.horizontal[io] = ho)
                                }
                                Ro(fo ? "left" : io)
                            }
                        }
                        let je = !1
                          , Ke = !1;
                        if (X.icon && X.icon.namePrimary) {
                            const at = jp(n.iconSizeData, w["icon-size"], g, n.zoom, X) * C.iconScaleFactor * b
                              , ot = X.icon.getPrimary().scaleSelf(at).serialize()
                              , Ct = a[ot];
                            Ct && ($e = O1(u[ot], X.icon.nameSecondary ? u[X.icon.getSecondary().scaleSelf(at).serialize()] : void 0, v.get("icon-offset").evaluate(X, {}, g), v.get("icon-anchor").evaluate(X, {}, g)),
                            je = Ct.sdf,
                            Ke = Ct.usvg,
                            void 0 === n.sdfIcons ? n.sdfIcons = Ct.sdf : n.sdfIcons !== Ct.sdf && vo("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"),
                            (Ct.pixelRatio !== n.pixelRatio || 0 !== v.get("icon-rotate").constantOr(1)) && (n.iconsNeedLinear = !0))
                        }
                        const rt = z_(Ne.horizontal) || Ne.vertical;
                        n.iconsInText || (n.iconsInText = !!rt && rt.iconsInText),
                        (rt || $e) && B1(n, X, Ne, $e, a, C, pe, 0, We, je, Ke, p, g, T, P, G)
                    }
                    l && n.generateCollisionDebugBuffers(x, n.collisionBoxArray, C.textScaleFactor)
                }
                ,
                s.e3 = Nh,
                s.e4 = xd,
                s.e5 = St,
                s.e6 = Tf,
                s.e7 = m_,
                s.e8 = so,
                s.e9 = function(n) {
                    let e = 0;
                    if (new Uint32Array(n,0,1)[0] !== o0) {
                        const o = new Uint32Array(n,0,7)
                          , [,,a,u,l,p] = o;
                        e = o.byteLength + u + l + p + l,
                        (a !== n.byteLength || e >= n.byteLength) && vo("Invalid b3dm header information.")
                    }
                    return s0(n, e)
                }
                ,
                s.ea = function(n, e) {
                    const o = l0(n);
                    for (const a of o) {
                        for (const u of a.meshes)
                            dv(u);
                        a.lights && (a.lightMeshIndex = a.meshes.length,
                        a.meshes.push(mv(a.lights, e)))
                    }
                    return o
                }
                ,
                s.eb = pd,
                s.ec = Mg,
                s.ed = Qn,
                s.ee = function(n) {
                    Fi(),
                    null != Ci && Ci.then(e => {
                        e.keys().then(o => {
                            for (let a = 0; a < o.length - n; a++)
                                e.delete(o[a])
                        }
                        )
                    }
                    )
                }
                ,
                s.f = function(n) {
                    return 0 === n.indexOf("mapbox:")
                }
                ,
                s.g = function(n, e) {
                    return ls(W(n, {
                        method: "GET"
                    }), e)
                }
                ,
                s.h = He,
                s.i = function(n) {
                    return Ee.API_STYLE_REGEX.test(n) && !oe(n)
                }
                ,
                s.j = function(n) {
                    return decodeURIComponent(atob(n).split("").map(e => "%" + ("00" + e.charCodeAt(0).toString(16)).slice(-2)).join(""))
                }
                ,
                s.k = function(n) {
                    return btoa(encodeURIComponent(n).replace(/%([0-9A-F]{2})/g, (e, o) => String.fromCharCode(+("0x" + o))))
                }
                ,
                s.l = W,
                s.m = Yn,
                s.n = function(n, e) {
                    return ls(W(n, {
                        type: "json"
                    }), e)
                }
                ,
                s.o = Wa,
                s.p = function(n, e) {
                    return ls(W(n, {
                        method: "POST"
                    }), e)
                }
                ,
                s.q = Qt,
                s.r = hr,
                s.s = function(n) {
                    try {
                        const e = self[n];
                        return e.setItem("_mapbox_test_", 1),
                        e.removeItem("_mapbox_test_"),
                        !0
                    } catch {
                        return !1
                    }
                }
                ,
                s.t = Rt,
                s.u = function() {
                    return function n(e) {
                        return e ? (e ^ Math.random() * (16 >> e / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, n)
                    }()
                }
                ,
                s.v = function(n) {
                    return !!n && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(n)
                }
                ,
                s.w = vo,
                s.x = function() {
                    return Im || (Im = new dd),
                    Im
                }
                ,
                s.y = hs,
                s.z = Wr
            }),
            r(0, function(s) {
                function so(xt) {
                    const Z = xt ? xt.url.toString() : void 0;
                    return Z ? performance.getEntriesByName(Z) : []
                }
                function Wt(xt) {
                    if ("number" == typeof xt || "boolean" == typeof xt || "string" == typeof xt || null == xt)
                        return JSON.stringify(xt);
                    if (Array.isArray(xt)) {
                        let se = "[";
                        for (const Ee of xt)
                            se += "".concat(Wt(Ee), ",");
                        return "".concat(se, "]")
                    }
                    let Z = "{";
                    for (const se of Object.keys(xt).sort())
                        Z += "".concat(se, ":").concat(Wt(xt[se]), ",");
                    return "".concat(Z, "}")
                }
                function _t(xt) {
                    let Z = "";
                    for (const se of s.bm)
                        Z += "/".concat(Wt(xt[se]));
                    return Z
                }
                class Ae {
                    constructor(Z) {
                        this.keyCache = {},
                        this._layers = {},
                        this._layerConfigs = {},
                        Z && this.replace(Z)
                    }
                    replace(Z, se) {
                        this._layerConfigs = {},
                        this._layers = {},
                        this.update(Z, [], se)
                    }
                    update(Z, se, Ee) {
                        this._options = Ee;
                        for (const oe of Z)
                            this._layerConfigs[oe.id] = oe,
                            (this._layers[oe.id] = s.cu(oe, this.scope, null, this._options)).compileFilter(Ee),
                            this.keyCache[oe.id] && delete this.keyCache[oe.id];
                        for (const oe of se)
                            delete this.keyCache[oe],
                            delete this._layerConfigs[oe],
                            delete this._layers[oe];
                        this.familiesBySource = {};
                        const He = function(oe, ue) {
                            const J = {};
                            for (let le = 0; le < oe.length; le++) {
                                const Se = oe[le];
                                let st = ue && ue[Se.id];
                                !st && (st = _t(Se),
                                "line" === Se.type && Se.paint) && function Qt(wo) {
                                    return "string" == typeof wo && "line-progress" === wo || (Array.isArray(wo) ? wo.some(Qt) : !(!wo || "object" != typeof wo) && Object.values(wo).some(Qt))
                                }(Se.paint["line-width"]) && (st += "/".concat(Wt(Se.paint["line-width"]))),
                                ue && (ue[Se.id] = st);
                                let Rt = J[st];
                                Rt || (Rt = J[st] = []),
                                Rt.push(Se)
                            }
                            const q = [];
                            for (const le in J)
                                q.push(J[le]);
                            return q
                        }(s.bj(this._layerConfigs), this.keyCache);
                        for (const oe of He) {
                            const ue = oe.map(Rt => this._layers[Rt.id])
                              , J = ue[0];
                            if ("none" === J.visibility)
                                continue;
                            const q = J.source || "";
                            let le = this.familiesBySource[q];
                            le || (le = this.familiesBySource[q] = {});
                            const Se = J.sourceLayer || "_geojsonTileLayer";
                            let st = le[Se];
                            st || (st = le[Se] = []),
                            st.push(ue)
                        }
                    }
                }
                const Me = 1 * s.dX;
                class ct {
                    constructor(Z) {
                        const se = {}
                          , Ee = [];
                        for (const J in Z) {
                            const q = Z[J]
                              , le = se[J] = {};
                            for (const Se in q.glyphs) {
                                const st = q.glyphs[+Se];
                                if (!st || 0 === st.bitmap.width || 0 === st.bitmap.height)
                                    continue;
                                const Rt = st.metrics.localGlyph ? Me : 1
                                  , Qt = {
                                    x: 0,
                                    y: 0,
                                    w: st.bitmap.width + 2 * Rt,
                                    h: st.bitmap.height + 2 * Rt
                                };
                                Ee.push(Qt),
                                le[Se] = Qt
                            }
                        }
                        const {w: He, h: oe} = s.C(Ee)
                          , ue = new s.dW({
                            width: He || 1,
                            height: oe || 1
                        });
                        for (const J in Z) {
                            const q = Z[J];
                            for (const le in q.glyphs) {
                                const Se = q.glyphs[+le];
                                if (!Se || 0 === Se.bitmap.width || 0 === Se.bitmap.height)
                                    continue;
                                const st = se[J][le]
                                  , Rt = Se.metrics.localGlyph ? Me : 1;
                                s.dW.copy(Se.bitmap, ue, {
                                    x: 0,
                                    y: 0
                                }, {
                                    x: st.x + Rt,
                                    y: st.y + Rt
                                }, Se.bitmap)
                            }
                        }
                        this.image = ue,
                        this.positions = se
                    }
                }
                s.dV(ct, "GlyphAtlas");
                class Tt {
                    constructor(Z) {
                        this.tileID = new s.aG(Z.tileID.overscaledZ,Z.tileID.wrap,Z.tileID.canonical.z,Z.tileID.canonical.x,Z.tileID.canonical.y),
                        this.tileZoom = Z.tileZoom,
                        this.uid = Z.uid,
                        this.zoom = Z.zoom,
                        this.lut = Z.lut,
                        this.canonical = Z.tileID.canonical,
                        this.pixelRatio = Z.pixelRatio,
                        this.tileSize = Z.tileSize,
                        this.source = Z.source,
                        this.scope = Z.scope,
                        this.overscaling = this.tileID.overscaleFactor(),
                        this.showCollisionBoxes = Z.showCollisionBoxes,
                        this.collectResourceTiming = !!Z.request && Z.request.collectResourceTiming,
                        this.promoteId = Z.promoteId,
                        this.isSymbolTile = Z.isSymbolTile,
                        this.tileTransform = s.aQ(Z.tileID.canonical, Z.projection),
                        this.projection = Z.projection,
                        this.worldview = Z.worldview,
                        this.localizableLayerIds = Z.localizableLayerIds,
                        this.brightness = Z.brightness,
                        this.extraShadowCaster = !!Z.extraShadowCaster,
                        this.tessellationStep = Z.tessellationStep,
                        this.scaleFactor = Z.scaleFactor
                    }
                    parse(Z, se, Ee, He, oe) {
                        this.status = "parsing",
                        this.data = Z,
                        this.collisionBoxArray = new s.aW;
                        const ue = new s.dY(Object.keys(Z.layers).sort())
                          , J = new s.dZ(this.tileID,this.promoteId);
                        J.bucketLayerIDs = [];
                        const q = {}
                          , le = new s.d_(256,256)
                          , Se = {
                            featureIndex: J,
                            iconDependencies: {},
                            patternDependencies: {},
                            glyphDependencies: {},
                            lineAtlas: le,
                            availableImages: Ee,
                            brightness: this.brightness,
                            scaleFactor: this.scaleFactor
                        }
                          , st = se.familiesBySource[this.source];
                        for (const Go in st) {
                            const Ii = Z.layers[Go];
                            if (!Ii)
                                continue;
                            let Ci = !1
                              , fi = !1
                              , Ai = !1;
                            for (const Yn of st[Go])
                                "symbol" === Yn[0].type ? Ci = !0 : fi = !0,
                                Yn[0].is3D() && "model" !== Yn[0].type && (Ai = !0);
                            if (this.extraShadowCaster && !Ai || !0 === this.isSymbolTile && !Ci || !1 === this.isSymbolTile && !fi)
                                continue;
                            1 === Ii.version && s.w('Vector tile source "'.concat(this.source, '" layer "').concat(Go, '" does not use vector tile spec v2 and therefore may have some rendering errors.'));
                            const Fi = ue.encode(Go)
                              , fn = [];
                            for (let Yn = 0, Sn = 0; Yn < Ii.length; Yn++) {
                                const Fn = Ii.feature(Yn)
                                  , xs = J.getId(Fn, Go);
                                if (this.localizableLayerIds && this.localizableLayerIds.has(Go)) {
                                    const Hr = Fn.properties ? Fn.properties.worldview : null;
                                    if (this.worldview && "string" == typeof Hr)
                                        if ("all" === Hr)
                                            Fn.properties.$localized = !0;
                                        else {
                                            if (!Hr.split(",").includes(this.worldview))
                                                continue;
                                            Fn.properties.$localized = !0,
                                            Fn.properties.worldview = this.worldview
                                        }
                                }
                                fn.push({
                                    feature: Fn,
                                    id: xs,
                                    index: Sn,
                                    sourceLayerIndex: Fi
                                }),
                                Sn++
                            }
                            for (const Yn of st[Go]) {
                                const Sn = Yn[0];
                                (!this.extraShadowCaster || Sn.is3D() && "model" !== Sn.type) && (void 0 !== this.isSymbolTile && "symbol" === Sn.type !== this.isSymbolTile || Sn.minzoom && this.zoom < Math.floor(Sn.minzoom) || Sn.maxzoom && this.zoom >= Sn.maxzoom || "none" !== Sn.visibility && (Qe(Yn, this.zoom, Se.brightness, Ee),
                                (q[Sn.id] = Sn.createBucket({
                                    index: J.bucketLayerIDs.length,
                                    layers: Yn,
                                    zoom: this.zoom,
                                    lut: this.lut,
                                    canonical: this.canonical,
                                    pixelRatio: this.pixelRatio,
                                    overscaling: this.overscaling,
                                    collisionBoxArray: this.collisionBoxArray,
                                    sourceLayerIndex: Fi,
                                    sourceID: this.source,
                                    projection: this.projection.spec,
                                    tessellationStep: this.tessellationStep
                                })).populate(fn, Se, this.tileID.canonical, this.tileTransform),
                                J.bucketLayerIDs.push(Yn.map(Fn => s.aC(Fn.id, Fn.scope)))))
                            }
                        }
                        let Rt, Qt, wo, Ho;
                        le.trim();
                        const Jo = {
                            type: "maybePrepare",
                            isSymbolTile: this.isSymbolTile,
                            zoom: this.zoom
                        }
                          , qo = () => {
                            if (Rt)
                                return this.status = "done",
                                oe(Rt);
                            if (this.extraShadowCaster)
                                this.status = "done",
                                oe(null, {
                                    buckets: s.bj(q).filter(Go => !Go.isEmpty()),
                                    featureIndex: J,
                                    collisionBoxArray: null,
                                    glyphAtlasImage: null,
                                    lineAtlas: null,
                                    imageAtlas: null,
                                    brightness: Se.brightness,
                                    glyphMap: null,
                                    iconMap: null,
                                    glyphPositions: null
                                });
                            else if (Qt && wo && Ho) {
                                const Go = new ct(Qt)
                                  , Ii = new s.e1(wo,Ho,this.lut);
                                for (const Ci in q) {
                                    const fi = q[Ci];
                                    fi instanceof s.aX ? (Qe(fi.layers, this.zoom, Se.brightness, Ee),
                                    s.e2(fi, Qt, Go.positions, wo, Ii.iconPositions, this.showCollisionBoxes, Ee, this.tileID.canonical, this.tileZoom, this.projection, this.scaleFactor, this.pixelRatio, this.brightness)) : fi.hasPattern && (fi instanceof s.b1 || fi instanceof s.b2 || fi instanceof s.d5) && (Qe(fi.layers, this.zoom, Se.brightness, Ee),
                                    fi.addFeatures(Se, this.tileID.canonical, Ii.patternPositions, Ee, this.tileTransform, this.brightness))
                                }
                                this.status = "done",
                                oe(null, {
                                    buckets: s.bj(q).filter(Ci => !Ci.isEmpty()),
                                    featureIndex: J,
                                    collisionBoxArray: this.collisionBoxArray,
                                    glyphAtlasImage: Go.image,
                                    lineAtlas: le,
                                    imageAtlas: Ii,
                                    brightness: Se.brightness
                                })
                            }
                        }
                        ;
                        if (!this.extraShadowCaster) {
                            const Go = s.d$(Se.glyphDependencies, fi => Object.keys(fi).map(Number));
                            Object.keys(Go).length ? He.send("getGlyphs", {
                                uid: this.uid,
                                stacks: Go,
                                scope: this.scope
                            }, (fi, Ai) => {
                                Rt || (Rt = fi,
                                Qt = Ai,
                                qo())
                            }
                            , void 0, !1, Jo) : Qt = {};
                            const Ii = Object.keys(Se.iconDependencies);
                            Ii.length ? He.send("getImages", {
                                icons: Ii,
                                source: this.source,
                                scope: this.scope,
                                tileID: this.tileID,
                                type: "icons"
                            }, (fi, Ai) => {
                                if (Rt)
                                    return;
                                Rt = fi;
                                const Fi = {};
                                Object.values(Ai).some(fn => fn.usvg) ? this.rasterize(He, Fi, Ai, Se.iconDependencies, () => {
                                    wo = Fi,
                                    qo()
                                }
                                ) : (this.fillImageMap(Fi, Se.iconDependencies, Ai),
                                wo = Fi,
                                qo())
                            }
                            , void 0, !1, Jo) : wo = {};
                            const Ci = Object.keys(Se.patternDependencies);
                            Ci.length ? He.send("getImages", {
                                icons: Ci,
                                source: this.source,
                                scope: this.scope,
                                tileID: this.tileID,
                                type: "patterns"
                            }, (fi, Ai) => {
                                if (!Rt) {
                                    Rt = fi;
                                    const Fi = {};
                                    Object.values(Ai).some(fn => fn.usvg) ? this.rasterize(He, Fi, Ai, Se.patternDependencies, () => {
                                        Ho = Fi,
                                        qo()
                                    }
                                    ) : (this.fillImageMap(Fi, Se.patternDependencies, Ai),
                                    Ho = Fi,
                                    qo())
                                }
                            }
                            , void 0, !1, Jo) : Ho = {}
                        }
                        qo()
                    }
                    fillImageMap(Z, se, Ee) {
                        for (const He in Ee) {
                            const oe = se[He] || [];
                            for (const ue of oe)
                                Ee[ue.id].usvg || (Z[ue.serialize()] = Ee[ue.id])
                        }
                    }
                    getImageTaskQueue(Z, se, Ee) {
                        const He = {};
                        for (const oe in se) {
                            const ue = Ee[oe] || [];
                            for (const J of ue) {
                                const q = J.serialize();
                                se[J.id].usvg ? He[q] || (He[q] = J) : Z[q] = se[J.id]
                            }
                        }
                        return He
                    }
                    rasterize(Z, se, Ee, He, oe) {
                        const ue = this.getImageTaskQueue(se, Ee, He);
                        this.rasterizeTask = Z.send("rasterizeImages", {
                            scope: this.scope,
                            imageTasks: ue
                        }, (J, q) => {
                            if (!J)
                                for (const le in q) {
                                    const {id: Se} = s.e0.deserializeFromString(le);
                                    se[le] = Object.assign({}, Ee[Se], {
                                        data: q[le]
                                    })
                                }
                            oe()
                        }
                        )
                    }
                    cancelRasterize() {
                        this.rasterizeTask && this.rasterizeTask.cancel()
                    }
                }
                function Qe(xt, Z, se, Ee) {
                    const He = new s.a8(Z,{
                        brightness: se
                    });
                    for (const oe of xt)
                        oe.recalculate(He, Ee)
                }
                class jt extends s.E {
                    constructor(Z, se, Ee, He, oe, ue) {
                        super(),
                        this.actor = Z,
                        this.layerIndex = se,
                        this.availableImages = Ee,
                        this.loadVectorData = oe || s.aD,
                        this.loading = {},
                        this.loaded = {},
                        this.deduped = new s.aB(Z.scheduler),
                        this.isSpriteLoaded = He,
                        this.scheduler = Z.scheduler,
                        this.brightness = ue
                    }
                    loadTile(Z, se) {
                        const Ee = Z.uid
                          , He = Z && Z.request
                          , oe = He && He.collectResourceTiming
                          , ue = this.loading[Ee] = new Tt(Z);
                        ue.abort = this.loadVectorData(Z, (J, q) => {
                            const le = !this.loading[Ee];
                            if (delete this.loading[Ee],
                            ue.cancelRasterize(),
                            le || J || !q)
                                return ue.status = "done",
                                le || (this.loaded[Ee] = ue),
                                se(J);
                            const Se = q.rawData
                              , st = {};
                            q.expires && (st.expires = q.expires),
                            q.cacheControl && (st.cacheControl = q.cacheControl),
                            ue.vectorTile = q.vectorTile || new s.e3.VectorTile(new s.bh(Se));
                            const Rt = () => {
                                ue.parse(ue.vectorTile, this.layerIndex, this.availableImages, this.actor, (Qt, wo) => {
                                    if (Qt || !wo)
                                        return se(Qt);
                                    const Ho = {};
                                    if (oe) {
                                        const Jo = so(He);
                                        Jo.length > 0 && (Ho.resourceTiming = JSON.parse(JSON.stringify(Jo)))
                                    }
                                    se(null, s.l({
                                        rawTileData: Se.slice(0)
                                    }, wo, st, Ho))
                                }
                                )
                            }
                            ;
                            this.isSpriteLoaded ? Rt() : this.once("isSpriteLoaded", () => {
                                this.scheduler ? this.scheduler.add(Rt, {
                                    type: "parseTile",
                                    isSymbolTile: Z.isSymbolTile,
                                    zoom: Z.tileZoom
                                }) : Rt()
                            }
                            ),
                            this.loaded = this.loaded || {},
                            this.loaded[Ee] = ue
                        }
                        )
                    }
                    reloadTile(Z, se) {
                        const Ee = this.loaded
                          , He = Z.uid;
                        if (Ee && Ee[He]) {
                            const oe = Ee[He];
                            oe.scaleFactor = Z.scaleFactor,
                            oe.showCollisionBoxes = Z.showCollisionBoxes,
                            oe.projection = Z.projection,
                            oe.brightness = Z.brightness,
                            oe.tileTransform = s.aQ(Z.tileID.canonical, Z.projection),
                            oe.extraShadowCaster = Z.extraShadowCaster,
                            oe.lut = Z.lut;
                            const ue = (J, q) => {
                                const le = oe.reloadCallback;
                                le && (delete oe.reloadCallback,
                                oe.parse(oe.vectorTile, this.layerIndex, this.availableImages, this.actor, le)),
                                se(J, q)
                            }
                            ;
                            "parsing" === oe.status ? oe.reloadCallback = ue : "done" === oe.status && (oe.vectorTile ? oe.parse(oe.vectorTile, this.layerIndex, this.availableImages, this.actor, ue) : ue())
                        } else
                            se(null, void 0)
                    }
                    abortTile(Z, se) {
                        const Ee = Z.uid
                          , He = this.loading[Ee];
                        He && (He.abort && He.abort(),
                        delete this.loading[Ee]),
                        se()
                    }
                    removeTile(Z, se) {
                        const Ee = this.loaded
                          , He = Z.uid;
                        Ee && Ee[He] && delete Ee[He],
                        se()
                    }
                }
                class Xe {
                    loadTile(Z, se) {
                        const {uid: Ee, encoding: He, rawImageData: oe, padding: ue} = Z
                          , J = ImageBitmap && oe instanceof ImageBitmap ? this.getImageData(oe, ue) : oe;
                        se(null, new s.e4(Ee,J,He,ue < 1))
                    }
                    getImageData(Z, se) {
                        this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(Z.width,Z.height),
                        this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", {
                            willReadFrequently: !0
                        })),
                        this.offscreenCanvas.width = Z.width,
                        this.offscreenCanvas.height = Z.height,
                        this.offscreenCanvasContext.drawImage(Z, 0, 0, Z.width, Z.height);
                        const Ee = this.offscreenCanvasContext.getImageData(-se, -se, Z.width + 2 * se, Z.height + 2 * se);
                        return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height),
                        Ee
                    }
                }
                s.bg.setPbf(s.bh);
                class Ce {
                    decodeRasterArray({task: Z, buffer: se}, Ee) {
                        s.bg.performDecoding(se, Z).then(He => {
                            Ee(null, He)
                        }
                        , He => {
                            Ee(He)
                        }
                        )
                    }
                }
                const it = s.e3.VectorTileFeature.prototype.toGeoJSON;
                class et {
                    constructor(Z) {
                        this._feature = Z,
                        this.extent = s.ag,
                        this.type = Z.type,
                        this.properties = Z.tags,
                        "id"in Z && !isNaN(Z.id) && (this.id = parseInt(Z.id, 10))
                    }
                    loadGeometry() {
                        if (1 === this._feature.type) {
                            const Z = [];
                            for (const se of this._feature.geometry)
                                Z.push([new s.P(se[0],se[1])]);
                            return Z
                        }
                        {
                            const Z = [];
                            for (const se of this._feature.geometry) {
                                const Ee = [];
                                for (const He of se)
                                    Ee.push(new s.P(He[0],He[1]));
                                Z.push(Ee)
                            }
                            return Z
                        }
                    }
                    toGeoJSON(Z, se, Ee) {
                        return it.call(this, Z, se, Ee)
                    }
                }
                class re {
                    constructor(Z) {
                        this.layers = {
                            _geojsonTileLayer: this
                        },
                        this.name = "_geojsonTileLayer",
                        this.extent = s.ag,
                        this.length = Z.length,
                        this._features = Z
                    }
                    feature(Z) {
                        return new et(this._features[Z])
                    }
                }
                const pt = 64 / 4096;
                class ze {
                    constructor() {
                        this.features = new Map
                    }
                    clear() {
                        this.features.clear()
                    }
                    load(Z=[], se) {
                        for (const Ee of Z) {
                            const He = Ee.id;
                            if (null == He)
                                continue;
                            let oe = this.features.get(He);
                            oe && this.updateCache(oe, se),
                            Ee.geometry ? (oe = ge(Ee),
                            this.updateCache(oe, se),
                            this.features.set(He, oe)) : this.features.delete(He),
                            this.updateCache(oe, se)
                        }
                    }
                    updateCache(Z, se) {
                        for (const {canonical: Ee, uid: He} of Object.values(se)) {
                            const {z: oe, x: ue, y: J} = Ee;
                            ye(Z, Math.pow(2, oe), ue, J) && delete se[He]
                        }
                    }
                    getTile(Z, se, Ee) {
                        const He = Math.pow(2, Z)
                          , oe = [];
                        for (const ue of this.features.values())
                            ye(ue, He, se, Ee) && oe.push(yt(ue, He, se, Ee));
                        return {
                            features: oe
                        }
                    }
                    getFeatures() {
                        return [...this.features.values()]
                    }
                }
                function ye({minX: xt, minY: Z, maxX: se, maxY: Ee}, He, oe, ue) {
                    return xt < (oe + 1 + pt) / He && Z < (ue + 1 + pt) / He && se > (oe - pt) / He && Ee > (ue - pt) / He
                }
                function ge(xt) {
                    const {id: Z, geometry: se, properties: Ee} = xt;
                    if (!se)
                        return;
                    if ("GeometryCollection" === se.type)
                        throw new Error("GeometryCollection not supported in dynamic mode.");
                    const {type: He, coordinates: oe} = se
                      , ue = {
                        id: Z,
                        type: 1,
                        geometry: [],
                        tags: Ee,
                        minX: 1 / 0,
                        minY: 1 / 0,
                        maxX: -1 / 0,
                        maxY: -1 / 0
                    }
                      , J = ue.geometry;
                    if ("Point" === He)
                        Ie(oe, J, ue);
                    else if ("MultiPoint" === He)
                        for (const q of oe)
                            Ie(q, J, ue);
                    else if ("LineString" === He)
                        ue.type = 2,
                        gt(oe, J, ue);
                    else if ("MultiLineString" === He)
                        ue.type = 2,
                        Ye(oe, J, ue);
                    else if ("Polygon" === He)
                        ue.type = 3,
                        Ye(oe, J, ue, !0);
                    else {
                        if ("MultiPolygon" !== He)
                            throw new Error("Input data is not a valid GeoJSON object.");
                        ue.type = 3;
                        for (const q of oe)
                            Ye(q, J, ue, !0)
                    }
                    return ue
                }
                function Ie([xt,Z], se, Ee) {
                    const He = s.at(xt);
                    let oe = s.aA(Z);
                    oe = oe < 0 ? 0 : oe > 1 ? 1 : oe,
                    se.push(He, oe),
                    Ee.minX = Math.min(Ee.minX, He),
                    Ee.minY = Math.min(Ee.minY, oe),
                    Ee.maxX = Math.max(Ee.maxX, He),
                    Ee.maxY = Math.max(Ee.maxY, oe)
                }
                function gt(xt, Z, se, Ee=!1, He=!1) {
                    const oe = [];
                    for (const ue of xt)
                        Ie(ue, oe, se);
                    Z.push(oe),
                    Ee && function(ue, J) {
                        let q = 0;
                        for (let le = 0, Se = ue.length, st = Se - 2; le < Se; st = le,
                        le += 2)
                            q += (ue[le] - ue[st]) * (ue[le + 1] + ue[st + 1]);
                        if (q > 0 === J)
                            for (let le = 0, Se = ue.length; le < Se / 2; le += 2) {
                                const st = ue[le]
                                  , Rt = ue[le + 1];
                                ue[le] = ue[Se - 2 - le],
                                ue[le + 1] = ue[Se - 1 - le],
                                ue[Se - 2 - le] = st,
                                ue[Se - 1 - le] = Rt
                            }
                    }(oe, He)
                }
                function Ye(xt, Z, se, Ee=!1) {
                    for (let He = 0; He < xt.length; He++)
                        gt(xt[He], Z, se, Ee, 0 === He)
                }
                function yt(xt, Z, se, Ee) {
                    const {id: He, type: oe, geometry: ue, tags: J} = xt
                      , q = [];
                    if (1 === oe)
                        !function(le, Se, st, Rt, Qt) {
                            for (let wo = 0; wo < le.length; wo += 2) {
                                const Ho = Math.round(s.ag * (le[wo + 0] * Se - st))
                                  , Jo = Math.round(s.ag * (le[wo + 1] * Se - Rt));
                                Qt.push([Ho, Jo])
                            }
                        }(ue, Z, se, Ee, q);
                    else
                        for (const le of ue)
                            ht(le, Z, se, Ee, q);
                    return {
                        id: He,
                        type: oe,
                        geometry: q,
                        tags: J
                    }
                }
                function ht(xt, Z, se, Ee, He) {
                    const oe = -128
                      , ue = s.ag + 128;
                    let J;
                    for (let q = 0; q < xt.length - 2; q += 2) {
                        let le = Math.round(s.ag * (xt[q + 0] * Z - se))
                          , Se = Math.round(s.ag * (xt[q + 1] * Z - Ee))
                          , st = Math.round(s.ag * (xt[q + 2] * Z - se))
                          , Rt = Math.round(s.ag * (xt[q + 3] * Z - Ee));
                        const Qt = st - le
                          , wo = Rt - Se;
                        le < oe && st < oe || (le < oe ? (Se += Math.round(wo * ((oe - le) / Qt)),
                        le = oe) : st < oe && (Rt = Se + Math.round(wo * ((oe - le) / Qt)),
                        st = oe),
                        Se < oe && Rt < oe || (Se < oe ? (le += Math.round(Qt * ((oe - Se) / wo)),
                        Se = oe) : Rt < oe && (st = le + Math.round(Qt * ((oe - Se) / wo)),
                        Rt = oe),
                        le >= ue && st >= ue || (le >= ue ? (Se += Math.round(wo * ((ue - le) / Qt)),
                        le = ue) : st >= ue && (Rt = Se + Math.round(wo * ((ue - le) / Qt)),
                        st = ue),
                        Se >= ue && Rt >= ue || (Se >= ue ? (le += Math.round(Qt * ((ue - Se) / wo)),
                        Se = ue) : Rt >= ue && (st = le + Math.round(Qt * ((ue - Se) / wo)),
                        Rt = ue),
                        J && le === J[J.length - 1][0] && Se === J[J.length - 1][1] || (J = [[le, Se]],
                        He.push(J)),
                        J.push([st, Rt])))))
                    }
                }
                var mo, no, Co, Lt = {
                    exports: {}
                }, Ft = function() {
                    if (Co)
                        return Lt.exports;
                    Co = 1;
                    var xt = s.e7()
                      , Z = function() {
                        if (no)
                            return mo;
                        no = 1;
                        var Se = s.e5()
                          , st = s.e6().VectorTileFeature;
                        function Rt(wo, Ho) {
                            this.options = Ho || {},
                            this.features = wo,
                            this.length = wo.length
                        }
                        function Qt(wo, Ho) {
                            this.id = "number" == typeof wo.id ? wo.id : void 0,
                            this.type = wo.type,
                            this.rawGeometry = 1 === wo.type ? [wo.geometry] : wo.geometry,
                            this.properties = wo.tags,
                            this.extent = Ho || 4096
                        }
                        return mo = Rt,
                        Rt.prototype.feature = function(wo) {
                            return new Qt(this.features[wo],this.options.extent)
                        }
                        ,
                        Qt.prototype.loadGeometry = function() {
                            var wo = this.rawGeometry;
                            this.geometry = [];
                            for (var Ho = 0; Ho < wo.length; Ho++) {
                                for (var Jo = wo[Ho], qo = [], Go = 0; Go < Jo.length; Go++)
                                    qo.push(new Se(Jo[Go][0],Jo[Go][1]));
                                this.geometry.push(qo)
                            }
                            return this.geometry
                        }
                        ,
                        Qt.prototype.bbox = function() {
                            this.geometry || this.loadGeometry();
                            for (var wo = this.geometry, Ho = 1 / 0, Jo = -1 / 0, qo = 1 / 0, Go = -1 / 0, Ii = 0; Ii < wo.length; Ii++)
                                for (var Ci = wo[Ii], fi = 0; fi < Ci.length; fi++) {
                                    var Ai = Ci[fi];
                                    Ho = Math.min(Ho, Ai.x),
                                    Jo = Math.max(Jo, Ai.x),
                                    qo = Math.min(qo, Ai.y),
                                    Go = Math.max(Go, Ai.y)
                                }
                            return [Ho, qo, Jo, Go]
                        }
                        ,
                        Qt.prototype.toGeoJSON = st.prototype.toGeoJSON,
                        mo
                    }();
                    function se(Se) {
                        var st = new xt;
                        return function(Rt, Qt) {
                            for (var wo in Rt.layers)
                                Qt.writeMessage(3, Ee, Rt.layers[wo])
                        }(Se, st),
                        st.finish()
                    }
                    function Ee(Se, st) {
                        var Rt;
                        st.writeVarintField(15, Se.version || 1),
                        st.writeStringField(1, Se.name || ""),
                        st.writeVarintField(5, Se.extent || 4096);
                        var Qt = {
                            keys: [],
                            values: [],
                            keycache: {},
                            valuecache: {}
                        };
                        for (Rt = 0; Rt < Se.length; Rt++)
                            Qt.feature = Se.feature(Rt),
                            st.writeMessage(2, He, Qt);
                        var wo = Qt.keys;
                        for (Rt = 0; Rt < wo.length; Rt++)
                            st.writeStringField(3, wo[Rt]);
                        var Ho = Qt.values;
                        for (Rt = 0; Rt < Ho.length; Rt++)
                            st.writeMessage(4, le, Ho[Rt])
                    }
                    function He(Se, st) {
                        var Rt = Se.feature;
                        void 0 !== Rt.id && st.writeVarintField(1, Rt.id),
                        st.writeMessage(2, oe, Se),
                        st.writeVarintField(3, Rt.type),
                        st.writeMessage(4, q, Rt)
                    }
                    function oe(Se, st) {
                        var Rt = Se.feature
                          , Qt = Se.keys
                          , wo = Se.values
                          , Ho = Se.keycache
                          , Jo = Se.valuecache;
                        for (var qo in Rt.properties) {
                            var Go = Rt.properties[qo]
                              , Ii = Ho[qo];
                            if (null !== Go) {
                                void 0 === Ii && (Qt.push(qo),
                                Ho[qo] = Ii = Qt.length - 1),
                                st.writeVarint(Ii);
                                var Ci = typeof Go;
                                "string" !== Ci && "boolean" !== Ci && "number" !== Ci && (Go = JSON.stringify(Go));
                                var fi = Ci + ":" + Go
                                  , Ai = Jo[fi];
                                void 0 === Ai && (wo.push(Go),
                                Jo[fi] = Ai = wo.length - 1),
                                st.writeVarint(Ai)
                            }
                        }
                    }
                    function ue(Se, st) {
                        return (st << 3) + (7 & Se)
                    }
                    function J(Se) {
                        return Se << 1 ^ Se >> 31
                    }
                    function q(Se, st) {
                        for (var Rt = Se.loadGeometry(), Qt = Se.type, wo = 0, Ho = 0, Jo = Rt.length, qo = 0; qo < Jo; qo++) {
                            var Go = Rt[qo]
                              , Ii = 1;
                            1 === Qt && (Ii = Go.length),
                            st.writeVarint(ue(1, Ii));
                            for (var Ci = 3 === Qt ? Go.length - 1 : Go.length, fi = 0; fi < Ci; fi++) {
                                1 === fi && 1 !== Qt && st.writeVarint(ue(2, Ci - 1));
                                var Ai = Go[fi].x - wo
                                  , Fi = Go[fi].y - Ho;
                                st.writeVarint(J(Ai)),
                                st.writeVarint(J(Fi)),
                                wo += Ai,
                                Ho += Fi
                            }
                            3 === Qt && st.writeVarint(ue(7, 1))
                        }
                    }
                    function le(Se, st) {
                        var Rt = typeof Se;
                        "string" === Rt ? st.writeStringField(1, Se) : "boolean" === Rt ? st.writeBooleanField(7, Se) : "number" === Rt && (Se % 1 != 0 ? st.writeDoubleField(3, Se) : Se < 0 ? st.writeSVarintField(6, Se) : st.writeVarintField(5, Se))
                    }
                    return Lt.exports = se,
                    Lt.exports.fromVectorTileJs = se,
                    Lt.exports.fromGeojsonVt = function(Se, st) {
                        st = st || {};
                        var Rt = {};
                        for (var Qt in Se)
                            Rt[Qt] = new Z(Se[Qt].features,st),
                            Rt[Qt].name = Qt,
                            Rt[Qt].version = st.version,
                            Rt[Qt].extent = st.extent;
                        return se({
                            layers: Rt
                        })
                    }
                    ,
                    Lt.exports.GeoJSONWrapper = Z,
                    Lt.exports
                }(), co = s.e8(Ft);
                const Jt = {
                    minZoom: 0,
                    maxZoom: 16,
                    minPoints: 2,
                    radius: 40,
                    extent: 512,
                    nodeSize: 64,
                    log: !1,
                    generateId: !1,
                    reduce: null,
                    map: xt => xt
                }
                  , po = Math.fround || (Et = new Float32Array(1),
                xt => (Et[0] = +xt,
                Et[0]));
                var Et;
                class ve {
                    constructor(Z) {
                        this.options = Object.assign(Object.create(Jt), Z),
                        this.trees = new Array(this.options.maxZoom + 1),
                        this.stride = this.options.reduce ? 7 : 6,
                        this.clusterProps = []
                    }
                    load(Z) {
                        const {log: se, minZoom: Ee, maxZoom: He} = this.options;
                        se && console.time("total time");
                        const oe = "prepare ".concat(Z.length, " points");
                        se && console.time(oe),
                        this.points = Z;
                        const ue = [];
                        for (let q = 0; q < Z.length; q++) {
                            const le = Z[q];
                            if (!le.geometry)
                                continue;
                            const [Se,st] = le.geometry.coordinates
                              , Rt = po(de(Se))
                              , Qt = po(lt(st));
                            ue.push(Rt, Qt, 1 / 0, q, -1, 1),
                            this.options.reduce && ue.push(0)
                        }
                        let J = this.trees[He + 1] = this._createTree(ue);
                        se && console.timeEnd(oe);
                        for (let q = He; q >= Ee; q--) {
                            const le = +Date.now();
                            J = this.trees[q] = this._createTree(this._cluster(J, q)),
                            se && console.log("z%d: %d clusters in %dms", q, J.numItems, +Date.now() - le)
                        }
                        return se && console.timeEnd("total time"),
                        this
                    }
                    getClusters(Z, se) {
                        let Ee = ((Z[0] + 180) % 360 + 360) % 360 - 180;
                        const He = Math.max(-90, Math.min(90, Z[1]));
                        let oe = 180 === Z[2] ? 180 : ((Z[2] + 180) % 360 + 360) % 360 - 180;
                        const ue = Math.max(-90, Math.min(90, Z[3]));
                        if (Z[2] - Z[0] >= 360)
                            Ee = -180,
                            oe = 180;
                        else if (Ee > oe) {
                            const st = this.getClusters([Ee, He, 180, ue], se)
                              , Rt = this.getClusters([-180, He, oe, ue], se);
                            return st.concat(Rt)
                        }
                        const J = this.trees[this._limitZoom(se)]
                          , q = J.range(de(Ee), lt(ue), de(oe), lt(He))
                          , le = J.data
                          , Se = [];
                        for (const st of q) {
                            const Rt = this.stride * st;
                            Se.push(le[Rt + 5] > 1 ? ne(le, Rt, this.clusterProps) : this.points[le[Rt + 3]])
                        }
                        return Se
                    }
                    getChildren(Z) {
                        const se = this._getOriginId(Z)
                          , Ee = this._getOriginZoom(Z)
                          , He = "No cluster with the specified id."
                          , oe = this.trees[Ee];
                        if (!oe)
                            throw new Error(He);
                        const ue = oe.data;
                        if (se * this.stride >= ue.length)
                            throw new Error(He);
                        const J = this.options.radius / (this.options.extent * Math.pow(2, Ee - 1))
                          , q = oe.within(ue[se * this.stride], ue[se * this.stride + 1], J)
                          , le = [];
                        for (const Se of q) {
                            const st = Se * this.stride;
                            ue[st + 4] === Z && le.push(ue[st + 5] > 1 ? ne(ue, st, this.clusterProps) : this.points[ue[st + 3]])
                        }
                        if (0 === le.length)
                            throw new Error(He);
                        return le
                    }
                    getLeaves(Z, se, Ee) {
                        const He = [];
                        return this._appendLeaves(He, Z, se = se || 10, Ee = Ee || 0, 0),
                        He
                    }
                    getTile(Z, se, Ee) {
                        const He = this.trees[this._limitZoom(Z)]
                          , oe = Math.pow(2, Z)
                          , {extent: ue, radius: J} = this.options
                          , q = J / ue
                          , le = (Ee - q) / oe
                          , Se = (Ee + 1 + q) / oe
                          , st = {
                            features: []
                        };
                        return this._addTileFeatures(He.range((se - q) / oe, le, (se + 1 + q) / oe, Se), He.data, se, Ee, oe, st),
                        0 === se && this._addTileFeatures(He.range(1 - q / oe, le, 1, Se), He.data, oe, Ee, oe, st),
                        se === oe - 1 && this._addTileFeatures(He.range(0, le, q / oe, Se), He.data, -1, Ee, oe, st),
                        st.features.length ? st : null
                    }
                    getClusterExpansionZoom(Z) {
                        let se = this._getOriginZoom(Z) - 1;
                        for (; se <= this.options.maxZoom; ) {
                            const Ee = this.getChildren(Z);
                            if (se++,
                            1 !== Ee.length)
                                break;
                            Z = Ee[0].properties.cluster_id
                        }
                        return se
                    }
                    _appendLeaves(Z, se, Ee, He, oe) {
                        const ue = this.getChildren(se);
                        for (const J of ue) {
                            const q = J.properties;
                            if (q && q.cluster ? oe + q.point_count <= He ? oe += q.point_count : oe = this._appendLeaves(Z, q.cluster_id, Ee, He, oe) : oe < He ? oe++ : Z.push(J),
                            Z.length === Ee)
                                break
                        }
                        return oe
                    }
                    _createTree(Z) {
                        const se = new s.bE(Z.length / this.stride | 0,this.options.nodeSize,Float32Array);
                        for (let Ee = 0; Ee < Z.length; Ee += this.stride)
                            se.add(Z[Ee], Z[Ee + 1]);
                        return se.finish(),
                        se.data = Z,
                        se
                    }
                    _addTileFeatures(Z, se, Ee, He, oe, ue) {
                        for (const J of Z) {
                            const q = J * this.stride
                              , le = se[q + 5] > 1;
                            let Se, st, Rt;
                            if (le)
                                Se = B(se, q, this.clusterProps),
                                st = se[q],
                                Rt = se[q + 1];
                            else {
                                const Ho = this.points[se[q + 3]];
                                Se = Ho.properties;
                                const [Jo,qo] = Ho.geometry.coordinates;
                                st = de(Jo),
                                Rt = lt(qo)
                            }
                            const Qt = {
                                type: 1,
                                geometry: [[Math.round(this.options.extent * (st * oe - Ee)), Math.round(this.options.extent * (Rt * oe - He))]],
                                tags: Se
                            };
                            let wo;
                            wo = le || this.options.generateId ? se[q + 3] : this.points[se[q + 3]].id,
                            void 0 !== wo && (Qt.id = wo),
                            ue.features.push(Qt)
                        }
                    }
                    _limitZoom(Z) {
                        return Math.max(this.options.minZoom, Math.min(Math.floor(+Z), this.options.maxZoom + 1))
                    }
                    _cluster(Z, se) {
                        const {radius: Ee, extent: He, reduce: oe, minPoints: ue} = this.options
                          , J = Ee / (He * Math.pow(2, se))
                          , q = Z.data
                          , le = []
                          , Se = this.stride;
                        for (let st = 0; st < q.length; st += Se) {
                            if (q[st + 2] <= se)
                                continue;
                            q[st + 2] = se;
                            const Rt = q[st]
                              , Qt = q[st + 1]
                              , wo = Z.within(q[st], q[st + 1], J)
                              , Ho = q[st + 5];
                            let Jo = Ho;
                            for (const qo of wo) {
                                const Go = qo * Se;
                                q[Go + 2] > se && (Jo += q[Go + 5])
                            }
                            if (Jo > Ho && Jo >= ue) {
                                let qo, Go = Rt * Ho, Ii = Qt * Ho, Ci = -1;
                                const fi = (st / Se << 5) + (se + 1) + this.points.length;
                                for (const Ai of wo) {
                                    const Fi = Ai * Se;
                                    if (q[Fi + 2] <= se)
                                        continue;
                                    q[Fi + 2] = se;
                                    const fn = q[Fi + 5];
                                    Go += q[Fi] * fn,
                                    Ii += q[Fi + 1] * fn,
                                    q[Fi + 4] = fi,
                                    oe && (qo || (qo = this._map(q, st, !0),
                                    Ci = this.clusterProps.length,
                                    this.clusterProps.push(qo)),
                                    oe(qo, this._map(q, Fi)))
                                }
                                q[st + 4] = fi,
                                le.push(Go / Jo, Ii / Jo, 1 / 0, fi, -1, Jo),
                                oe && le.push(Ci)
                            } else {
                                for (let qo = 0; qo < Se; qo++)
                                    le.push(q[st + qo]);
                                if (Jo > 1)
                                    for (const qo of wo) {
                                        const Go = qo * Se;
                                        if (!(q[Go + 2] <= se)) {
                                            q[Go + 2] = se;
                                            for (let Ii = 0; Ii < Se; Ii++)
                                                le.push(q[Go + Ii])
                                        }
                                    }
                            }
                        }
                        return le
                    }
                    _getOriginId(Z) {
                        return Z - this.points.length >> 5
                    }
                    _getOriginZoom(Z) {
                        return (Z - this.points.length) % 32
                    }
                    _map(Z, se, Ee) {
                        if (Z[se + 5] > 1) {
                            const ue = this.clusterProps[Z[se + 6]];
                            return Ee ? Object.assign({}, ue) : ue
                        }
                        const He = this.points[Z[se + 3]].properties
                          , oe = this.options.map(He);
                        return Ee && oe === He ? Object.assign({}, oe) : oe
                    }
                }
                function ne(xt, Z, se) {
                    return {
                        type: "Feature",
                        id: xt[Z + 3],
                        properties: B(xt, Z, se),
                        geometry: {
                            type: "Point",
                            coordinates: [(Ee = xt[Z],
                            360 * (Ee - .5)), St(xt[Z + 1])]
                        }
                    };
                    var Ee
                }
                function B(xt, Z, se) {
                    const Ee = xt[Z + 5]
                      , He = Ee >= 1e4 ? "".concat(Math.round(Ee / 1e3), "k") : Ee >= 1e3 ? Math.round(Ee / 100) / 10 + "k" : Ee
                      , oe = xt[Z + 6]
                      , ue = -1 === oe ? {} : Object.assign({}, se[oe]);
                    return Object.assign(ue, {
                        cluster: !0,
                        cluster_id: xt[Z + 3],
                        point_count: Ee,
                        point_count_abbreviated: He
                    })
                }
                function de(xt) {
                    return xt / 360 + .5
                }
                function lt(xt) {
                    const Z = Math.sin(xt * Math.PI / 180)
                      , se = .5 - .25 * Math.log((1 + Z) / (1 - Z)) / Math.PI;
                    return se < 0 ? 0 : se > 1 ? 1 : se
                }
                function St(xt) {
                    const Z = (180 - 360 * xt) * Math.PI / 180;
                    return 360 * Math.atan(Math.exp(Z)) / Math.PI - 90
                }
                function tt(xt, Z, se, Ee) {
                    let He = Ee;
                    const oe = Z + (se - Z >> 1);
                    let ue, J = se - Z;
                    const q = xt[Z]
                      , le = xt[Z + 1]
                      , Se = xt[se]
                      , st = xt[se + 1];
                    for (let Rt = Z + 3; Rt < se; Rt += 3) {
                        const Qt = $t(xt[Rt], xt[Rt + 1], q, le, Se, st);
                        if (Qt > He)
                            ue = Rt,
                            He = Qt;
                        else if (Qt === He) {
                            const wo = Math.abs(Rt - oe);
                            wo < J && (ue = Rt,
                            J = wo)
                        }
                    }
                    He > Ee && (ue - Z > 3 && tt(xt, Z, ue, Ee),
                    xt[ue + 2] = He,
                    se - ue > 3 && tt(xt, ue, se, Ee))
                }
                function $t(xt, Z, se, Ee, He, oe) {
                    let ue = He - se
                      , J = oe - Ee;
                    if (0 !== ue || 0 !== J) {
                        const q = ((xt - se) * ue + (Z - Ee) * J) / (ue * ue + J * J);
                        q > 1 ? (se = He,
                        Ee = oe) : q > 0 && (se += ue * q,
                        Ee += J * q)
                    }
                    return ue = xt - se,
                    J = Z - Ee,
                    ue * ue + J * J
                }
                function Nt(xt, Z, se, Ee) {
                    const He = {
                        id: null != xt ? xt : null,
                        type: Z,
                        geometry: se,
                        tags: Ee,
                        minX: 1 / 0,
                        minY: 1 / 0,
                        maxX: -1 / 0,
                        maxY: -1 / 0
                    };
                    if ("Point" === Z || "MultiPoint" === Z || "LineString" === Z)
                        Vt(He, se);
                    else if ("Polygon" === Z)
                        Vt(He, se[0]);
                    else if ("MultiLineString" === Z)
                        for (const oe of se)
                            Vt(He, oe);
                    else if ("MultiPolygon" === Z)
                        for (const oe of se)
                            Vt(He, oe[0]);
                    return He
                }
                function Vt(xt, Z) {
                    for (let se = 0; se < Z.length; se += 3)
                        xt.minX = Math.min(xt.minX, Z[se]),
                        xt.minY = Math.min(xt.minY, Z[se + 1]),
                        xt.maxX = Math.max(xt.maxX, Z[se]),
                        xt.maxY = Math.max(xt.maxY, Z[se + 1])
                }
                function _o(xt, Z, se, Ee) {
                    if (!Z.geometry)
                        return;
                    const He = Z.geometry.coordinates;
                    if (He && 0 === He.length)
                        return;
                    const oe = Z.geometry.type
                      , ue = Math.pow(se.tolerance / ((1 << se.maxZoom) * se.extent), 2);
                    let J = []
                      , q = Z.id;
                    if (se.promoteId ? q = Z.properties[se.promoteId] : se.generateId && (q = Ee || 0),
                    "Point" === oe)
                        Lo(He, J);
                    else if ("MultiPoint" === oe)
                        for (const le of He)
                            Lo(le, J);
                    else if ("LineString" === oe)
                        ao(He, J, ue, !1);
                    else if ("MultiLineString" === oe) {
                        if (se.lineMetrics) {
                            for (const le of He)
                                J = [],
                                ao(le, J, ue, !1),
                                xt.push(Nt(q, "LineString", J, Z.properties));
                            return
                        }
                        bt(He, J, ue, !1)
                    } else if ("Polygon" === oe)
                        bt(He, J, ue, !0);
                    else {
                        if ("MultiPolygon" !== oe) {
                            if ("GeometryCollection" === oe) {
                                for (const le of Z.geometry.geometries)
                                    _o(xt, {
                                        id: q,
                                        geometry: le,
                                        properties: Z.properties
                                    }, se, Ee);
                                return
                            }
                            throw new Error("Input data is not a valid GeoJSON object.")
                        }
                        for (const le of He) {
                            const Se = [];
                            bt(le, Se, ue, !0),
                            J.push(Se)
                        }
                    }
                    xt.push(Nt(q, oe, J, Z.properties))
                }
                function Lo(xt, Z) {
                    Z.push(Do(xt[0]), Xt(xt[1]), 0)
                }
                function ao(xt, Z, se, Ee) {
                    let He, oe, ue = 0;
                    for (let q = 0; q < xt.length; q++) {
                        const le = Do(xt[q][0])
                          , Se = Xt(xt[q][1]);
                        Z.push(le, Se, 0),
                        q > 0 && (ue += Ee ? (He * Se - le * oe) / 2 : Math.sqrt(Math.pow(le - He, 2) + Math.pow(Se - oe, 2))),
                        He = le,
                        oe = Se
                    }
                    const J = Z.length - 3;
                    Z[2] = 1,
                    tt(Z, 0, J, se),
                    Z[J + 2] = 1,
                    Z.size = Math.abs(ue),
                    Z.start = 0,
                    Z.end = Z.size
                }
                function bt(xt, Z, se, Ee) {
                    for (let He = 0; He < xt.length; He++) {
                        const oe = [];
                        ao(xt[He], oe, se, Ee),
                        Z.push(oe)
                    }
                }
                function Do(xt) {
                    return xt / 360 + .5
                }
                function Xt(xt) {
                    const Z = Math.sin(xt * Math.PI / 180)
                      , se = .5 - .25 * Math.log((1 + Z) / (1 - Z)) / Math.PI;
                    return se < 0 ? 0 : se > 1 ? 1 : se
                }
                function ie(xt, Z, se, Ee, He, oe, ue, J) {
                    if (Ee /= Z,
                    oe >= (se /= Z) && ue < Ee)
                        return xt;
                    if (ue < se || oe >= Ee)
                        return null;
                    const q = [];
                    for (const le of xt) {
                        const Se = le.geometry;
                        let st = le.type;
                        const Rt = 0 === He ? le.minX : le.minY
                          , Qt = 0 === He ? le.maxX : le.maxY;
                        if (Rt >= se && Qt < Ee) {
                            q.push(le);
                            continue
                        }
                        if (Qt < se || Rt >= Ee)
                            continue;
                        let wo = [];
                        if ("Point" === st || "MultiPoint" === st)
                            we(Se, wo, se, Ee, He);
                        else if ("LineString" === st)
                            Oe(Se, wo, se, Ee, He, !1, J.lineMetrics);
                        else if ("MultiLineString" === st)
                            W(Se, wo, se, Ee, He, !1);
                        else if ("Polygon" === st)
                            W(Se, wo, se, Ee, He, !0);
                        else if ("MultiPolygon" === st)
                            for (const Ho of Se) {
                                const Jo = [];
                                W(Ho, Jo, se, Ee, He, !0),
                                Jo.length && wo.push(Jo)
                            }
                        if (wo.length) {
                            if (J.lineMetrics && "LineString" === st) {
                                for (const Ho of wo)
                                    q.push(Nt(le.id, st, Ho, le.tags));
                                continue
                            }
                            "LineString" !== st && "MultiLineString" !== st || (1 === wo.length ? (st = "LineString",
                            wo = wo[0]) : st = "MultiLineString"),
                            "Point" !== st && "MultiPoint" !== st || (st = 3 === wo.length ? "Point" : "MultiPoint"),
                            q.push(Nt(le.id, st, wo, le.tags))
                        }
                    }
                    return q.length ? q : null
                }
                function we(xt, Z, se, Ee, He) {
                    for (let oe = 0; oe < xt.length; oe += 3) {
                        const ue = xt[oe + He];
                        ue >= se && ue <= Ee && ae(Z, xt[oe], xt[oe + 1], xt[oe + 2])
                    }
                }
                function Oe(xt, Z, se, Ee, He, oe, ue) {
                    let J = ee(xt);
                    const q = 0 === He ? Ve : fe;
                    let le, Se, st = xt.start;
                    for (let Jo = 0; Jo < xt.length - 3; Jo += 3) {
                        const qo = xt[Jo]
                          , Go = xt[Jo + 1]
                          , Ii = xt[Jo + 2]
                          , Ci = xt[Jo + 3]
                          , fi = xt[Jo + 4]
                          , Ai = 0 === He ? qo : Go
                          , Fi = 0 === He ? Ci : fi;
                        let fn = !1;
                        ue && (le = Math.sqrt(Math.pow(qo - Ci, 2) + Math.pow(Go - fi, 2))),
                        Ai < se ? Fi > se && (Se = q(J, qo, Go, Ci, fi, se),
                        ue && (J.start = st + le * Se)) : Ai > Ee ? Fi < Ee && (Se = q(J, qo, Go, Ci, fi, Ee),
                        ue && (J.start = st + le * Se)) : ae(J, qo, Go, Ii),
                        Fi < se && Ai >= se && (Se = q(J, qo, Go, Ci, fi, se),
                        fn = !0),
                        Fi > Ee && Ai <= Ee && (Se = q(J, qo, Go, Ci, fi, Ee),
                        fn = !0),
                        !oe && fn && (ue && (J.end = st + le * Se),
                        Z.push(J),
                        J = ee(xt)),
                        ue && (st += le)
                    }
                    let Rt = xt.length - 3;
                    const Qt = xt[Rt]
                      , wo = xt[Rt + 1]
                      , Ho = 0 === He ? Qt : wo;
                    Ho >= se && Ho <= Ee && ae(J, Qt, wo, xt[Rt + 2]),
                    Rt = J.length - 3,
                    oe && Rt >= 3 && (J[Rt] !== J[0] || J[Rt + 1] !== J[1]) && ae(J, J[0], J[1], J[2]),
                    J.length && Z.push(J)
                }
                function ee(xt) {
                    const Z = [];
                    return Z.size = xt.size,
                    Z.start = xt.start,
                    Z.end = xt.end,
                    Z
                }
                function W(xt, Z, se, Ee, He, oe) {
                    for (const ue of xt)
                        Oe(ue, Z, se, Ee, He, oe, !1)
                }
                function ae(xt, Z, se, Ee) {
                    xt.push(Z, se, Ee)
                }
                function Ve(xt, Z, se, Ee, He, oe) {
                    const ue = (oe - Z) / (Ee - Z);
                    return ae(xt, oe, se + (He - se) * ue, 1),
                    ue
                }
                function fe(xt, Z, se, Ee, He, oe) {
                    const ue = (oe - se) / (He - se);
                    return ae(xt, Z + (Ee - Z) * ue, oe, 1),
                    ue
                }
                function Pt(xt, Z) {
                    const se = [];
                    for (let Ee = 0; Ee < xt.length; Ee++) {
                        const He = xt[Ee]
                          , oe = He.type;
                        let ue;
                        if ("Point" === oe || "MultiPoint" === oe || "LineString" === oe)
                            ue = mt(He.geometry, Z);
                        else if ("MultiLineString" === oe || "Polygon" === oe) {
                            ue = [];
                            for (const J of He.geometry)
                                ue.push(mt(J, Z))
                        } else if ("MultiPolygon" === oe) {
                            ue = [];
                            for (const J of He.geometry) {
                                const q = [];
                                for (const le of J)
                                    q.push(mt(le, Z));
                                ue.push(q)
                            }
                        }
                        se.push(Nt(He.id, oe, ue, He.tags))
                    }
                    return se
                }
                function mt(xt, Z) {
                    const se = [];
                    se.size = xt.size,
                    void 0 !== xt.start && (se.start = xt.start,
                    se.end = xt.end);
                    for (let Ee = 0; Ee < xt.length; Ee += 3)
                        se.push(xt[Ee] + Z, xt[Ee + 1], xt[Ee + 2]);
                    return se
                }
                function xo(xt, Z) {
                    if (xt.transformed)
                        return xt;
                    const se = 1 << xt.z
                      , Ee = xt.x
                      , He = xt.y;
                    for (const oe of xt.features) {
                        const ue = oe.geometry
                          , J = oe.type;
                        if (oe.geometry = [],
                        1 === J)
                            for (let q = 0; q < ue.length; q += 2)
                                oe.geometry.push(So(ue[q], ue[q + 1], Z, se, Ee, He));
                        else
                            for (let q = 0; q < ue.length; q++) {
                                const le = [];
                                for (let Se = 0; Se < ue[q].length; Se += 2)
                                    le.push(So(ue[q][Se], ue[q][Se + 1], Z, se, Ee, He));
                                oe.geometry.push(le)
                            }
                    }
                    return xt.transformed = !0,
                    xt
                }
                function So(xt, Z, se, Ee, He, oe) {
                    return [Math.round(se * (xt * Ee - He)), Math.round(se * (Z * Ee - oe))]
                }
                function ro(xt, Z, se, Ee, He) {
                    const oe = Z === He.maxZoom ? 0 : He.tolerance / ((1 << Z) * He.extent)
                      , ue = {
                        features: [],
                        numPoints: 0,
                        numSimplified: 0,
                        numFeatures: xt.length,
                        source: null,
                        x: se,
                        y: Ee,
                        z: Z,
                        transformed: !1,
                        minX: 2,
                        minY: 1,
                        maxX: -1,
                        maxY: 0
                    };
                    for (const J of xt)
                        Vo(ue, J, oe, He);
                    return ue
                }
                function Vo(xt, Z, se, Ee) {
                    const He = Z.geometry
                      , oe = Z.type
                      , ue = [];
                    if (xt.minX = Math.min(xt.minX, Z.minX),
                    xt.minY = Math.min(xt.minY, Z.minY),
                    xt.maxX = Math.max(xt.maxX, Z.maxX),
                    xt.maxY = Math.max(xt.maxY, Z.maxY),
                    "Point" === oe || "MultiPoint" === oe)
                        for (let J = 0; J < He.length; J += 3)
                            ue.push(He[J], He[J + 1]),
                            xt.numPoints++,
                            xt.numSimplified++;
                    else if ("LineString" === oe)
                        vo(ue, He, xt, se, !1, !1);
                    else if ("MultiLineString" === oe || "Polygon" === oe)
                        for (let J = 0; J < He.length; J++)
                            vo(ue, He[J], xt, se, "Polygon" === oe, 0 === J);
                    else if ("MultiPolygon" === oe)
                        for (let J = 0; J < He.length; J++) {
                            const q = He[J];
                            for (let le = 0; le < q.length; le++)
                                vo(ue, q[le], xt, se, !0, 0 === le)
                        }
                    if (ue.length) {
                        let J = Z.tags || null;
                        if ("LineString" === oe && Ee.lineMetrics) {
                            J = {};
                            for (const le in Z.tags)
                                J[le] = Z.tags[le];
                            J.mapbox_clip_start = He.start / He.size,
                            J.mapbox_clip_end = He.end / He.size
                        }
                        const q = {
                            geometry: ue,
                            type: "Polygon" === oe || "MultiPolygon" === oe ? 3 : "LineString" === oe || "MultiLineString" === oe ? 2 : 1,
                            tags: J
                        };
                        null !== Z.id && (q.id = Z.id),
                        xt.features.push(q)
                    }
                }
                function vo(xt, Z, se, Ee, He, oe) {
                    const ue = Ee * Ee;
                    if (Ee > 0 && Z.size < (He ? ue : Ee))
                        return void (se.numPoints += Z.length / 3);
                    const J = [];
                    for (let q = 0; q < Z.length; q += 3)
                        (0 === Ee || Z[q + 2] > ue) && (se.numSimplified++,
                        J.push(Z[q], Z[q + 1])),
                        se.numPoints++;
                    He && function(q, le) {
                        let Se = 0;
                        for (let st = 0, Rt = q.length, Qt = Rt - 2; st < Rt; Qt = st,
                        st += 2)
                            Se += (q[st] - q[Qt]) * (q[st + 1] + q[Qt + 1]);
                        if (Se > 0 === le)
                            for (let st = 0, Rt = q.length; st < Rt / 2; st += 2) {
                                const Qt = q[st]
                                  , wo = q[st + 1];
                                q[st] = q[Rt - 2 - st],
                                q[st + 1] = q[Rt - 1 - st],
                                q[Rt - 2 - st] = Qt,
                                q[Rt - 1 - st] = wo
                            }
                    }(J, oe),
                    xt.push(J)
                }
                const ei = {
                    maxZoom: 14,
                    indexMaxZoom: 5,
                    indexMaxPoints: 1e5,
                    tolerance: 3,
                    extent: 4096,
                    buffer: 64,
                    lineMetrics: !1,
                    promoteId: null,
                    generateId: !1,
                    debug: 0
                };
                class Ti {
                    constructor(Z, se) {
                        const Ee = (se = this.options = function(oe, ue) {
                            for (const J in ue)
                                oe[J] = ue[J];
                            return oe
                        }(Object.create(ei), se)).debug;
                        if (Ee && console.time("preprocess data"),
                        se.maxZoom < 0 || se.maxZoom > 24)
                            throw new Error("maxZoom should be in the 0-24 range");
                        if (se.promoteId && se.generateId)
                            throw new Error("promoteId and generateId cannot be used together.");
                        let He = function(oe, ue) {
                            const J = [];
                            if ("FeatureCollection" === oe.type)
                                for (let q = 0; q < oe.features.length; q++)
                                    _o(J, oe.features[q], ue, q);
                            else
                                _o(J, "Feature" === oe.type ? oe : {
                                    geometry: oe
                                }, ue);
                            return J
                        }(Z, se);
                        this.tiles = {},
                        this.tileCoords = [],
                        Ee && (console.timeEnd("preprocess data"),
                        console.log("index: maxZoom: %d, maxPoints: %d", se.indexMaxZoom, se.indexMaxPoints),
                        console.time("generate tiles"),
                        this.stats = {},
                        this.total = 0),
                        He = function(oe, ue) {
                            const J = ue.buffer / ue.extent;
                            let q = oe;
                            const le = ie(oe, 1, -1 - J, J, 0, -1, 2, ue)
                              , Se = ie(oe, 1, 1 - J, 2 + J, 0, -1, 2, ue);
                            return (le || Se) && (q = ie(oe, 1, -J, 1 + J, 0, -1, 2, ue) || [],
                            le && (q = Pt(le, 1).concat(q)),
                            Se && (q = q.concat(Pt(Se, -1)))),
                            q
                        }(He, se),
                        He.length && this.splitTile(He, 0, 0, 0),
                        Ee && (He.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints),
                        console.timeEnd("generate tiles"),
                        console.log("tiles generated:", this.total, JSON.stringify(this.stats)))
                    }
                    splitTile(Z, se, Ee, He, oe, ue, J) {
                        const q = [Z, se, Ee, He]
                          , le = this.options
                          , Se = le.debug;
                        for (; q.length; ) {
                            He = q.pop(),
                            Ee = q.pop(),
                            se = q.pop(),
                            Z = q.pop();
                            const st = 1 << se
                              , Rt = ci(se, Ee, He);
                            let Qt = this.tiles[Rt];
                            if (!Qt && (Se > 1 && console.time("creation"),
                            Qt = this.tiles[Rt] = ro(Z, se, Ee, He, le),
                            this.tileCoords.push({
                                z: se,
                                x: Ee,
                                y: He
                            }),
                            Se)) {
                                Se > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", se, Ee, He, Qt.numFeatures, Qt.numPoints, Qt.numSimplified),
                                console.timeEnd("creation"));
                                const fn = "z".concat(se);
                                this.stats[fn] = (this.stats[fn] || 0) + 1,
                                this.total++
                            }
                            if (Qt.source = Z,
                            null == oe) {
                                if (se === le.indexMaxZoom || Qt.numPoints <= le.indexMaxPoints)
                                    continue
                            } else {
                                if (se === le.maxZoom || se === oe)
                                    continue;
                                if (null != oe) {
                                    const fn = oe - se;
                                    if (Ee !== ue >> fn || He !== J >> fn)
                                        continue
                                }
                            }
                            if (Qt.source = null,
                            0 === Z.length)
                                continue;
                            Se > 1 && console.time("clipping");
                            const wo = .5 * le.buffer / le.extent
                              , Ho = .5 - wo
                              , Jo = .5 + wo
                              , qo = 1 + wo;
                            let Go = null
                              , Ii = null
                              , Ci = null
                              , fi = null
                              , Ai = ie(Z, st, Ee - wo, Ee + Jo, 0, Qt.minX, Qt.maxX, le)
                              , Fi = ie(Z, st, Ee + Ho, Ee + qo, 0, Qt.minX, Qt.maxX, le);
                            Z = null,
                            Ai && (Go = ie(Ai, st, He - wo, He + Jo, 1, Qt.minY, Qt.maxY, le),
                            Ii = ie(Ai, st, He + Ho, He + qo, 1, Qt.minY, Qt.maxY, le),
                            Ai = null),
                            Fi && (Ci = ie(Fi, st, He - wo, He + Jo, 1, Qt.minY, Qt.maxY, le),
                            fi = ie(Fi, st, He + Ho, He + qo, 1, Qt.minY, Qt.maxY, le),
                            Fi = null),
                            Se > 1 && console.timeEnd("clipping"),
                            q.push(Go || [], se + 1, 2 * Ee, 2 * He),
                            q.push(Ii || [], se + 1, 2 * Ee, 2 * He + 1),
                            q.push(Ci || [], se + 1, 2 * Ee + 1, 2 * He),
                            q.push(fi || [], se + 1, 2 * Ee + 1, 2 * He + 1)
                        }
                    }
                    getTile(Z, se, Ee) {
                        Z = +Z,
                        se = +se,
                        Ee = +Ee;
                        const He = this.options
                          , {extent: oe, debug: ue} = He;
                        if (Z < 0 || Z > 24)
                            return null;
                        const J = 1 << Z
                          , q = ci(Z, se = se + J & J - 1, Ee);
                        if (this.tiles[q])
                            return xo(this.tiles[q], oe);
                        ue > 1 && console.log("drilling down to z%d-%d-%d", Z, se, Ee);
                        let le, Se = Z, st = se, Rt = Ee;
                        for (; !le && Se > 0; )
                            Se--,
                            st >>= 1,
                            Rt >>= 1,
                            le = this.tiles[ci(Se, st, Rt)];
                        return le && le.source ? (ue > 1 && (console.log("found parent tile z%d-%d-%d", Se, st, Rt),
                        console.time("drilling down")),
                        this.splitTile(le.source, Se, st, Rt, Z, se, Ee),
                        ue > 1 && console.timeEnd("drilling down"),
                        this.tiles[q] ? xo(this.tiles[q], oe) : null) : null
                    }
                }
                function ci(xt, Z, se) {
                    return 32 * ((1 << xt) * se + Z) + xt
                }
                function ji(xt, Z) {
                    const se = xt.tileID.canonical;
                    if (!this._geoJSONIndex)
                        return void Z(null, null);
                    const Ee = this._geoJSONIndex.getTile(se.z, se.x, se.y);
                    if (!Ee)
                        return void Z(null, null);
                    const He = new re(Ee.features);
                    let oe = co(He);
                    0 === oe.byteOffset && oe.byteLength === oe.buffer.byteLength || (oe = new Uint8Array(oe)),
                    Z(null, {
                        vectorTile: He,
                        rawData: oe.buffer
                    })
                }
                class yn extends jt {
                    constructor(Z, se, Ee, He, oe, ue) {
                        super(Z, se, Ee, He, ji, ue),
                        oe && (this.loadGeoJSON = oe),
                        this._dynamicIndex = new ze
                    }
                    loadData(Z, se) {
                        const Ee = Z && Z.request
                          , He = Ee && Ee.collectResourceTiming;
                        this.loadGeoJSON(Z, (oe, ue) => {
                            if (oe || !ue)
                                return se(oe);
                            if ("object" != typeof ue)
                                return se(new Error("Input data given to '".concat(Z.source, "' is not a valid GeoJSON object.")));
                            {
                                try {
                                    if (Z.filter) {
                                        const q = s.U(Z.filter, {
                                            type: "boolean",
                                            "property-type": "data-driven",
                                            overridable: !1,
                                            transition: !1
                                        });
                                        if ("error" === q.result)
                                            throw new Error(q.value.map(le => "".concat(le.key, ": ").concat(le.message)).join(", "));
                                        ue.features = ue.features.filter(le => q.value.evaluate({
                                            zoom: 0
                                        }, le))
                                    }
                                    Z.dynamic ? ("Feature" === ue.type && (ue = {
                                        type: "FeatureCollection",
                                        features: [ue]
                                    }),
                                    Z.append || (this._dynamicIndex.clear(),
                                    this.loaded = {}),
                                    this._dynamicIndex.load(ue.features, this.loaded),
                                    Z.cluster && (ue.features = this._dynamicIndex.getFeatures())) : this.loaded = {},
                                    this._geoJSONIndex = Z.cluster ? new ve(function({superclusterOptions: q, clusterProperties: le}) {
                                        if (!le || !q)
                                            return q;
                                        const Se = {}
                                          , st = {}
                                          , Rt = {
                                            accumulated: null,
                                            zoom: 0
                                        }
                                          , Qt = {
                                            properties: null
                                        }
                                          , wo = Object.keys(le);
                                        for (const Ho of wo) {
                                            const [Jo,qo] = le[Ho]
                                              , Go = s.U(qo)
                                              , Ii = s.U("string" == typeof Jo ? [Jo, ["accumulated"], ["get", Ho]] : Jo);
                                            Se[Ho] = Go.value,
                                            st[Ho] = Ii.value
                                        }
                                        return q.map = Ho => {
                                            Qt.properties = Ho;
                                            const Jo = {};
                                            for (const qo of wo)
                                                Jo[qo] = Se[qo].evaluate(Rt, Qt);
                                            return Jo
                                        }
                                        ,
                                        q.reduce = (Ho, Jo) => {
                                            Qt.properties = Jo;
                                            for (const qo of wo)
                                                Rt.accumulated = Ho[qo],
                                                Ho[qo] = st[qo].evaluate(Rt, Qt)
                                        }
                                        ,
                                        q
                                    }(Z)).load(ue.features) : Z.dynamic ? this._dynamicIndex : new Ti(q = ue,Z.geojsonVtOptions)
                                } catch (q) {
                                    return se(q)
                                }
                                const J = {};
                                if (He) {
                                    const q = so(Ee);
                                    q && (J.resourceTiming = {},
                                    J.resourceTiming[Z.source] = JSON.parse(JSON.stringify(q)))
                                }
                                se(null, J)
                            }
                            var q
                        }
                        )
                    }
                    reloadTile(Z, se) {
                        const Ee = this.loaded;
                        return Ee && Ee[Z.uid] ? Z.partial ? se(null, void 0) : super.reloadTile(Z, se) : this.loadTile(Z, se)
                    }
                    loadGeoJSON(Z, se) {
                        if (Z.request)
                            s.n(Z.request, se);
                        else {
                            if ("string" != typeof Z.data)
                                return se(new Error("Input data given to '".concat(Z.source, "' is not a valid GeoJSON object.")));
                            try {
                                return se(null, JSON.parse(Z.data))
                            } catch {
                                return se(new Error("Input data given to '".concat(Z.source, "' is not a valid GeoJSON object.")))
                            }
                        }
                    }
                    getClusterExpansionZoom(Z, se) {
                        try {
                            se(null, this._geoJSONIndex.getClusterExpansionZoom(Z.clusterId))
                        } catch (Ee) {
                            se(Ee)
                        }
                    }
                    getClusterChildren(Z, se) {
                        try {
                            se(null, this._geoJSONIndex.getChildren(Z.clusterId))
                        } catch (Ee) {
                            se(Ee)
                        }
                    }
                    getClusterLeaves(Z, se) {
                        try {
                            se(null, this._geoJSONIndex.getLeaves(Z.clusterId, Z.limit, Z.offset))
                        } catch (Ee) {
                            se(Ee)
                        }
                    }
                }
                class Dr {
                    constructor(Z, se) {
                        this.tileID = new s.aG(Z.tileID.overscaledZ,Z.tileID.wrap,Z.tileID.canonical.z,Z.tileID.canonical.x,Z.tileID.canonical.y),
                        this.tileZoom = Z.tileZoom,
                        this.uid = Z.uid,
                        this.zoom = Z.zoom,
                        this.canonical = Z.tileID.canonical,
                        this.pixelRatio = Z.pixelRatio,
                        this.tileSize = Z.tileSize,
                        this.source = Z.source,
                        this.overscaling = this.tileID.overscaleFactor(),
                        this.projection = Z.projection,
                        this.brightness = se
                    }
                    parse(Z, se, Ee, He) {
                        this.status = "parsing";
                        const oe = new s.aG(Ee.tileID.overscaledZ,Ee.tileID.wrap,Ee.tileID.canonical.z,Ee.tileID.canonical.x,Ee.tileID.canonical.y)
                          , ue = []
                          , J = se.familiesBySource[Ee.source]
                          , q = new s.dZ(oe,Ee.promoteId);
                        return q.bucketLayerIDs = [],
                        q.is3DTile = !0,
                        s.e9(Z).then(le => {
                            if (!le)
                                return He(new Error("Could not parse tile"));
                            const Se = s.ea(le, 1 / s.cc(Ee.tileID.canonical))
                              , st = le.json.extensionsUsed && le.json.extensionsUsed.includes("MAPBOX_mesh_features") || le.json.asset.extras && le.json.asset.extras.MAPBOX_mesh_features
                              , Rt = le.json.extensionsUsed && le.json.extensionsUsed.includes("EXT_meshopt_compression")
                              , Qt = new s.a8(this.zoom,{
                                brightness: this.brightness
                            });
                            for (const wo in J)
                                for (const Ho of J[wo]) {
                                    const Jo = Ho[0];
                                    q.bucketLayerIDs.push(Ho.map(Go => s.aC(Go.id, Go.scope))),
                                    Jo.recalculate(Qt, []);
                                    const qo = new s.eb(Ho,Se,oe,st,Rt,this.brightness,q);
                                    st || (qo.needsUpload = !0),
                                    ue.push(qo),
                                    qo.evaluate(Jo)
                                }
                            this.status = "done",
                            He(null, {
                                buckets: ue,
                                featureIndex: q,
                                collisionBoxArray: null,
                                glyphAtlasImage: null,
                                lineAtlas: null,
                                imageAtlas: null,
                                brightness: null
                            })
                        }
                        ).catch(le => He(new Error(le.message)))
                    }
                }
                class Ln {
                    constructor(Z, se, Ee, He, oe, ue) {
                        this.actor = Z,
                        this.layerIndex = se,
                        this.availableImages = Ee,
                        this.brightness = ue,
                        this.loading = {},
                        this.loaded = {}
                    }
                    loadTile(Z, se) {
                        const Ee = Z.uid
                          , He = this.loading[Ee] = new Dr(Z,this.brightness);
                        s.bi(Z.request, (oe, ue) => {
                            const J = !this.loading[Ee];
                            return delete this.loading[Ee],
                            J || oe ? (He.status = "done",
                            J || (this.loaded[Ee] = He),
                            se(oe)) : ue && 0 !== ue.byteLength ? void He.parse(ue, this.layerIndex, Z, (q, le) => {
                                He.status = "done",
                                this.loaded = this.loaded || {},
                                this.loaded[Ee] = He,
                                q || !le ? se(q) : se(null, le)
                            }
                            ) : (He.status = "done",
                            this.loaded[Ee] = He,
                            se())
                        }
                        )
                    }
                    reloadTile(Z, se) {
                        const Ee = this.loaded
                          , He = Z.uid;
                        if (Ee && Ee[He]) {
                            const oe = Ee[He];
                            oe.projection = Z.projection,
                            oe.brightness = Z.brightness;
                            const ue = (J, q) => {
                                oe.reloadCallback && (delete oe.reloadCallback,
                                this.loadTile(Z, se)),
                                se(J, q)
                            }
                            ;
                            "parsing" === oe.status ? oe.reloadCallback = ue : "done" === oe.status && this.loadTile(Z, se)
                        }
                    }
                    abortTile(Z, se) {
                        const Ee = Z.uid;
                        this.loading[Ee] && delete this.loading[Ee],
                        se()
                    }
                    removeTile(Z, se) {
                        const Ee = this.loaded
                          , He = Z.uid;
                        Ee && Ee[He] && delete Ee[He],
                        se()
                    }
                }
                class Lr {
                    constructor(Z) {
                        this.self = Z,
                        this.actor = new s.ec(Z,this),
                        this.layerIndexes = {},
                        this.availableImages = {},
                        this.isSpriteLoaded = {},
                        this.imageRasterizer = new s.I,
                        this.projections = {},
                        this.defaultProjection = s.bP({
                            name: "mercator"
                        }),
                        this.workerSourceTypes = {
                            vector: jt,
                            geojson: yn,
                            "batched-model": Ln
                        },
                        this.workerSources = {},
                        this.demWorkerSources = {},
                        this.self.registerWorkerSource = (se, Ee) => {
                            if (this.workerSourceTypes[se])
                                throw new Error('Worker source with name "'.concat(se, '" already registered.'));
                            this.workerSourceTypes[se] = Ee
                        }
                        ,
                        this.self.registerRTLTextPlugin = se => {
                            if (s.ed.isParsed())
                                throw new Error("RTL text plugin already registered.");
                            s.ed.applyArabicShaping = se.applyArabicShaping,
                            s.ed.processBidirectionalText = se.processBidirectionalText,
                            s.ed.processStyledBidirectionalText = se.processStyledBidirectionalText
                        }
                    }
                    clearCaches(Z, se, Ee) {
                        delete this.layerIndexes[Z],
                        delete this.availableImages[Z],
                        delete this.workerSources[Z],
                        delete this.demWorkerSources[Z],
                        delete this.rasterArrayWorkerSource,
                        Ee()
                    }
                    checkIfReady(Z, se, Ee) {
                        Ee()
                    }
                    setReferrer(Z, se) {
                        this.referrer = se
                    }
                    spriteLoaded(Z, {scope: se, isLoaded: Ee}) {
                        if (this.isSpriteLoaded[Z] || (this.isSpriteLoaded[Z] = {}),
                        this.isSpriteLoaded[Z][se] = Ee,
                        this.workerSources[Z] && this.workerSources[Z][se])
                            for (const He in this.workerSources[Z][se]) {
                                const oe = this.workerSources[Z][se][He];
                                for (const ue in oe) {
                                    const J = oe[ue];
                                    J instanceof jt && (J.isSpriteLoaded = Ee,
                                    J.fire(new s.z("isSpriteLoaded")))
                                }
                            }
                    }
                    setImages(Z, {scope: se, images: Ee}, He) {
                        if (this.availableImages[Z] || (this.availableImages[Z] = {}),
                        this.availableImages[Z][se] = Ee,
                        this.workerSources[Z] && this.workerSources[Z][se]) {
                            for (const oe in this.workerSources[Z][se]) {
                                const ue = this.workerSources[Z][se][oe];
                                for (const J in ue)
                                    ue[J].availableImages = Ee
                            }
                            He()
                        } else
                            He()
                    }
                    setProjection(Z, se) {
                        this.projections[Z] = s.bP(se)
                    }
                    setBrightness(Z, se, Ee) {
                        this.brightness = se,
                        Ee()
                    }
                    setLayers(Z, se, Ee) {
                        this.getLayerIndex(Z, se.scope).replace(se.layers, se.options),
                        Ee()
                    }
                    updateLayers(Z, se, Ee) {
                        this.getLayerIndex(Z, se.scope).update(se.layers, se.removedIds, se.options),
                        Ee()
                    }
                    loadTile(Z, se, Ee) {
                        se.projection = this.projections[Z] || this.defaultProjection,
                        this.getWorkerSource(Z, se.type, se.source, se.scope).loadTile(se, Ee)
                    }
                    loadDEMTile(Z, se, Ee) {
                        this.getDEMWorkerSource(Z, se.source, se.scope).loadTile(se, Ee)
                    }
                    decodeRasterArray(Z, se, Ee) {
                        this.getRasterArrayWorkerSource().decodeRasterArray(se, Ee)
                    }
                    reloadTile(Z, se, Ee) {
                        se.projection = this.projections[Z] || this.defaultProjection,
                        this.getWorkerSource(Z, se.type, se.source, se.scope).reloadTile(se, Ee)
                    }
                    abortTile(Z, se, Ee) {
                        this.getWorkerSource(Z, se.type, se.source, se.scope).abortTile(se, Ee)
                    }
                    removeTile(Z, se, Ee) {
                        this.getWorkerSource(Z, se.type, se.source, se.scope).removeTile(se, Ee)
                    }
                    removeSource(Z, se, Ee) {
                        if (!(this.workerSources[Z] && this.workerSources[Z][se.scope] && this.workerSources[Z][se.scope][se.type] && this.workerSources[Z][se.scope][se.type][se.source]))
                            return;
                        const He = this.workerSources[Z][se.scope][se.type][se.source];
                        delete this.workerSources[Z][se.scope][se.type][se.source],
                        void 0 !== He.removeSource ? He.removeSource(se, Ee) : Ee()
                    }
                    loadWorkerSource(Z, se, Ee) {
                        try {
                            this.self.importScripts(se.url),
                            Ee()
                        } catch (He) {
                            Ee(He.toString())
                        }
                    }
                    syncRTLPluginState(Z, se, Ee) {
                        try {
                            s.ed.setState(se);
                            const He = s.ed.getPluginURL();
                            if (s.ed.isLoaded() && !s.ed.isParsed() && null != He) {
                                this.self.importScripts(He);
                                const oe = s.ed.isParsed();
                                Ee(oe ? void 0 : new Error("RTL Text Plugin failed to import scripts from ".concat(He)), oe)
                            }
                        } catch (He) {
                            Ee(He.toString())
                        }
                    }
                    setDracoUrl(Z, se) {
                        this.dracoUrl = se
                    }
                    getAvailableImages(Z, se) {
                        this.availableImages[Z] || (this.availableImages[Z] = {});
                        let Ee = this.availableImages[Z][se];
                        return Ee || (Ee = []),
                        Ee
                    }
                    getLayerIndex(Z, se) {
                        this.layerIndexes[Z] || (this.layerIndexes[Z] = {});
                        let Ee = this.layerIndexes[Z][se];
                        return Ee || (Ee = this.layerIndexes[Z][se] = new Ae,
                        Ee.scope = se),
                        Ee
                    }
                    getWorkerSource(Z, se, Ee, He) {
                        return this.workerSources[Z] || (this.workerSources[Z] = {}),
                        this.workerSources[Z][He] || (this.workerSources[Z][He] = {}),
                        this.workerSources[Z][He][se] || (this.workerSources[Z][He][se] = {}),
                        this.isSpriteLoaded[Z] || (this.isSpriteLoaded[Z] = {}),
                        this.workerSources[Z][He][se][Ee] || (this.workerSources[Z][He][se][Ee] = new this.workerSourceTypes[se]({
                            send: (oe, ue, J, q, le, Se) => {
                                this.actor.send(oe, ue, J, Z, le, Se)
                            }
                            ,
                            scheduler: this.actor.scheduler
                        },this.getLayerIndex(Z, He),this.getAvailableImages(Z, He),this.isSpriteLoaded[Z][He],void 0,this.brightness)),
                        this.workerSources[Z][He][se][Ee]
                    }
                    rasterizeImages(Z, se, Ee) {
                        const {imageTasks: He, scope: oe} = se
                          , ue = {};
                        for (const J in He) {
                            const {image: q, imageIdWithOptions: le} = He[J];
                            ue[J] = this.imageRasterizer.rasterize(le, q, oe, Z)
                        }
                        Ee(void 0, ue)
                    }
                    removeRasterizedImages(Z, se, Ee) {
                        const {imageIds: He, scope: oe} = se;
                        this.imageRasterizer.removeImagesFromCacheByIds(He, oe, Z),
                        Ee()
                    }
                    getDEMWorkerSource(Z, se, Ee) {
                        return this.demWorkerSources[Z] || (this.demWorkerSources[Z] = {}),
                        this.demWorkerSources[Z][Ee] || (this.demWorkerSources[Z][Ee] = {}),
                        this.demWorkerSources[Z][Ee][se] || (this.demWorkerSources[Z][Ee][se] = new Xe),
                        this.demWorkerSources[Z][Ee][se]
                    }
                    getRasterArrayWorkerSource() {
                        return this.rasterArrayWorkerSource || (this.rasterArrayWorkerSource = new Ce),
                        this.rasterArrayWorkerSource
                    }
                    enforceCacheSizeLimit(Z, se) {
                        s.ee(se)
                    }
                    getWorkerPerformanceMetrics(Z, se, Ee) {
                        Ee(void 0, void 0)
                    }
                }
                return typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope && (self.worker = new Lr(self)),
                Lr
            }),
            r(0, function(s) {
                var so = "3.9.4";
                const Wt = {
                    create: "create",
                    load: "load",
                    fullLoad: "fullLoad"
                }
                  , _t = {
                    mark(c) {
                        performance.mark(c)
                    },
                    measure(c, t, i) {
                        performance.measure(c, t, i)
                    }
                };
                function Ae(c) {
                    const t = c.name.split("?")[0];
                    return s.a(t) && t.includes("mapbox-gl.js") ? "javascript" : s.a(t) && t.includes("mapbox-gl.css") ? "css" : s.b(t) ? "fontRange" : s.c(t) ? "sprite" : s.i(t) ? "style" : s.d(t) ? "tilejson" : "other"
                }
                var Me, ct = {}, Tt = function() {
                    if (Me)
                        return ct;
                    function c(h) {
                        return !t(h)
                    }
                    function t(h) {
                        return typeof window > "u" || typeof document > "u" ? "not a browser" : function() {
                            if (!("Worker"in window && "Blob"in window && "URL"in window))
                                return !1;
                            var m, y, M = new Blob([""],{
                                type: "text/javascript"
                            }), E = URL.createObjectURL(M);
                            try {
                                y = new Worker(E),
                                m = !0
                            } catch {
                                m = !1
                            }
                            return y && y.terminate(),
                            URL.revokeObjectURL(E),
                            m
                        }() ? function() {
                            var m = document.createElement("canvas");
                            m.width = m.height = 1;
                            var y = m.getContext("2d");
                            if (!y)
                                return !1;
                            var M = y.getImageData(0, 0, 1, 1);
                            return M && M.width === m.width
                        }() ? (void 0 === i[d = h && h.failIfMajorPerformanceCaveat] && (i[d] = function(m) {
                            var y, E, S, I, M = (E = m,
                            S = document.createElement("canvas"),
                            (I = Object.create(c.webGLContextAttributes)).failIfMajorPerformanceCaveat = E,
                            S.getContext("webgl2", I));
                            if (!M)
                                return !1;
                            try {
                                y = M.createShader(M.VERTEX_SHADER)
                            } catch {
                                return !1
                            }
                            return !(!y || M.isContextLost()) && (M.shaderSource(y, "void main() {}"),
                            M.compileShader(y),
                            !0 === M.getShaderParameter(y, M.COMPILE_STATUS))
                        }(d)),
                        i[d] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL2 support") : "insufficient Canvas/getImageData support" : "insufficient worker support";
                        var d
                    }
                    Me = 1,
                    ct.supported = c,
                    ct.notSupportedReason = t;
                    var i = {};
                    return c.webGLContextAttributes = {
                        antialias: !1,
                        alpha: !0,
                        stencil: !0,
                        depth: !0
                    },
                    ct
                }();
                function Qe(c, t, i) {
                    const h = document.createElement(c);
                    return null != t && (h.className = t),
                    i && i.appendChild(h),
                    h
                }
                function jt(c, t, i) {
                    const h = document.createElementNS("http://www.w3.org/2000/svg", c);
                    for (const d of Object.keys(t))
                        h.setAttributeNS(null, d, String(t[d]));
                    return i && i.appendChild(h),
                    h
                }
                const Xe = typeof document < "u" ? document.documentElement && document.documentElement.style : null
                  , Ce = Xe && void 0 !== Xe.userSelect ? "userSelect" : "WebkitUserSelect";
                let it;
                function et() {
                    Xe && Ce && (it = Xe[Ce],
                    Xe[Ce] = "none")
                }
                function re() {
                    Xe && Ce && (Xe[Ce] = it)
                }
                function pt(c) {
                    c.preventDefault(),
                    c.stopPropagation(),
                    window.removeEventListener("click", pt, !0)
                }
                function Be() {
                    window.addEventListener("click", pt, !0),
                    window.setTimeout( () => {
                        window.removeEventListener("click", pt, !0)
                    }
                    , 0)
                }
                function ze(c, t) {
                    const i = c.getBoundingClientRect();
                    return Ie(c, i, t)
                }
                function ye(c, t) {
                    const i = c.getBoundingClientRect()
                      , h = [];
                    for (let d = 0; d < t.length; d++)
                        h.push(Ie(c, i, t[d]));
                    return h
                }
                function ge(c) {
                    return void 0 !== window.InstallTrigger && 2 === c.button && c.ctrlKey && window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : c.button
                }
                function Ie(c, t, i) {
                    const h = c.offsetWidth === t.width ? 1 : c.offsetWidth / t.width;
                    return new s.P((i.clientX - t.left) * h,(i.clientY - t.top) * h)
                }
                const gt = "01"
                  , Ye = "NO_ACCESS_TOKEN";
                class yt {
                    constructor(t, i, h) {
                        this._transformRequestFn = t,
                        this._customAccessToken = i,
                        this._silenceAuthErrors = !!h,
                        this._createSkuToken()
                    }
                    _createSkuToken() {
                        const t = function() {
                            let i = "";
                            for (let h = 0; h < 10; h++)
                                i += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
                            return {
                                token: ["1", gt, i].join(""),
                                tokenExpiresAt: Date.now() + 432e5
                            }
                        }();
                        this._skuToken = t.token,
                        this._skuTokenExpiresAt = t.tokenExpiresAt
                    }
                    _isSkuTokenExpired() {
                        return Date.now() > this._skuTokenExpiresAt
                    }
                    transformRequest(t, i) {
                        return this._transformRequestFn && this._transformRequestFn(t, i) || {
                            url: t
                        }
                    }
                    normalizeStyleURL(t, i) {
                        if (!s.f(t))
                            return t;
                        const h = mo(t);
                        return h.params.push("sdk=js-".concat(so)),
                        h.path = "/styles/v1".concat(h.path),
                        this._makeAPIURL(h, this._customAccessToken || i)
                    }
                    normalizeGlyphsURL(t, i) {
                        if (!s.f(t))
                            return t;
                        const h = mo(t);
                        return h.path = "/fonts/v1".concat(h.path),
                        this._makeAPIURL(h, this._customAccessToken || i)
                    }
                    normalizeModelURL(t, i) {
                        if (!s.f(t))
                            return t;
                        const h = mo(t);
                        return h.path = "/models/v1".concat(h.path),
                        this._makeAPIURL(h, this._customAccessToken || i)
                    }
                    normalizeSourceURL(t, i, h, d) {
                        if (!s.f(t))
                            return t;
                        const m = mo(t);
                        return m.path = "/v4/".concat(m.authority, ".json"),
                        m.params.push("secure"),
                        h && m.params.push("language=".concat(h)),
                        d && m.params.push("worldview=".concat(d)),
                        this._makeAPIURL(m, this._customAccessToken || i)
                    }
                    normalizeIconsetURL(t, i) {
                        const h = mo(t);
                        return s.f(t) ? (h.path = "/styles/v1".concat(h.path, "/iconset.pbf"),
                        this._makeAPIURL(h, this._customAccessToken || i)) : no(h)
                    }
                    normalizeSpriteURL(t, i, h, d) {
                        const m = mo(t);
                        return s.f(t) ? (m.path = "/styles/v1".concat(m.path, "/sprite").concat(i).concat(h),
                        this._makeAPIURL(m, this._customAccessToken || d)) : (m.path += "".concat(i).concat(h),
                        no(m))
                    }
                    normalizeTileURL(t, i, h) {
                        if (this._isSkuTokenExpired() && this._createSkuToken(),
                        t && !s.f(t))
                            return t;
                        const d = mo(t);
                        d.path = d.path.replace(/(\.(png|jpg)\d*)(?=$)/, "".concat(i || h && "raster" !== d.authority && 512 === h ? "@2x" : "").concat(s.m.supported ? ".webp" : "$1")),
                        "raster" === d.authority ? d.path = "/".concat(s.e.RASTER_URL_PREFIX).concat(d.path) : "rasterarrays" === d.authority ? d.path = "/".concat(s.e.RASTERARRAYS_URL_PREFIX).concat(d.path) : "3dtiles" === d.authority ? d.path = "/".concat(s.e.TILES3D_URL_PREFIX).concat(d.path) : (d.path = d.path.replace(/^.+\/v4\//, "/"),
                        d.path = "/".concat(s.e.TILE_URL_VERSION).concat(d.path));
                        const m = this._customAccessToken || function(y) {
                            for (const M of y) {
                                const E = M.match(/^access_token=(.*)$/);
                                if (E)
                                    return E[1]
                            }
                            return null
                        }(d.params) || s.e.ACCESS_TOKEN;
                        return s.e.REQUIRE_ACCESS_TOKEN && m && this._skuToken && d.params.push("sku=".concat(this._skuToken)),
                        this._makeAPIURL(d, m)
                    }
                    canonicalizeTileURL(t, i) {
                        const h = mo(t);
                        if (!h.path.match(/^(\/v4\/|\/(raster|rasterarrays)\/v1\/)/) || !h.path.match(/\.[\w]+$/))
                            return t;
                        let d = "mapbox://";
                        h.path.match(/^\/raster\/v1\//) ? d += "raster/".concat(h.path.replace("/".concat(s.e.RASTER_URL_PREFIX, "/"), "")) : h.path.match(/^\/rasterarrays\/v1\//) ? d += "rasterarrays/".concat(h.path.replace("/".concat(s.e.RASTERARRAYS_URL_PREFIX, "/"), "")) : d += "tiles/".concat(h.path.replace("/".concat(s.e.TILE_URL_VERSION, "/"), ""));
                        let m = h.params;
                        return i && (m = m.filter(y => !y.match(/^access_token=/))),
                        m.length && (d += "?".concat(m.join("&"))),
                        d
                    }
                    canonicalizeTileset(t, i) {
                        const h = !!i && s.f(i)
                          , d = [];
                        for (const m of t.tiles || [])
                            s.h(m) ? d.push(this.canonicalizeTileURL(m, h)) : d.push(m);
                        return d
                    }
                    _makeAPIURL(t, i) {
                        const h = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"
                          , d = mo(s.e.API_URL);
                        if (t.protocol = d.protocol,
                        t.authority = d.authority,
                        "http" === t.protocol) {
                            const m = t.params.indexOf("secure");
                            m >= 0 && t.params.splice(m, 1)
                        }
                        if ("/" !== d.path && (t.path = "".concat(d.path).concat(t.path)),
                        !s.e.REQUIRE_ACCESS_TOKEN)
                            return no(t);
                        if (i = i || s.e.ACCESS_TOKEN,
                        !this._silenceAuthErrors) {
                            if (!i)
                                throw new Error("An API access token is required to use Mapbox GL. ".concat(h));
                            if ("s" === i[0])
                                throw new Error("Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ".concat(h))
                        }
                        return t.params = t.params.filter(m => -1 === m.indexOf("access_token")),
                        t.params.push("access_token=".concat(i || "")),
                        no(t)
                    }
                }
                const ht = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
                function mo(c) {
                    const t = c.match(ht);
                    if (!t)
                        throw new Error("Unable to parse URL object");
                    return {
                        protocol: t[1],
                        authority: t[2],
                        path: t[3] || "/",
                        params: t[4] ? t[4].split("&") : []
                    }
                }
                function no(c) {
                    const t = c.params.length ? "?".concat(c.params.join("&")) : "";
                    return "".concat(c.protocol, "://").concat(c.authority).concat(c.path).concat(t)
                }
                const Co = "mapbox.eventData";
                function Lt(c) {
                    if (!c)
                        return null;
                    const t = c.split(".");
                    if (!t || 3 !== t.length)
                        return null;
                    try {
                        return JSON.parse(s.j(t[1]))
                    } catch {
                        return null
                    }
                }
                class Ft {
                    constructor(t) {
                        this.type = t,
                        this.anonId = null,
                        this.eventData = {},
                        this.queue = [],
                        this.pendingRequest = null
                    }
                    getStorageKey(t) {
                        const i = Lt(s.e.ACCESS_TOKEN);
                        let h = "";
                        return h = i && i.u ? s.k(i.u) : s.e.ACCESS_TOKEN || "",
                        t ? "".concat(Co, ".").concat(t, ":").concat(h) : "".concat(Co, ":").concat(h)
                    }
                    fetchEventData() {
                        const t = s.s("localStorage")
                          , i = this.getStorageKey()
                          , h = this.getStorageKey("uuid");
                        if (t)
                            try {
                                const d = localStorage.getItem(i);
                                d && (this.eventData = JSON.parse(d));
                                const m = localStorage.getItem(h);
                                m && (this.anonId = m)
                            } catch {
                                s.w("Unable to read from LocalStorage")
                            }
                    }
                    saveEventData() {
                        const t = s.s("localStorage")
                          , i = this.getStorageKey()
                          , h = this.getStorageKey("uuid")
                          , d = this.anonId;
                        if (t && d)
                            try {
                                localStorage.setItem(h, d),
                                Object.keys(this.eventData).length >= 1 && localStorage.setItem(i, JSON.stringify(this.eventData))
                            } catch {
                                s.w("Unable to write to LocalStorage")
                            }
                    }
                    processRequests(t) {}
                    postEvent(t, i, h, d) {
                        if (!s.e.EVENTS_URL)
                            return;
                        const m = mo(s.e.EVENTS_URL);
                        m.params.push("access_token=".concat(d || s.e.ACCESS_TOKEN || ""));
                        const y = {
                            event: this.type,
                            created: new Date(t).toISOString()
                        }
                          , M = i ? s.l(y, i) : y
                          , E = {
                            url: no(m),
                            headers: {
                                "Content-Type": "text/plain"
                            },
                            body: JSON.stringify([M])
                        };
                        this.pendingRequest = s.p(E, S => {
                            this.pendingRequest = null,
                            h(S),
                            this.saveEventData(),
                            this.processRequests(d)
                        }
                        )
                    }
                    queueRequest(t, i) {
                        this.queue.push(t),
                        this.processRequests(i)
                    }
                }
                const co = new class extends Ft {
                    constructor(c) {
                        super("appUserTurnstile"),
                        this._customAccessToken = c
                    }
                    postTurnstileEvent(c, t) {
                        s.e.EVENTS_URL && s.e.ACCESS_TOKEN && Array.isArray(c) && c.some(i => s.f(i) || s.h(i)) && this.queueRequest(Date.now(), t)
                    }
                    processRequests(c) {
                        if (this.pendingRequest || 0 === this.queue.length)
                            return;
                        this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
                        const t = Lt(s.e.ACCESS_TOKEN)
                          , i = t ? t.u : s.e.ACCESS_TOKEN;
                        let h = i !== this.eventData.tokenU;
                        s.v(this.anonId) || (this.anonId = s.u(),
                        h = !0);
                        const d = this.queue.shift();
                        if (this.eventData.lastSuccess) {
                            const m = new Date(this.eventData.lastSuccess)
                              , y = new Date(d)
                              , M = (d - this.eventData.lastSuccess) / 864e5;
                            h = h || M >= 1 || M < -1 || m.getDate() !== y.getDate()
                        } else
                            h = !0;
                        h ? this.postEvent(d, {
                            sdkIdentifier: "mapbox-gl-js",
                            sdkVersion: so,
                            skuId: gt,
                            "enabled.telemetry": !1,
                            userId: this.anonId
                        }, m => {
                            m || (this.eventData.lastSuccess = d,
                            this.eventData.tokenU = i)
                        }
                        , c) : this.processRequests()
                    }
                }
                  , Jt = co.postTurnstileEvent.bind(co)
                  , po = new class extends Ft {
                    constructor() {
                        super("map.load"),
                        this.success = {},
                        this.skuToken = ""
                    }
                    postMapLoadEvent(c, t, i, h) {
                        this.skuToken = t,
                        this.errorCb = h,
                        s.e.EVENTS_URL && (i || s.e.ACCESS_TOKEN ? this.queueRequest({
                            id: c,
                            timestamp: Date.now()
                        }, i) : this.errorCb(new Error(Ye)))
                    }
                    processRequests(c) {
                        if (this.pendingRequest || 0 === this.queue.length)
                            return;
                        const {id: t, timestamp: i} = this.queue.shift();
                        t && this.success[t] || (this.anonId || this.fetchEventData(),
                        s.v(this.anonId) || (this.anonId = s.u()),
                        this.postEvent(i, {
                            sdkIdentifier: "mapbox-gl-js",
                            sdkVersion: so,
                            skuId: gt,
                            skuToken: this.skuToken,
                            userId: this.anonId
                        }, h => {
                            h ? this.errorCb(h) : t && (this.success[t] = !0)
                        }
                        , c))
                    }
                    remove() {
                        this.errorCb = null
                    }
                }
                  , Et = po.postMapLoadEvent.bind(po)
                  , Kt = new class extends Ft {
                    constructor() {
                        super("style.load"),
                        this.eventIdPerMapInstanceMap = new Map,
                        this.mapInstanceIdMap = new WeakMap
                    }
                    getMapInstanceId(c) {
                        let t = this.mapInstanceIdMap.get(c);
                        return t || (t = s.u(),
                        this.mapInstanceIdMap.set(c, t)),
                        t
                    }
                    getEventId(c) {
                        const t = this.eventIdPerMapInstanceMap.get(c) || 0;
                        return this.eventIdPerMapInstanceMap.set(c, t + 1),
                        t
                    }
                    postStyleLoadEvent(c, t) {
                        const {map: i, style: h, importedStyles: d} = t;
                        if (!s.e.EVENTS_URL || !c && !s.e.ACCESS_TOKEN)
                            return;
                        const m = this.getMapInstanceId(i)
                          , y = {
                            mapInstanceId: m,
                            eventId: this.getEventId(m),
                            style: h
                        };
                        d.length && (y.importedStyles = d),
                        this.queueRequest({
                            timestamp: Date.now(),
                            payload: y
                        }, c)
                    }
                    processRequests(c) {
                        if (this.pendingRequest || 0 === this.queue.length)
                            return;
                        const {timestamp: t, payload: i} = this.queue.shift();
                        this.postEvent(t, i, () => {}
                        , c)
                    }
                }
                  , At = Kt.postStyleLoadEvent.bind(Kt)
                  , Re = new class extends Ft {
                    constructor() {
                        super("gljs.performance")
                    }
                    postPerformanceEvent(c, t) {
                        s.e.EVENTS_URL && (c || s.e.ACCESS_TOKEN) && this.queueRequest({
                            timestamp: Date.now(),
                            performanceData: t
                        }, c)
                    }
                    processRequests(c) {
                        if (this.pendingRequest || 0 === this.queue.length)
                            return;
                        const {timestamp: t, performanceData: i} = this.queue.shift()
                          , h = function(d) {
                            const m = performance.getEntriesByType("resource")
                              , y = performance.getEntriesByType("mark")
                              , M = function(k) {
                                const H = {};
                                if (k)
                                    for (const j in k)
                                        if ("other" !== j)
                                            for (const Y of k[j]) {
                                                const K = "".concat(j, "ResolveRangeMin")
                                                  , he = "".concat(j, "ResolveRangeMax")
                                                  , Te = "".concat(j, "RequestCount")
                                                  , be = "".concat(j, "RequestCachedCount");
                                                H[K] = Math.min(H[K] || 1 / 0, Y.startTime),
                                                H[he] = Math.max(H[he] || -1 / 0, Y.responseEnd);
                                                const Ue = De => {
                                                    void 0 === H[De] && (H[De] = 0),
                                                    ++H[De]
                                                }
                                                ;
                                                void 0 !== Y.transferSize && 0 === Y.transferSize && Ue(be),
                                                Ue(Te)
                                            }
                                return H
                            }(function(k, H) {
                                const j = {};
                                if (k)
                                    for (const Y of k) {
                                        const K = H(Y);
                                        void 0 === j[K] && (j[K] = []),
                                        j[K].push(Y)
                                    }
                                return j
                            }(m, Ae))
                              , E = window.devicePixelRatio
                              , S = navigator.connection || navigator.mozConnection || navigator.webkitConnection
                              , I = S ? S.effectiveType : void 0
                              , R = {
                                counters: [],
                                metadata: [],
                                attributes: []
                            }
                              , D = (k, H, j) => {
                                null != j && k.push({
                                    name: H,
                                    value: j.toString()
                                })
                            }
                            ;
                            for (const k in M)
                                D(R.counters, k, M[k]);
                            if (d.interactionRange[0] !== 1 / 0 && d.interactionRange[1] !== -1 / 0 && (D(R.counters, "interactionRangeMin", d.interactionRange[0]),
                            D(R.counters, "interactionRangeMax", d.interactionRange[1])),
                            y)
                                for (const k of Object.keys(Wt)) {
                                    const H = Wt[k]
                                      , j = y.find(Y => Y.name === H);
                                    j && D(R.counters, H, j.startTime)
                                }
                            return D(R.counters, "visibilityHidden", d.visibilityHidden),
                            D(R.attributes, "style", function(k) {
                                if (k)
                                    for (const H of k) {
                                        const j = H.name.split("?")[0];
                                        if (s.i(j)) {
                                            const Y = j.split("/").slice(-2);
                                            if (2 === Y.length)
                                                return "mapbox://styles/".concat(Y[0], "/").concat(Y[1])
                                        }
                                    }
                            }(m)),
                            D(R.attributes, "terrainEnabled", d.terrainEnabled ? "true" : "false"),
                            D(R.attributes, "fogEnabled", d.fogEnabled ? "true" : "false"),
                            D(R.attributes, "projection", d.projection),
                            D(R.attributes, "zoom", d.zoom),
                            D(R.metadata, "devicePixelRatio", E),
                            D(R.metadata, "connectionEffectiveType", I),
                            D(R.metadata, "navigatorUserAgent", navigator.userAgent),
                            D(R.metadata, "screenWidth", window.screen.width),
                            D(R.metadata, "screenHeight", window.screen.height),
                            D(R.metadata, "windowWidth", window.innerWidth),
                            D(R.metadata, "windowHeight", window.innerHeight),
                            D(R.metadata, "mapWidth", d.width / E),
                            D(R.metadata, "mapHeight", d.height / E),
                            D(R.metadata, "webglRenderer", d.renderer),
                            D(R.metadata, "webglVendor", d.vendor),
                            D(R.metadata, "sdkVersion", so),
                            D(R.metadata, "sdkIdentifier", "mapbox-gl-js"),
                            R
                        }(i);
                        for (const d of h.metadata)
                            ;
                        for (const d of h.counters)
                            ;
                        for (const d of h.attributes)
                            ;
                        this.postEvent(t, h, () => {}
                        , c)
                    }
                }
                  , ve = Re.postPerformanceEvent.bind(Re)
                  , ne = new class extends Ft {
                    constructor() {
                        super("map.auth"),
                        this.success = {},
                        this.skuToken = ""
                    }
                    getSession(c, t, i, h) {
                        if (!s.e.API_URL || !s.e.SESSION_PATH)
                            return;
                        const d = mo(s.e.API_URL + s.e.SESSION_PATH);
                        d.params.push("sku=".concat(t || "")),
                        d.params.push("access_token=".concat(h || s.e.ACCESS_TOKEN || ""));
                        const m = {
                            url: no(d),
                            headers: {
                                "Content-Type": "text/plain"
                            }
                        };
                        this.pendingRequest = s.g(m, y => {
                            this.pendingRequest = null,
                            i(y),
                            this.saveEventData(),
                            this.processRequests(h)
                        }
                        )
                    }
                    getSessionAPI(c, t, i, h) {
                        this.skuToken = t,
                        this.errorCb = h,
                        s.e.SESSION_PATH && s.e.API_URL && (i || s.e.ACCESS_TOKEN ? this.queueRequest({
                            id: c,
                            timestamp: Date.now()
                        }, i) : this.errorCb(new Error(Ye)))
                    }
                    processRequests(c) {
                        if (this.pendingRequest || 0 === this.queue.length)
                            return;
                        const {id: t, timestamp: i} = this.queue.shift();
                        t && this.success[t] || this.getSession(i, this.skuToken, h => {
                            h ? this.errorCb(h) : t && (this.success[t] = !0)
                        }
                        , c)
                    }
                    remove() {
                        this.errorCb = null
                    }
                }
                  , B = ne.getSessionAPI.bind(ne)
                  , de = new Set;
                function lt(c, t) {
                    t ? de.add(c) : de.delete(c)
                }
                class St {
                    constructor() {
                        this._changed = !1,
                        this._updatedLayers = {},
                        this._removedLayers = {},
                        this._updatedSourceCaches = {},
                        this._updatedPaintProps = new Set,
                        this._updatedImages = new Set
                    }
                    isDirty() {
                        return this._changed
                    }
                    setDirty() {
                        this._changed = !0
                    }
                    getUpdatedSourceCaches() {
                        return this._updatedSourceCaches
                    }
                    updateSourceCache(t, i) {
                        this._updatedSourceCaches[t] = i,
                        this.setDirty()
                    }
                    discardSourceCacheUpdate(t) {
                        delete this._updatedSourceCaches[t]
                    }
                    updateLayer(t) {
                        const i = t.scope;
                        this._updatedLayers[i] = this._updatedLayers[i] || new Set,
                        this._updatedLayers[i].add(t.id),
                        this.setDirty()
                    }
                    removeLayer(t) {
                        const i = t.scope;
                        this._removedLayers[i] = this._removedLayers[i] || {},
                        this._updatedLayers[i] = this._updatedLayers[i] || new Set,
                        this._removedLayers[i][t.id] = t,
                        this._updatedLayers[i].delete(t.id),
                        this._updatedPaintProps.delete(t.fqid),
                        this.setDirty()
                    }
                    getRemovedLayer(t) {
                        return this._removedLayers[t.scope] ? this._removedLayers[t.scope][t.id] : null
                    }
                    discardLayerRemoval(t) {
                        this._removedLayers[t.scope] && delete this._removedLayers[t.scope][t.id]
                    }
                    getLayerUpdatesByScope() {
                        const t = {};
                        for (const i in this._updatedLayers)
                            t[i] = t[i] || {},
                            t[i].updatedIds = Array.from(this._updatedLayers[i].values());
                        for (const i in this._removedLayers)
                            t[i] = t[i] || {},
                            t[i].removedIds = Object.keys(this._removedLayers[i]);
                        return t
                    }
                    getUpdatedPaintProperties() {
                        return this._updatedPaintProps
                    }
                    updatePaintProperties(t) {
                        this._updatedPaintProps.add(t.fqid),
                        this.setDirty()
                    }
                    getUpdatedImages() {
                        return Array.from(this._updatedImages.values())
                    }
                    updateImage(t) {
                        this._updatedImages.add(t),
                        this.setDirty()
                    }
                    resetUpdatedImages() {
                        this._updatedImages.clear()
                    }
                    reset() {
                        this._changed = !1,
                        this._updatedLayers = {},
                        this._removedLayers = {},
                        this._updatedSourceCaches = {},
                        this._updatedPaintProps.clear(),
                        this._updatedImages.clear()
                    }
                }
                function tt(c) {
                    const {userImage: t} = c;
                    return !!(t && t.render && t.render()) && (c.data.replace(new Uint8Array(t.data.buffer)),
                    !0)
                }
                class $t extends s.E {
                    constructor(t) {
                        super(),
                        this.images = {},
                        this.updatedImages = {},
                        this.callbackDispatchedThisFrame = {},
                        this.loaded = {},
                        this.requestors = [],
                        this.patterns = {},
                        this.atlasImage = {},
                        this.atlasTexture = {},
                        this.dirty = !0,
                        this.spriteFormat = t,
                        "raster" !== t && s.t() && (this.imageRasterizerDispatcher = new s.D(s.x(),this,"Image Rasterizer Worker",1))
                    }
                    get imageRasterizer() {
                        return this._imageRasterizer || (this._imageRasterizer = new s.I),
                        this._imageRasterizer
                    }
                    createScope(t) {
                        this.images[t] = {},
                        this.loaded[t] = !1,
                        this.updatedImages[t] = {},
                        this.patterns[t] = {},
                        this.callbackDispatchedThisFrame[t] = {},
                        this.atlasImage[t] = new s.r({
                            width: 1,
                            height: 1
                        })
                    }
                    isLoaded() {
                        for (const t in this.loaded)
                            if (!this.loaded[t])
                                return !1;
                        return !0
                    }
                    setLoaded(t, i) {
                        if (this.loaded[i] !== t && (this.loaded[i] = t,
                        t)) {
                            for (const {ids: h, callback: d} of this.requestors)
                                this._notify(h, i, d);
                            this.requestors = []
                        }
                    }
                    hasImage(t, i) {
                        return !!this.getImage(t, i)
                    }
                    getImage(t, i) {
                        return this.images[i][t]
                    }
                    addImage(t, i, h) {
                        this._validate(t, h) && (this.images[i][t] = h)
                    }
                    _validate(t, i) {
                        let h = !0;
                        return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new s.y(new Error('Image "'.concat(t, '" has invalid "stretchX" value')))),
                        h = !1),
                        this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new s.y(new Error('Image "'.concat(t, '" has invalid "stretchY" value')))),
                        h = !1),
                        this._validateContent(i.content, i) || (this.fire(new s.y(new Error('Image "'.concat(t, '" has invalid "content" value')))),
                        h = !1),
                        h
                    }
                    _validateStretch(t, i) {
                        if (!t)
                            return !0;
                        let h = 0;
                        for (const d of t) {
                            if (d[0] < h || d[1] < d[0] || i < d[1])
                                return !1;
                            h = d[1]
                        }
                        return !0
                    }
                    _validateContent(t, i) {
                        return !t || !(4 !== t.length || !i.usvg && (t[0] < 0 || i.data.width < t[0] || t[1] < 0 || i.data.height < t[1] || t[2] < 0 || i.data.width < t[2] || t[3] < 0 || i.data.height < t[3])) && !(t[2] < t[0] || t[3] < t[1])
                    }
                    updateImage(t, i, h) {
                        h.version = this.images[i][t].version + 1,
                        this.images[i][t] = h,
                        this.updatedImages[i][t] = !0,
                        this.removeFromImageRasterizerCache(t, i)
                    }
                    removeFromImageRasterizerCache(t, i) {
                        "raster" !== this.spriteFormat && (s.t() ? this.imageRasterizerDispatcher.getActor().send("removeRasterizedImages", {
                            imageIds: [t],
                            scope: i
                        }) : this.imageRasterizer.removeImagesFromCacheByIds([t], i))
                    }
                    removeImage(t, i) {
                        const h = this.images[i][t];
                        delete this.images[i][t],
                        delete this.patterns[i][t],
                        this.removeFromImageRasterizerCache(t, i),
                        h.userImage && h.userImage.onRemove && h.userImage.onRemove()
                    }
                    listImages(t) {
                        return Object.keys(this.images[t])
                    }
                    getImages(t, i, h) {
                        let d = !0;
                        const m = !!this.loaded[i];
                        if (!m)
                            for (const y of t)
                                this.images[i][y] || (d = !1);
                        m || d ? this._notify(t, i, h) : this.requestors.push({
                            ids: t,
                            scope: i,
                            callback: h
                        })
                    }
                    rasterizeImages({scope: t, imageTasks: i}, h) {
                        const d = {};
                        for (const m in i) {
                            const y = i[m]
                              , M = this.getImage(y.id, t);
                            M && (d[m] = {
                                image: M,
                                imageIdWithOptions: y
                            })
                        }
                        s.t() ? this.imageRasterizerDispatcher.getActor().send("rasterizeImages", {
                            imageTasks: d,
                            scope: t
                        }, h) : this.rasterizeImagesInMainThread({
                            imageTasks: d,
                            scope: t
                        }, h)
                    }
                    rasterizeImagesInMainThread(t, i) {
                        const {imageTasks: h, scope: d} = t
                          , m = {};
                        for (const y in h) {
                            const {image: M, imageIdWithOptions: E} = h[y];
                            m[y] = this.imageRasterizer.rasterize(E, M, d, "")
                        }
                        i(void 0, m)
                    }
                    getUpdatedImages(t) {
                        return this.updatedImages[t]
                    }
                    _notify(t, i, h) {
                        const d = {};
                        for (const m of t) {
                            this.images[i][m] || this.fire(new s.z("styleimagemissing",{
                                id: m
                            }));
                            const y = this.images[i][m];
                            y ? d[m] = {
                                data: y.usvg ? null : y.data.clone(),
                                pixelRatio: y.pixelRatio,
                                sdf: y.sdf,
                                usvg: y.usvg,
                                version: y.version,
                                stretchX: y.stretchX,
                                stretchY: y.stretchY,
                                content: y.content,
                                hasRenderCallback: !(!y.userImage || !y.userImage.render)
                            } : s.w('Image "'.concat(m, '" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.'))
                        }
                        h(null, d)
                    }
                    getPixelSize(t) {
                        const {width: i, height: h} = this.atlasImage[t];
                        return {
                            width: i,
                            height: h
                        }
                    }
                    getPattern(t, i, h) {
                        const d = this.patterns[i][t]
                          , m = this.getImage(t, i);
                        if (!m)
                            return null;
                        if (d && d.position.version === m.version)
                            return d.position;
                        if (d)
                            d.position.version = m.version;
                        else {
                            m.usvg && !m.data && (m.data = this.imageRasterizer.rasterize(s.A.from(t).getPrimary(), m, i, ""));
                            const y = {
                                w: m.data.width + 2 * s.B,
                                h: m.data.height + 2 * s.B,
                                x: 0,
                                y: 0
                            }
                              , M = new s.F(y,m,s.B);
                            this.patterns[i][t] = {
                                bin: y,
                                position: M
                            }
                        }
                        return this._updatePatternAtlas(i, h),
                        this.patterns[i][t].position
                    }
                    bind(t, i) {
                        const h = t.gl;
                        let d = this.atlasTexture[i];
                        d ? this.dirty && (d.update(this.atlasImage[i]),
                        this.dirty = !1) : (d = new s.T(t,this.atlasImage[i],h.RGBA8),
                        this.atlasTexture[i] = d),
                        d.bind(h.LINEAR, h.CLAMP_TO_EDGE)
                    }
                    _updatePatternAtlas(t, i) {
                        const h = [];
                        for (const M in this.patterns[t])
                            h.push(this.patterns[t][M].bin);
                        const {w: d, h: m} = s.C(h)
                          , y = this.atlasImage[t];
                        y.resize({
                            width: d || 1,
                            height: m || 1
                        });
                        for (const M in this.patterns[t]) {
                            const {bin: E, position: S} = this.patterns[t][M];
                            let I = S.padding;
                            const R = E.x + I
                              , D = E.y + I
                              , k = this.images[t][M].data
                              , H = k.width
                              , j = k.height;
                            I = I > 1 ? I - 1 : I,
                            s.r.copy(k, y, {
                                x: 0,
                                y: 0
                            }, {
                                x: R,
                                y: D
                            }, {
                                width: H,
                                height: j
                            }, i),
                            s.r.copy(k, y, {
                                x: 0,
                                y: j - I
                            }, {
                                x: R,
                                y: D - I
                            }, {
                                width: H,
                                height: I
                            }, i),
                            s.r.copy(k, y, {
                                x: 0,
                                y: 0
                            }, {
                                x: R,
                                y: D + j
                            }, {
                                width: H,
                                height: I
                            }, i),
                            s.r.copy(k, y, {
                                x: H - I,
                                y: 0
                            }, {
                                x: R - I,
                                y: D
                            }, {
                                width: I,
                                height: j
                            }, i),
                            s.r.copy(k, y, {
                                x: 0,
                                y: 0
                            }, {
                                x: R + H,
                                y: D
                            }, {
                                width: I,
                                height: j
                            }, i),
                            s.r.copy(k, y, {
                                x: H - I,
                                y: j - I
                            }, {
                                x: R - I,
                                y: D - I
                            }, {
                                width: I,
                                height: I
                            }, i),
                            s.r.copy(k, y, {
                                x: 0,
                                y: j - I
                            }, {
                                x: R + H,
                                y: D - I
                            }, {
                                width: I,
                                height: I
                            }, i),
                            s.r.copy(k, y, {
                                x: 0,
                                y: 0
                            }, {
                                x: R + H,
                                y: D + j
                            }, {
                                width: I,
                                height: I
                            }, i),
                            s.r.copy(k, y, {
                                x: H - I,
                                y: 0
                            }, {
                                x: R - I,
                                y: D + j
                            }, {
                                width: I,
                                height: I
                            }, i)
                        }
                        this.dirty = !0
                    }
                    beginFrame() {
                        for (const t in this.images)
                            this.callbackDispatchedThisFrame[t] = {}
                    }
                    dispatchRenderCallbacks(t, i) {
                        for (const h of t) {
                            if (this.callbackDispatchedThisFrame[i][h])
                                continue;
                            this.callbackDispatchedThisFrame[i][h] = !0;
                            const d = this.images[i][h];
                            tt(d) && this.updateImage(h, i, d)
                        }
                    }
                }
                function Nt(c) {
                    const t = c.key
                      , i = c.value
                      , h = c.valueSpec || {}
                      , d = c.objectElementValidators || {}
                      , m = c.style
                      , y = c.styleSpec;
                    let M = [];
                    const E = s.H(i);
                    if ("object" !== E)
                        return [new s.V(t,i,"object expected, ".concat(E, " found"))];
                    for (const S in i) {
                        const I = S.split(".")[0];
                        let R;
                        d[I] ? R = d[I] : h[I] ? R = vo : d["*"] ? R = d["*"] : h["*"] && (R = vo),
                        R ? M = M.concat(R({
                            key: (t && "".concat(t, ".")) + S,
                            value: i[S],
                            valueSpec: h[I] || h["*"],
                            style: m,
                            styleSpec: y,
                            object: i,
                            objectKey: S
                        }, i)) : M.push(new s.G(t,i[S],'unknown property "'.concat(S, '"')))
                    }
                    for (const S in h)
                        d[S] || h[S].required && void 0 === h[S].default && void 0 === i[S] && M.push(new s.V(t,i,'missing required property "'.concat(S, '"')));
                    return M
                }
                function Vt(c) {
                    const t = c.value
                      , i = c.valueSpec
                      , h = c.style
                      , d = c.styleSpec
                      , m = c.key
                      , y = c.arrayElementValidator || vo;
                    if ("array" !== s.H(t))
                        return [new s.V(m,t,"array expected, ".concat(s.H(t), " found"))];
                    if (i.length && t.length !== i.length)
                        return [new s.V(m,t,"array length ".concat(i.length, " expected, length ").concat(t.length, " found"))];
                    if (i["min-length"] && t.length < i["min-length"])
                        return [new s.V(m,t,"array length at least ".concat(i["min-length"], " expected, length ").concat(t.length, " found"))];
                    let M = {
                        type: i.value,
                        values: i.values,
                        minimum: i.minimum,
                        maximum: i.maximum,
                        function: void 0
                    };
                    d.$version < 7 && (M.function = i.function),
                    "object" === s.H(i.value) && (M = i.value);
                    let E = [];
                    for (let S = 0; S < t.length; S++)
                        E = E.concat(y({
                            array: t,
                            arrayIndex: S,
                            value: t[S],
                            valueSpec: M,
                            style: h,
                            styleSpec: d,
                            key: "".concat(m, "[").concat(S, "]")
                        }, !0));
                    return E
                }
                function _o(c) {
                    const t = c.key
                      , i = c.value
                      , h = c.valueSpec;
                    let d = s.H(i);
                    if ("number" === d && i != i && (d = "NaN"),
                    "number" !== d)
                        return [new s.V(t,i,"number expected, ".concat(d, " found"))];
                    if ("minimum"in h) {
                        let m = h.minimum;
                        if ("array" === s.H(h.minimum) && (m = h.minimum[c.arrayIndex]),
                        i < m)
                            return [new s.V(t,i,"".concat(i, " is less than the minimum value ").concat(m))]
                    }
                    if ("maximum"in h) {
                        let m = h.maximum;
                        if ("array" === s.H(h.maximum) && (m = h.maximum[c.arrayIndex]),
                        i > m)
                            return [new s.V(t,i,"".concat(i, " is greater than the maximum value ").concat(m))]
                    }
                    return []
                }
                function Lo(c) {
                    const t = c.valueSpec
                      , i = s.K(c.value.type);
                    let h, d, m, y = {};
                    const M = "categorical" !== i && void 0 === c.value.property
                      , E = !M
                      , S = "array" === s.H(c.value.stops) && "array" === s.H(c.value.stops[0]) && "object" === s.H(c.value.stops[0][0])
                      , I = Nt({
                        key: c.key,
                        value: c.value,
                        valueSpec: c.styleSpec.function,
                        style: c.style,
                        styleSpec: c.styleSpec,
                        objectElementValidators: {
                            stops: function(k) {
                                if ("identity" === i)
                                    return [new s.V(k.key,k.value,'identity function may not have a "stops" property')];
                                let H = [];
                                const j = k.value;
                                return H = H.concat(Vt({
                                    key: k.key,
                                    value: j,
                                    valueSpec: k.valueSpec,
                                    style: k.style,
                                    styleSpec: k.styleSpec,
                                    arrayElementValidator: R
                                })),
                                "array" === s.H(j) && 0 === j.length && H.push(new s.V(k.key,j,"array must have at least one stop")),
                                H
                            },
                            default: function(k) {
                                return vo({
                                    key: k.key,
                                    value: k.value,
                                    valueSpec: t,
                                    style: k.style,
                                    styleSpec: k.styleSpec
                                })
                            }
                        }
                    });
                    return "identity" === i && M && I.push(new s.V(c.key,c.value,'missing required property "property"')),
                    "identity" === i || c.value.stops || I.push(new s.V(c.key,c.value,'missing required property "stops"')),
                    "exponential" === i && c.valueSpec.expression && !s.L(c.valueSpec) && I.push(new s.V(c.key,c.value,"exponential functions not supported")),
                    c.styleSpec.$version >= 8 && (E && !s.M(c.valueSpec) ? I.push(new s.V(c.key,c.value,"property functions not supported")) : M && !s.N(c.valueSpec) && I.push(new s.V(c.key,c.value,"zoom functions not supported"))),
                    "categorical" !== i && !S || void 0 !== c.value.property || I.push(new s.V(c.key,c.value,'"property" property is required')),
                    I;
                    function R(k) {
                        let H = [];
                        const j = k.value
                          , Y = k.key;
                        if ("array" !== s.H(j))
                            return [new s.V(Y,j,"array expected, ".concat(s.H(j), " found"))];
                        if (2 !== j.length)
                            return [new s.V(Y,j,"array length 2 expected, length ".concat(j.length, " found"))];
                        if (S) {
                            if ("object" !== s.H(j[0]))
                                return [new s.V(Y,j,"object expected, ".concat(s.H(j[0]), " found"))];
                            if (void 0 === j[0].zoom)
                                return [new s.V(Y,j,"object stop key must have zoom")];
                            if (void 0 === j[0].value)
                                return [new s.V(Y,j,"object stop key must have value")];
                            const K = s.K(j[0].zoom);
                            if ("number" != typeof K)
                                return [new s.V(Y,j[0].zoom,"stop zoom values must be numbers")];
                            if (m && m > K)
                                return [new s.V(Y,j[0].zoom,"stop zoom values must appear in ascending order")];
                            K !== m && (m = K,
                            d = void 0,
                            y = {}),
                            H = H.concat(Nt({
                                key: "".concat(Y, "[0]"),
                                value: j[0],
                                valueSpec: {
                                    zoom: {}
                                },
                                style: k.style,
                                styleSpec: k.styleSpec,
                                objectElementValidators: {
                                    zoom: _o,
                                    value: D
                                }
                            }))
                        } else
                            H = H.concat(D({
                                key: "".concat(Y, "[0]"),
                                value: j[0],
                                valueSpec: {},
                                style: k.style,
                                styleSpec: k.styleSpec
                            }, j));
                        return s.O(s.Q(j[1])) ? H.concat([new s.V("".concat(Y, "[1]"),j[1],"expressions are not allowed in function stops.")]) : H.concat(vo({
                            key: "".concat(Y, "[1]"),
                            value: j[1],
                            valueSpec: t,
                            style: k.style,
                            styleSpec: k.styleSpec
                        }))
                    }
                    function D(k, H) {
                        const j = s.H(k.value)
                          , Y = s.K(k.value)
                          , K = null !== k.value ? k.value : H;
                        if (h) {
                            if (j !== h)
                                return [new s.V(k.key,K,"".concat(j, " stop domain type must match previous stop domain type ").concat(h))]
                        } else
                            h = j;
                        if ("number" !== j && "string" !== j && "boolean" !== j && "number" != typeof Y && "string" != typeof Y && "boolean" != typeof Y)
                            return [new s.V(k.key,K,"stop domain value must be a number, string, or boolean")];
                        if ("number" !== j && "categorical" !== i) {
                            let he = "number expected, ".concat(j, " found");
                            return s.M(t) && void 0 === i && (he += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),
                            [new s.V(k.key,K,he)]
                        }
                        return "categorical" !== i || "number" !== j || "number" == typeof Y && isFinite(Y) && Math.floor(Y) === Y ? "categorical" !== i && "number" === j && "number" == typeof Y && "number" == typeof d && void 0 !== d && Y < d ? [new s.V(k.key,K,"stop domain values must appear in ascending order")] : (d = Y,
                        "categorical" === i && Y in y ? [new s.V(k.key,K,"stop domain values must be unique")] : (y[Y] = !0,
                        [])) : [new s.V(k.key,K,"integer expected, found ".concat(String(Y)))]
                    }
                }
                function ao(c) {
                    const t = ("property" === c.expressionContext ? s.S : s.U)(s.Q(c.value), c.valueSpec);
                    if ("error" === t.result)
                        return t.value.map(h => new s.V("".concat(c.key).concat(h.key),c.value,h.message));
                    const i = t.value.expression || t.value._styleExpression.expression;
                    if ("property" === c.expressionContext && "text-font" === c.propertyKey && !i.outputDefined())
                        return [new s.V(c.key,c.value,'Invalid data expression for "'.concat(c.propertyKey, '". Output values must be contained as literals within the expression.'))];
                    if ("property" === c.expressionContext && "layout" === c.propertyType && !s.W(i))
                        return [new s.V(c.key,c.value,'"feature-state" data expressions are not supported with layout properties.')];
                    if ("filter" === c.expressionContext)
                        return bt(i, c);
                    if (c.expressionContext && 0 === c.expressionContext.indexOf("cluster")) {
                        if (!s.X(i, ["zoom", "feature-state"]))
                            return [new s.V(c.key,c.value,'"zoom" and "feature-state" expressions are not supported with cluster properties.')];
                        if ("cluster-initial" === c.expressionContext && !s.Y(i))
                            return [new s.V(c.key,c.value,"Feature data expressions are not supported with initial expression part of cluster properties.")]
                    }
                    return []
                }
                function bt(c, t) {
                    const i = new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
                    if (t.valueSpec && t.valueSpec.expression)
                        for (const d of t.valueSpec.expression.parameters)
                            i.delete(d);
                    if (0 === i.size)
                        return [];
                    const h = [];
                    return c instanceof s.Z && i.has(c.name) ? [new s.V(t.key,t.value,'["'.concat(c.name, '"] expression is not supported in a filter for a ').concat(t.object.type, " layer with id: ").concat(t.object.id))] : (c.eachChild(d => {
                        h.push(...bt(d, t))
                    }
                    ),
                    h)
                }
                function Do(c) {
                    const t = c.key
                      , i = c.value
                      , h = c.valueSpec
                      , d = [];
                    return Array.isArray(h.values) ? -1 === h.values.indexOf(s.K(i)) && d.push(new s.V(t,i,"expected one of [".concat(h.values.join(", "), "], ").concat(JSON.stringify(i), " found"))) : -1 === Object.keys(h.values).indexOf(s.K(i)) && d.push(new s.V(t,i,"expected one of [".concat(Object.keys(h.values).join(", "), "], ").concat(JSON.stringify(i), " found"))),
                    d
                }
                function Xt(c) {
                    return s.$(s.Q(c.value)) ? ao(s.J({}, c, {
                        expressionContext: "filter",
                        valueSpec: c.styleSpec["filter_".concat(c.layerType || "fill")]
                    })) : ie(c)
                }
                function ie(c) {
                    const t = c.value
                      , i = c.key;
                    if ("array" !== s.H(t))
                        return [new s.V(i,t,"array expected, ".concat(s.H(t), " found"))];
                    const h = c.styleSpec;
                    let d, m = [];
                    if (t.length < 1)
                        return [new s.V(i,t,"filter array must have at least 1 element")];
                    switch (m = m.concat(Do({
                        key: "".concat(i, "[0]"),
                        value: t[0],
                        valueSpec: h.filter_operator,
                        style: c.style,
                        styleSpec: c.styleSpec
                    })),
                    s.K(t[0])) {
                    case "<":
                    case "<=":
                    case ">":
                    case ">=":
                        t.length >= 2 && "$type" === s.K(t[1]) && m.push(new s.V(i,t,'"$type" cannot be use with operator "'.concat(t[0], '"')));
                    case "==":
                    case "!=":
                        3 !== t.length && m.push(new s.V(i,t,'filter array for operator "'.concat(t[0], '" must have 3 elements')));
                    case "in":
                    case "!in":
                        t.length >= 2 && (d = s.H(t[1]),
                        "string" !== d && m.push(new s.V("".concat(i, "[1]"),t[1],"string expected, ".concat(d, " found"))));
                        for (let y = 2; y < t.length; y++)
                            d = s.H(t[y]),
                            "$type" === s.K(t[1]) ? m = m.concat(Do({
                                key: "".concat(i, "[").concat(y, "]"),
                                value: t[y],
                                valueSpec: h.geometry_type,
                                style: c.style,
                                styleSpec: c.styleSpec
                            })) : "string" !== d && "number" !== d && "boolean" !== d && m.push(new s.V("".concat(i, "[").concat(y, "]"),t[y],"string, number, or boolean expected, ".concat(d, " found")));
                        break;
                    case "any":
                    case "all":
                    case "none":
                        for (let y = 1; y < t.length; y++)
                            m = m.concat(ie({
                                key: "".concat(i, "[").concat(y, "]"),
                                value: t[y],
                                style: c.style,
                                styleSpec: c.styleSpec
                            }));
                        break;
                    case "has":
                    case "!has":
                        d = s.H(t[1]),
                        2 !== t.length ? m.push(new s.V(i,t,'filter array for "'.concat(t[0], '" operator must have 2 elements'))) : "string" !== d && m.push(new s.V("".concat(i, "[1]"),t[1],"string expected, ".concat(d, " found")))
                    }
                    return m
                }
                function we(c, t) {
                    const i = c.key
                      , h = c.style
                      , d = c.layer
                      , m = c.styleSpec
                      , y = c.value
                      , M = c.objectKey
                      , E = m["".concat(t, "_").concat(c.layerType)];
                    if (!E)
                        return [];
                    const S = M.match(/^(.*)-use-theme$/);
                    if ("paint" === t && S && E[S[1]])
                        return vo({
                            key: i,
                            value: y,
                            valueSpec: {
                                type: "string"
                            },
                            style: h,
                            styleSpec: m
                        });
                    const I = M.match(/^(.*)-transition$/);
                    if ("paint" === t && I && E[I[1]] && E[I[1]].transition)
                        return vo({
                            key: i,
                            value: y,
                            valueSpec: m.transition,
                            style: h,
                            styleSpec: m
                        });
                    const R = c.valueSpec || E[M];
                    if (!R)
                        return [new s.G(i,y,'unknown property "'.concat(M, '"'))];
                    let D;
                    if ("string" === s.H(y) && s.M(R) && !R.tokens && (D = /^{([^}]+)}$/.exec(y))) {
                        const H = '`{ "type": "identity", "property": '.concat(D ? JSON.stringify(D[1]) : '"_"', " }`");
                        return [new s.V(i,y,'"'.concat(M, '" does not support interpolation syntax\nUse an identity property function instead: ').concat(H, "."))]
                    }
                    const k = [];
                    if ("symbol" === c.layerType)
                        "text-field" !== M || !h || h.glyphs || h.imports || k.push(new s.V(i,y,'use of "text-field" requires a style "glyphs" property')),
                        "text-font" === M && s.a0(s.Q(y)) && "identity" === s.K(y.type) && k.push(new s.V(i,y,'"text-font" does not support identity functions'));
                    else if ("model" === c.layerType && "paint" === t && d && d.layout && d.layout.hasOwnProperty("model-id") && s.M(R) && (s.a1(R) || s.N(R))) {
                        const H = s.S(s.Q(y), R)
                          , j = H.value.expression || H.value._styleExpression.expression;
                        j && !s.X(j, ["measure-light"]) && ("model-emissive-strength" === M && s.Y(j) && s.W(j) || k.push(new s.V(i,y,"".concat(M, " does not support measure-light expressions when the model layer source is vector tile or GeoJSON."))))
                    }
                    return k.concat(vo({
                        key: c.key,
                        value: y,
                        valueSpec: R,
                        style: h,
                        styleSpec: m,
                        expressionContext: "property",
                        propertyType: t,
                        propertyKey: M
                    }))
                }
                function Oe(c) {
                    return we(c, "paint")
                }
                function ee(c) {
                    return we(c, "layout")
                }
                function W(c) {
                    let t = [];
                    const i = c.value
                      , h = c.key
                      , d = c.style
                      , m = c.styleSpec;
                    i.type || i.ref || t.push(new s.V(h,i,'either "type" or "ref" is required'));
                    let y = s.K(i.type);
                    const M = s.K(i.ref);
                    if (i.id) {
                        const E = s.K(i.id);
                        for (let S = 0; S < c.arrayIndex; S++) {
                            const I = d.layers[S];
                            s.K(I.id) === E && t.push(new s.V(h,i.id,'duplicate layer id "'.concat(i.id, '", previously used at line ').concat(I.id.__line__)))
                        }
                    }
                    if ("ref"in i) {
                        let E;
                        ["type", "source", "source-layer", "filter", "layout"].forEach(S => {
                            S in i && t.push(new s.V(h,i[S],'"'.concat(S, '" is prohibited for ref layers')))
                        }
                        ),
                        d.layers.forEach(S => {
                            s.K(S.id) === M && (E = S)
                        }
                        ),
                        E ? E.ref ? t.push(new s.V(h,i.ref,"ref cannot reference another ref layer")) : y = s.K(E.type) : "string" == typeof M && t.push(new s.V(h,i.ref,'ref layer "'.concat(M, '" not found')))
                    } else if ("background" !== y && "sky" !== y && "slot" !== y)
                        if (i.source) {
                            const E = d.sources && d.sources[i.source]
                              , S = E && s.K(E.type);
                            E ? "vector" === S && "raster" === y ? t.push(new s.V(h,i.source,'layer "'.concat(i.id, '" requires a raster source'))) : "raster" === S && "raster" !== y ? t.push(new s.V(h,i.source,'layer "'.concat(i.id, '" requires a vector source'))) : "vector" !== S || i["source-layer"] ? "raster-dem" === S && "hillshade" !== y ? t.push(new s.V(h,i.source,"raster-dem source can only be used with layer type 'hillshade'.")) : "raster-array" !== S || ["raster", "raster-particle"].includes(y) ? "line" !== y || !i.paint || !i.paint["line-gradient"] && !i.paint["line-trim-offset"] || "geojson" === S && E.lineMetrics ? "raster-particle" === y && "raster-array" !== S && t.push(new s.V(h,i.source,'layer "'.concat(i.id, "\" requires a 'raster-array' source."))) : t.push(new s.V(h,i,'layer "'.concat(i.id, '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.'))) : t.push(new s.V(h,i.source,"raster-array source can only be used with layer type 'raster'.")) : t.push(new s.V(h,i,'layer "'.concat(i.id, '" must specify a "source-layer"'))) : t.push(new s.V(h,i.source,'source "'.concat(i.source, '" not found')))
                        } else
                            t.push(new s.V(h,i,'missing required property "source"'));
                    return t = t.concat(Nt({
                        key: h,
                        value: i,
                        valueSpec: m.layer,
                        style: c.style,
                        styleSpec: c.styleSpec,
                        objectElementValidators: {
                            "*": () => [],
                            type: () => vo({
                                key: "".concat(h, ".type"),
                                value: i.type,
                                valueSpec: m.layer.type,
                                style: c.style,
                                styleSpec: c.styleSpec,
                                object: i,
                                objectKey: "type"
                            }),
                            filter: E => Xt(s.J({
                                layerType: y
                            }, E)),
                            layout: E => Nt({
                                layer: i,
                                key: E.key,
                                value: E.value,
                                valueSpec: {},
                                style: E.style,
                                styleSpec: E.styleSpec,
                                objectElementValidators: {
                                    "*": S => ee(s.J({
                                        layerType: y
                                    }, S))
                                }
                            }),
                            paint: E => Nt({
                                layer: i,
                                key: E.key,
                                value: E.value,
                                valueSpec: {},
                                style: E.style,
                                styleSpec: E.styleSpec,
                                objectElementValidators: {
                                    "*": S => Oe(s.J({
                                        layerType: y,
                                        layer: i
                                    }, S))
                                }
                            })
                        }
                    })),
                    t
                }
                function ae(c) {
                    const t = c.value
                      , i = c.key
                      , h = s.H(t);
                    return "string" !== h ? [new s.V(i,t,"string expected, ".concat(h, " found"))] : []
                }
                const Ve = {
                    promoteId: function({key: c, value: t}) {
                        if ("string" === s.H(t))
                            return ae({
                                key: c,
                                value: t
                            });
                        {
                            const i = [];
                            for (const h in t)
                                i.push(...ae({
                                    key: "".concat(c, ".").concat(h),
                                    value: t[h]
                                }));
                            return i
                        }
                    }
                };
                function fe(c) {
                    const t = c.value
                      , i = c.key
                      , h = c.styleSpec
                      , d = c.style;
                    if (!t.type)
                        return [new s.V(i,t,'"type" is required')];
                    const m = s.K(t.type);
                    let y = [];
                    switch (["vector", "raster", "raster-dem", "raster-array"].includes(m) && (t.url || t.tiles || y.push(new s.G(i,t,'Either "url" or "tiles" is required.'))),
                    m) {
                    case "vector":
                    case "raster":
                    case "raster-dem":
                    case "raster-array":
                        return y = y.concat(Nt({
                            key: i,
                            value: t,
                            valueSpec: h["source_".concat(m.replace("-", "_"))],
                            style: c.style,
                            styleSpec: h,
                            objectElementValidators: Ve
                        })),
                        y;
                    case "geojson":
                        if (y = Nt({
                            key: i,
                            value: t,
                            valueSpec: h.source_geojson,
                            style: d,
                            styleSpec: h,
                            objectElementValidators: Ve
                        }),
                        t.cluster)
                            for (const M in t.clusterProperties) {
                                const [E,S] = t.clusterProperties[M]
                                  , I = "string" == typeof E ? [E, ["accumulated"], ["get", M]] : E;
                                y.push(...ao({
                                    key: "".concat(i, ".").concat(M, ".map"),
                                    value: S,
                                    expressionContext: "cluster-map"
                                })),
                                y.push(...ao({
                                    key: "".concat(i, ".").concat(M, ".reduce"),
                                    value: I,
                                    expressionContext: "cluster-reduce"
                                }))
                            }
                        return y;
                    case "video":
                        return Nt({
                            key: i,
                            value: t,
                            valueSpec: h.source_video,
                            style: d,
                            styleSpec: h
                        });
                    case "image":
                        return Nt({
                            key: i,
                            value: t,
                            valueSpec: h.source_image,
                            style: d,
                            styleSpec: h
                        });
                    case "canvas":
                        return [new s.V(i,null,"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.","source.canvas")];
                    default:
                        return Do({
                            key: "".concat(i, ".type"),
                            value: t.type,
                            valueSpec: {
                                values: Pt(h)
                            },
                            style: d,
                            styleSpec: h
                        })
                    }
                }
                function Pt(c) {
                    return c.source.reduce( (t, i) => {
                        const h = c[i];
                        return "enum" === h.type.type && (t = t.concat(Object.keys(h.type.values))),
                        t
                    }
                    , [])
                }
                function mt(c) {
                    const t = c.value
                      , i = c.styleSpec
                      , h = i.light
                      , d = c.style;
                    let m = [];
                    const y = s.H(t);
                    if (void 0 === t)
                        return m;
                    if ("object" !== y)
                        return m = m.concat([new s.V("light",t,"object expected, ".concat(y, " found"))]),
                        m;
                    for (const M in t) {
                        const E = M.match(/^(.*)-transition$/)
                          , S = M.match(/^(.*)-use-theme$/);
                        m = m.concat(S && h[S[1]] ? vo({
                            key: M,
                            value: t[M],
                            valueSpec: {
                                type: "string"
                            },
                            style: d,
                            styleSpec: i
                        }) : E && h[E[1]] && h[E[1]].transition ? vo({
                            key: M,
                            value: t[M],
                            valueSpec: i.transition,
                            style: d,
                            styleSpec: i
                        }) : h[M] ? vo({
                            key: M,
                            value: t[M],
                            valueSpec: h[M],
                            style: d,
                            styleSpec: i
                        }) : [new s.V(M,t[M],'unknown property "'.concat(M, '"'))])
                    }
                    return m
                }
                function xo(c) {
                    const t = c.value;
                    let i = [];
                    if (!t)
                        return i;
                    const h = s.H(t);
                    if ("object" !== h)
                        return i = i.concat([new s.V("light-3d",t,"object expected, ".concat(h, " found"))]),
                        i;
                    const d = c.styleSpec
                      , m = d["light-3d"]
                      , y = c.key
                      , M = c.style
                      , E = c.style.lights;
                    for (const R of ["type", "id"])
                        if (!(R in t))
                            return i = i.concat([new s.V("light-3d",t,"missing property ".concat(R, " on light"))]),
                            i;
                    if (t.type && E)
                        for (let R = 0; R < c.arrayIndex; R++) {
                            const D = s.K(t.type)
                              , k = E[R];
                            s.K(k.type) === D && i.push(new s.V(y,t.id,'duplicate light type "'.concat(t.type, '", previously defined at line ').concat(k.id.__line__)))
                        }
                    const S = "properties_light_".concat(t.type);
                    if (!(S in d))
                        return i = i.concat([new s.V("light-3d",t,"Invalid light type ".concat(t.type))]),
                        i;
                    const I = d[S];
                    for (const R in t)
                        if ("properties" === R) {
                            const D = t[R]
                              , k = s.H(D);
                            if ("object" !== k)
                                return i = i.concat([new s.V("properties",D,"object expected, ".concat(k, " found"))]),
                                i;
                            for (const H in D)
                                i = i.concat(I[H] ? vo({
                                    key: H,
                                    value: D[H],
                                    valueSpec: I[H],
                                    style: M,
                                    styleSpec: d
                                }) : [new s.G(c.key,D[H],'unknown property "'.concat(H, '"'))])
                        } else {
                            const D = R.match(/^(.*)-transition$/)
                              , k = R.match(/^(.*)-use-theme$/);
                            i = i.concat(k && m[k[1]] ? vo({
                                key: R,
                                value: t[R],
                                valueSpec: {
                                    type: "string"
                                },
                                style: M,
                                styleSpec: d
                            }) : D && m[D[1]] && m[D[1]].transition ? vo({
                                key: R,
                                value: t[R],
                                valueSpec: d.transition,
                                style: M,
                                styleSpec: d
                            }) : m[R] ? vo({
                                key: R,
                                value: t[R],
                                valueSpec: m[R],
                                style: M,
                                styleSpec: d
                            }) : [new s.G(R,t[R],'unknown property "'.concat(R, '"'))])
                        }
                    return i
                }
                function So(c) {
                    const t = c.value
                      , i = c.key
                      , h = c.style
                      , d = c.styleSpec
                      , m = d.terrain;
                    let y = [];
                    const M = s.H(t);
                    if (void 0 === t || "null" === M)
                        return y;
                    if ("object" !== M)
                        return y = y.concat([new s.V("terrain",t,"object expected, ".concat(M, " found"))]),
                        y;
                    for (const E in t) {
                        const S = E.match(/^(.*)-transition$/)
                          , I = E.match(/^(.*)-use-theme$/);
                        y = y.concat(I && m[I[1]] ? vo({
                            key: E,
                            value: t[E],
                            valueSpec: {
                                type: "string"
                            },
                            style: h,
                            styleSpec: d
                        }) : S && m[S[1]] && m[S[1]].transition ? vo({
                            key: E,
                            value: t[E],
                            valueSpec: d.transition,
                            style: h,
                            styleSpec: d
                        }) : m[E] ? vo({
                            key: E,
                            value: t[E],
                            valueSpec: m[E],
                            style: h,
                            styleSpec: d
                        }) : [new s.G(E,t[E],'unknown property "'.concat(E, '"'))])
                    }
                    if (t.source) {
                        const E = h.sources && h.sources[t.source]
                          , S = E && s.K(E.type);
                        E ? "raster-dem" !== S && y.push(new s.V(i,t.source,"terrain cannot be used with a source of type ".concat(String(S), ', it only be used with a "raster-dem" source type'))) : y.push(new s.V(i,t.source,'source "'.concat(t.source, '" not found')))
                    } else
                        y.push(new s.V(i,t,'terrain is missing required property "source"'));
                    return y
                }
                function ro(c) {
                    const t = c.value
                      , i = c.style
                      , h = c.styleSpec
                      , d = h.fog;
                    let m = [];
                    const y = s.H(t);
                    if (void 0 === t)
                        return m;
                    if ("object" !== y)
                        return m = m.concat([new s.V("fog",t,"object expected, ".concat(y, " found"))]),
                        m;
                    for (const M in t) {
                        const E = M.match(/^(.*)-transition$/)
                          , S = M.match(/^(.*)-use-theme$/);
                        m = m.concat(S && d[S[1]] ? vo({
                            key: M,
                            value: t[M],
                            valueSpec: {
                                type: "string"
                            },
                            style: i,
                            styleSpec: h
                        }) : E && d[E[1]] && d[E[1]].transition ? vo({
                            key: M,
                            value: t[M],
                            valueSpec: h.transition,
                            style: i,
                            styleSpec: h
                        }) : d[M] ? vo({
                            key: M,
                            value: t[M],
                            valueSpec: d[M],
                            style: i,
                            styleSpec: h
                        }) : [new s.G(M,t[M],'unknown property "'.concat(M, '"'))])
                    }
                    return m
                }
                const Vo = {
                    "*": () => [],
                    array: Vt,
                    boolean: function(c) {
                        const t = c.value
                          , i = c.key
                          , h = s.H(t);
                        return "boolean" !== h ? [new s.V(i,t,"boolean expected, ".concat(h, " found"))] : []
                    },
                    number: _o,
                    color: function(c) {
                        const t = c.key
                          , i = c.value
                          , h = s.H(i);
                        return "string" !== h ? [new s.V(t,i,"color expected, ".concat(h, " found"))] : null === s._.parseCSSColor(i) ? [new s.V(t,i,'color expected, "'.concat(i, '" found'))] : []
                    },
                    enum: Do,
                    filter: Xt,
                    function: Lo,
                    layer: W,
                    object: Nt,
                    source: fe,
                    model: s.a2,
                    light: mt,
                    "light-3d": xo,
                    terrain: So,
                    fog: ro,
                    string: ae,
                    formatted: function(c) {
                        return 0 === ae(c).length ? [] : ao(c)
                    },
                    resolvedImage: function(c) {
                        return 0 === ae(c).length ? [] : ao(c)
                    },
                    projection: function(c) {
                        const t = c.value
                          , i = c.styleSpec
                          , h = i.projection
                          , d = c.style;
                        let m = [];
                        const y = s.H(t);
                        if ("object" === y)
                            for (const M in t)
                                m = m.concat(vo({
                                    key: M,
                                    value: t[M],
                                    valueSpec: h[M],
                                    style: d,
                                    styleSpec: i
                                }));
                        else
                            "string" !== y && (m = m.concat([new s.V("projection",t,"object or string expected, ".concat(y, " found"))]));
                        return m
                    },
                    import: function(c) {
                        const {value: t, styleSpec: i} = c
                          , {data: h, ...d} = t;
                        Object.defineProperty(d, "__line__", {
                            value: t.__line__,
                            enumerable: !1
                        });
                        let m = Nt(s.J({}, c, {
                            value: d,
                            valueSpec: i.import
                        }));
                        return "" === s.K(d.id) && m.push(new s.V("".concat(c.key, ".id"),d,"import id can't be an empty string")),
                        h && (m = m.concat(Ti(h, i, {
                            key: "".concat(c.key, ".data")
                        }))),
                        m
                    }
                };
                function vo(c, t=!1) {
                    const i = c.value
                      , h = c.valueSpec
                      , d = c.styleSpec;
                    if (h.expression && s.a0(s.K(i)))
                        return Lo(c);
                    if (h.expression && s.O(s.Q(i)))
                        return ao(c);
                    if (h.type && Vo[h.type]) {
                        const m = Vo[h.type](c);
                        return !0 === t && m.length > 0 && "array" === s.H(c.value) ? ao(c) : m
                    }
                    return Nt(s.J({}, c, {
                        valueSpec: h.type ? d[h.type] : h
                    }))
                }
                function ei(c) {
                    const t = c.value
                      , i = c.key
                      , h = ae(c);
                    return h.length || (-1 === t.indexOf("{fontstack}") && h.push(new s.V(i,t,'"glyphs" url must include a "{fontstack}" token')),
                    -1 === t.indexOf("{range}") && h.push(new s.V(i,t,'"glyphs" url must include a "{range}" token'))),
                    h
                }
                function Ti(c, t=s.a3, i={}) {
                    return vo({
                        key: i.key || "",
                        value: c,
                        valueSpec: t.$root,
                        styleSpec: t,
                        style: c,
                        objectElementValidators: {
                            glyphs: ei,
                            "*": () => []
                        }
                    })
                }
                function ci(c, t=s.a3) {
                    return J(Ti(c, t))
                }
                const ji = c => J(fe(c))
                  , yn = c => J(mt(c))
                  , Dr = c => J(xo(c))
                  , Ln = c => J(So(c))
                  , Lr = c => J(ro(c))
                  , xt = c => J(function(t) {
                    const i = t.value
                      , h = t.style
                      , d = t.styleSpec
                      , m = d.snow;
                    let y = [];
                    const M = s.H(i);
                    if (void 0 === i)
                        return y;
                    if ("object" !== M)
                        return y = y.concat([new s.V("snow",i,"object expected, ".concat(M, " found"))]),
                        y;
                    for (const E in i) {
                        const S = E.match(/^(.*)-transition$/);
                        y = y.concat(S && m[S[1]] && m[S[1]].transition ? vo({
                            key: E,
                            value: i[E],
                            valueSpec: d.transition,
                            style: h,
                            styleSpec: d
                        }) : m[E] ? vo({
                            key: E,
                            value: i[E],
                            valueSpec: m[E],
                            style: h,
                            styleSpec: d
                        }) : [new s.G(E,i[E],'unknown property "'.concat(E, '"'))])
                    }
                    return y
                }(c))
                  , Z = c => J(function(t) {
                    const i = t.value
                      , h = t.style
                      , d = t.styleSpec
                      , m = d.rain;
                    let y = [];
                    const M = s.H(i);
                    if (void 0 === i)
                        return y;
                    if ("object" !== M)
                        return y = y.concat([new s.V("rain",i,"object expected, ".concat(M, " found"))]),
                        y;
                    for (const E in i) {
                        const S = E.match(/^(.*)-transition$/);
                        y = y.concat(S && m[S[1]] && m[S[1]].transition ? vo({
                            key: E,
                            value: i[E],
                            valueSpec: d.transition,
                            style: h,
                            styleSpec: d
                        }) : m[E] ? vo({
                            key: E,
                            value: i[E],
                            valueSpec: m[E],
                            style: h,
                            styleSpec: d
                        }) : [new s.G(E,i[E],'unknown property "'.concat(E, '"'))])
                    }
                    return y
                }(c))
                  , se = c => J(W(c))
                  , Ee = c => J(Xt(c))
                  , He = c => J(Oe(c))
                  , oe = c => J(ee(c))
                  , ue = c => J(s.a2(c));
                function J(c) {
                    return c.slice().sort( (t, i) => t.line && i.line ? t.line - i.line : 0)
                }
                function q(c, t) {
                    let i = !1;
                    if (t && t.length)
                        for (const h of t)
                            h instanceof s.G ? s.w(h.message) : (c.fire(new s.y(new Error(h.message))),
                            i = !0);
                    return i
                }
                let le;
                class Se extends s.E {
                    constructor(t, i="flat") {
                        super(),
                        this._transitionable = new s.a4(le || (le = new s.a5({
                            anchor: new s.a6(s.a3.light.anchor),
                            position: new s.a7(s.a3.light.position),
                            color: new s.a6(s.a3.light.color),
                            intensity: new s.a6(s.a3.light.intensity)
                        }))),
                        this.setLight(t, i),
                        this._transitioning = this._transitionable.untransitioned()
                    }
                    getLight() {
                        return this._transitionable.serialize()
                    }
                    setLight(t, i, h={}) {
                        this._validate(yn, t, h) || (this._transitionable.setTransitionOrValue(t),
                        this.id = i)
                    }
                    updateTransitions(t) {
                        this._transitioning = this._transitionable.transitioned(t, this._transitioning)
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition()
                    }
                    recalculate(t) {
                        this.properties = this._transitioning.possiblyEvaluate(t)
                    }
                    _validate(t, i, h) {
                        return (!h || !1 !== h.validate) && q(this, t.call(ci, s.l({
                            value: i,
                            style: {
                                glyphs: !0,
                                sprite: !0
                            },
                            styleSpec: s.a3
                        })))
                    }
                }
                let st = class extends s.E {
                    constructor(c, t, i, h) {
                        super(),
                        this.scope = i,
                        this._transitionable = new s.a4(new s.a5({
                            source: new s.a6(s.a3.terrain.source),
                            exaggeration: new s.a6(s.a3.terrain.exaggeration)
                        }),i,h),
                        this._transitionable.setTransitionOrValue(c, h),
                        this._transitioning = this._transitionable.untransitioned(),
                        this.drapeRenderMode = t
                    }
                    get() {
                        return this._transitionable.serialize()
                    }
                    set(c, t) {
                        this._transitionable.setTransitionOrValue(c, t)
                    }
                    updateTransitions(c) {
                        this._transitioning = this._transitionable.transitioned(c, this._transitioning)
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition()
                    }
                    recalculate(c) {
                        this.properties = this._transitioning.possiblyEvaluate(c)
                    }
                    getExaggeration(c) {
                        return this._transitioning.possiblyEvaluate(new s.a8(c)).get("exaggeration")
                    }
                    getAttenuationRange() {
                        if (!this.isZoomDependent())
                            return null;
                        const c = this._transitionable._values.exaggeration;
                        if (!c)
                            return null;
                        const t = c.value.expression;
                        if (!t)
                            return null;
                        let i = -1
                          , h = -1
                          , d = 1;
                        for (const m of t.zoomStops)
                            d = t.evaluate(new s.a8(m)),
                            d > .01 ? (i = m,
                            h = -1) : h = m;
                        return d < .01 && i > 0 && h > i ? [i, h] : null
                    }
                    isZoomDependent() {
                        const c = this._transitionable._values.exaggeration;
                        return null != c && null != c.value && null != c.value.expression && c.value.expression instanceof s.a9
                    }
                }
                ;
                const wo = .05;
                function Ho(c, t, i, h) {
                    const d = s.ac(45, 65, i)
                      , [m,y] = Jo(c, h);
                    let M = 1 - Math.min(1, Math.exp((t - m) / (y - m) * -6));
                    return M *= M * M,
                    M = Math.min(1, 1.00747 * M),
                    M * d * c.alpha
                }
                function Jo(c, t) {
                    const i = .5 / Math.tan(.5 * t);
                    return [c.range[0] + i, c.range[1] + i]
                }
                function qo(c, t, i, h, d) {
                    const m = s.ab.vec3.transformMat4([], [t, i, h], d.mercatorFogMatrix);
                    return Ho(c, s.ab.vec3.length(m), d.pitch, d._fov)
                }
                function Go(c, t, i, h, d, m, y) {
                    const M = [[i, h, 0], [d, h, 0], [d, m, 0], [i, m, 0]];
                    let E = Number.MAX_VALUE
                      , S = -Number.MAX_VALUE;
                    for (const I of M) {
                        const R = s.ab.vec3.transformMat4([], I, t)
                          , D = s.ab.vec3.length(R);
                        E = Math.min(E, D),
                        S = Math.max(S, D)
                    }
                    return [Ho(c, E, y.pitch, y._fov), Ho(c, S, y.pitch, y._fov)]
                }
                class Ii extends s.E {
                    constructor(t, i, h, d) {
                        super();
                        const m = new s.a5({
                            range: new s.a6(s.a3.fog.range),
                            color: new s.a6(s.a3.fog.color),
                            "color-use-theme": new s.a6({
                                type: "string",
                                "property-type": "data-constant",
                                default: "default"
                            }),
                            "high-color": new s.a6(s.a3.fog["high-color"]),
                            "high-color-use-theme": new s.a6({
                                type: "string",
                                "property-type": "data-constant",
                                default: "default"
                            }),
                            "space-color": new s.a6(s.a3.fog["space-color"]),
                            "space-color-use-theme": new s.a6({
                                type: "string",
                                "property-type": "data-constant",
                                default: "default"
                            }),
                            "horizon-blend": new s.a6(s.a3.fog["horizon-blend"]),
                            "star-intensity": new s.a6(s.a3.fog["star-intensity"]),
                            "vertical-range": new s.a6(s.a3.fog["vertical-range"])
                        });
                        this._transitionable = new s.a4(m,h,new Map(d)),
                        this.set(t, d),
                        this._transitioning = this._transitionable.untransitioned(),
                        this._transform = i,
                        this.properties = new s.ad(m),
                        this.scope = h
                    }
                    get state() {
                        const t = this._transform
                          , i = "globe" === t.projection.name
                          , h = s.ae(t.zoom)
                          , d = this.properties.get("range")
                          , m = [.5, 3];
                        return {
                            range: i ? [s.af(m[0], d[0], h), s.af(m[1], d[1], h)] : d,
                            horizonBlend: this.properties.get("horizon-blend"),
                            alpha: this.properties.get("color").a
                        }
                    }
                    get() {
                        return this._transitionable.serialize()
                    }
                    set(t, i, h={}) {
                        if (this._validate(Lr, t, h))
                            return;
                        const d = s.l({}, t);
                        for (const m of Object.keys(s.a3.fog))
                            void 0 === d[m] && (d[m] = s.a3.fog[m].default);
                        this._options = d,
                        this._transitionable.setTransitionOrValue(this._options, i)
                    }
                    getOpacity(t) {
                        if (!this._transform.projection.supportsFog)
                            return 0;
                        const i = this.properties && this.properties.get("color") || 1;
                        return ("globe" === this._transform.projection.name ? 1 : s.ac(45, 65, t)) * i.a
                    }
                    getOpacityAtLatLng(t, i) {
                        return this._transform.projection.supportsFog ? function(h, d, m) {
                            const y = s.aa.fromLngLat(d)
                              , M = m.elevation ? m.elevation.getAtPointOrZero(y) : 0;
                            return qo(h, y.x, y.y, M, m)
                        }(this.state, t, i) : 0
                    }
                    getOpacityForTile(t) {
                        if (!this._transform.projection.supportsFog)
                            return [1, 1];
                        const i = this._transform.calculateFogTileMatrix(t.toUnwrapped());
                        return Go(this.state, i, 0, 0, s.ag, s.ag, this._transform)
                    }
                    getOpacityForBounds(t, i, h, d, m) {
                        return this._transform.projection.supportsFog ? Go(this.state, t, i, h, d, m, this._transform) : [1, 1]
                    }
                    getFovAdjustedRange(t) {
                        return this._transform.projection.supportsFog ? Jo(this.state, t) : [0, 1]
                    }
                    isVisibleOnFrustum(t) {
                        if (!this._transform.projection.supportsFog)
                            return !1;
                        const i = [4, 5, 6, 7];
                        for (const h of i) {
                            const d = t.points[h];
                            let m;
                            if (d[2] >= 0)
                                m = d;
                            else {
                                const y = t.points[h - 4];
                                m = s.ah(y, d, y[2] / (y[2] - d[2]))
                            }
                            if (qo(this.state, m[0], m[1], 0, this._transform) >= wo)
                                return !0
                        }
                        return !1
                    }
                    updateConfig(t) {
                        this._transitionable.setTransitionOrValue(this._options, new Map(t))
                    }
                    updateTransitions(t) {
                        this._transitioning = this._transitionable.transitioned(t, this._transitioning)
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition()
                    }
                    recalculate(t) {
                        this.properties = this._transitioning.possiblyEvaluate(t)
                    }
                    _validate(t, i, h) {
                        return (!h || !1 !== h.validate) && q(this, t.call(ci, s.l({
                            value: i,
                            style: {
                                glyphs: !0,
                                sprite: !0
                            },
                            styleSpec: s.a3
                        })))
                    }
                }
                let Ci, fi, Ai, Fi, fn = class extends s.E {
                    constructor(c, t, i, h) {
                        super();
                        const d = Ci || (Ci = new s.a5({
                            density: new s.a6(s.a3.snow.density),
                            intensity: new s.a6(s.a3.snow.intensity),
                            color: new s.a6(s.a3.snow.color),
                            opacity: new s.a6(s.a3.snow.opacity),
                            vignette: new s.a6(s.a3.snow.vignette),
                            "vignette-color": new s.a6(s.a3.snow["vignette-color"]),
                            "center-thinning": new s.a6(s.a3.snow["center-thinning"]),
                            direction: new s.a6(s.a3.snow.direction),
                            "flake-size": new s.a6(s.a3.snow["flake-size"])
                        }));
                        this._transitionable = new s.a4(d,i,new Map(h)),
                        this.set(c, h),
                        this._transitioning = this._transitionable.untransitioned(),
                        this.properties = new s.ad(d),
                        this.scope = i
                    }
                    get state() {
                        const c = this.properties.get("opacity")
                          , t = this.properties.get("color")
                          , i = this.properties.get("direction")
                          , h = s.ai(i[0])
                          , d = -Math.max(s.ai(i[1]), .01)
                          , m = [Math.cos(h) * Math.cos(d), Math.sin(h) * Math.cos(d), Math.sin(d)]
                          , y = this.properties.get("vignette")
                          , M = this.properties.get("vignette-color");
                        return M.a = y,
                        {
                            density: this.properties.get("density"),
                            intensity: this.properties.get("intensity"),
                            color: new s.aj(t.r,t.g,t.b,t.a * c),
                            direction: m,
                            centerThinning: this.properties.get("center-thinning"),
                            flakeSize: this.properties.get("flake-size"),
                            vignetteColor: M
                        }
                    }
                    get() {
                        return this._transitionable.serialize()
                    }
                    set(c, t, i={}) {
                        if (this._validate(xt, c, i))
                            return;
                        const h = s.l({}, c);
                        for (const d of Object.keys(s.a3.snow))
                            void 0 === h[d] && (h[d] = s.a3.snow[d].default);
                        this._options = h,
                        this._transitionable.setTransitionOrValue(this._options, t)
                    }
                    updateConfig(c) {
                        this._transitionable.setTransitionOrValue(this._options, new Map(c))
                    }
                    updateTransitions(c) {
                        this._transitioning = this._transitionable.transitioned(c, this._transitioning)
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition()
                    }
                    recalculate(c) {
                        this.properties = this._transitioning.possiblyEvaluate(c)
                    }
                    _validate(c, t, i) {
                        return (!i || !1 !== i.validate) && q(this, c.call(ci, s.l({
                            value: t,
                            style: {
                                glyphs: !0,
                                sprite: !0
                            },
                            styleSpec: s.a3
                        })))
                    }
                }
                , Yn = class extends s.E {
                    constructor(c, t, i, h) {
                        super();
                        const d = fi || (fi = new s.a5({
                            density: new s.a6(s.a3.rain.density),
                            intensity: new s.a6(s.a3.rain.intensity),
                            color: new s.a6(s.a3.rain.color),
                            opacity: new s.a6(s.a3.rain.opacity),
                            vignette: new s.a6(s.a3.rain.vignette),
                            "vignette-color": new s.a6(s.a3.rain["vignette-color"]),
                            "center-thinning": new s.a6(s.a3.rain["center-thinning"]),
                            direction: new s.a6(s.a3.rain.direction),
                            "droplet-size": new s.a6(s.a3.rain["droplet-size"]),
                            "distortion-strength": new s.a6(s.a3.rain["distortion-strength"])
                        }));
                        this._transitionable = new s.a4(d,i,new Map(h)),
                        this.set(c, h),
                        this._transitioning = this._transitionable.untransitioned(),
                        this.properties = new s.ad(d),
                        this.scope = i
                    }
                    get state() {
                        const c = this.properties.get("opacity")
                          , t = this.properties.get("color")
                          , i = this.properties.get("direction")
                          , h = s.ai(i[0])
                          , d = -Math.max(s.ai(i[1]), .01)
                          , m = [Math.cos(h) * Math.cos(d), Math.sin(h) * Math.cos(d), Math.sin(d)]
                          , y = this.properties.get("vignette-color");
                        return y.a = this.properties.get("vignette"),
                        {
                            density: this.properties.get("density"),
                            intensity: this.properties.get("intensity"),
                            color: new s.aj(t.r,t.g,t.b,t.a * c),
                            direction: m,
                            centerThinning: this.properties.get("center-thinning"),
                            dropletSize: this.properties.get("droplet-size"),
                            distortionStrength: this.properties.get("distortion-strength"),
                            vignetteColor: y
                        }
                    }
                    get() {
                        return this._transitionable.serialize()
                    }
                    set(c, t, i={}) {
                        if (this._validate(Z, c, i))
                            return;
                        const h = s.l({}, c);
                        for (const d of Object.keys(s.a3.rain))
                            void 0 === h[d] && (h[d] = s.a3.rain[d].default);
                        this._options = h,
                        this._transitionable.setTransitionOrValue(this._options, t)
                    }
                    updateConfig(c) {
                        this._transitionable.setTransitionOrValue(this._options, new Map(c))
                    }
                    updateTransitions(c) {
                        this._transitioning = this._transitionable.transitioned(c, this._transitioning)
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition()
                    }
                    recalculate(c) {
                        this.properties = this._transitioning.possiblyEvaluate(c)
                    }
                    _validate(c, t, i) {
                        return (!i || !1 !== i.validate) && q(this, c.call(ci, s.l({
                            value: t,
                            style: {
                                glyphs: !0,
                                sprite: !0
                            },
                            styleSpec: s.a3
                        })))
                    }
                }
                ;
                class Sn extends s.E {
                    constructor(t, i, h, d) {
                        super(),
                        this.scope = h,
                        this._options = t,
                        this.properties = new s.ad(i),
                        this._transitionable = new s.a4(i,h,new Map(d)),
                        this._transitionable.setTransitionOrValue(t.properties),
                        this._transitioning = this._transitionable.untransitioned()
                    }
                    updateConfig(t) {
                        this._transitionable.setTransitionOrValue(this._options.properties, new Map(t))
                    }
                    updateTransitions(t) {
                        this._transitioning = this._transitionable.transitioned(t, this._transitioning)
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition()
                    }
                    recalculate(t) {
                        this.properties = this._transitioning.possiblyEvaluate(t)
                    }
                    get() {
                        return this._options.properties = this._transitionable.serialize(),
                        this._options
                    }
                    set(t, i) {
                        this._options = t,
                        this._transitionable.setTransitionOrValue(t.properties, i)
                    }
                    shadowsEnabled() {
                        return !!this.properties && !0 === this.properties.get("cast-shadows")
                    }
                }
                class Fn {
                    constructor(t, i, h, d) {
                        this.screenBounds = t,
                        this.cameraPoint = i,
                        this._screenRaycastCache = {},
                        this._cameraRaycastCache = {},
                        this.isAboveHorizon = h,
                        this.screenGeometry = this.bufferedScreenGeometry(0),
                        this.screenGeometryMercator = this._bufferedScreenMercator(0, d)
                    }
                    static createFromScreenPoints(t, i) {
                        let h, d;
                        if (t instanceof s.P || "number" == typeof t[0]) {
                            const m = s.P.convert(t);
                            h = [m],
                            d = i.isPointAboveHorizon(m)
                        } else {
                            const m = s.P.convert(t[0])
                              , y = s.P.convert(t[1]);
                            h = [m, y],
                            d = s.al(m, y).every(M => i.isPointAboveHorizon(M))
                        }
                        return new Fn(h,i.getCameraPoint(),d,i)
                    }
                    isPointQuery() {
                        return 1 === this.screenBounds.length
                    }
                    bufferedScreenGeometry(t) {
                        return s.al(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t)
                    }
                    bufferedCameraGeometry(t) {
                        const i = this.screenBounds[0]
                          , h = 1 === this.screenBounds.length ? this.screenBounds[0].add(new s.P(1,1)) : this.screenBounds[1]
                          , d = s.al(i, h, 0, !1);
                        return this.cameraPoint.y > h.y && (this.cameraPoint.x > i.x && this.cameraPoint.x < h.x ? d.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= h.x ? d[2] = this.cameraPoint : this.cameraPoint.x <= i.x && (d[3] = this.cameraPoint)),
                        s.am(d, t)
                    }
                    bufferedCameraGeometryGlobe(t) {
                        const i = this.screenBounds[0]
                          , h = 1 === this.screenBounds.length ? this.screenBounds[0].add(new s.P(1,1)) : this.screenBounds[1]
                          , d = s.al(i, h, t)
                          , m = this.cameraPoint.clone();
                        switch (3 * ((m.y > i.y) + (m.y > h.y)) + ((m.x > i.x) + (m.x > h.x))) {
                        case 0:
                            d[0] = m,
                            d[4] = m.clone();
                            break;
                        case 1:
                            d.splice(1, 0, m);
                            break;
                        case 2:
                            d[1] = m;
                            break;
                        case 3:
                            d.splice(4, 0, m);
                            break;
                        case 5:
                            d.splice(2, 0, m);
                            break;
                        case 6:
                            d[3] = m;
                            break;
                        case 7:
                            d.splice(3, 0, m);
                            break;
                        case 8:
                            d[2] = m
                        }
                        return d
                    }
                    containsTile(t, i, h, d=0) {
                        const m = t.queryPadding / i._pixelsPerMercatorPixel + 1
                          , y = h ? this._bufferedCameraMercator(m, i) : this._bufferedScreenMercator(m, i);
                        let M = t.tileID.wrap + (y.unwrapped ? d : 0);
                        const E = y.polygon.map(Y => s.an(t.tileTransform, Y, M));
                        if (!s.ao(E, 0, 0, s.ag, s.ag))
                            return;
                        M = t.tileID.wrap + (this.screenGeometryMercator.unwrapped ? d : 0);
                        const S = this.screenGeometryMercator.polygon.map(Y => s.ap(t.tileTransform, Y, M))
                          , I = S.map(Y => new s.P(Y[0],Y[1]))
                          , R = i.getFreeCameraOptions().position || new s.aa(0,0,0)
                          , D = s.ap(t.tileTransform, R, M)
                          , k = S.map(Y => {
                            const K = s.ab.vec3.sub(Y, Y, D);
                            return s.ab.vec3.normalize(K, K),
                            new s.aq(D,K)
                        }
                        )
                          , H = s.ar(t, 1, i.zoom) * i._pixelsPerMercatorPixel;
                        return {
                            queryGeometry: this,
                            tilespaceGeometry: I,
                            tilespaceRays: k,
                            bufferedTilespaceGeometry: E,
                            bufferedTilespaceBounds: (j = s.as(E),
                            j.min.x = s.aw(j.min.x, 0, s.ag),
                            j.min.y = s.aw(j.min.y, 0, s.ag),
                            j.max.x = s.aw(j.max.x, 0, s.ag),
                            j.max.y = s.aw(j.max.y, 0, s.ag),
                            j),
                            tile: t,
                            tileID: t.tileID,
                            pixelToTileUnitsFactor: H
                        };
                        var j
                    }
                    _bufferedScreenMercator(t, i) {
                        const h = Gl(t);
                        if (this._screenRaycastCache[h])
                            return this._screenRaycastCache[h];
                        {
                            let d;
                            return d = "globe" === i.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(t), i) : {
                                polygon: this.bufferedScreenGeometry(t).map(m => i.pointCoordinate3D(m)),
                                unwrapped: !0
                            },
                            this._screenRaycastCache[h] = d,
                            d
                        }
                    }
                    _bufferedCameraMercator(t, i) {
                        const h = Gl(t);
                        if (this._cameraRaycastCache[h])
                            return this._cameraRaycastCache[h];
                        {
                            let d;
                            return d = "globe" === i.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(t), i) : {
                                polygon: this.bufferedCameraGeometry(t).map(m => i.pointCoordinate3D(m)),
                                unwrapped: !0
                            },
                            this._cameraRaycastCache[h] = d,
                            d
                        }
                    }
                    _projectAndResample(t, i) {
                        const h = function(m, y) {
                            const M = s.ab.mat4.multiply([], y.pixelMatrix, y.globeMatrix)
                              , E = [0, -s.ax, 0, 1]
                              , S = [0, s.ax, 0, 1]
                              , I = [0, 0, 0, 1];
                            s.ab.vec4.transformMat4(E, E, M),
                            s.ab.vec4.transformMat4(S, S, M),
                            s.ab.vec4.transformMat4(I, I, M);
                            const R = new s.P(E[0] / E[3],E[1] / E[3])
                              , D = new s.P(S[0] / S[3],S[1] / S[3])
                              , k = s.au(m, R) && E[3] < I[3]
                              , H = s.au(m, D) && S[3] < I[3];
                            if (!k && !H)
                                return null;
                            const j = function(ke, Le, Ge) {
                                for (let qe = 1; qe < ke.length; qe++) {
                                    const vt = Hr(Le.pointCoordinate3D(ke[qe - 1]).x)
                                      , dt = Hr(Le.pointCoordinate3D(ke[qe]).x);
                                    if (Ge < 0) {
                                        if (vt < dt)
                                            return {
                                                idx: qe,
                                                t: -vt / (dt - 1 - vt)
                                            }
                                    } else if (dt < vt)
                                        return {
                                            idx: qe,
                                            t: (1 - vt) / (dt + 1 - vt)
                                        }
                                }
                                return null
                            }(m, y, k ? -1 : 1);
                            if (!j)
                                return null;
                            const {idx: Y, t: K} = j;
                            let he = Y > 1 ? xs(m.slice(0, Y), y) : []
                              , Te = Y < m.length ? xs(m.slice(Y), y) : [];
                            he = he.map(ke => new s.P(Hr(ke.x),ke.y)),
                            Te = Te.map(ke => new s.P(Hr(ke.x),ke.y));
                            const be = [...he];
                            0 === be.length && be.push(Te[Te.length - 1]);
                            const Ue = s.af(be[be.length - 1].y, (0 === Te.length ? he[0] : Te[0]).y, K);
                            let De;
                            return De = k ? [new s.P(0,Ue), new s.P(0,0), new s.P(1,0), new s.P(1,Ue)] : [new s.P(1,Ue), new s.P(1,1), new s.P(0,1), new s.P(0,Ue)],
                            be.push(...De),
                            0 === Te.length ? be.push(he[0]) : be.push(...Te),
                            {
                                polygon: be.map(ke => new s.aa(ke.x,ke.y)),
                                unwrapped: !1
                            }
                        }(t, i);
                        if (h)
                            return h;
                        const d = function(m, y) {
                            let M = !1
                              , E = -1 / 0
                              , S = 0;
                            for (let R = 0; R < m.length - 1; R++)
                                m[R].x > E && (E = m[R].x,
                                S = R);
                            for (let R = 0; R < m.length - 1; R++) {
                                const D = (S + R) % (m.length - 1)
                                  , k = m[D]
                                  , H = m[D + 1];
                                Math.abs(k.x - H.x) > .5 && (k.x < H.x ? (k.x += 1,
                                0 === D && (m[m.length - 1].x += 1)) : (H.x += 1,
                                D + 1 === m.length - 1 && (m[0].x += 1)),
                                M = !0)
                            }
                            const I = s.at(y.center.lng);
                            return M && I < Math.abs(I - 1) && m.forEach(R => {
                                R.x -= 1
                            }
                            ),
                            {
                                polygon: m,
                                unwrapped: M
                            }
                        }(xs(t, i).map(m => new s.P(Hr(m.x),m.y)), i);
                        return {
                            polygon: d.polygon.map(m => new s.aa(m.x,m.y)),
                            unwrapped: d.unwrapped
                        }
                    }
                }
                function xs(c, t) {
                    return s.av(c, i => {
                        const h = t.pointCoordinate3D(i);
                        i.x = h.x,
                        i.y = h.y
                    }
                    , 1 / 256)
                }
                function Hr(c) {
                    return c < 0 ? 1 + c % 1 : c % 1
                }
                function Gl(c) {
                    return 100 * c | 0
                }
                function jl(c, t, i, h, d) {
                    const m = function(M, E) {
                        if (M)
                            return d(M);
                        if (E) {
                            if (c.url && E.tiles && c.tiles && delete c.tiles,
                            E.variants) {
                                if (!Array.isArray(E.variants))
                                    return d(new Error("variants must be an array"));
                                for (const I of E.variants) {
                                    if (null == I || "object" != typeof I || I.constructor !== Object)
                                        return d(new Error("variant must be an object"));
                                    if (!Array.isArray(I.capabilities))
                                        return d(new Error("capabilities must be an array"));
                                    if (1 === I.capabilities.length && "meshopt" === I.capabilities[0]) {
                                        E = s.l(E, I);
                                        break
                                    }
                                }
                            }
                            const S = s.ay(s.l({}, E, c), ["tilejson", "tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding", "vector_layers", "raster_layers", "worldview_options", "worldview_default", "worldview"]);
                            S.tiles = t.canonicalizeTileset(S, c.url),
                            d(null, S)
                        }
                    }
                      , y = function(M, E, S) {
                        if (!M)
                            return null;
                        if (!E && !S)
                            return M;
                        S = S || M.worldview_default;
                        const I = Object.values(M.language || {});
                        if (0 === I.length)
                            return null;
                        const R = Object.values(M.worldview || {});
                        if (0 === R.length)
                            return null;
                        const D = I.every(H => H === E)
                          , k = R.every(H => H === S);
                        return D && k ? M : E in (M.language_options || {}) || S in (M.worldview_options || {}) ? null : M.language_options && M.worldview_options ? M : null
                    }(c.data, i, h);
                    return y ? s.q.frame( () => m(null, y)) : c.url ? s.n(t.transformRequest(t.normalizeSourceURL(c.url, null, i, h), s.R.Source), m) : s.q.frame( () => {
                        const {data: M, ...E} = c;
                        m(null, E)
                    }
                    )
                }
                class bs {
                    constructor(t, i, h) {
                        this.bounds = s.az.convert(this.validateBounds(t)),
                        this.minzoom = i || 0,
                        this.maxzoom = h || 24
                    }
                    validateBounds(t) {
                        return Array.isArray(t) && 4 === t.length ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90]
                    }
                    contains(t) {
                        const i = Math.pow(2, t.z)
                          , h = Math.floor(s.at(this.bounds.getWest()) * i)
                          , d = Math.floor(s.aA(this.bounds.getNorth()) * i)
                          , m = Math.ceil(s.at(this.bounds.getEast()) * i)
                          , y = Math.ceil(s.aA(this.bounds.getSouth()) * i);
                        return t.x >= h && t.x < m && t.y >= d && t.y < y
                    }
                }
                class Va extends s.E {
                    constructor(t, i, h, d) {
                        if (super(),
                        this.id = t,
                        this.dispatcher = h,
                        this.type = "vector",
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.scheme = "xyz",
                        this.tileSize = 512,
                        this.reparseOverscaled = !0,
                        this.isTileClipped = !0,
                        this._loaded = !1,
                        s.l(this, s.ay(i, ["url", "scheme", "tileSize", "promoteId"])),
                        this._options = s.l({
                            type: "vector"
                        }, i),
                        this._collectResourceTiming = !!i.collectResourceTiming,
                        512 !== this.tileSize)
                            throw new Error("vector tile sources must have a tileSize of 512");
                        this.setEventedParent(d),
                        this._tileWorkers = {},
                        this._deduped = new s.aB
                    }
                    load(t) {
                        this._loaded = !1,
                        this.fire(new s.z("dataloading",{
                            dataType: "source"
                        }));
                        const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language
                          , h = this.map.getWorldview();
                        this._tileJSONRequest = jl(this._options, this.map._requestManager, i, h, (d, m) => {
                            if (this._tileJSONRequest = null,
                            this._loaded = !0,
                            d)
                                i && console.warn("Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ".concat(i)),
                                h && console.warn("Requested worldview strings must be a valid ISO alpha-2 code. Found: ".concat(h)),
                                this.fire(new s.y(d));
                            else if (m) {
                                if (s.l(this, m),
                                this.hasWorldviews = !!m.worldview_options,
                                m.worldview_default && (this.worldviewDefault = m.worldview_default),
                                m.vector_layers) {
                                    this.vectorLayers = m.vector_layers,
                                    this.vectorLayerIds = [],
                                    this.localizableLayerIds = new Set;
                                    for (const y of m.vector_layers)
                                        this.vectorLayerIds.push(y.id),
                                        m.worldview && m.worldview[y.source] && this.localizableLayerIds.add(y.id)
                                }
                                m.bounds && (this.tileBounds = new bs(m.bounds,this.minzoom,this.maxzoom)),
                                Jt(m.tiles, this.map._requestManager._customAccessToken),
                                this.fire(new s.z("data",{
                                    dataType: "source",
                                    sourceDataType: "metadata"
                                })),
                                this.fire(new s.z("data",{
                                    dataType: "source",
                                    sourceDataType: "content"
                                }))
                            }
                            t && t(d)
                        }
                        )
                    }
                    loaded() {
                        return this._loaded
                    }
                    hasTile(t) {
                        return !this.tileBounds || this.tileBounds.contains(t.canonical)
                    }
                    onAdd(t) {
                        this.map = t,
                        this.load()
                    }
                    reload() {
                        this.cancelTileJSONRequest();
                        const t = s.aC(this.id, this.scope);
                        this.load( () => this.map.style.clearSource(t))
                    }
                    setTiles(t) {
                        return this._options.tiles = t,
                        this.reload(),
                        this
                    }
                    setUrl(t) {
                        return this.url = t,
                        this._options.url = t,
                        this.reload(),
                        this
                    }
                    onRemove(t) {
                        this.cancelTileJSONRequest()
                    }
                    serialize() {
                        return s.l({}, this._options)
                    }
                    loadTile(t, i) {
                        const h = t.tileID.canonical.url(this.tiles, this.scheme)
                          , d = this.map._requestManager.normalizeTileURL(h)
                          , m = this.map._requestManager.transformRequest(d, s.R.Tile)
                          , y = this.map.style ? this.map.style.getLut(this.scope) : null
                          , M = y ? {
                            image: y.image.clone()
                        } : null
                          , E = {
                            request: m,
                            data: void 0,
                            uid: t.uid,
                            tileID: t.tileID,
                            tileZoom: t.tileZoom,
                            zoom: t.tileID.overscaledZ,
                            maxZoom: this.maxzoom,
                            lut: M,
                            tileSize: this.tileSize * t.tileID.overscaleFactor(),
                            type: this.type,
                            source: this.id,
                            scope: this.scope,
                            pixelRatio: s.q.devicePixelRatio,
                            showCollisionBoxes: this.map.showCollisionBoxes,
                            promoteId: this.promoteId,
                            isSymbolTile: t.isSymbolTile,
                            brightness: this.map.style && this.map.style.getBrightness() || 0,
                            extraShadowCaster: t.isExtraShadowCaster,
                            tessellationStep: this.map._tessellationStep,
                            scaleFactor: this.map.getScaleFactor()
                        };
                        if (this.hasWorldviews && s.f(h) && (E.worldview = this.map.getWorldview() || this.worldviewDefault,
                        E.localizableLayerIds = this.localizableLayerIds),
                        E.request.collectResourceTiming = this._collectResourceTiming,
                        t.actor && "expired" !== t.state)
                            "loading" === t.state ? t.reloadCallback = i : t.request = t.actor.send("reloadTile", E, S.bind(this));
                        else if (t.actor = this._tileWorkers[d] = this._tileWorkers[d] || this.dispatcher.getActor(),
                        this.dispatcher.ready)
                            t.request = t.actor.send("loadTile", E, S.bind(this), void 0, !0);
                        else {
                            const I = s.aD.call({
                                deduped: this._deduped
                            }, E, (R, D) => {
                                R || !D ? S.call(this, R) : (E.data = {
                                    cacheControl: D.cacheControl,
                                    expires: D.expires,
                                    rawData: D.rawData.slice(0)
                                },
                                t.actor && t.actor.send("loadTile", E, S.bind(this), void 0, !0))
                            }
                            , !0);
                            t.request = {
                                cancel: I
                            }
                        }
                        function S(I, R) {
                            return delete t.request,
                            t.aborted ? i(null) : I && 404 !== I.status ? i(I) : (R && R.resourceTiming && (t.resourceTiming = R.resourceTiming),
                            this.map._refreshExpiredTiles && R && t.setExpiryData(R),
                            t.loadVectorData(R, this.map.painter),
                            s.aE(this.dispatcher),
                            i(null),
                            void (t.reloadCallback && (this.loadTile(t, t.reloadCallback),
                            t.reloadCallback = null)))
                        }
                    }
                    abortTile(t) {
                        t.request && (t.request.cancel(),
                        delete t.request),
                        t.actor && t.actor.send("abortTile", {
                            uid: t.uid,
                            type: this.type,
                            source: this.id,
                            scope: this.scope
                        })
                    }
                    unloadTile(t, i) {
                        t.actor && t.actor.send("removeTile", {
                            uid: t.uid,
                            type: this.type,
                            source: this.id,
                            scope: this.scope
                        }),
                        t.destroy()
                    }
                    hasTransition() {
                        return !1
                    }
                    afterUpdate() {
                        this._tileWorkers = {}
                    }
                    cancelTileJSONRequest() {
                        this._tileJSONRequest && (this._tileJSONRequest.cancel(),
                        this._tileJSONRequest = null)
                    }
                }
                class js extends s.E {
                    constructor(t, i, h, d) {
                        super(),
                        this.id = t,
                        this.dispatcher = h,
                        this.setEventedParent(d),
                        this.type = "raster",
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.roundZoom = !0,
                        this.scheme = "xyz",
                        this.tileSize = 512,
                        this._loaded = !1,
                        this._options = s.l({
                            type: "raster"
                        }, i),
                        s.l(this, s.ay(i, ["url", "scheme", "tileSize"]))
                    }
                    load(t) {
                        this._loaded = !1,
                        this.fire(new s.z("dataloading",{
                            dataType: "source"
                        })),
                        this._tileJSONRequest = jl(this._options, this.map._requestManager, null, null, (i, h) => {
                            this._tileJSONRequest = null,
                            this._loaded = !0,
                            i ? this.fire(new s.y(i)) : h && (s.l(this, h),
                            h.raster_layers && (this.rasterLayers = h.raster_layers,
                            this.rasterLayerIds = this.rasterLayers.map(d => d.id)),
                            h.bounds && (this.tileBounds = new bs(h.bounds,this.minzoom,this.maxzoom)),
                            Jt(h.tiles),
                            this.fire(new s.z("data",{
                                dataType: "source",
                                sourceDataType: "metadata"
                            })),
                            this.fire(new s.z("data",{
                                dataType: "source",
                                sourceDataType: "content"
                            }))),
                            t && t(i)
                        }
                        )
                    }
                    loaded() {
                        return this._loaded
                    }
                    onAdd(t) {
                        this.map = t,
                        this.load()
                    }
                    reload() {
                        this.cancelTileJSONRequest();
                        const t = s.aC(this.id, this.scope);
                        this.load( () => this.map.style.clearSource(t))
                    }
                    setTiles(t) {
                        return this._options.tiles = t,
                        this.reload(),
                        this
                    }
                    setUrl(t) {
                        return this.url = t,
                        this._options.url = t,
                        this.reload(),
                        this
                    }
                    onRemove(t) {
                        this.cancelTileJSONRequest()
                    }
                    serialize() {
                        return s.l({}, this._options)
                    }
                    hasTile(t) {
                        return !this.tileBounds || this.tileBounds.contains(t.canonical)
                    }
                    loadTile(t, i) {
                        const h = s.q.devicePixelRatio >= 2
                          , d = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), h, this.tileSize);
                        t.request = s.o(this.map._requestManager.transformRequest(d, s.R.Tile), (m, y, M, E) => (delete t.request,
                        t.aborted ? (t.state = "unloaded",
                        i(null)) : m ? (t.state = "errored",
                        i(m)) : y ? (this.map._refreshExpiredTiles && t.setExpiryData({
                            cacheControl: M,
                            expires: E
                        }),
                        t.setTexture(y, this.map.painter),
                        t.state = "loaded",
                        s.aE(this.dispatcher),
                        void i(null)) : i(null)))
                    }
                    abortTile(t, i) {
                        t.request && (t.request.cancel(),
                        delete t.request),
                        i && i()
                    }
                    unloadTile(t, i) {
                        t.texture && t.texture instanceof s.T ? (t.destroy(!0),
                        t.texture && t.texture instanceof s.T && this.map.painter.saveTileTexture(t.texture)) : t.destroy(),
                        i && i()
                    }
                    hasTransition() {
                        return !1
                    }
                    cancelTileJSONRequest() {
                        this._tileJSONRequest && (this._tileJSONRequest.cancel(),
                        this._tileJSONRequest = null)
                    }
                }
                class ls extends js {
                    constructor(t, i, h, d) {
                        super(t, i, h, d),
                        this.type = "raster-array",
                        this.maxzoom = 22,
                        this._options = s.l({
                            type: "raster-array"
                        }, i)
                    }
                    triggerRepaint(t) {
                        const i = this.map.painter._terrain
                          , h = this.map.style.getSourceCache(this.id);
                        i && i.enabled && h && i._clearRenderCacheForTile(h.id, t.tileID),
                        this.map.triggerRepaint()
                    }
                    loadTile(t, i) {
                        const h = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize)
                          , d = this.map._requestManager.transformRequest(h, s.R.Tile);
                        t.requestParams = d,
                        t.actor || (t.actor = this.dispatcher.getActor()),
                        t.request = t.fetchHeader(void 0, (m, y, M, E) => (delete t.request,
                        t.aborted ? (t.state = "unloaded",
                        i(null)) : m ? 20 === m.code ? void 0 : (t.state = "errored",
                        i(m)) : (this.map._refreshExpiredTiles && t.setExpiryData({
                            cacheControl: M,
                            expires: E
                        }),
                        t.state = "empty",
                        void i(null))))
                    }
                    unloadTile(t, i) {
                        const h = t.texture;
                        h && h instanceof s.T ? (t.destroy(!0),
                        this.map.painter.saveTileTexture(h)) : (t.destroy(),
                        t.flushQueues(),
                        t._isHeaderLoaded = !1,
                        delete t._mrt,
                        delete t.textureDescriptor),
                        t.fbo && (t.fbo.destroy(),
                        delete t.fbo),
                        delete t.request,
                        delete t.requestParams,
                        delete t.neighboringTiles,
                        t.state = "unloaded"
                    }
                    prepareTile(t, i, h) {
                        t._isHeaderLoaded && ("empty" !== t.state && (t.state = "reloading"),
                        t.fetchBand(i, h, (d, m) => {
                            if (d)
                                return t.state = "errored",
                                this.fire(new s.y(d)),
                                void this.triggerRepaint(t);
                            m && (t.setTexture(m, this.map.painter),
                            t.state = "loaded",
                            this.triggerRepaint(t))
                        }
                        ))
                    }
                    getInitialBand(t) {
                        if (!this.rasterLayers)
                            return 0;
                        const i = this.rasterLayers.find( ({id: m}) => m === t)
                          , h = i && i.fields
                          , d = h && h.bands && h.bands;
                        return d ? d[0] : 0
                    }
                    getTextureDescriptor(t, i, h) {
                        if (!t)
                            return;
                        const d = i.sourceLayer || this.rasterLayerIds && this.rasterLayerIds[0];
                        if (!d)
                            return;
                        let m = null;
                        i instanceof s.aH ? m = i.paint.get("raster-array-band") : i instanceof s.aI && (m = i.paint.get("raster-particle-array-band"));
                        const y = m || this.getInitialBand(d);
                        if (null != y)
                            if (t.textureDescriptor) {
                                if (!t.updateNeeded(d, y) || h)
                                    return Object.assign({}, t.textureDescriptor, {
                                        texture: t.texture
                                    })
                            } else
                                this.prepareTile(t, d, y)
                    }
                }
                const fr = {
                    vector: Va,
                    raster: js,
                    "raster-dem": class extends js {
                        constructor(c, t, i, h) {
                            super(c, t, i, h),
                            this.type = "raster-dem",
                            this.maxzoom = 22,
                            this._options = s.l({
                                type: "raster-dem"
                            }, t),
                            this.encoding = t.encoding || "mapbox"
                        }
                        loadTile(c, t) {
                            const i = this.map._requestManager.normalizeTileURL(c.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);
                            function h(d, m) {
                                d && (c.state = "errored",
                                t(d)),
                                m && (c.dem = m,
                                c.dem.onDeserialize(),
                                c.needsHillshadePrepare = !0,
                                c.needsDEMTextureUpload = !0,
                                c.state = "loaded",
                                t(null))
                            }
                            c.request = s.o(this.map._requestManager.transformRequest(i, s.R.Tile), function(d, m, y, M) {
                                if (delete c.request,
                                c.aborted)
                                    c.state = "unloaded",
                                    t(null);
                                else if (d)
                                    c.state = "errored",
                                    t(d);
                                else if (m) {
                                    this.map._refreshExpiredTiles && c.setExpiryData({
                                        cacheControl: y,
                                        expires: M
                                    });
                                    const E = ImageBitmap && m instanceof ImageBitmap && s.t()
                                      , S = 1 - (m.width - s.aF(m.width)) / 2;
                                    S < 1 || c.neighboringTiles || (c.neighboringTiles = this._getNeighboringTiles(c.tileID));
                                    const I = E ? m : s.q.getImageData(m, S)
                                      , R = {
                                        uid: c.uid,
                                        coord: c.tileID,
                                        source: this.id,
                                        scope: this.scope,
                                        rawImageData: I,
                                        encoding: this.encoding,
                                        padding: S
                                    };
                                    c.actor && "expired" !== c.state || (c.actor = this.dispatcher.getActor(),
                                    c.actor.send("loadDEMTile", R, h.bind(this), void 0, !0))
                                }
                            }
                            .bind(this))
                        }
                        _getNeighboringTiles(c) {
                            const t = c.canonical
                              , i = Math.pow(2, t.z)
                              , h = (t.x - 1 + i) % i
                              , d = 0 === t.x ? c.wrap - 1 : c.wrap
                              , m = (t.x + 1 + i) % i
                              , y = t.x + 1 === i ? c.wrap + 1 : c.wrap
                              , M = {};
                            return M[new s.aG(c.overscaledZ,d,t.z,h,t.y).key] = {
                                backfilled: !1
                            },
                            M[new s.aG(c.overscaledZ,y,t.z,m,t.y).key] = {
                                backfilled: !1
                            },
                            t.y > 0 && (M[new s.aG(c.overscaledZ,d,t.z,h,t.y - 1).key] = {
                                backfilled: !1
                            },
                            M[new s.aG(c.overscaledZ,c.wrap,t.z,t.x,t.y - 1).key] = {
                                backfilled: !1
                            },
                            M[new s.aG(c.overscaledZ,y,t.z,m,t.y - 1).key] = {
                                backfilled: !1
                            }),
                            t.y + 1 < i && (M[new s.aG(c.overscaledZ,d,t.z,h,t.y + 1).key] = {
                                backfilled: !1
                            },
                            M[new s.aG(c.overscaledZ,c.wrap,t.z,t.x,t.y + 1).key] = {
                                backfilled: !1
                            },
                            M[new s.aG(c.overscaledZ,y,t.z,m,t.y + 1).key] = {
                                backfilled: !1
                            }),
                            M
                        }
                    }
                    ,
                    "raster-array": ls,
                    geojson: class extends s.E {
                        constructor(c, t, i, h) {
                            super(),
                            this.id = c,
                            this.type = "geojson",
                            this.minzoom = 0,
                            this.maxzoom = 18,
                            this.tileSize = 512,
                            this.isTileClipped = !0,
                            this.reparseOverscaled = !0,
                            this._loaded = !1,
                            this.actor = i.getActor(),
                            this.setEventedParent(h),
                            this._data = t.data,
                            this._options = s.l({}, t),
                            this._collectResourceTiming = t.collectResourceTiming,
                            void 0 !== t.maxzoom && (this.maxzoom = t.maxzoom),
                            void 0 !== t.minzoom && (this.minzoom = t.minzoom),
                            t.type && (this.type = t.type),
                            t.attribution && (this.attribution = t.attribution),
                            this.promoteId = t.promoteId;
                            const d = s.ag / this.tileSize;
                            this.workerOptions = s.l({
                                source: this.id,
                                scope: this.scope,
                                cluster: t.cluster || !1,
                                geojsonVtOptions: {
                                    buffer: (void 0 !== t.buffer ? t.buffer : 128) * d,
                                    tolerance: (void 0 !== t.tolerance ? t.tolerance : .375) * d,
                                    extent: s.ag,
                                    maxZoom: this.maxzoom,
                                    lineMetrics: t.lineMetrics || !1,
                                    generateId: t.generateId || !1
                                },
                                superclusterOptions: {
                                    maxZoom: void 0 !== t.clusterMaxZoom ? t.clusterMaxZoom : this.maxzoom - 1,
                                    minPoints: Math.max(2, t.clusterMinPoints || 2),
                                    extent: s.ag,
                                    radius: (void 0 !== t.clusterRadius ? t.clusterRadius : 50) * d,
                                    log: !1,
                                    generateId: t.generateId || !1
                                },
                                clusterProperties: t.clusterProperties,
                                filter: t.filter,
                                dynamic: t.dynamic
                            }, t.workerOptions)
                        }
                        onAdd(c) {
                            this.map = c,
                            this.setData(this._data)
                        }
                        setData(c) {
                            return this._data = c,
                            this._updateWorkerData(),
                            this
                        }
                        updateData(c) {
                            if (!this._options.dynamic)
                                return this.fire(new s.y(new Error("Can't call updateData on a GeoJSON source with dynamic set to false.")));
                            if ("string" != typeof c && ("Feature" === c.type && (c = {
                                type: "FeatureCollection",
                                features: [c]
                            }),
                            "FeatureCollection" !== c.type))
                                return this.fire(new s.y(new Error("Data to update should be a feature or a feature collection.")));
                            if (this._coalesce && "string" != typeof c && "string" != typeof this._data && "FeatureCollection" === this._data.type) {
                                const t = new Map;
                                for (const i of this._data.features)
                                    t.set(i.id, i);
                                for (const i of c.features)
                                    t.set(i.id, i);
                                this._data.features = [...t.values()]
                            } else
                                this._data = c;
                            return this._updateWorkerData(!0),
                            this
                        }
                        getClusterExpansionZoom(c, t) {
                            return this.actor.send("geojson.getClusterExpansionZoom", {
                                clusterId: c,
                                source: this.id,
                                scope: this.scope
                            }, t),
                            this
                        }
                        getClusterChildren(c, t) {
                            return this.actor.send("geojson.getClusterChildren", {
                                clusterId: c,
                                source: this.id,
                                scope: this.scope
                            }, t),
                            this
                        }
                        getClusterLeaves(c, t, i, h) {
                            return this.actor.send("geojson.getClusterLeaves", {
                                source: this.id,
                                scope: this.scope,
                                clusterId: c,
                                limit: t,
                                offset: i
                            }, h),
                            this
                        }
                        _updateWorkerData(c=!1) {
                            if (this._pendingLoad)
                                return void (this._coalesce = !0);
                            this.fire(new s.z("dataloading",{
                                dataType: "source"
                            })),
                            this._loaded = !1;
                            const t = s.l({
                                append: c
                            }, this.workerOptions);
                            t.scope = this.scope;
                            const i = this._data;
                            "string" == typeof i ? (t.request = this.map._requestManager.transformRequest(s.q.resolveURL(i), s.R.Source),
                            t.request.collectResourceTiming = this._collectResourceTiming) : t.data = JSON.stringify(i),
                            this._pendingLoad = this.actor.send("".concat(this.type, ".loadData"), t, (h, d) => {
                                if (this._loaded = !0,
                                this._pendingLoad = null,
                                h)
                                    this.fire(new s.y(h));
                                else {
                                    const m = {
                                        dataType: "source",
                                        sourceDataType: this._metadataFired ? "content" : "metadata"
                                    };
                                    this._collectResourceTiming && d && d.resourceTiming && d.resourceTiming[this.id] && (m.resourceTiming = d.resourceTiming[this.id]),
                                    c && (this._partialReload = !0),
                                    this.fire(new s.z("data",m)),
                                    this._partialReload = !1,
                                    this._metadataFired = !0
                                }
                                this._coalesce && (this._updateWorkerData(c),
                                this._coalesce = !1)
                            }
                            )
                        }
                        loaded() {
                            return this._loaded
                        }
                        loadTile(c, t) {
                            const i = c.actor ? "reloadTile" : "loadTile";
                            c.actor = this.actor;
                            const h = this.map.style ? this.map.style.getLut(this.scope) : null
                              , d = h ? {
                                image: h.image.clone()
                            } : null
                              , m = this._partialReload
                              , y = {
                                type: this.type,
                                uid: c.uid,
                                tileID: c.tileID,
                                tileZoom: c.tileZoom,
                                zoom: c.tileID.overscaledZ,
                                maxZoom: this.maxzoom,
                                tileSize: this.tileSize,
                                source: this.id,
                                lut: d,
                                scope: this.scope,
                                pixelRatio: s.q.devicePixelRatio,
                                showCollisionBoxes: this.map.showCollisionBoxes,
                                promoteId: this.promoteId,
                                brightness: this.map.style && this.map.style.getBrightness() || 0,
                                scaleFactor: this.map.getScaleFactor(),
                                partial: m
                            };
                            c.request = this.actor.send(i, y, (M, E) => m && !E ? (c.state = "loaded",
                            t(null)) : (delete c.request,
                            c.destroy(),
                            c.aborted ? t(null) : M ? t(M) : (c.loadVectorData(E, this.map.painter, "reloadTile" === i),
                            t(null))), void 0, "loadTile" === i)
                        }
                        abortTile(c) {
                            c.request && (c.request.cancel(),
                            delete c.request),
                            c.aborted = !0
                        }
                        unloadTile(c, t) {
                            this.actor.send("removeTile", {
                                uid: c.uid,
                                type: this.type,
                                source: this.id,
                                scope: this.scope
                            }),
                            c.destroy()
                        }
                        onRemove(c) {
                            this._pendingLoad && this._pendingLoad.cancel()
                        }
                        serialize() {
                            return s.l({}, this._options, {
                                type: this.type,
                                data: this._data
                            })
                        }
                        hasTransition() {
                            return !1
                        }
                    }
                    ,
                    video: class extends s.aJ {
                        constructor(c, t, i, h) {
                            super(c, t, i, h),
                            this.roundZoom = !0,
                            this.type = "video",
                            this.options = t
                        }
                        load() {
                            this._loaded = !1;
                            const c = this.options;
                            this.urls = [];
                            for (const t of c.urls)
                                this.urls.push(this.map._requestManager.transformRequest(t, s.R.Source).url);
                            s.aK(this.urls, (t, i) => {
                                this._loaded = !0,
                                t ? this.fire(new s.y(t)) : i && (this.video = i,
                                this.video.loop = !0,
                                this.video.setAttribute("playsinline", ""),
                                this.video.addEventListener("playing", () => {
                                    this.map.triggerRepaint()
                                }
                                ),
                                this.map && this.video.play(),
                                this._finishLoading())
                            }
                            )
                        }
                        pause() {
                            this.video && this.video.pause()
                        }
                        play() {
                            this.video && this.video.play()
                        }
                        seek(c) {
                            if (this.video) {
                                const t = this.video.seekable;
                                c < t.start(0) || c > t.end(0) ? this.fire(new s.y(new s.V("sources.".concat(this.id),null,"Playback for this video can be set only between the ".concat(t.start(0), " and ").concat(t.end(0), "-second mark.")))) : this.video.currentTime = c
                            }
                        }
                        getVideo() {
                            return this.video
                        }
                        onAdd(c) {
                            this.map || (this.map = c,
                            this.load(),
                            this.video && (this.video.play(),
                            this.setCoordinates(this.coordinates)))
                        }
                        prepare() {
                            if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
                                return;
                            const c = this.map.painter.context
                              , t = c.gl;
                            this.texture ? this.video.paused || (this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE),
                            t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, t.RGBA, t.UNSIGNED_BYTE, this.video)) : (this.texture = new s.T(c,this.video,t.RGBA8),
                            this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE),
                            this.width = this.video.videoWidth,
                            this.height = this.video.videoHeight),
                            this._prepareData(c)
                        }
                        serialize() {
                            return {
                                type: "video",
                                urls: this.urls,
                                coordinates: this.coordinates
                            }
                        }
                        hasTransition() {
                            return this.video && !this.video.paused
                        }
                    }
                    ,
                    image: s.aJ,
                    model: class extends s.E {
                        constructor(c, t, i, h) {
                            super(),
                            this.id = c,
                            this.type = "model",
                            this.models = [],
                            this._loaded = !1,
                            this._options = t
                        }
                        load() {
                            const c = [];
                            for (const t in this._options.models) {
                                const i = this._options.models[t]
                                  , h = s.aM(this.map._requestManager.transformRequest(i.uri, s.R.Model).url).then(d => {
                                    if (!d)
                                        return;
                                    const m = s.aN(d)
                                      , y = new s.aO(t,i.position,i.orientation,m);
                                    y.computeBoundsAndApplyParent(),
                                    this.models.push(y)
                                }
                                ).catch(d => {
                                    this.fire(new s.y(new Error("Could not load model ".concat(t, " from ").concat(i.uri, ": ").concat(d.message))))
                                }
                                );
                                c.push(h)
                            }
                            return Promise.allSettled(c).then( () => {
                                this._loaded = !0,
                                this.fire(new s.z("data",{
                                    dataType: "source",
                                    sourceDataType: "metadata"
                                }))
                            }
                            ).catch(t => {
                                this.fire(new s.y(new Error("Could not load models: ".concat(t.message))))
                            }
                            )
                        }
                        onAdd(c) {
                            this.map = c,
                            this.load()
                        }
                        hasTransition() {
                            return !1
                        }
                        loaded() {
                            return this._loaded
                        }
                        getModels() {
                            return this.models
                        }
                        loadTile(c, t) {}
                        serialize() {
                            return {
                                type: "model"
                            }
                        }
                    }
                    ,
                    "batched-model": class extends s.E {
                        constructor(c, t, i, h) {
                            super(),
                            this.type = "batched-model",
                            this.id = c,
                            this.tileSize = 512,
                            this._options = t,
                            this.tiles = this._options.tiles,
                            this.maxzoom = t.maxzoom || 19,
                            this.minzoom = t.minzoom || 0,
                            this.roundZoom = !0,
                            this.usedInConflation = !0,
                            this.dispatcher = i,
                            this.reparseOverscaled = !1,
                            this.scheme = "xyz",
                            this._loaded = !1,
                            this.setEventedParent(h)
                        }
                        onAdd(c) {
                            this.map = c,
                            this.load()
                        }
                        load(c) {
                            this._loaded = !1,
                            this.fire(new s.z("dataloading",{
                                dataType: "source"
                            }));
                            const t = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language
                              , i = this.map.getWorldview();
                            this._tileJSONRequest = jl(this._options, this.map._requestManager, t, i, (h, d) => {
                                this._tileJSONRequest = null,
                                this._loaded = !0,
                                h ? (t && console.warn("Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ".concat(t)),
                                i && 2 !== i.length && console.warn("Requested worldview strings must be a valid ISO alpha-2 code. Found: ".concat(i)),
                                this.fire(new s.y(h))) : d && (s.l(this, d),
                                d.bounds && (this.tileBounds = new bs(d.bounds,this.minzoom,this.maxzoom)),
                                Jt(d.tiles, this.map._requestManager._customAccessToken),
                                this.fire(new s.z("data",{
                                    dataType: "source",
                                    sourceDataType: "metadata"
                                })),
                                this.fire(new s.z("data",{
                                    dataType: "source",
                                    sourceDataType: "content"
                                }))),
                                c && c(h)
                            }
                            )
                        }
                        hasTransition() {
                            return !1
                        }
                        hasTile(c) {
                            return !this.tileBounds || this.tileBounds.contains(c.canonical)
                        }
                        loaded() {
                            return this._loaded
                        }
                        loadTile(c, t) {
                            const i = this.map._requestManager.normalizeTileURL(c.tileID.canonical.url(this.tiles, this.scheme))
                              , h = {
                                request: this.map._requestManager.transformRequest(i, s.R.Tile),
                                data: void 0,
                                uid: c.uid,
                                tileID: c.tileID,
                                tileZoom: c.tileZoom,
                                zoom: c.tileID.overscaledZ,
                                tileSize: this.tileSize * c.tileID.overscaleFactor(),
                                type: this.type,
                                source: this.id,
                                scope: this.scope,
                                showCollisionBoxes: this.map.showCollisionBoxes,
                                isSymbolTile: c.isSymbolTile,
                                brightness: this.map.style && this.map.style.getBrightness() || 0,
                                lut: null,
                                maxZoom: null,
                                promoteId: null,
                                pixelRatio: null,
                                scaleFactor: null
                            };
                            if (c.actor && "expired" !== c.state)
                                if ("loading" === c.state)
                                    c.reloadCallback = t;
                                else {
                                    if (c.buckets) {
                                        const m = Object.values(c.buckets);
                                        for (const y of m)
                                            y.dirty = !0;
                                        return void (c.state = "loaded")
                                    }
                                    c.request = c.actor.send("reloadTile", h, d.bind(this))
                                }
                            else
                                c.actor = this.dispatcher.getActor(),
                                c.request = c.actor.send("loadTile", h, d.bind(this), void 0, !0);
                            function d(m, y) {
                                return c.aborted ? t(null) : m && 404 !== m.status ? t(m) : (this.map._refreshExpiredTiles && y && c.setExpiryData(y),
                                c.loadModelData(y, this.map.painter),
                                c.state = "loaded",
                                void t(null))
                            }
                        }
                        serialize() {
                            return s.l({}, this._options)
                        }
                    }
                    ,
                    canvas: class extends s.aJ {
                        constructor(c, t, i, h) {
                            super(c, t, i, h),
                            t.coordinates ? Array.isArray(t.coordinates) && 4 === t.coordinates.length && !t.coordinates.some(d => !Array.isArray(d) || 2 !== d.length || d.some(m => "number" != typeof m)) || this.fire(new s.y(new s.V("sources.".concat(c),null,'"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new s.y(new s.V("sources.".concat(c),null,'missing required property "coordinates"'))),
                            t.animate && "boolean" != typeof t.animate && this.fire(new s.y(new s.V("sources.".concat(c),null,'optional "animate" property must be a boolean value'))),
                            t.canvas ? "string" == typeof t.canvas || t.canvas instanceof HTMLCanvasElement || this.fire(new s.y(new s.V("sources.".concat(c),null,'"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new s.y(new s.V("sources.".concat(c),null,'missing required property "canvas"'))),
                            this.options = t,
                            this.animate = void 0 === t.animate || t.animate
                        }
                        load() {
                            this._loaded = !0,
                            this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)),
                            this.width = this.canvas.width,
                            this.height = this.canvas.height,
                            this._hasInvalidDimensions() ? this.fire(new s.y(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                                this._playing = !0,
                                this.map.triggerRepaint()
                            }
                            ,
                            this.pause = function() {
                                this._playing && (this.prepare(),
                                this._playing = !1)
                            }
                            ,
                            this._finishLoading())
                        }
                        getCanvas() {
                            return this.canvas
                        }
                        onAdd(c) {
                            this.map = c,
                            this.load(),
                            this.canvas && this.animate && this.play()
                        }
                        onRemove(c) {
                            this.pause()
                        }
                        prepare() {
                            let c = !1;
                            if (this.canvas.width !== this.width && (this.width = this.canvas.width,
                            c = !0),
                            this.canvas.height !== this.height && (this.height = this.canvas.height,
                            c = !0),
                            this._hasInvalidDimensions() || 0 === Object.keys(this.tiles).length)
                                return;
                            const t = this.map.painter.context;
                            this.texture ? !c && !this._playing || this.texture instanceof s.aL || this.texture.update(this.canvas, {
                                premultiply: !0
                            }) : this.texture = new s.T(t,this.canvas,t.gl.RGBA8,{
                                premultiply: !0
                            }),
                            this._prepareData(t)
                        }
                        serialize() {
                            return {
                                type: "canvas",
                                coordinates: this.coordinates
                            }
                        }
                        hasTransition() {
                            return this._playing
                        }
                        _hasInvalidDimensions() {
                            for (const c of [this.canvas.width, this.canvas.height])
                                if (isNaN(c) || c <= 0)
                                    return !0;
                            return !1
                        }
                    }
                    ,
                    custom: class extends s.E {
                        constructor(c, t, i, h) {
                            super(),
                            this.id = c,
                            this.type = "custom",
                            this._dataType = "raster",
                            this._dispatcher = i,
                            this._implementation = t,
                            this.setEventedParent(h),
                            this.scheme = "xyz",
                            this.minzoom = 0,
                            this.maxzoom = 22,
                            this.tileSize = 512,
                            this._loaded = !1,
                            this.roundZoom = !0,
                            this._implementation || this.fire(new s.y(new Error("Missing implementation for ".concat(this.id, " custom source")))),
                            this._implementation.loadTile || this.fire(new s.y(new Error("Missing loadTile implementation for ".concat(this.id, " custom source")))),
                            this._implementation.bounds && (this.tileBounds = new bs(this._implementation.bounds,this.minzoom,this.maxzoom)),
                            t.update = this._update.bind(this),
                            t.clearTiles = this._clearTiles.bind(this),
                            t.coveringTiles = this._coveringTiles.bind(this),
                            s.l(this, s.ay(t, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]))
                        }
                        serialize() {
                            return s.ay(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"])
                        }
                        load() {
                            this._loaded = !0,
                            this.fire(new s.z("data",{
                                dataType: "source",
                                sourceDataType: "metadata"
                            })),
                            this.fire(new s.z("data",{
                                dataType: "source",
                                sourceDataType: "content"
                            }))
                        }
                        loaded() {
                            return this._loaded
                        }
                        onAdd(c) {
                            this.map = c,
                            this._loaded = !1,
                            this.fire(new s.z("dataloading",{
                                dataType: "source"
                            })),
                            this._implementation.onAdd && this._implementation.onAdd(c),
                            this.load()
                        }
                        onRemove(c) {
                            this._implementation.onRemove && this._implementation.onRemove(c)
                        }
                        hasTile(c) {
                            if (this._implementation.hasTile) {
                                const {x: t, y: i, z: h} = c.canonical;
                                return this._implementation.hasTile({
                                    x: t,
                                    y: i,
                                    z: h
                                })
                            }
                            return !this.tileBounds || this.tileBounds.contains(c.canonical)
                        }
                        loadTile(c, t) {
                            const {x: i, y: h, z: d} = c.tileID.canonical
                              , m = new AbortController;
                            c.request = Promise.resolve(this._implementation.loadTile({
                                x: i,
                                y: h,
                                z: d
                            }, {
                                signal: m.signal
                            })).then(function(y) {
                                return delete c.request,
                                c.aborted ? (c.state = "unloaded",
                                t(null)) : void 0 === y ? (c.state = "errored",
                                t(null)) : null === y ? (this.loadTileData(c, {
                                    width: this.tileSize,
                                    height: this.tileSize,
                                    data: null
                                }),
                                c.state = "loaded",
                                t(null)) : (M = y)instanceof ImageData || M instanceof HTMLCanvasElement || M instanceof ImageBitmap || M instanceof HTMLImageElement ? (this.loadTileData(c, y),
                                c.state = "loaded",
                                void t(null)) : (c.state = "errored",
                                t(new Error("Can't infer data type for ".concat(this.id, ", only raster data supported at the moment"))));
                                var M
                            }
                            .bind(this)).catch(y => {
                                20 !== y.code && (c.state = "errored",
                                t(y))
                            }
                            ),
                            c.request.cancel = () => m.abort()
                        }
                        loadTileData(c, t) {
                            c.setTexture(t, this.map.painter)
                        }
                        unloadTile(c, t) {
                            if (c.texture && c.texture instanceof s.T ? (c.destroy(!0),
                            c.texture && c.texture instanceof s.T && this.map.painter.saveTileTexture(c.texture)) : c.destroy(),
                            this._implementation.unloadTile) {
                                const {x: i, y: h, z: d} = c.tileID.canonical;
                                this._implementation.unloadTile({
                                    x: i,
                                    y: h,
                                    z: d
                                })
                            }
                            t && t()
                        }
                        abortTile(c, t) {
                            c.request && c.request.cancel && (c.request.cancel(),
                            delete c.request),
                            t && t()
                        }
                        hasTransition() {
                            return !1
                        }
                        _coveringTiles() {
                            return this.map.transform.coveringTiles({
                                tileSize: this.tileSize,
                                minzoom: this.minzoom,
                                maxzoom: this.maxzoom,
                                roundZoom: this.roundZoom
                            }).map(c => ({
                                x: c.canonical.x,
                                y: c.canonical.y,
                                z: c.canonical.z
                            }))
                        }
                        _clearTiles() {
                            const c = s.aC(this.id, this.scope);
                            this.map.style.clearSource(c)
                        }
                        _update() {
                            this.fire(new s.z("data",{
                                dataType: "source",
                                sourceDataType: "content"
                            }))
                        }
                    }
                }
                  , jc = function(c, t, i, h) {
                    const d = new fr[t.type](c,t,i,h);
                    if (d.id !== c)
                        throw new Error("Expected Source id to be ".concat(c, " instead of ").concat(d.id));
                    return s.aP(["load", "abort", "unload", "serialize", "prepare"], d),
                    d
                };
                function Vc(c, t, i, h, d=!1) {
                    const m = t.sourceCache.transform
                      , y = t.sourceCache.tilesIn(c, t.has3DLayers, d);
                    y.sort(Wa);
                    const M = [];
                    for (const E of y) {
                        const S = E.tile.queryRenderedFeatures(t, E, i, h, m, d);
                        Object.keys(S).length && M.push({
                            wrappedTileID: E.tile.tileID.wrapped().key,
                            queryResults: S
                        })
                    }
                    return 0 === M.length ? {} : function(E) {
                        const S = {}
                          , I = {};
                        for (const R of E) {
                            const D = R.queryResults
                              , k = R.wrappedTileID
                              , H = I[k] = I[k] || {};
                            for (const j in D) {
                                const Y = D[j]
                                  , K = H[j] = H[j] || {}
                                  , he = S[j] = S[j] || [];
                                for (const Te of Y)
                                    K[Te.featureIndex] || (K[Te.featureIndex] = !0,
                                    he.push(Te))
                            }
                        }
                        return S
                    }(M)
                }
                function Ha(c, t, i, h, d) {
                    const m = {}
                      , y = h.queryRenderedSymbols(c)
                      , M = [];
                    for (const E of Object.keys(y).map(Number))
                        M.push(d[E]);
                    M.sort(Wa);
                    for (const E of M) {
                        const S = E.featureIndex.lookupSymbolFeatures(y[E.bucketInstanceId], E.bucketIndex, E.sourceLayerIndex, t, i);
                        for (const I in S) {
                            const R = m[I] = m[I] || []
                              , D = S[I];
                            D.sort( (k, H) => {
                                const j = E.featureSortOrder;
                                if (j) {
                                    const Y = j.indexOf(k.featureIndex);
                                    return j.indexOf(H.featureIndex) - Y
                                }
                                return H.featureIndex - k.featureIndex
                            }
                            );
                            for (const k of D)
                                R.push(k)
                        }
                    }
                    return m
                }
                function wa(c, t) {
                    const i = c.getRenderableIds().map(m => c.getTileByID(m))
                      , h = []
                      , d = {};
                    for (let m = 0; m < i.length; m++) {
                        const y = i[m]
                          , M = y.tileID.canonical.key;
                        d[M] || (d[M] = !0,
                        y.querySourceFeatures(h, t))
                    }
                    return h
                }
                function Wa(c, t) {
                    const i = c.tileID
                      , h = t.tileID;
                    return i.overscaledZ - h.overscaledZ || i.canonical.y - h.canonical.y || i.wrap - h.wrap || i.canonical.x - h.canonical.x
                }
                function Hc(c, t) {
                    const i = {};
                    if (!t)
                        return i;
                    for (const h of c) {
                        const d = h.layerIds.map(m => t.getLayer(m)).filter(Boolean);
                        if (0 !== d.length) {
                            h.layers = d,
                            h.stateDependentLayerIds && (h.stateDependentLayers = h.stateDependentLayerIds.map(m => d.filter(y => y.id === m)[0]));
                            for (const m of d)
                                i[m.fqid] = h
                        }
                    }
                    return i
                }
                const _r = new Uint16Array(8184);
                for (let c = 0; c < 2046; c++) {
                    let t = c + 2
                      , i = 0
                      , h = 0
                      , d = 0
                      , m = 0
                      , y = 0
                      , M = 0;
                    for (1 & t ? d = m = y = 32 : i = h = M = 32; (t >>= 1) > 1; ) {
                        const S = i + d >> 1
                          , I = h + m >> 1;
                        1 & t ? (d = i,
                        m = h,
                        i = y,
                        h = M) : (i = d,
                        h = m,
                        d = y,
                        m = M),
                        y = S,
                        M = I
                    }
                    const E = 4 * c;
                    _r[E + 0] = i,
                    _r[E + 1] = h,
                    _r[E + 2] = d,
                    _r[E + 3] = m
                }
                const Fr = new Uint16Array(2178)
                  , cs = new Uint8Array(1089)
                  , Vs = new Uint16Array(1089);
                function Xa(c) {
                    return 0 === c ? -.03125 : 32 === c ? .03125 : 0
                }
                const Wr = {
                    type: 2,
                    extent: s.ag,
                    loadGeometry: () => [[new s.P(0,0), new s.P(s.ag + 1,0), new s.P(s.ag + 1,s.ag + 1), new s.P(0,s.ag + 1), new s.P(0,0)]]
                };
                class hs {
                    constructor(t, i, h, d, m) {
                        this.tileID = t,
                        this.uid = s.aV(),
                        this.uses = 0,
                        this.tileSize = i,
                        this.tileZoom = h,
                        this.buckets = {},
                        this.expirationTime = null,
                        this.queryPadding = 0,
                        this.hasSymbolBuckets = !1,
                        this.hasRTLText = !1,
                        this.dependencies = {},
                        this.isRaster = m,
                        d && d.style && (this._lastUpdatedBrightness = d.style.getBrightness()),
                        this.expiredRequestCount = 0,
                        this.state = "loading",
                        d && d.transform && (this.projection = d.transform.projection)
                    }
                    registerFadeDuration(t) {
                        const i = t + this.timeAdded;
                        i < s.q.now() || this.fadeEndTime && i < this.fadeEndTime || (this.fadeEndTime = i)
                    }
                    wasRequested() {
                        return "errored" === this.state || "loaded" === this.state || "reloading" === this.state
                    }
                    get tileTransform() {
                        return this._tileTransform || (this._tileTransform = s.aQ(this.tileID.canonical, this.projection)),
                        this._tileTransform
                    }
                    loadVectorData(t, i, h) {
                        if (this.unloadVectorData(),
                        this.state = "loaded",
                        t) {
                            t.featureIndex && (this.latestFeatureIndex = t.featureIndex,
                            t.rawTileData ? (this.latestRawTileData = t.rawTileData,
                            this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)),
                            this.collisionBoxArray = t.collisionBoxArray,
                            this.buckets = Hc(t.buckets, i.style),
                            this.hasSymbolBuckets = !1;
                            for (const d in this.buckets) {
                                const m = this.buckets[d];
                                if (m instanceof s.aX) {
                                    if (this.hasSymbolBuckets = !0,
                                    !h)
                                        break;
                                    m.justReloaded = !0
                                }
                            }
                            if (this.hasRTLText = !1,
                            this.hasSymbolBuckets)
                                for (const d in this.buckets) {
                                    const m = this.buckets[d];
                                    if (m instanceof s.aX && m.hasRTLText) {
                                        this.hasRTLText = !0,
                                        s.aY();
                                        break
                                    }
                                }
                            this.queryPadding = 0;
                            for (const d in this.buckets) {
                                const m = this.buckets[d]
                                  , y = i.style.getOwnLayer(d);
                                if (!y)
                                    continue;
                                const M = y.queryRadius(m);
                                this.queryPadding = Math.max(this.queryPadding, M)
                            }
                            t.imageAtlas && (this.imageAtlas = t.imageAtlas),
                            t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage),
                            t.lineAtlas && (this.lineAtlas = t.lineAtlas),
                            this._lastUpdatedBrightness = t.brightness
                        } else
                            this.collisionBoxArray = new s.aW
                    }
                    unloadVectorData() {
                        if (this.hasData()) {
                            for (const t in this.buckets)
                                this.buckets[t].destroy();
                            this.buckets = {},
                            this.imageAtlas && (this.imageAtlas = null),
                            this.lineAtlas && (this.lineAtlas = null),
                            this.imageAtlasTexture && this.imageAtlasTexture.destroy(),
                            this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(),
                            this.lineAtlasTexture && this.lineAtlasTexture.destroy(),
                            this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(),
                            this._tileBoundsIndexBuffer.destroy(),
                            this._tileBoundsSegments.destroy(),
                            this._tileBoundsBuffer = null),
                            this._tileDebugBuffer && (this._tileDebugBuffer.destroy(),
                            this._tileDebugSegments.destroy(),
                            this._tileDebugBuffer = null),
                            this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(),
                            this._tileDebugIndexBuffer = null),
                            this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(),
                            this._globeTileDebugBorderBuffer = null),
                            this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(),
                            this._tileDebugTextSegments.destroy(),
                            this._tileDebugTextIndexBuffer.destroy(),
                            this._tileDebugTextBuffer = null),
                            this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(),
                            this._globeTileDebugTextBuffer = null),
                            this.latestFeatureIndex = null,
                            this.state = "unloaded"
                        }
                    }
                    loadModelData(t, i, h) {
                        t && (t.resourceTiming && (this.resourceTiming = t.resourceTiming),
                        this.buckets = {
                            ...this.buckets,
                            ...Hc(t.buckets, i.style)
                        },
                        t.featureIndex && (this.latestFeatureIndex = t.featureIndex))
                    }
                    getBucket(t) {
                        return this.buckets[t.fqid]
                    }
                    upload(t) {
                        for (const d in this.buckets) {
                            const m = this.buckets[d];
                            m.uploadPending() && m.upload(t)
                        }
                        const i = t.gl
                          , h = this.imageAtlas;
                        if (h && !h.uploaded) {
                            const d = !!Object.keys(h.patternPositions).length;
                            this.imageAtlasTexture = new s.T(t,h.image,i.RGBA8,{
                                useMipmap: d
                            }),
                            this.imageAtlas.uploaded = !0
                        }
                        this.glyphAtlasImage && (this.glyphAtlasTexture = new s.T(t,this.glyphAtlasImage,i.R8),
                        this.glyphAtlasImage = null),
                        this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new s.T(t,this.lineAtlas.image,i.R8),
                        this.lineAtlas.uploaded = !0)
                    }
                    prepare(t, i, h) {
                        if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture, h),
                        !i || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData)
                            return;
                        const d = i.style.getBrightness();
                        (this._lastUpdatedBrightness || d) && (this._lastUpdatedBrightness && d && Math.abs(this._lastUpdatedBrightness - d) < .001 || (this.updateBuckets(i, this._lastUpdatedBrightness !== d),
                        this._lastUpdatedBrightness = d))
                    }
                    queryRenderedFeatures(t, i, h, d, m, y) {
                        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData && !this.latestFeatureIndex.is3DTile)
                            return {};
                        const M = function(E, S) {
                            const I = s.ab.mat4.fromScaling([], [.5 * E.width, .5 * -E.height, 1]);
                            return s.ab.mat4.translate(I, I, [1, -1, 0]),
                            s.ab.mat4.multiply(I, I, E.calculateProjMatrix(S.toUnwrapped())),
                            Float32Array.from(I)
                        }(m, this.tileID);
                        return this.latestFeatureIndex.query(t, {
                            tilespaceGeometry: i,
                            pixelPosMatrix: M,
                            transform: d,
                            availableImages: h,
                            tileTransform: this.tileTransform
                        })
                    }
                    querySourceFeatures(t, i) {
                        const h = this.latestFeatureIndex;
                        if (!h || !h.rawTileData)
                            return;
                        const d = h.loadVTLayers()
                          , m = i ? i.sourceLayer : ""
                          , y = d._geojsonTileLayer || d[m];
                        if (!y)
                            return;
                        const M = s.aZ(i && i.filter)
                          , {z: E, x: S, y: I} = this.tileID.canonical
                          , R = {
                            z: E,
                            x: S,
                            y: I
                        };
                        for (let D = 0; D < y.length; D++) {
                            const k = y.feature(D);
                            if (M.needGeometry) {
                                const Y = s.a_(k, !0);
                                if (!M.filter(new s.a8(this.tileID.overscaledZ), Y, this.tileID.canonical))
                                    continue
                            } else if (!M.filter(new s.a8(this.tileID.overscaledZ), k))
                                continue;
                            const H = h.getId(k, m)
                              , j = new s.a$(k,E,S,I,H);
                            j.tile = R,
                            t.push(j)
                        }
                    }
                    hasData() {
                        return "loaded" === this.state || "reloading" === this.state || "expired" === this.state
                    }
                    patternsLoaded() {
                        return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length
                    }
                    setExpiryData(t) {
                        const i = this.expirationTime;
                        if (t.cacheControl) {
                            const h = s.b0(t.cacheControl);
                            h["max-age"] && (this.expirationTime = Date.now() + 1e3 * h["max-age"])
                        } else
                            t.expires && (this.expirationTime = new Date(t.expires).getTime());
                        if (this.expirationTime) {
                            const h = Date.now();
                            let d = !1;
                            if (this.expirationTime > h)
                                d = !1;
                            else if (i)
                                if (this.expirationTime < i)
                                    d = !0;
                                else {
                                    const m = this.expirationTime - i;
                                    m ? this.expirationTime = h + Math.max(m, 3e4) : d = !0
                                }
                            else
                                d = !0;
                            d ? (this.expiredRequestCount++,
                            this.state = "expired") : this.expiredRequestCount = 0
                        }
                    }
                    getExpiryTimeout() {
                        if (this.expirationTime)
                            return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (new Date).getTime(), Math.pow(2, 31) - 1)
                    }
                    refreshFeatureState(t) {
                        this.latestFeatureIndex && (this.latestFeatureIndex.rawTileData || this.latestFeatureIndex.is3DTile) && t && this.updateBuckets(t)
                    }
                    updateBuckets(t, i) {
                        if (!this.latestFeatureIndex || !t.style)
                            return;
                        const h = this.latestFeatureIndex.loadVTLayers()
                          , d = t.style.listImages()
                          , m = t.style.getBrightness();
                        for (const y in this.buckets) {
                            if (!t.style.hasLayer(y))
                                continue;
                            const M = this.buckets[y]
                              , E = M.layers[0]
                              , S = E.sourceLayer || "_geojsonTileLayer"
                              , I = h[S]
                              , R = t.style.getLayerSourceCache(E);
                            let D = {};
                            R && (D = R._state.getState(S, void 0));
                            const k = this.imageAtlas && this.imageAtlas.patternPositions || {}
                              , H = Object.keys(D).length > 0 && !i;
                            H && !M.stateDependentLayers.length && !i || M.update(D, I, d, k, H ? M.stateDependentLayers : M.layers, i, m),
                            (M instanceof s.b1 || M instanceof s.b2) && t._terrain && t._terrain.enabled && R && M.programConfigurations.needsUpload && t._terrain._clearRenderCacheForTile(R.id, this.tileID);
                            const j = t && t.style && t.style.getOwnLayer(y);
                            j && (this.queryPadding = Math.max(this.queryPadding, j.queryRadius(M)))
                        }
                    }
                    holdingForFade() {
                        return void 0 !== this.symbolFadeHoldUntil
                    }
                    symbolFadeFinished() {
                        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < s.q.now()
                    }
                    clearFadeHold() {
                        this.symbolFadeHoldUntil = void 0
                    }
                    setHoldDuration(t) {
                        this.symbolFadeHoldUntil = s.q.now() + t
                    }
                    setTexture(t, i) {
                        const h = i.context
                          , d = h.gl;
                        this.texture = this.texture || i.getTileTexture(t.width),
                        this.texture && this.texture instanceof s.T ? this.texture.update(t) : (this.texture = new s.T(h,t,d.RGBA8,{
                            useMipmap: !0
                        }),
                        this.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE))
                    }
                    setDependencies(t, i) {
                        const h = {};
                        for (const d of i)
                            h[d] = !0;
                        this.dependencies[t] = h
                    }
                    hasDependency(t, i) {
                        for (const h of t) {
                            const d = this.dependencies[h];
                            if (d)
                                for (const m of i)
                                    if (d[m])
                                        return !0
                        }
                        return !1
                    }
                    clearQueryDebugViz() {}
                    _makeDebugTileBoundsBuffers(t, i) {
                        if (!i || "mercator" === i.name || this._tileDebugBuffer)
                            return;
                        const h = s.b3(Wr, this.tileID.canonical, this.tileTransform)[0]
                          , d = new s.b4
                          , m = new s.b5;
                        for (let y = 0; y < h.length; y++) {
                            const {x: M, y: E} = h[y];
                            d.emplaceBack(M, E),
                            m.emplaceBack(y)
                        }
                        m.emplaceBack(0),
                        this._tileDebugIndexBuffer = t.createIndexBuffer(m),
                        this._tileDebugBuffer = t.createVertexBuffer(d, s.b6.members),
                        this._tileDebugSegments = s.b7.simpleSegment(0, 0, d.length, m.length)
                    }
                    _makeTileBoundsBuffers(t, i) {
                        if (this._tileBoundsBuffer || !i || "mercator" === i.name)
                            return;
                        const h = s.b3(Wr, this.tileID.canonical, this.tileTransform)[0];
                        let d, m;
                        if (this.isRaster) {
                            const y = function(M, E) {
                                const S = s.aQ(M, E)
                                  , I = Math.pow(2, M.z);
                                for (let Y = 0; Y < 33; Y++)
                                    for (let K = 0; K < 33; K++) {
                                        const he = s.aR((M.x + (K + Xa(K)) / 32) / I)
                                          , Te = s.aS((M.y + (Y + Xa(Y)) / 32) / I)
                                          , be = E.project(he, Te)
                                          , Ue = 33 * Y + K;
                                        Fr[2 * Ue + 0] = Math.round((be.x * S.scale - S.x) * s.ag),
                                        Fr[2 * Ue + 1] = Math.round((be.y * S.scale - S.y) * s.ag)
                                    }
                                cs.fill(0),
                                Vs.fill(0);
                                for (let Y = 2045; Y >= 0; Y--) {
                                    const K = 4 * Y
                                      , he = _r[K + 0]
                                      , Te = _r[K + 1]
                                      , be = _r[K + 2]
                                      , Ue = _r[K + 3]
                                      , De = he + be >> 1
                                      , ke = Te + Ue >> 1
                                      , Le = De + ke - Te
                                      , Ge = ke + he - De
                                      , qe = 33 * Te + he
                                      , vt = 33 * Ue + be
                                      , dt = 33 * ke + De
                                      , Ze = Math.hypot((Fr[2 * qe + 0] + Fr[2 * vt + 0]) / 2 - Fr[2 * dt + 0], (Fr[2 * qe + 1] + Fr[2 * vt + 1]) / 2 - Fr[2 * dt + 1]) >= 16;
                                    cs[dt] = cs[dt] || (Ze ? 1 : 0),
                                    Y < 1022 && (cs[dt] = cs[dt] || cs[33 * (Te + Ge >> 1) + (he + Le >> 1)] || cs[33 * (Ue + Ge >> 1) + (be + Le >> 1)])
                                }
                                const R = new s.aT
                                  , D = new s.aU;
                                let k = 0;
                                function H(Y, K) {
                                    const he = 33 * K + Y;
                                    return 0 === Vs[he] && (R.emplaceBack(Fr[2 * he + 0], Fr[2 * he + 1], Y * s.ag / 32, K * s.ag / 32),
                                    Vs[he] = ++k),
                                    Vs[he] - 1
                                }
                                function j(Y, K, he, Te, be, Ue) {
                                    const De = Y + he >> 1
                                      , ke = K + Te >> 1;
                                    if (Math.abs(Y - be) + Math.abs(K - Ue) > 1 && cs[33 * ke + De])
                                        j(be, Ue, Y, K, De, ke),
                                        j(he, Te, be, Ue, De, ke);
                                    else {
                                        const Le = H(Y, K)
                                          , Ge = H(he, Te)
                                          , qe = H(be, Ue);
                                        D.emplaceBack(Le, Ge, qe)
                                    }
                                }
                                return j(0, 0, 32, 32, 32, 0),
                                j(32, 32, 0, 0, 0, 32),
                                {
                                    vertices: R,
                                    indices: D
                                }
                            }(this.tileID.canonical, i);
                            d = y.vertices,
                            m = y.indices
                        } else {
                            d = new s.aT,
                            m = new s.aU;
                            for (const {x: M, y: E} of h)
                                d.emplaceBack(M, E, 0, 0);
                            const y = s.b8(d.int16, void 0, 4);
                            for (let M = 0; M < y.length; M += 3)
                                m.emplaceBack(y[M], y[M + 1], y[M + 2])
                        }
                        this._tileBoundsBuffer = t.createVertexBuffer(d, s.b9.members),
                        this._tileBoundsIndexBuffer = t.createIndexBuffer(m),
                        this._tileBoundsSegments = s.b7.simpleSegment(0, 0, d.length, m.length)
                    }
                    _makeGlobeTileDebugBuffers(t, i) {
                        const h = i.projection;
                        if (!h || "globe" !== h.name || i.freezeTileCoverage)
                            return;
                        const d = this.tileID.canonical
                          , m = s.ba(d, i)
                          , y = s.bb(m)
                          , M = s.ae(i.zoom);
                        let E;
                        M > 0 && (E = s.ab.mat4.invert(new Float64Array(16), i.globeMatrix)),
                        this._makeGlobeTileDebugBorderBuffer(t, d, i, y, E, M),
                        this._makeGlobeTileDebugTextBuffer(t, d, i, y, E, M)
                    }
                    _globePoint(t, i, h, d, m, y, M) {
                        let E = s.bc(t, i, h);
                        if (y) {
                            const S = 1 << h.z
                              , I = s.at(d.center.lng)
                              , R = s.aA(d.center.lat)
                              , D = (h.x + .5) / S - I;
                            let k = 0;
                            D > .5 ? k = -1 : D < -.5 && (k = 1);
                            let H = (t / s.ag + h.x) / S + k
                              , j = (i / s.ag + h.y) / S;
                            H = (H - I) * d._pixelsPerMercatorPixel + I,
                            j = (j - R) * d._pixelsPerMercatorPixel + R;
                            const Y = [H * d.worldSize, j * d.worldSize, 0];
                            s.ab.vec3.transformMat4(Y, Y, y),
                            E = s.bd(E, Y, M)
                        }
                        return s.ab.vec3.transformMat4(E, E, m)
                    }
                    _makeGlobeTileDebugBorderBuffer(t, i, h, d, m, y) {
                        const M = new s.b4
                          , E = new s.b5
                          , S = new s.be
                          , I = (D, k, H, j, Y) => {
                            const K = (H - D) / (Y - 1)
                              , he = (j - k) / (Y - 1)
                              , Te = M.length;
                            for (let be = 0; be < Y; be++) {
                                const Ue = D + be * K
                                  , De = k + be * he;
                                M.emplaceBack(Ue, De);
                                const ke = this._globePoint(Ue, De, i, h, d, m, y);
                                S.emplaceBack(ke[0], ke[1], ke[2]),
                                E.emplaceBack(Te + be)
                            }
                        }
                          , R = s.ag;
                        I(0, 0, R, 0, 16),
                        I(R, 0, R, R, 16),
                        I(R, R, 0, R, 16),
                        I(0, R, 0, 0, 16),
                        this._tileDebugIndexBuffer = t.createIndexBuffer(E),
                        this._tileDebugBuffer = t.createVertexBuffer(M, s.b6.members),
                        this._globeTileDebugBorderBuffer = t.createVertexBuffer(S, s.bf.members),
                        this._tileDebugSegments = s.b7.simpleSegment(0, 0, M.length, E.length)
                    }
                    _makeGlobeTileDebugTextBuffer(t, i, h, d, m, y) {
                        const M = s.ag / 4
                          , E = new s.b4
                          , S = new s.aU
                          , I = new s.be
                          , R = 25;
                        S.reserve(32),
                        E.reserve(R),
                        I.reserve(R);
                        const D = (k, H) => R * k + H;
                        for (let k = 0; k < R; k++) {
                            const H = k * M;
                            for (let j = 0; j < R; j++) {
                                const Y = j * M;
                                E.emplaceBack(Y, H);
                                const K = this._globePoint(Y, H, i, h, d, m, y);
                                I.emplaceBack(K[0], K[1], K[2])
                            }
                        }
                        for (let k = 0; k < 4; k++)
                            for (let H = 0; H < 4; H++) {
                                const j = D(k, H)
                                  , Y = D(k, H + 1)
                                  , K = D(k + 1, H)
                                  , he = D(k + 1, H + 1);
                                S.emplaceBack(j, Y, K),
                                S.emplaceBack(K, Y, he)
                            }
                        this._tileDebugTextIndexBuffer = t.createIndexBuffer(S),
                        this._tileDebugTextBuffer = t.createVertexBuffer(E, s.b6.members),
                        this._globeTileDebugTextBuffer = t.createVertexBuffer(I, s.bf.members),
                        this._tileDebugTextSegments = s.b7.simpleSegment(0, 0, R, 32)
                    }
                    destroy(t=!1) {
                        for (const i in this.buckets)
                            this.buckets[i].destroy();
                        this.buckets = {},
                        this.imageAtlas && (this.imageAtlas = null),
                        this.lineAtlas && (this.lineAtlas = null),
                        this.imageAtlasTexture && (this.imageAtlasTexture.destroy(),
                        delete this.imageAtlasTexture),
                        this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(),
                        delete this.glyphAtlasTexture),
                        this.lineAtlasTexture && (this.lineAtlasTexture.destroy(),
                        delete this.lineAtlasTexture),
                        this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(),
                        this._tileBoundsIndexBuffer.destroy(),
                        this._tileBoundsSegments.destroy(),
                        this._tileBoundsBuffer = null),
                        this._tileDebugBuffer && (this._tileDebugBuffer.destroy(),
                        this._tileDebugSegments.destroy(),
                        this._tileDebugBuffer = null),
                        this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(),
                        this._tileDebugIndexBuffer = null),
                        this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(),
                        this._globeTileDebugBorderBuffer = null),
                        this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(),
                        this._tileDebugTextSegments.destroy(),
                        this._tileDebugTextIndexBuffer.destroy(),
                        this._tileDebugTextBuffer = null),
                        this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(),
                        this._globeTileDebugTextBuffer = null),
                        !t && this.texture && this.texture instanceof s.T && (this.texture.destroy(),
                        delete this.texture),
                        this.hillshadeFBO && (this.hillshadeFBO.destroy(),
                        delete this.hillshadeFBO),
                        this.dem && delete this.dem,
                        this.neighboringTiles && delete this.neighboringTiles,
                        this.demTexture && (this.demTexture.destroy(),
                        delete this.demTexture),
                        this.rasterParticleState && (this.rasterParticleState.destroy(),
                        delete this.rasterParticleState),
                        this.latestFeatureIndex = null,
                        this.state = "unloaded"
                    }
                }
                s.bg.setPbf(s.bh);
                class Ya extends hs {
                    constructor(t, i, h, d, m) {
                        super(t, i, h, d, m),
                        this._workQueue = [],
                        this._fetchQueue = [],
                        this._isHeaderLoaded = !1
                    }
                    setTexture(t, i) {
                        const h = i.context
                          , d = h.gl;
                        this.texture = this.texture || i.getTileTexture(t.width),
                        this.texture && this.texture instanceof s.T ? this.texture.update(t, {
                            premultiply: !1
                        }) : this.texture = new s.T(h,t,d.RGBA8,{
                            premultiply: !1
                        })
                    }
                    flushQueues() {
                        for (; this._workQueue.length; )
                            this._workQueue.pop()();
                        for (; this._fetchQueue.length; )
                            this._fetchQueue.pop()()
                    }
                    fetchHeader(t=16384, i) {
                        const h = this._mrt = new s.bg(30)
                          , d = Object.assign({}, this.requestParams, {
                            headers: {
                                Range: "bytes=0-" + (t - 1)
                            }
                        });
                        return this.entireBuffer = null,
                        this.request = s.bi(d, (m, y, M, E) => {
                            if (m)
                                i(m);
                            else
                                try {
                                    const S = h.getHeaderLength(y);
                                    if (S > t)
                                        return void (this.request = this.fetchHeader(S, i));
                                    h.parseHeader(y),
                                    this._isHeaderLoaded = !0;
                                    let I = 0;
                                    for (const R of Object.values(h.layers))
                                        I = Math.max(I, R.dataIndex[R.dataIndex.length - 1].last_byte);
                                    y.byteLength >= I && (this.entireBuffer = y),
                                    i(null, this.entireBuffer || y, M, E)
                                } catch (S) {
                                    i(S)
                                }
                        }
                        ),
                        this.request
                    }
                    fetchBand(t, i, h) {
                        const d = this._mrt;
                        if (!this._isHeaderLoaded || !d)
                            return void h(new Error("Tile header is not ready"));
                        const m = this.actor;
                        if (!m)
                            return void h(new Error("Can't fetch tile band without an actor"));
                        let y;
                        const M = (R, D) => {
                            y.complete(R, D),
                            R ? h(R) : (this.updateTextureDescriptor(t, i),
                            h(null, this.textureDescriptor && this.textureDescriptor.img))
                        }
                          , E = (R, D) => {
                            if (R)
                                return h(R);
                            const k = m.send("decodeRasterArray", {
                                buffer: D,
                                task: y
                            }, M, void 0, !0);
                            this._workQueue.push( () => {
                                k && k.cancel(),
                                y.cancel()
                            }
                            )
                        }
                          , S = d.getLayer(t);
                        if (!S)
                            return void h(new Error('Unknown sourceLayer "'.concat(t, '"')));
                        if (S.hasDataForBand(i))
                            return this.updateTextureDescriptor(t, i),
                            void h(null, this.textureDescriptor ? this.textureDescriptor.img : null);
                        const I = S.getDataRange([i]);
                        if (y = d.createDecodingTask(I),
                        !y || y.tasks.length)
                            if (this.flushQueues(),
                            this.entireBuffer)
                                E(null, this.entireBuffer.slice(I.firstByte, I.lastByte + 1));
                            else {
                                const R = Object.assign({}, this.requestParams, {
                                    headers: {
                                        Range: "bytes=".concat(I.firstByte, "-").concat(I.lastByte)
                                    }
                                })
                                  , D = s.bi(R, E);
                                this._fetchQueue.push( () => {
                                    D.cancel(),
                                    y.cancel()
                                }
                                )
                            }
                        else
                            h(null)
                    }
                    updateNeeded(t, i) {
                        return (!this.textureDescriptor || this.textureDescriptor.band !== i || this.textureDescriptor.layer !== t) && "errored" !== this.state
                    }
                    updateTextureDescriptor(t, i) {
                        if (!this._mrt)
                            return;
                        const h = this._mrt.getLayer(t);
                        if (!h || !h.hasBand(i) || !h.hasDataForBand(i))
                            return;
                        const {bytes: d, tileSize: m, buffer: y, offset: M, scale: E} = h.getBandView(i)
                          , S = m + 2 * y
                          , I = {
                            data: d,
                            width: S,
                            height: S
                        }
                          , R = this.texture;
                        R && R instanceof s.T && R.update(I, {
                            premultiply: !1
                        }),
                        this.textureDescriptor = {
                            layer: t,
                            band: i,
                            img: I,
                            buffer: y,
                            offset: M,
                            tileSize: m,
                            format: h.pixelFormat,
                            mix: [E, 256 * E, 65536 * E, 16777216 * E]
                        }
                    }
                }
                class Wc {
                    constructor(t, i) {
                        this.max = t,
                        this.onRemove = i,
                        this.reset()
                    }
                    reset() {
                        for (const t in this.data)
                            for (const i of this.data[t])
                                i.timeout && clearTimeout(i.timeout),
                                this.onRemove(i.value);
                        return this.data = {},
                        this.order = [],
                        this
                    }
                    add(t, i, h) {
                        const d = t.wrapped().key;
                        void 0 === this.data[d] && (this.data[d] = []);
                        const m = {
                            value: i,
                            timeout: void 0
                        };
                        if (void 0 !== h && (m.timeout = setTimeout( () => {
                            this.remove(t, m)
                        }
                        , h)),
                        this.data[d].push(m),
                        this.order.push(d),
                        this.order.length > this.max) {
                            const y = this._getAndRemoveByKey(this.order[0]);
                            y && this.onRemove(y)
                        }
                        return this
                    }
                    has(t) {
                        return t.wrapped().key in this.data
                    }
                    getAndRemove(t) {
                        return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null
                    }
                    _getAndRemoveByKey(t) {
                        const i = this.data[t].shift();
                        return i.timeout && clearTimeout(i.timeout),
                        0 === this.data[t].length && delete this.data[t],
                        this.order.splice(this.order.indexOf(t), 1),
                        i.value
                    }
                    getByKey(t) {
                        const i = this.data[t];
                        return i ? i[0].value : null
                    }
                    get(t) {
                        return this.has(t) ? this.data[t.wrapped().key][0].value : null
                    }
                    remove(t, i) {
                        if (!this.has(t))
                            return this;
                        const h = t.wrapped().key
                          , d = void 0 === i ? 0 : this.data[h].indexOf(i)
                          , m = this.data[h][d];
                        return this.data[h].splice(d, 1),
                        m.timeout && clearTimeout(m.timeout),
                        0 === this.data[h].length && delete this.data[h],
                        this.onRemove(m.value),
                        this.order.splice(this.order.indexOf(h), 1),
                        this
                    }
                    setMaxSize(t) {
                        for (this.max = t; this.order.length > this.max; ) {
                            const i = this._getAndRemoveByKey(this.order[0]);
                            i && this.onRemove(i)
                        }
                        return this
                    }
                    filter(t) {
                        const i = [];
                        for (const h in this.data)
                            for (const d of this.data[h])
                                t(d.value) || i.push(d);
                        for (const h of i)
                            this.remove(h.value.tileID, h)
                    }
                }
                class Hs {
                    constructor() {
                        this.state = {},
                        this.stateChanges = {},
                        this.deletedStates = {}
                    }
                    updateState(t, i, h) {
                        const d = String(i);
                        if (this.stateChanges[t] = this.stateChanges[t] || {},
                        this.stateChanges[t][d] = this.stateChanges[t][d] || {},
                        s.l(this.stateChanges[t][d], h),
                        null === this.deletedStates[t]) {
                            this.deletedStates[t] = {};
                            for (const m in this.state[t])
                                m !== d && (this.deletedStates[t][m] = null)
                        } else if (this.deletedStates[t] && null === this.deletedStates[t][d]) {
                            this.deletedStates[t][d] = {};
                            for (const m in this.state[t][d])
                                h[m] || (this.deletedStates[t][d][m] = null)
                        } else
                            for (const m in h)
                                this.deletedStates[t] && this.deletedStates[t][d] && null === this.deletedStates[t][d][m] && delete this.deletedStates[t][d][m]
                    }
                    removeFeatureState(t, i, h) {
                        if (null === this.deletedStates[t])
                            return;
                        const d = String(i);
                        if (this.deletedStates[t] = this.deletedStates[t] || {},
                        h && void 0 !== i)
                            null !== this.deletedStates[t][d] && (this.deletedStates[t][d] = this.deletedStates[t][d] || {},
                            this.deletedStates[t][d][h] = null);
                        else if (void 0 !== i)
                            if (this.stateChanges[t] && this.stateChanges[t][d])
                                for (h in this.deletedStates[t][d] = {},
                                this.stateChanges[t][d])
                                    this.deletedStates[t][d][h] = null;
                            else
                                this.deletedStates[t][d] = null;
                        else
                            this.deletedStates[t] = null
                    }
                    getState(t, i) {
                        const h = this.state[t] || {}
                          , d = this.stateChanges[t] || {}
                          , m = this.deletedStates[t];
                        if (null === m)
                            return {};
                        if (void 0 !== i) {
                            const M = String(i)
                              , E = s.l({}, h[M], d[M]);
                            if (m) {
                                const S = m[i];
                                if (null === S)
                                    return {};
                                for (const I in S)
                                    delete E[I]
                            }
                            return E
                        }
                        const y = s.l({}, h, d);
                        if (m)
                            for (const M in m)
                                delete y[M];
                        return y
                    }
                    initializeTileState(t, i) {
                        t.refreshFeatureState(i)
                    }
                    coalesceChanges(t, i) {
                        const h = {};
                        for (const d in this.stateChanges) {
                            this.state[d] = this.state[d] || {};
                            const m = {};
                            for (const y in this.stateChanges[d])
                                this.state[d][y] || (this.state[d][y] = {}),
                                s.l(this.state[d][y], this.stateChanges[d][y]),
                                m[y] = this.state[d][y];
                            h[d] = m
                        }
                        for (const d in this.deletedStates) {
                            this.state[d] = this.state[d] || {};
                            const m = {};
                            if (null === this.deletedStates[d])
                                for (const y in this.state[d])
                                    m[y] = {},
                                    this.state[d][y] = {};
                            else
                                for (const y in this.deletedStates[d]) {
                                    if (null === this.deletedStates[d][y])
                                        this.state[d][y] = {};
                                    else if (this.state[d][y])
                                        for (const M of Object.keys(this.deletedStates[d][y]))
                                            delete this.state[d][y][M];
                                    m[y] = this.state[d][y]
                                }
                            h[d] = h[d] || {},
                            s.l(h[d], m)
                        }
                        if (this.stateChanges = {},
                        this.deletedStates = {},
                        0 !== Object.keys(h).length)
                            for (const d in t)
                                t[d].refreshFeatureState(i)
                    }
                }
                class Ir extends s.E {
                    constructor(t, i, h) {
                        super(),
                        this.id = t,
                        this._onlySymbols = h,
                        i.on("data", d => {
                            "source" === d.dataType && "metadata" === d.sourceDataType && (this._sourceLoaded = !0),
                            this._sourceLoaded && !this._paused && "source" === d.dataType && "content" === d.sourceDataType && (this.reload(),
                            this.transform && this.update(this.transform))
                        }
                        ),
                        i.on("error", () => {
                            this._sourceErrored = !0
                        }
                        ),
                        this._source = i,
                        this._tiles = {},
                        this._cache = new Wc(0,this._unloadTile.bind(this)),
                        this._timers = {},
                        this._cacheTimers = {},
                        this._minTileCacheSize = i.minTileCacheSize,
                        this._maxTileCacheSize = i.maxTileCacheSize,
                        this._loadedParentTiles = {},
                        this.castsShadows = !1,
                        this.tileCoverLift = 0,
                        this._coveredTiles = {},
                        this._shadowCasterTiles = {},
                        this._state = new Hs,
                        this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "raster-array" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType
                    }
                    onAdd(t) {
                        this.map = t,
                        this._minTileCacheSize = void 0 === this._minTileCacheSize && t ? t._minTileCacheSize : this._minTileCacheSize,
                        this._maxTileCacheSize = void 0 === this._maxTileCacheSize && t ? t._maxTileCacheSize : this._maxTileCacheSize
                    }
                    loaded() {
                        if (this._sourceErrored)
                            return !0;
                        if (!this._sourceLoaded || !this._source.loaded())
                            return !1;
                        for (const t in this._tiles) {
                            const i = this._tiles[t];
                            if ("loaded" !== i.state && "errored" !== i.state)
                                return !1
                        }
                        return !0
                    }
                    getSource() {
                        return this._source
                    }
                    pause() {
                        this._paused = !0
                    }
                    resume() {
                        if (!this._paused)
                            return;
                        const t = this._shouldReloadOnResume;
                        this._paused = !1,
                        this._shouldReloadOnResume = !1,
                        t && this.reload(),
                        this.transform && this.update(this.transform)
                    }
                    _loadTile(t, i) {
                        return t.isSymbolTile = this._onlySymbols,
                        t.isExtraShadowCaster = this._shadowCasterTiles[t.tileID.key],
                        this._source.loadTile(t, i)
                    }
                    _unloadTile(t) {
                        if (this._source.unloadTile)
                            return this._source.unloadTile(t)
                    }
                    _abortTile(t) {
                        if (this._source.abortTile)
                            return this._source.abortTile(t)
                    }
                    serialize() {
                        return this._source.serialize()
                    }
                    prepare(t) {
                        this._source.prepare && this._source.prepare(),
                        this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
                        for (const i in this._tiles) {
                            const h = this._tiles[i];
                            h.upload(t),
                            h.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope)
                        }
                    }
                    getIds() {
                        return s.bj(this._tiles).map(t => t.tileID).sort(Za).map(t => t.key)
                    }
                    getRenderableIds(t, i) {
                        const h = [];
                        for (const d in this._tiles)
                            this._isIdRenderable(+d, t, i) && h.push(this._tiles[d]);
                        return t ? h.sort( (d, m) => {
                            const y = d.tileID
                              , M = m.tileID
                              , E = new s.P(y.canonical.x,y.canonical.y)._rotate(this.transform.angle)
                              , S = new s.P(M.canonical.x,M.canonical.y)._rotate(this.transform.angle);
                            return y.overscaledZ - M.overscaledZ || S.y - E.y || S.x - E.x
                        }
                        ).map(d => d.tileID.key) : h.map(d => d.tileID).sort(Za).map(d => d.key)
                    }
                    hasRenderableParent(t) {
                        const i = this.findLoadedParent(t, 0);
                        return !!i && this._isIdRenderable(i.tileID.key)
                    }
                    _isIdRenderable(t, i, h) {
                        return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (i || !this._tiles[t].holdingForFade()) && (h || !this._shadowCasterTiles[t])
                    }
                    reload() {
                        if (this._paused)
                            this._shouldReloadOnResume = !0;
                        else {
                            this._cache.reset();
                            for (const t in this._tiles)
                                "errored" !== this._tiles[t].state && this._reloadTile(+t, "reloading")
                        }
                    }
                    _reloadTile(t, i) {
                        const h = this._tiles[t];
                        h && ("loading" !== h.state && (h.state = i),
                        this._loadTile(h, this._tileLoaded.bind(this, h, t, i)))
                    }
                    _tileLoaded(t, i, h, d) {
                        if (d)
                            if (t.state = "errored",
                            404 !== d.status)
                                this._source.fire(new s.y(d,{
                                    tile: t
                                }));
                            else {
                                if (this._source.fire(new s.z("data",{
                                    dataType: "source",
                                    sourceDataType: "error",
                                    sourceId: this._source.id,
                                    tile: t
                                })),
                                !(t.tileID.key in this._loadedParentTiles))
                                    return;
                                if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                                    const m = this.map.painter.terrain;
                                    this.update(this.transform, m.getScaledDemTileSize(), !0),
                                    m.resetTileLookupCache(this.id)
                                } else
                                    this.update(this.transform)
                            }
                        else
                            t.timeAdded = s.q.now(),
                            "expired" === h && (t.refreshedUponExpiration = !0),
                            this._setTileReloadTimer(i, t),
                            "raster-dem" === this._source.type && t.dem && this._backfillDEM(t),
                            this._state.initializeTileState(t, this.map ? this.map.painter : null),
                            this._source.fire(new s.z("data",{
                                dataType: "source",
                                tile: t,
                                coord: t.tileID,
                                sourceCacheId: this.id
                            }))
                    }
                    _backfillDEM(t) {
                        const i = this.getRenderableIds();
                        for (let d = 0; d < i.length; d++) {
                            const m = i[d];
                            if (t.neighboringTiles && t.neighboringTiles[m]) {
                                const y = this.getTileByID(m);
                                h(t, y),
                                h(y, t)
                            }
                        }
                        function h(d, m) {
                            if (!d.dem || d.dem.borderReady)
                                return;
                            d.needsHillshadePrepare = !0,
                            d.needsDEMTextureUpload = !0;
                            let y = m.tileID.canonical.x - d.tileID.canonical.x;
                            const M = m.tileID.canonical.y - d.tileID.canonical.y
                              , E = Math.pow(2, d.tileID.canonical.z)
                              , S = m.tileID.key;
                            0 === y && 0 === M || Math.abs(M) > 1 || (Math.abs(y) > 1 && (1 === Math.abs(y + E) ? y += E : 1 === Math.abs(y - E) && (y -= E)),
                            m.dem && d.dem && (d.dem.backfillBorder(m.dem, y, M),
                            d.neighboringTiles && d.neighboringTiles[S] && (d.neighboringTiles[S].backfilled = !0)))
                        }
                    }
                    getTile(t) {
                        return this.getTileByID(t.key)
                    }
                    getTileByID(t) {
                        return this._tiles[t]
                    }
                    _retainLoadedChildren(t, i, h, d) {
                        for (const m in this._tiles) {
                            let y = this._tiles[m];
                            if (d[m] || !y.hasData() || y.tileID.overscaledZ <= i || y.tileID.overscaledZ > h)
                                continue;
                            let M = y.tileID;
                            for (; y && y.tileID.overscaledZ > i + 1; ) {
                                const S = y.tileID.scaledTo(y.tileID.overscaledZ - 1);
                                y = this._tiles[S.key],
                                y && y.hasData() && (M = S)
                            }
                            let E = M;
                            for (; E.overscaledZ > i; )
                                if (E = E.scaledTo(E.overscaledZ - 1),
                                t[E.key]) {
                                    d[M.key] = M;
                                    break
                                }
                        }
                    }
                    findLoadedParent(t, i) {
                        if (t.key in this._loadedParentTiles) {
                            const h = this._loadedParentTiles[t.key];
                            return h && h.tileID.overscaledZ >= i ? h : null
                        }
                        for (let h = t.overscaledZ - 1; h >= i; h--) {
                            const d = t.scaledTo(h)
                              , m = this._getLoadedTile(d);
                            if (m)
                                return m
                        }
                    }
                    _getLoadedTile(t) {
                        const i = this._tiles[t.key];
                        return i && i.hasData() ? i : this._cache.getByKey(this._source.reparseOverscaled ? t.wrapped().key : t.canonical.key)
                    }
                    updateCacheSize(t, i) {
                        i = i || this._source.tileSize;
                        const h = Math.ceil(t.width / i) + 1
                          , d = Math.ceil(t.height / i) + 1
                          , m = Math.floor(h * d * 5)
                          , y = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, m) : m
                          , M = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, y) : y;
                        this._cache.setMaxSize(M)
                    }
                    handleWrapJump(t) {
                        const i = Math.round((t - (void 0 === this._prevLng ? t : this._prevLng)) / 360);
                        if (this._prevLng = t,
                        i) {
                            const h = {};
                            for (const d in this._tiles) {
                                const m = this._tiles[d];
                                m.tileID = m.tileID.unwrapTo(m.tileID.wrap + i),
                                h[m.tileID.key] = m
                            }
                            this._tiles = h;
                            for (const d in this._timers)
                                clearTimeout(this._timers[d]),
                                delete this._timers[d];
                            for (const d in this._tiles)
                                this._setTileReloadTimer(+d, this._tiles[d])
                        }
                    }
                    update(t, i, h, d) {
                        if (this.transform = t,
                        !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage || this.usedForTerrain && !h)
                            return;
                        this.updateCacheSize(t, i),
                        "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng),
                        this._shadowCasterTiles = {},
                        this._coveredTiles = {};
                        const m = "batched-model" === this._source.type;
                        let y, M = this._source.maxzoom;
                        const E = this.map && this.map.painter ? this.map.painter._terrain : null;
                        if (E && E.sourceCache === this && E.attenuationRange()) {
                            const R = E.attenuationRange()[0]
                              , D = Math.floor(R) - Math.log2(E.getDemUpscale());
                            M > D && (M = D)
                        }
                        if (this.used || this.usedForTerrain) {
                            if (this._source.tileID)
                                y = t.getVisibleUnwrappedCoordinates(this._source.tileID).map(R => new s.aG(R.canonical.z,R.wrap,R.canonical.z,R.canonical.x,R.canonical.y));
                            else if (0 !== this.tileCoverLift) {
                                const R = t.clone();
                                R.tileCoverLift = this.tileCoverLift,
                                y = R.coveringTiles({
                                    tileSize: i || this._source.tileSize,
                                    minzoom: this._source.minzoom,
                                    maxzoom: M,
                                    roundZoom: this._source.roundZoom && !h,
                                    reparseOverscaled: this._source.reparseOverscaled,
                                    isTerrainDEM: this.usedForTerrain,
                                    calculateQuadrantVisibility: m
                                }),
                                this._source.minzoom <= 1 && "globe" === t.projection.name && (y.push(new s.aG(1,0,1,0,0)),
                                y.push(new s.aG(1,0,1,1,0)),
                                y.push(new s.aG(1,0,1,0,1)),
                                y.push(new s.aG(1,0,1,1,1)))
                            } else if (y = t.coveringTiles({
                                tileSize: i || this._source.tileSize,
                                minzoom: this._source.minzoom,
                                maxzoom: M,
                                roundZoom: this._source.roundZoom && !h,
                                reparseOverscaled: this._source.reparseOverscaled,
                                isTerrainDEM: this.usedForTerrain,
                                calculateQuadrantVisibility: m
                            }),
                            this._source.hasTile) {
                                const R = this._source.hasTile.bind(this._source);
                                y = y.filter(D => R(D))
                            }
                        } else
                            y = [];
                        if (y.length > 0 && this.castsShadows && d && "globe" !== this.transform.projection.name && !this.usedForTerrain && !Ka(this._source.type)) {
                            const R = t.coveringZoomLevel({
                                tileSize: i || this._source.tileSize,
                                roundZoom: this._source.roundZoom && !h
                            })
                              , D = Math.min(R, this._source.maxzoom);
                            if (m) {
                                const k = t.extendTileCover(y, D);
                                for (const H of k)
                                    y.push(H)
                            } else {
                                const k = t.extendTileCover(y, D, d);
                                for (const H of k)
                                    this._shadowCasterTiles[H.key] = !0,
                                    y.push(H)
                            }
                        }
                        const S = this._updateRetainedTiles(y);
                        if (Ka(this._source.type) && 0 !== y.length) {
                            const R = {}
                              , D = {}
                              , k = Object.keys(S);
                            for (const j of k) {
                                const Y = S[j]
                                  , K = this._tiles[j];
                                if (!K || K.fadeEndTime && K.fadeEndTime <= s.q.now())
                                    continue;
                                const he = this.findLoadedParent(Y, Math.max(Y.overscaledZ - Ir.maxOverzooming, this._source.minzoom));
                                he && (this._addTile(he.tileID),
                                R[he.tileID.key] = he.tileID),
                                D[j] = Y
                            }
                            const H = y[y.length - 1].overscaledZ;
                            for (const j in this._tiles) {
                                const Y = this._tiles[j];
                                if (S[j] || !Y.hasData())
                                    continue;
                                let K = Y.tileID;
                                for (; K.overscaledZ > H; ) {
                                    K = K.scaledTo(K.overscaledZ - 1);
                                    const he = this._tiles[K.key];
                                    if (he && he.hasData() && D[K.key]) {
                                        S[j] = Y.tileID;
                                        break
                                    }
                                }
                            }
                            for (const j in R)
                                S[j] || (this._coveredTiles[j] = !0,
                                S[j] = R[j])
                        }
                        for (const R in S)
                            this._tiles[R].clearFadeHold();
                        const I = s.bk(this._tiles, S);
                        for (const R of I) {
                            const D = this._tiles[R];
                            D.hasSymbolBuckets && !D.holdingForFade() ? D.setHoldDuration(this.map._fadeDuration) : D.hasSymbolBuckets && !D.symbolFadeFinished() || this._removeTile(+R)
                        }
                        this._updateLoadedParentTileCache(),
                        this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate()
                    }
                    releaseSymbolFadeTiles() {
                        for (const t in this._tiles)
                            this._tiles[t].holdingForFade() && this._removeTile(+t)
                    }
                    _updateRetainedTiles(t) {
                        const i = {};
                        if (0 === t.length)
                            return i;
                        const h = {}
                          , d = t.reduce( (S, I) => Math.min(S, I.overscaledZ), 1 / 0)
                          , m = t[0].overscaledZ
                          , y = Math.max(m - Ir.maxOverzooming, this._source.minzoom)
                          , M = Math.max(m + Ir.maxUnderzooming, this._source.minzoom)
                          , E = {};
                        for (const S of t) {
                            const I = this._addTile(S);
                            i[S.key] = S,
                            I.hasData() || d < this._source.maxzoom && (E[S.key] = S)
                        }
                        this._retainLoadedChildren(E, d, M, i);
                        for (const S of t) {
                            let I = this._tiles[S.key];
                            if (I.hasData())
                                continue;
                            if (S.canonical.z >= this._source.maxzoom) {
                                const D = S.children(this._source.maxzoom)[0]
                                  , k = this.getTile(D);
                                if (k && k.hasData()) {
                                    i[D.key] = D;
                                    continue
                                }
                            } else {
                                const D = S.children(this._source.maxzoom);
                                if (i[D[0].key] && i[D[1].key] && i[D[2].key] && i[D[3].key])
                                    continue
                            }
                            let R = I.wasRequested();
                            for (let D = S.overscaledZ - 1; D >= y; --D) {
                                const k = S.scaledTo(D);
                                if (h[k.key] || (h[k.key] = !0,
                                I = this.getTile(k),
                                !I && R && (I = this._addTile(k)),
                                I && (i[k.key] = k,
                                R = I.wasRequested(),
                                I.hasData())))
                                    break
                            }
                        }
                        return i
                    }
                    _updateLoadedParentTileCache() {
                        this._loadedParentTiles = {};
                        for (const t in this._tiles) {
                            const i = [];
                            let h, d = this._tiles[t].tileID;
                            for (; d.overscaledZ > 0; ) {
                                if (d.key in this._loadedParentTiles) {
                                    h = this._loadedParentTiles[d.key];
                                    break
                                }
                                i.push(d.key);
                                const m = d.scaledTo(d.overscaledZ - 1);
                                if (h = this._getLoadedTile(m),
                                h)
                                    break;
                                d = m
                            }
                            for (const m of i)
                                this._loadedParentTiles[m] = h
                        }
                    }
                    _addTile(t) {
                        let i = this._tiles[t.key];
                        if (i)
                            return !0 !== i.isExtraShadowCaster || this._shadowCasterTiles[t.key] || this._reloadTile(t.key, "reloading"),
                            i;
                        i = this._cache.getAndRemove(t),
                        i && (this._setTileReloadTimer(t.key, i),
                        i.tileID = t,
                        this._state.initializeTileState(i, this.map ? this.map.painter : null),
                        this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]),
                        delete this._cacheTimers[t.key],
                        this._setTileReloadTimer(t.key, i)));
                        const h = !!i;
                        if (!h) {
                            const d = this.map ? this.map.painter : null
                              , m = this._source.tileSize * t.overscaleFactor();
                            i = "raster-array" === this._source.type ? new Ya(t,m,this.transform.tileZoom,d,this._isRaster) : new hs(t,m,this.transform.tileZoom,d,this._isRaster),
                            this._loadTile(i, this._tileLoaded.bind(this, i, t.key, i.state))
                        }
                        return i ? (i.uses++,
                        this._tiles[t.key] = i,
                        h || this._source.fire(new s.z("dataloading",{
                            tile: i,
                            coord: i.tileID,
                            dataType: "source"
                        })),
                        i) : null
                    }
                    _setTileReloadTimer(t, i) {
                        t in this._timers && (clearTimeout(this._timers[t]),
                        delete this._timers[t]);
                        const h = i.getExpiryTimeout();
                        h && (this._timers[t] = setTimeout( () => {
                            this._reloadTile(t, "expired"),
                            delete this._timers[t]
                        }
                        , h))
                    }
                    _removeTile(t) {
                        const i = this._tiles[t];
                        i && (i.uses--,
                        delete this._tiles[t],
                        this._timers[t] && (clearTimeout(this._timers[t]),
                        delete this._timers[t]),
                        i.uses > 0 || (i.hasData() && "reloading" !== i.state || "empty" === i.state ? this._cache.add(i.tileID, i, i.getExpiryTimeout()) : (i.aborted = !0,
                        this._abortTile(i),
                        this._unloadTile(i))))
                    }
                    clearTiles() {
                        this._shouldReloadOnResume = !1,
                        this._paused = !1;
                        for (const t in this._tiles)
                            this._removeTile(+t);
                        this._source._clear && this._source._clear(),
                        this._cache.reset(),
                        this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id)
                    }
                    tilesIn(t, i, h) {
                        const d = []
                          , m = this.transform;
                        if (!m)
                            return d;
                        const y = "globe" === m.projection.name
                          , M = s.at(m.center.lng);
                        for (const E in this._tiles) {
                            const S = this._tiles[E];
                            if (h && S.clearQueryDebugViz(),
                            S.holdingForFade())
                                continue;
                            let I;
                            if (y) {
                                const R = S.tileID.canonical;
                                if (0 === R.z) {
                                    const D = [Math.abs(s.aw(M, ...wi(R, -1)) - M), Math.abs(s.aw(M, ...wi(R, 1)) - M)];
                                    I = [0, 2 * D.indexOf(Math.min(...D)) - 1]
                                } else {
                                    const D = [Math.abs(s.aw(M, ...wi(R, -1)) - M), Math.abs(s.aw(M, ...wi(R, 0)) - M), Math.abs(s.aw(M, ...wi(R, 1)) - M)];
                                    I = [D.indexOf(Math.min(...D)) - 1]
                                }
                            } else
                                I = [0];
                            for (const R of I) {
                                const D = t.containsTile(S, m, i, R);
                                D && d.push(D)
                            }
                        }
                        return d
                    }
                    getShadowCasterCoordinates() {
                        return this._getRenderableCoordinates(!1, !0)
                    }
                    getVisibleCoordinates(t) {
                        return this._getRenderableCoordinates(t)
                    }
                    _getRenderableCoordinates(t, i) {
                        const h = this.getRenderableIds(t, i).map(m => this._tiles[m].tileID)
                          , d = "globe" === this.transform.projection.name;
                        for (const m of h)
                            m.projMatrix = this.transform.calculateProjMatrix(m.toUnwrapped()),
                            m.expandedProjMatrix = d ? this.transform.calculateProjMatrix(m.toUnwrapped(), !1, !0) : m.projMatrix;
                        return h
                    }
                    sortCoordinatesByDistance(t) {
                        const i = t.slice()
                          , h = this.transform._camera.position
                          , d = this.transform._camera.forward()
                          , m = {};
                        for (const y of i) {
                            const M = 1 / (1 << y.canonical.z);
                            m[y.key] = ((y.canonical.x + .5) * M + y.wrap - h[0]) * d[0] + ((y.canonical.y + .5) * M - h[1]) * d[1] - h[2] * d[2]
                        }
                        return i.sort( (y, M) => m[y.key] - m[M.key]),
                        i
                    }
                    hasTransition() {
                        if (this._source.hasTransition())
                            return !0;
                        if (Ka(this._source.type))
                            for (const t in this._tiles) {
                                const i = this._tiles[t];
                                if (void 0 !== i.fadeEndTime && i.fadeEndTime >= s.q.now())
                                    return !0
                            }
                        return !1
                    }
                    setFeatureState(t, i, h) {
                        this._state.updateState(t = t || "_geojsonTileLayer", i, h)
                    }
                    removeFeatureState(t, i, h) {
                        this._state.removeFeatureState(t = t || "_geojsonTileLayer", i, h)
                    }
                    getFeatureState(t, i) {
                        return this._state.getState(t = t || "_geojsonTileLayer", i)
                    }
                    setDependencies(t, i, h) {
                        const d = this._tiles[t];
                        d && d.setDependencies(i, h)
                    }
                    reloadTilesForDependencies(t, i) {
                        for (const h in this._tiles)
                            this._tiles[h].hasDependency(t, i) && this._reloadTile(+h, "reloading");
                        this._cache.filter(h => !h.hasDependency(t, i))
                    }
                    _preloadTiles(t, i) {
                        if (!this._sourceLoaded) {
                            const E = () => {
                                this._sourceLoaded && (this._source.off("data", E),
                                this._preloadTiles(t, i))
                            }
                            ;
                            return void this._source.on("data", E)
                        }
                        const h = new Map
                          , d = Array.isArray(t) ? t : [t]
                          , m = this.map.painter.terrain
                          , y = this.usedForTerrain && m ? m.getScaledDemTileSize() : this._source.tileSize;
                        for (const E of d) {
                            const S = E.coveringTiles({
                                tileSize: y,
                                minzoom: this._source.minzoom,
                                maxzoom: this._source.maxzoom,
                                roundZoom: this._source.roundZoom && !this.usedForTerrain,
                                reparseOverscaled: this._source.reparseOverscaled,
                                isTerrainDEM: this.usedForTerrain
                            });
                            for (const I of S)
                                h.set(I.key, I);
                            this.usedForTerrain && E.updateElevation(!1)
                        }
                        const M = Array.from(h.values());
                        s.bl(M, (E, S) => {
                            const I = new hs(E,this._source.tileSize * E.overscaleFactor(),this.transform.tileZoom,this.map.painter,this._isRaster);
                            this._loadTile(I, R => {
                                "raster-dem" === this._source.type && I.dem && this._backfillDEM(I),
                                S(R, I)
                            }
                            )
                        }
                        , i)
                    }
                }
                function Za(c, t) {
                    const i = Math.abs(2 * c.wrap) - +(c.wrap < 0)
                      , h = Math.abs(2 * t.wrap) - +(t.wrap < 0);
                    return c.overscaledZ - t.overscaledZ || h - i || t.canonical.y - c.canonical.y || t.canonical.x - c.canonical.x
                }
                function Ka(c) {
                    return "raster" === c || "image" === c || "video" === c || "custom" === c
                }
                function wi(c, t) {
                    const i = 1 << c.z;
                    return [c.x / i + t, (c.x + 1) / i + t]
                }
                Ir.maxOverzooming = 10,
                Ir.maxUnderzooming = 3;
                class pp {
                    constructor(t) {
                        this.style = t,
                        this.layersGotHidden = !1,
                        this.layers = []
                    }
                    processLayersChanged() {
                        this.layers = [];
                        const t = !1
                          , i = !1;
                        for (const h in this.style._mergedLayers) {
                            const d = this.style._mergedLayers[h];
                            if ("fill-extrusion" === d.type)
                                this.layers.push({
                                    layer: d,
                                    visible: t,
                                    visibilityChanged: i
                                });
                            else if ("model" === d.type) {
                                const m = this.style.getLayerSource(d);
                                m && "batched-model" === m.type && this.layers.push({
                                    layer: d,
                                    visible: t,
                                    visibilityChanged: i
                                })
                            }
                        }
                    }
                    onNewFrame(t) {
                        this.layersGotHidden = !1;
                        for (const i of this.layers) {
                            const h = i.layer;
                            let d = !1;
                            "fill-extrusion" === h.type ? d = !h.isHidden(t) && h.paint.get("fill-extrusion-opacity") > 0 : "model" === h.type && (d = !h.isHidden(t) && h.paint.get("model-opacity").constantOr(1) > 0),
                            this.layersGotHidden = this.layersGotHidden || !d && i.visible,
                            i.visible = d
                        }
                    }
                    updateZOffset(t, i) {
                        this.currentBuildingBuckets = [];
                        for (const d of this.layers) {
                            const m = d.layer
                              , y = this.style.getLayerSourceCache(m);
                            let M = 1;
                            "fill-extrusion" === m.type && (M = d.visible ? m.paint.get("fill-extrusion-vertical-scale") : 0);
                            let E = y ? y.getTile(i) : null;
                            if (!E && y && i.canonical.z > y.getSource().minzoom) {
                                let S = i.scaledTo(Math.min(y.getSource().maxzoom, i.overscaledZ - 1));
                                for (; S.overscaledZ >= y.getSource().minzoom && (E = y.getTile(S),
                                !E && 0 !== S.overscaledZ); )
                                    S = S.scaledTo(S.overscaledZ - 1)
                            }
                            this.currentBuildingBuckets.push({
                                bucket: E ? E.getBucket(m) : null,
                                tileID: E ? E.tileID : i,
                                verticalScale: M
                            })
                        }
                        t.hasAnyZOffset = !1;
                        let h = !1;
                        for (let d = 0; d < t.symbolInstances.length; d++) {
                            const m = t.symbolInstances.get(d)
                              , y = m.zOffset
                              , M = this._getHeightAtTileOffset(i, m.tileAnchorX, m.tileAnchorY);
                            m.zOffset = M !== Number.NEGATIVE_INFINITY ? M : y,
                            h || y === m.zOffset || (h = !0),
                            t.hasAnyZOffset || 0 === m.zOffset || (t.hasAnyZOffset = !0)
                        }
                        h && (t.zOffsetBuffersNeedUpload = !0,
                        t.zOffsetSortDirty = !0)
                    }
                    _mapCoordToOverlappingTile(t, i, h, d) {
                        let m = i
                          , y = h;
                        if (t.canonical.z !== d.canonical.z) {
                            const M = d.canonical
                              , E = 1 / (1 << t.canonical.z - M.z);
                            m = (i + t.canonical.x * s.ag) * E - M.x * s.ag | 0,
                            y = (h + t.canonical.y * s.ag) * E - M.y * s.ag | 0
                        }
                        return {
                            tileX: m,
                            tileY: y
                        }
                    }
                    _getHeightAtTileOffset(t, i, h) {
                        let d, m;
                        for (let y = 0; y < this.layers.length; ++y) {
                            if ("fill-extrusion" !== this.layers[y].layer.type)
                                continue;
                            const {bucket: M, tileID: E, verticalScale: S} = this.currentBuildingBuckets[y];
                            if (!M)
                                continue;
                            const {tileX: I, tileY: R} = this._mapCoordToOverlappingTile(t, i, h, E)
                              , D = M.getHeightAtTileCoord(I, R);
                            D && void 0 !== D.height && (D.hidden ? d = D.height : m = Math.max(D.height * S, m || 0))
                        }
                        if (void 0 !== m)
                            return m;
                        for (let y = 0; y < this.layers.length; ++y) {
                            const M = this.layers[y];
                            if ("model" !== M.layer.type || !M.visible)
                                continue;
                            const {bucket: E, tileID: S} = this.currentBuildingBuckets[y];
                            if (!E)
                                continue;
                            const {tileX: I, tileY: R} = this._mapCoordToOverlappingTile(t, i, h, S)
                              , D = E.getHeightAtTileCoord(I, R);
                            if (D && !D.hidden)
                                return void 0 === D.height && void 0 !== d ? Math.min(D.maxHeight, d) * D.verticalScale : D.height ? D.height * D.verticalScale : Number.NEGATIVE_INFINITY
                        }
                        return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY
                    }
                }
                function jo(c, t) {
                    const i = {};
                    for (const h in c)
                        "ref" !== h && (i[h] = c[h]);
                    return s.bm.forEach(h => {
                        h in t && (i[h] = t[h])
                    }
                    ),
                    i
                }
                function Vl(c) {
                    c = c.slice();
                    const t = Object.create(null);
                    for (let i = 0; i < c.length; i++)
                        t[c[i].id] = c[i];
                    for (let i = 0; i < c.length; i++)
                        "ref"in c[i] && (c[i] = jo(c[i], t[c[i].ref]));
                    return c
                }
                const xi = {
                    setStyle: "setStyle",
                    addLayer: "addLayer",
                    removeLayer: "removeLayer",
                    setPaintProperty: "setPaintProperty",
                    setLayoutProperty: "setLayoutProperty",
                    setSlot: "setSlot",
                    setFilter: "setFilter",
                    addSource: "addSource",
                    removeSource: "removeSource",
                    setGeoJSONSourceData: "setGeoJSONSourceData",
                    setLayerZoomRange: "setLayerZoomRange",
                    setLayerProperty: "setLayerProperty",
                    setCenter: "setCenter",
                    setZoom: "setZoom",
                    setBearing: "setBearing",
                    setPitch: "setPitch",
                    setSprite: "setSprite",
                    setGlyphs: "setGlyphs",
                    setTransition: "setTransition",
                    setLight: "setLight",
                    setTerrain: "setTerrain",
                    setFog: "setFog",
                    setSnow: "setSnow",
                    setRain: "setRain",
                    setCamera: "setCamera",
                    setLights: "setLights",
                    setProjection: "setProjection",
                    addImport: "addImport",
                    removeImport: "removeImport",
                    updateImport: "updateImport"
                };
                function Hl(c, t, i) {
                    i.push({
                        command: xi.addSource,
                        args: [c, t[c]]
                    })
                }
                function Zn(c, t, i) {
                    t.push({
                        command: xi.removeSource,
                        args: [c]
                    }),
                    i[c] = !0
                }
                function Wl(c, t, i, h) {
                    Zn(c, i, h),
                    Hl(c, t, i)
                }
                function Ws(c, t, i) {
                    let h;
                    for (h in c[i])
                        if (c[i].hasOwnProperty(h) && "data" !== h && !s.bn(c[i][h], t[i][h]))
                            return !1;
                    for (h in t[i])
                        if (t[i].hasOwnProperty(h) && "data" !== h && !s.bn(c[i][h], t[i][h]))
                            return !1;
                    return !0
                }
                function To(c, t, i, h, d, m) {
                    let y;
                    for (y in t = t || {},
                    c = c || {})
                        c.hasOwnProperty(y) && (s.bn(c[y], t[y]) || i.push({
                            command: m,
                            args: [h, y, t[y], d]
                        }));
                    for (y in t)
                        t.hasOwnProperty(y) && !c.hasOwnProperty(y) && (s.bn(c[y], t[y]) || i.push({
                            command: m,
                            args: [h, y, t[y], d]
                        }))
                }
                function Pi(c) {
                    return c.id
                }
                function bi(c, t) {
                    return c[t.id] = t,
                    c
                }
                class Hn {
                    constructor(t, i) {
                        this.reset(t, i)
                    }
                    reset(t, i) {
                        this.points = t || [],
                        this._distances = [0];
                        for (let h = 1; h < this.points.length; h++)
                            this._distances[h] = this._distances[h - 1] + this.points[h].dist(this.points[h - 1]);
                        this.length = this._distances[this._distances.length - 1],
                        this.padding = Math.min(i || 0, .5 * this.length),
                        this.paddedLength = this.length - 2 * this.padding
                    }
                    lerp(t) {
                        if (1 === this.points.length)
                            return this.points[0];
                        t = s.aw(t, 0, 1);
                        let i = 1
                          , h = this._distances[i];
                        const d = t * this.paddedLength + this.padding;
                        for (; h < d && i < this._distances.length; )
                            h = this._distances[++i];
                        const m = i - 1
                          , y = this._distances[m]
                          , M = h - y
                          , E = M > 0 ? (d - y) / M : 0;
                        return this.points[m].mult(1 - E).add(this.points[i].mult(E))
                    }
                }
                class Xs {
                    constructor(t, i, h) {
                        const d = this.boxCells = []
                          , m = this.circleCells = [];
                        this.xCellCount = Math.ceil(t / h),
                        this.yCellCount = Math.ceil(i / h);
                        for (let y = 0; y < this.xCellCount * this.yCellCount; y++)
                            d.push([]),
                            m.push([]);
                        this.circleKeys = [],
                        this.boxKeys = [],
                        this.bboxes = [],
                        this.circles = [],
                        this.width = t,
                        this.height = i,
                        this.xScale = this.xCellCount / t,
                        this.yScale = this.yCellCount / i,
                        this.boxUid = 0,
                        this.circleUid = 0
                    }
                    keysLength() {
                        return this.boxKeys.length + this.circleKeys.length
                    }
                    insert(t, i, h, d, m) {
                        this._forEachCell(i, h, d, m, this._insertBoxCell, this.boxUid++),
                        this.boxKeys.push(t),
                        this.bboxes.push(i),
                        this.bboxes.push(h),
                        this.bboxes.push(d),
                        this.bboxes.push(m)
                    }
                    insertCircle(t, i, h, d) {
                        this._forEachCell(i - d, h - d, i + d, h + d, this._insertCircleCell, this.circleUid++),
                        this.circleKeys.push(t),
                        this.circles.push(i),
                        this.circles.push(h),
                        this.circles.push(d)
                    }
                    _insertBoxCell(t, i, h, d, m, y) {
                        this.boxCells[m].push(y)
                    }
                    _insertCircleCell(t, i, h, d, m, y) {
                        this.circleCells[m].push(y)
                    }
                    _query(t, i, h, d, m, y) {
                        if (h < 0 || t > this.width || d < 0 || i > this.height)
                            return !m && [];
                        const M = [];
                        if (t <= 0 && i <= 0 && this.width <= h && this.height <= d) {
                            if (m)
                                return !0;
                            for (let E = 0; E < this.boxKeys.length; E++)
                                M.push({
                                    key: this.boxKeys[E],
                                    x1: this.bboxes[4 * E],
                                    y1: this.bboxes[4 * E + 1],
                                    x2: this.bboxes[4 * E + 2],
                                    y2: this.bboxes[4 * E + 3]
                                });
                            for (let E = 0; E < this.circleKeys.length; E++) {
                                const S = this.circles[3 * E]
                                  , I = this.circles[3 * E + 1]
                                  , R = this.circles[3 * E + 2];
                                M.push({
                                    key: this.circleKeys[E],
                                    x1: S - R,
                                    y1: I - R,
                                    x2: S + R,
                                    y2: I + R
                                })
                            }
                            return y ? M.filter(y) : M
                        }
                        return this._forEachCell(t, i, h, d, this._queryCell, M, {
                            hitTest: m,
                            seenUids: {
                                box: {},
                                circle: {}
                            }
                        }, y),
                        m ? M.length > 0 : M
                    }
                    _queryCircle(t, i, h, d, m) {
                        const y = t - h
                          , M = t + h
                          , E = i - h
                          , S = i + h;
                        if (M < 0 || y > this.width || S < 0 || E > this.height)
                            return !d && [];
                        const I = [];
                        return this._forEachCell(y, E, M, S, this._queryCellCircle, I, {
                            hitTest: d,
                            circle: {
                                x: t,
                                y: i,
                                radius: h
                            },
                            seenUids: {
                                box: {},
                                circle: {}
                            }
                        }, m),
                        d ? I.length > 0 : I
                    }
                    query(t, i, h, d, m) {
                        return this._query(t, i, h, d, !1, m)
                    }
                    hitTest(t, i, h, d, m) {
                        return this._query(t, i, h, d, !0, m)
                    }
                    hitTestCircle(t, i, h, d) {
                        return this._queryCircle(t, i, h, !0, d)
                    }
                    _queryCell(t, i, h, d, m, y, M, E) {
                        const S = M.seenUids
                          , I = this.boxCells[m];
                        if (null !== I) {
                            const D = this.bboxes;
                            for (const k of I)
                                if (!S.box[k]) {
                                    S.box[k] = !0;
                                    const H = 4 * k;
                                    if (t <= D[H + 2] && i <= D[H + 3] && h >= D[H + 0] && d >= D[H + 1] && (!E || E(this.boxKeys[k]))) {
                                        if (M.hitTest)
                                            return y.push(!0),
                                            !0;
                                        y.push({
                                            key: this.boxKeys[k],
                                            x1: D[H],
                                            y1: D[H + 1],
                                            x2: D[H + 2],
                                            y2: D[H + 3]
                                        })
                                    }
                                }
                        }
                        const R = this.circleCells[m];
                        if (null !== R) {
                            const D = this.circles;
                            for (const k of R)
                                if (!S.circle[k]) {
                                    S.circle[k] = !0;
                                    const H = 3 * k;
                                    if (this._circleAndRectCollide(D[H], D[H + 1], D[H + 2], t, i, h, d) && (!E || E(this.circleKeys[k]))) {
                                        if (M.hitTest)
                                            return y.push(!0),
                                            !0;
                                        {
                                            const j = D[H]
                                              , Y = D[H + 1]
                                              , K = D[H + 2];
                                            y.push({
                                                key: this.circleKeys[k],
                                                x1: j - K,
                                                y1: Y - K,
                                                x2: j + K,
                                                y2: Y + K
                                            })
                                        }
                                    }
                                }
                        }
                    }
                    _queryCellCircle(t, i, h, d, m, y, M, E) {
                        const S = M.circle
                          , I = M.seenUids
                          , R = this.boxCells[m];
                        if (null !== R) {
                            const k = this.bboxes;
                            for (const H of R)
                                if (!I.box[H]) {
                                    I.box[H] = !0;
                                    const j = 4 * H;
                                    if (this._circleAndRectCollide(S.x, S.y, S.radius, k[j + 0], k[j + 1], k[j + 2], k[j + 3]) && (!E || E(this.boxKeys[H])))
                                        return y.push(!0),
                                        !0
                                }
                        }
                        const D = this.circleCells[m];
                        if (null !== D) {
                            const k = this.circles;
                            for (const H of D)
                                if (!I.circle[H]) {
                                    I.circle[H] = !0;
                                    const j = 3 * H;
                                    if (this._circlesCollide(k[j], k[j + 1], k[j + 2], S.x, S.y, S.radius) && (!E || E(this.circleKeys[H])))
                                        return y.push(!0),
                                        !0
                                }
                        }
                    }
                    _forEachCell(t, i, h, d, m, y, M, E) {
                        const S = this._convertToXCellCoord(t)
                          , I = this._convertToYCellCoord(i)
                          , R = this._convertToXCellCoord(h)
                          , D = this._convertToYCellCoord(d);
                        for (let k = S; k <= R; k++)
                            for (let H = I; H <= D; H++)
                                if (m.call(this, t, i, h, d, this.xCellCount * H + k, y, M, E))
                                    return
                    }
                    _convertToXCellCoord(t) {
                        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale)))
                    }
                    _convertToYCellCoord(t) {
                        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale)))
                    }
                    _circlesCollide(t, i, h, d, m, y) {
                        const M = d - t
                          , E = m - i
                          , S = h + y;
                        return S * S > M * M + E * E
                    }
                    _circleAndRectCollide(t, i, h, d, m, y, M) {
                        const E = (y - d) / 2
                          , S = Math.abs(t - (d + E));
                        if (S > E + h)
                            return !1;
                        const I = (M - m) / 2
                          , R = Math.abs(i - (m + I));
                        if (R > I + h)
                            return !1;
                        if (S <= E || R <= I)
                            return !0;
                        const D = S - E
                          , k = R - I;
                        return D * D + k * k <= h * h
                    }
                }
                const _i_unknown = 0
                  , _i_flipRequired = 1
                  , _i_flipNotRequired = 2
                  , Xl = Math.tan(85 * Math.PI / 180);
                function Xr(c, t, i, h, d, m, y) {
                    const M = s.ab.mat4.create();
                    if (i)
                        if ("globe" === m.name) {
                            const E = s.bo(d, t);
                            s.ab.mat4.multiply(M, M, E)
                        } else {
                            const E = s.ab.mat2.invert([], y);
                            M[0] = E[0],
                            M[1] = E[1],
                            M[4] = E[2],
                            M[5] = E[3],
                            h || s.ab.mat4.rotateZ(M, M, d.angle)
                        }
                    else
                        s.ab.mat4.multiply(M, d.labelPlaneMatrix, c);
                    return M
                }
                function Ys(c, t, i, h, d, m, y) {
                    const M = Xr(c, t, i, h, d, m, y);
                    return "globe" === m.name && i || (M[2] = M[6] = M[10] = M[14] = 0),
                    M
                }
                function An(c, t, i, h, d, m, y) {
                    if (i) {
                        if ("globe" === m.name) {
                            const M = Xr(c, t, i, h, d, m, y);
                            return s.ab.mat4.invert(M, M),
                            s.ab.mat4.multiply(M, c, M),
                            M
                        }
                        {
                            const M = s.ab.mat4.clone(c)
                              , E = s.ab.mat4.identity([]);
                            return E[0] = y[0],
                            E[1] = y[1],
                            E[4] = y[2],
                            E[5] = y[3],
                            s.ab.mat4.multiply(M, M, E),
                            h || s.ab.mat4.rotateZ(M, M, -d.angle),
                            M
                        }
                    }
                    return d.glCoordMatrix
                }
                function Vi(c, t, i, h) {
                    const d = [c, t, i, 1];
                    i ? s.ab.vec4.transformMat4(d, d, h) : Ps(d, d, h);
                    const m = d[3];
                    return d[0] /= m,
                    d[1] /= m,
                    d[2] /= m,
                    d
                }
                function qa(c, t) {
                    return Math.min(.5 + c / t * .5, 1.5)
                }
                function Zs(c, t) {
                    const i = c[0] / c[3]
                      , h = c[1] / c[3];
                    return i >= -t[0] && i <= t[0] && h >= -t[1] && h <= t[1]
                }
                function Pa(c, t, i, h, d, m, y, M, E, S) {
                    const I = i.transform
                      , R = h ? c.textSizeData : c.iconSizeData
                      , D = s.bp(R, i.transform.zoom)
                      , k = "globe" === I.projection.name
                      , H = [256 / i.width * 2 + 1, 256 / i.height * 2 + 1]
                      , j = h ? c.text.dynamicLayoutVertexArray : c.icon.dynamicLayoutVertexArray;
                    j.clear();
                    let Y = null;
                    k && (Y = h ? c.text.globeExtVertexArray : c.icon.globeExtVertexArray);
                    const K = c.lineVertexArray
                      , he = h ? c.text.placedSymbolArray : c.icon.placedSymbolArray
                      , Te = i.transform.width / i.transform.height;
                    let be, Ue = !1;
                    for (let De = 0; De < he.length; De++) {
                        const ke = he.get(De)
                          , {numGlyphs: Le, writingMode: Ge} = ke;
                        if (Ge !== s.bq.vertical || Ue || be === s.bq.horizontal || (Ue = !0),
                        be = Ge,
                        (ke.hidden || Ge === s.bq.vertical) && !Ue) {
                            ws(Le, j);
                            continue
                        }
                        Ue = !1;
                        const qe = new s.P(ke.tileAnchorX,ke.tileAnchorY);
                        let {x: vt, y: dt, z: Ze} = I.projection.projectTilePoint(qe.x, qe.y, S.canonical);
                        if (E) {
                            const [Dt,bo,oo] = E(qe);
                            vt += Dt,
                            dt += bo,
                            Ze += oo
                        }
                        const nt = [vt, dt, Ze, 1];
                        if (s.ab.vec4.transformMat4(nt, nt, t),
                        !Zs(nt, H)) {
                            ws(Le, j);
                            continue
                        }
                        const zt = nt[3]
                          , Yt = qa(i.transform.getCameraToCenterDistance(I.projection), zt)
                          , to = s.br(R, D, ke)
                          , ut = y ? to / Yt : to * Yt
                          , Gt = Vi(vt, dt, Ze, d);
                        if (Gt[3] <= 0) {
                            ws(Le, j);
                            continue
                        }
                        let wt = {};
                        const qt = y ? null : E
                          , Ht = Ma(ke, ut, !1, M, t, d, m, c.glyphOffsetArray, K, j, Y, Gt, qe, wt, Te, qt, I.projection, S, y);
                        Ue = Ht.useVertical,
                        qt && Ht.needsFlipping && (wt = {}),
                        (Ht.notEnoughRoom || Ue || Ht.needsFlipping && Ma(ke, ut, !0, M, t, d, m, c.glyphOffsetArray, K, j, Y, Gt, qe, wt, Te, qt, I.projection, S, y).notEnoughRoom) && ws(Le, j)
                    }
                    h ? (c.text.dynamicLayoutVertexBuffer.updateData(j),
                    Y && c.text.globeExtVertexBuffer && c.text.globeExtVertexBuffer.updateData(Y)) : (c.icon.dynamicLayoutVertexBuffer.updateData(j),
                    Y && c.icon.globeExtVertexBuffer && c.icon.globeExtVertexBuffer.updateData(Y))
                }
                function Ks(c, t, i, h, d, m, y, M, E, S, I, R, D, k, H, j) {
                    const {lineStartIndex: Y, glyphStartIndex: K, segment: he} = M
                      , Te = K + M.numGlyphs
                      , be = Y + M.lineLength
                      , Ue = t.getoffsetX(K)
                      , De = t.getoffsetX(Te - 1)
                      , ke = In(c * Ue, i, h, d, m, y, he, Y, be, E, S, I, R, D, !0, k, H, j);
                    if (!ke)
                        return null;
                    const Le = In(c * De, i, h, d, m, y, he, Y, be, E, S, I, R, D, !0, k, H, j);
                    return Le ? {
                        first: ke,
                        last: Le
                    } : null
                }
                function Ja(c, t, i, h) {
                    return c === s.bq.horizontal && Math.abs(h) > Math.abs(i) ? {
                        useVertical: !0
                    } : c === s.bq.vertical ? h > 0 ? {
                        needsFlipping: !0
                    } : null : t !== _i_unknown && (0 === (d = i) || Math.abs(h / d) > Xl) ? t === _i_flipRequired ? {
                        needsFlipping: !0
                    } : null : i < 0 ? {
                        needsFlipping: !0
                    } : null;
                    var d
                }
                function Ma(c, t, i, h, d, m, y, M, E, S, I, R, D, k, H, j, Y, K, he) {
                    const Te = t / 24
                      , be = c.lineOffsetX * Te
                      , Ue = c.lineOffsetY * Te
                      , {lineStartIndex: De, glyphStartIndex: ke, numGlyphs: Le, segment: Ge, writingMode: qe, flipState: vt} = c
                      , dt = De + c.lineLength
                      , Ze = nt => {
                        if (I) {
                            const [ut,Gt,wt] = nt.up
                              , qt = S.length;
                            s.bs(I, qt + 0, ut, Gt, wt),
                            s.bs(I, qt + 1, ut, Gt, wt),
                            s.bs(I, qt + 2, ut, Gt, wt),
                            s.bs(I, qt + 3, ut, Gt, wt)
                        }
                        const [zt,Yt,to] = nt.point;
                        s.bt(S, zt, Yt, to, nt.angle)
                    }
                    ;
                    if (Le > 1) {
                        const nt = Ks(Te, M, be, Ue, i, R, D, c, E, m, k, j, !1, Y, K, he);
                        if (!nt)
                            return {
                                notEnoughRoom: !0
                            };
                        if (h && !i) {
                            let[zt,Yt,to] = nt.first.point
                              , [ut,Gt,wt] = nt.last.point;
                            [zt,Yt] = Vi(zt, Yt, to, y),
                            [ut,Gt] = Vi(ut, Gt, wt, y);
                            const qt = Ja(qe, vt, (ut - zt) * H, Gt - Yt);
                            if (c.flipState = qt && qt.needsFlipping ? _i_flipRequired : _i_flipNotRequired,
                            qt)
                                return qt
                        }
                        Ze(nt.first);
                        for (let zt = ke + 1; zt < ke + Le - 1; zt++) {
                            const Yt = In(Te * M.getoffsetX(zt), be, Ue, i, R, D, Ge, De, dt, E, m, k, j, !1, !1, Y, K, he);
                            if (!Yt)
                                return S.length -= 4 * (zt - ke),
                                {
                                    notEnoughRoom: !0
                                };
                            Ze(Yt)
                        }
                        Ze(nt.last)
                    } else {
                        if (h && !i) {
                            const zt = Vi(D.x, D.y, 0, d)
                              , Yt = De + Ge + 1
                              , to = new s.P(E.getx(Yt),E.gety(Yt))
                              , ut = Vi(to.x, to.y, 0, d)
                              , Gt = ut[3] > 0 ? ut : ir(D, to, zt, 1, d, void 0, Y, K.canonical)
                              , wt = Ja(qe, vt, (Gt[0] - zt[0]) * H, Gt[1] - zt[1]);
                            if (c.flipState = wt && wt.needsFlipping ? _i_flipRequired : _i_flipNotRequired,
                            wt)
                                return wt
                        }
                        const nt = In(Te * M.getoffsetX(ke), be, Ue, i, R, D, Ge, De, dt, E, m, k, j, !1, !1, Y, K, he);
                        if (!nt)
                            return {
                                notEnoughRoom: !0
                            };
                        Ze(nt)
                    }
                    return {}
                }
                function Nn(c, t, i, h, d) {
                    const {x: m, y, z: M} = h.projectTilePoint(c.x, c.y, t);
                    if (!d)
                        return Vi(m, y, M, i);
                    const [E,S,I] = d(c);
                    return Vi(m + E, y + S, M + I, i)
                }
                function ir(c, t, i, h, d, m, y, M) {
                    const E = Nn(c.sub(t)._unit()._add(c), M, d, y, m);
                    return s.ab.vec3.sub(E, i, E),
                    s.ab.vec3.normalize(E, E),
                    s.ab.vec3.scaleAndAdd(E, i, E, h)
                }
                function In(c, t, i, h, d, m, y, M, E, S, I, R, D, k, H, j, Y, K) {
                    const he = h ? c - t : c + t;
                    let Te = he > 0 ? 1 : -1
                      , be = 0;
                    h && (Te *= -1,
                    be = Math.PI),
                    Te < 0 && (be += Math.PI);
                    let Ue = M + y + (Te > 0 ? 0 : 1) | 0
                      , De = d
                      , ke = d
                      , Le = 0
                      , Ge = 0;
                    const qe = Math.abs(he)
                      , vt = []
                      , dt = [];
                    let Ze = m
                      , nt = Ze;
                    const zt = () => ir(nt, Ze, ke, qe - Le + 1, I, D, j, Y.canonical);
                    for (; Le + Ge <= qe; ) {
                        if (Ue += Te,
                        Ue < M || Ue >= E)
                            return null;
                        if (ke = De,
                        nt = Ze,
                        vt.push(ke),
                        k && dt.push(nt),
                        Ze = new s.P(S.getx(Ue),S.gety(Ue)),
                        De = R[Ue],
                        !De) {
                            const bo = Nn(Ze, Y.canonical, I, j, D);
                            De = bo[3] > 0 ? R[Ue] = bo : zt()
                        }
                        Le += Ge,
                        Ge = s.ab.vec3.distance(ke, De)
                    }
                    H && D && (R[Ue] && (De = zt(),
                    Ge = s.ab.vec3.distance(ke, De)),
                    R[Ue] = De);
                    const Yt = (qe - Le) / Ge
                      , to = Ze.sub(nt)._mult(Yt)._add(nt)
                      , ut = s.ab.vec3.sub([], De, ke)
                      , Gt = s.ab.vec3.scaleAndAdd([], ke, ut, Yt);
                    let wt = [0, 0, 1]
                      , qt = ut[0]
                      , Ht = ut[1];
                    if (K && (wt = j.upVector(Y.canonical, to.x, to.y),
                    0 !== wt[0] || 0 !== wt[1] || 1 !== wt[2])) {
                        const bo = [wt[2], 0, -wt[0]]
                          , oo = s.ab.vec3.cross([], wt, bo);
                        s.ab.vec3.normalize(bo, bo),
                        s.ab.vec3.normalize(oo, oo),
                        qt = s.ab.vec3.dot(ut, bo),
                        Ht = s.ab.vec3.dot(ut, oo)
                    }
                    if (i) {
                        const bo = s.ab.vec3.cross([], wt, ut);
                        s.ab.vec3.normalize(bo, bo),
                        s.ab.vec3.scaleAndAdd(Gt, Gt, bo, i * Te)
                    }
                    const Dt = be + Math.atan2(Ht, qt);
                    return vt.push(Gt),
                    k && dt.push(to),
                    {
                        point: Gt,
                        angle: Dt,
                        path: vt,
                        tilePath: dt,
                        up: wt
                    }
                }
                function ws(c, t) {
                    const i = t.length
                      , h = i + 4 * c;
                    t.resize(h),
                    t.float32.fill(-1 / 0, 4 * i, 4 * h)
                }
                function Ps(c, t, i) {
                    const h = t[0]
                      , d = t[1];
                    return c[0] = i[0] * h + i[4] * d + i[12],
                    c[1] = i[1] * h + i[5] * d + i[13],
                    c[3] = i[3] * h + i[7] * d + i[15],
                    c
                }
                const en = 100;
                class gr {
                    constructor(t, i, h=new Xs(t.width + 200,t.height + 200,25), d=new Xs(t.width + 200,t.height + 200,25)) {
                        this.transform = t,
                        this.grid = h,
                        this.ignoredGrid = d,
                        this.pitchfactor = Math.cos(t._pitch) * t.cameraToCenterDistance,
                        this.screenRightBoundary = t.width + en,
                        this.screenBottomBoundary = t.height + en,
                        this.gridRightBoundary = t.width + 200,
                        this.gridBottomBoundary = t.height + 200,
                        this.fogState = i
                    }
                    placeCollisionBox(t, i, h, d, m, y, M, E) {
                        let S = h.projectedAnchorX
                          , I = h.projectedAnchorY
                          , R = h.projectedAnchorZ;
                        const D = h.elevation
                          , k = h.tileID
                          , H = t.getProjection();
                        if (D && k) {
                            const [De,ke,Le] = H.upVector(k.canonical, h.tileAnchorX, h.tileAnchorY)
                              , Ge = H.upVectorScale(k.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
                            S += De * D * Ge,
                            I += ke * D * Ge,
                            R += Le * D * Ge
                        }
                        const j = this.projectAndGetPerspectiveRatio(M, S, I, R, h.tileID, "globe" === H.name || !!D || this.transform.pitch > 0, H)
                          , Y = y * j.perspectiveRatio
                          , K = (h.x1 * i + d.x - h.padding) * Y + j.point.x
                          , he = (h.y1 * i + d.y - h.padding) * Y + j.point.y
                          , Te = (h.x2 * i + d.x + h.padding) * Y + j.point.x
                          , be = (h.y2 * i + d.y + h.padding) * Y + j.point.y
                          , Ue = j.perspectiveRatio <= .55 || j.occluded;
                        return !this.isInsideGrid(K, he, Te, be) || !m && this.grid.hitTest(K, he, Te, be, E) || Ue ? {
                            box: [],
                            offscreen: !1,
                            occluded: j.occluded
                        } : {
                            box: [K, he, Te, be],
                            offscreen: this.isOffscreen(K, he, Te, be),
                            occluded: !1
                        }
                    }
                    placeCollisionCircles(t, i, h, d, m, y, M, E, S, I, R, D, k, H, j) {
                        const Y = []
                          , K = this.transform.elevation
                          , he = t.getProjection()
                          , Te = K ? K.getAtTileOffsetFunc(j, this.transform.center.lat, this.transform.worldSize, he) : null
                          , be = new s.P(h.tileAnchorX,h.tileAnchorY);
                        let {x: Ue, y: De, z: ke} = he.projectTilePoint(be.x, be.y, j.canonical);
                        if (Te) {
                            const [to,ut,Gt] = Te(be);
                            Ue += to,
                            De += ut,
                            ke += Gt
                        }
                        const Le = "globe" === he.name
                          , Ge = this.projectAndGetPerspectiveRatio(M, Ue, De, ke, j, Le || !!K || this.transform.pitch > 0, he)
                          , {perspectiveRatio: qe} = Ge
                          , vt = (R ? y / qe : y * qe) / s.bw
                          , dt = Vi(Ue, De, ke, E)
                          , Ze = Ge.signedDistanceFromCamera > 0 ? Ks(vt, m, h.lineOffsetX * vt, h.lineOffsetY * vt, !1, dt, be, h, d, E, {}, K && !R ? Te : null, R && !!K, he, j, R) : null;
                        let nt = !1
                          , zt = !1
                          , Yt = !0;
                        if (Ze && !Ge.occluded) {
                            const to = .5 * k * qe + H
                              , ut = new s.P(-100,-100)
                              , Gt = new s.P(this.screenRightBoundary,this.screenBottomBoundary)
                              , wt = new Hn
                              , {first: qt, last: Ht} = Ze
                              , Dt = qt.path.length;
                            let bo = [];
                            for (let Eo = Dt - 1; Eo >= 1; Eo--)
                                bo.push(qt.path[Eo]);
                            for (let Eo = 1; Eo < Ht.path.length; Eo++)
                                bo.push(Ht.path[Eo]);
                            const oo = 2.5 * to;
                            S && (bo = bo.map( ([Eo,Yo,ko], Uo) => (Te && !Le && (ko = Te(Uo < Dt - 1 ? qt.tilePath[Dt - 1 - Uo] : Ht.tilePath[Uo - Dt + 2])[2]),
                            Vi(Eo, Yo, ko, S))),
                            bo.some(Eo => Eo[3] <= 0) && (bo = []));
                            let Po = [];
                            if (bo.length > 0) {
                                let Eo = 1 / 0
                                  , Yo = -1 / 0
                                  , ko = 1 / 0
                                  , Uo = -1 / 0;
                                for (const Zo of bo)
                                    Eo = Math.min(Eo, Zo[0]),
                                    ko = Math.min(ko, Zo[1]),
                                    Yo = Math.max(Yo, Zo[0]),
                                    Uo = Math.max(Uo, Zo[1]);
                                Yo >= ut.x && Eo <= Gt.x && Uo >= ut.y && ko <= Gt.y && (Po = [bo.map(Zo => new s.P(Zo[0],Zo[1]))],
                                (Eo < ut.x || Yo > Gt.x || ko < ut.y || Uo > Gt.y) && (Po = s.bu(Po, ut.x, ut.y, Gt.x, Gt.y)))
                            }
                            for (const Eo of Po) {
                                wt.reset(Eo, .25 * to);
                                let Yo = 0;
                                Yo = wt.length <= .5 * to ? 1 : Math.ceil(wt.paddedLength / oo) + 1;
                                for (let ko = 0; ko < Yo; ko++) {
                                    const Uo = ko / Math.max(Yo - 1, 1)
                                      , Zo = wt.lerp(Uo)
                                      , yi = Zo.x + en
                                      , li = Zo.y + en;
                                    Y.push(yi, li, to, 0);
                                    const Ji = yi - to
                                      , on = li - to
                                      , Ri = yi + to
                                      , Ni = li + to;
                                    if (Yt = Yt && this.isOffscreen(Ji, on, Ri, Ni),
                                    zt = zt || this.isInsideGrid(Ji, on, Ri, Ni),
                                    !i && this.grid.hitTestCircle(yi, li, to, D) && (nt = !0,
                                    !I))
                                        return {
                                            circles: [],
                                            offscreen: !1,
                                            collisionDetected: nt,
                                            occluded: !1
                                        }
                                }
                            }
                        }
                        return {
                            circles: !I && nt || !zt ? [] : Y,
                            offscreen: Yt,
                            collisionDetected: nt,
                            occluded: Ge.occluded
                        }
                    }
                    queryRenderedSymbols(t) {
                        if (0 === t.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
                            return {};
                        const i = [];
                        let h = 1 / 0
                          , d = 1 / 0
                          , m = -1 / 0
                          , y = -1 / 0;
                        for (const I of t) {
                            const R = new s.P(I.x + en,I.y + en);
                            h = Math.min(h, R.x),
                            d = Math.min(d, R.y),
                            m = Math.max(m, R.x),
                            y = Math.max(y, R.y),
                            i.push(R)
                        }
                        const M = this.grid.query(h, d, m, y).concat(this.ignoredGrid.query(h, d, m, y))
                          , E = {}
                          , S = {};
                        for (const I of M) {
                            const R = I.key;
                            if (void 0 === E[R.bucketInstanceId] && (E[R.bucketInstanceId] = {}),
                            E[R.bucketInstanceId][R.featureIndex])
                                continue;
                            const D = [new s.P(I.x1,I.y1), new s.P(I.x2,I.y1), new s.P(I.x2,I.y2), new s.P(I.x1,I.y2)];
                            s.bv(i, D) && (E[R.bucketInstanceId][R.featureIndex] = !0,
                            void 0 === S[R.bucketInstanceId] && (S[R.bucketInstanceId] = []),
                            S[R.bucketInstanceId].push(R.featureIndex))
                        }
                        return S
                    }
                    insertCollisionBox(t, i, h, d, m) {
                        (i ? this.ignoredGrid : this.grid).insert({
                            bucketInstanceId: h,
                            featureIndex: d,
                            collisionGroupID: m
                        }, t[0], t[1], t[2], t[3])
                    }
                    insertCollisionCircles(t, i, h, d, m) {
                        const y = i ? this.ignoredGrid : this.grid
                          , M = {
                            bucketInstanceId: h,
                            featureIndex: d,
                            collisionGroupID: m
                        };
                        for (let E = 0; E < t.length; E += 4)
                            y.insertCircle(M, t[E], t[E + 1], t[E + 2])
                    }
                    projectAndGetPerspectiveRatio(t, i, h, d, m, y, M) {
                        const E = [i, h, d, 1];
                        let S = !1;
                        d || this.transform.pitch > 0 ? (s.ab.vec4.transformMat4(E, E, t),
                        this.fogState && m && "globe" !== M.name && (S = function(D, k, H, j, Y, K) {
                            const he = K.calculateFogTileMatrix(Y)
                              , Te = [k, H, j];
                            return s.ab.vec3.transformMat4(Te, Te, he),
                            Ho(D, s.ab.vec3.length(Te), K.pitch, K._fov)
                        }(this.fogState, i, h, d, m.toUnwrapped(), this.transform) > .9)) : Ps(E, E, t);
                        const I = E[3];
                        return {
                            point: new s.P((E[0] / I + 1) / 2 * this.transform.width + en,(-E[1] / I + 1) / 2 * this.transform.height + en),
                            perspectiveRatio: Math.min(.5 + this.transform.getCameraToCenterDistance(M) / I * .5, 1.5),
                            signedDistanceFromCamera: I,
                            occluded: y && E[2] > I || S
                        }
                    }
                    isOffscreen(t, i, h, d) {
                        return h < en || t >= this.screenRightBoundary || d < en || i > this.screenBottomBoundary
                    }
                    isInsideGrid(t, i, h, d) {
                        return h >= 0 && t < this.gridRightBoundary && d >= 0 && i < this.gridBottomBoundary
                    }
                    getViewportMatrix() {
                        const t = s.ab.mat4.identity([]);
                        return s.ab.mat4.translate(t, t, [-100, -100, 0]),
                        t
                    }
                }
                function Ar(c, t, i) {
                    const h = t.createTileMatrix(c, c.worldSize, i.toUnwrapped());
                    return s.ab.mat4.multiply(new Float32Array(16), c.projMatrix, h)
                }
                function Xi(c, t, i) {
                    if (t.projection.name === i.projection.name)
                        return c.projMatrix;
                    const h = i.clone();
                    return h.setProjection(t.projection),
                    Ar(h, t.getProjection(), c)
                }
                function yr(c, t, i) {
                    return t.name === i.projection.name ? c.projMatrix : Ar(i, t, c)
                }
                class On {
                    constructor(t, i, h, d) {
                        this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? i : -i))) : d && h ? 1 : 0,
                        this.placed = h
                    }
                    isHidden() {
                        return 0 === this.opacity && !this.placed
                    }
                }
                class Yr {
                    constructor(t, i, h, d, m, y=!1) {
                        this.text = new On(t ? t.text : null,i,h,m),
                        this.icon = new On(t ? t.icon : null,i,d,m),
                        this.clipped = y
                    }
                    isHidden() {
                        return this.text.isHidden() && this.icon.isHidden()
                    }
                }
                class qs {
                    constructor(t, i, h, d=!1) {
                        this.text = t,
                        this.icon = i,
                        this.skipFade = h,
                        this.clipped = d
                    }
                }
                class Ms {
                    constructor() {
                        this.invProjMatrix = s.ab.mat4.create(),
                        this.viewportMatrix = s.ab.mat4.create(),
                        this.circles = []
                    }
                }
                class ou {
                    constructor(t, i, h, d, m) {
                        this.bucketInstanceId = t,
                        this.featureIndex = i,
                        this.sourceLayerIndex = h,
                        this.bucketIndex = d,
                        this.tileID = m
                    }
                }
                class Zr {
                    constructor(t) {
                        this.crossSourceCollisions = t,
                        this.maxGroupID = 0,
                        this.collisionGroups = {}
                    }
                    get(t) {
                        if (this.crossSourceCollisions)
                            return {
                                ID: 0,
                                predicate: null
                            };
                        if (!this.collisionGroups[t]) {
                            const i = ++this.maxGroupID;
                            this.collisionGroups[t] = {
                                ID: i,
                                predicate: h => h.collisionGroupID === i
                            }
                        }
                        return this.collisionGroups[t]
                    }
                }
                function Xc(c, t, i, h, d) {
                    const {horizontalAlign: m, verticalAlign: y} = s.bD(c)
                      , M = -(m - .5) * t
                      , E = -(y - .5) * i
                      , S = s.bC(c, h);
                    return new s.P(M + S[0] * d,E + S[1] * d)
                }
                function Qa(c, t, i, h, d) {
                    const m = new s.P(c,t);
                    return i && m._rotate(h ? d : -d),
                    m
                }
                class nr {
                    constructor(t, i, h, d, m, y) {
                        this.transform = t.clone(),
                        this.projection = t.projection.name,
                        this.collisionIndex = new gr(this.transform,m),
                        this.buildingIndex = y,
                        this.placements = {},
                        this.opacities = {},
                        this.variableOffsets = {},
                        this.stale = !1,
                        this.commitTime = 0,
                        this.fadeDuration = i,
                        this.retainedQueryData = {},
                        this.collisionGroups = new Zr(h),
                        this.collisionCircleArrays = {},
                        this.prevPlacement = d,
                        d && (d.prevPlacement = void 0),
                        this.placedOrientations = {}
                    }
                    getBucketParts(t, i, h, d, m=1) {
                        const y = h.getBucket(i)
                          , M = h.latestFeatureIndex;
                        if (!y || !M || i.fqid !== y.layerIds[0])
                            return;
                        const E = y.layers[0].layout
                          , S = y.layers[0].paint
                          , I = h.collisionBoxArray
                          , R = Math.pow(2, this.transform.zoom - h.tileID.overscaledZ)
                          , D = h.tileSize / s.ag
                          , k = h.tileID.toUnwrapped();
                        this.transform.setProjection(y.projection);
                        const H = (j = h.tileID,
                        Y = y.getProjection(),
                        K = this.transform,
                        Y.name === this.projection ? K.calculateProjMatrix(j.toUnwrapped()) : Ar(K, Y, j));
                        var j, Y, K;
                        const he = "map" === E.get("text-pitch-alignment")
                          , Te = "map" === E.get("text-rotation-alignment");
                        i.compileFilter(i.options);
                        const be = i.dynamicFilter()
                          , Ue = i.dynamicFilterNeedsFeature()
                          , De = this.transform.calculatePixelsToTileUnitsMatrix(h)
                          , ke = Ys(H, h.tileID.canonical, he, Te, this.transform, y.getProjection(), De);
                        let Le = null;
                        if (he) {
                            const to = An(H, h.tileID.canonical, he, Te, this.transform, y.getProjection(), De);
                            Le = s.ab.mat4.multiply([], this.transform.labelPlaneMatrix, to)
                        }
                        let Ge = null;
                        be && h.latestFeatureIndex && (Ge = {
                            unwrappedTileID: k,
                            dynamicFilter: be,
                            dynamicFilterNeedsFeature: Ue
                        }),
                        this.retainedQueryData[y.bucketInstanceId] = new ou(y.bucketInstanceId,M,y.sourceLayerIndex,y.index,h.tileID);
                        const [qe,vt] = y.layers[0].layout.get("text-size-scale-range")
                          , dt = s.aw(m, qe, vt)
                          , [Ze,nt] = E.get("icon-size-scale-range")
                          , zt = s.aw(m, Ze, nt)
                          , Yt = {
                            bucket: y,
                            layout: E,
                            paint: S,
                            posMatrix: H,
                            textLabelPlaneMatrix: ke,
                            labelToScreenMatrix: Le,
                            clippingData: Ge,
                            scale: R,
                            textPixelRatio: D,
                            holdingForFade: h.holdingForFade(),
                            collisionBoxArray: I,
                            partiallyEvaluatedTextSize: s.bp(y.textSizeData, this.transform.zoom, dt),
                            partiallyEvaluatedIconSize: s.bp(y.iconSizeData, this.transform.zoom, zt),
                            collisionGroup: this.collisionGroups.get(y.sourceID),
                            latestFeatureIndex: h.latestFeatureIndex
                        };
                        if (d)
                            for (const to of y.sortKeyRanges) {
                                const {sortKey: ut, symbolInstanceStart: Gt, symbolInstanceEnd: wt} = to;
                                t.push({
                                    sortKey: ut,
                                    symbolInstanceStart: Gt,
                                    symbolInstanceEnd: wt,
                                    parameters: Yt
                                })
                            }
                        else
                            t.push({
                                symbolInstanceStart: 0,
                                symbolInstanceEnd: y.symbolInstances.length,
                                parameters: Yt
                            })
                    }
                    attemptAnchorPlacement(t, i, h, d, m, y, M, E, S, I, R, D, k, H, j, Y, K, he) {
                        const {textOffset0: Te, textOffset1: be, crossTileID: Ue} = D
                          , De = [Te, be]
                          , ke = Xc(t, h, d, De, m)
                          , Le = this.collisionIndex.placeCollisionBox(H, m, i, Qa(ke.x, ke.y, y, M, this.transform.angle), R, E, S, I.predicate);
                        if (Y) {
                            const Ge = H.getSymbolInstanceIconSize(he, this.transform.zoom, D.placedIconSymbolIndex);
                            if (0 === this.collisionIndex.placeCollisionBox(H, Ge, Y, Qa(ke.x, ke.y, y, M, this.transform.angle), R, E, S, I.predicate).box.length)
                                return
                        }
                        if (Le.box.length > 0) {
                            let Ge;
                            return this.prevPlacement && this.prevPlacement.variableOffsets[Ue] && this.prevPlacement.placements[Ue] && this.prevPlacement.placements[Ue].text && (Ge = this.prevPlacement.variableOffsets[Ue].anchor),
                            this.variableOffsets[Ue] = {
                                textOffset: De,
                                width: h,
                                height: d,
                                anchor: t,
                                textScale: m,
                                prevAnchor: Ge
                            },
                            this.markUsedJustification(H, t, D, j),
                            H.allowVerticalPlacement && (this.markUsedOrientation(H, j, D),
                            this.placedOrientations[Ue] = j),
                            {
                                shift: ke,
                                placedGlyphBoxes: Le
                            }
                        }
                    }
                    placeLayerBucketPart(t, i, h, d, m=1) {
                        const {bucket: y, layout: M, paint: E, posMatrix: S, textLabelPlaneMatrix: I, labelToScreenMatrix: R, clippingData: D, textPixelRatio: k, holdingForFade: H, collisionBoxArray: j, partiallyEvaluatedTextSize: Y, partiallyEvaluatedIconSize: K, collisionGroup: he, latestFeatureIndex: Te} = t.parameters
                          , be = M.get("text-optional")
                          , Ue = M.get("icon-optional")
                          , De = M.get("text-allow-overlap")
                          , ke = M.get("icon-allow-overlap")
                          , Le = "map" === M.get("text-rotation-alignment")
                          , Ge = "map" === M.get("text-pitch-alignment")
                          , qe = M.get("symbol-z-elevate")
                          , vt = E.get("symbol-z-offset")
                          , dt = "sea" === M.get("symbol-elevation-reference")
                          , [Ze,nt] = M.get("text-size-scale-range")
                          , [zt,Yt] = M.get("icon-size-scale-range")
                          , to = s.aw(m, Ze, nt)
                          , ut = s.aw(m, zt, Yt);
                        this.transform.setProjection(y.projection);
                        let Gt = De && (ke || !y.hasIconData() || Ue)
                          , wt = ke && (De || !y.hasTextData() || be);
                        const qt = !vt.isConstant();
                        !y.collisionArrays && j && y.deserializeCollisionBoxes(j),
                        h && d && y.updateCollisionDebugBuffers(this.transform.zoom, j, to, ut);
                        const Ht = (Dt, bo, oo) => {
                            const {crossTileID: Po, numVerticalGlyphVertices: Eo} = Dt;
                            let Yo = null;
                            if (D && D.dynamicFilterNeedsFeature || qt) {
                                const Yi = this.retainedQueryData[y.bucketInstanceId];
                                Yo = Te.loadFeature({
                                    featureIndex: Dt.featureIndex,
                                    bucketIndex: Yi.bucketIndex,
                                    sourceLayerIndex: Yi.sourceLayerIndex,
                                    layoutVertexArrayOffset: 0
                                })
                            }
                            if (D && !(0,
                            D.dynamicFilter)({
                                zoom: this.transform.zoom,
                                pitch: this.transform.pitch
                            }, Yo, this.retainedQueryData[y.bucketInstanceId].tileID.canonical, new s.P(Dt.tileAnchorX,Dt.tileAnchorY), this.transform.calculateDistanceTileData(D.unwrappedTileID)))
                                return this.placements[Po] = new qs(!1,!1,!1,!0),
                                void i.add(Po);
                            const ko = vt.evaluate(Yo, {});
                            if (i.has(Po))
                                return;
                            if (H)
                                return void (this.placements[Po] = new qs(!1,!1,!1));
                            let Uo = !1
                              , Zo = !1
                              , yi = !0
                              , li = !1
                              , Ji = !1
                              , on = null
                              , Ri = {
                                box: null,
                                offscreen: null,
                                occluded: null
                            }
                              , Ni = {
                                box: null,
                                offscreen: null,
                                occluded: null
                            }
                              , ii = null
                              , No = null
                              , Ei = null
                              , Di = 0
                              , an = 0
                              , jn = 0;
                            oo.textFeatureIndex ? Di = oo.textFeatureIndex : Dt.useRuntimeCollisionCircles && (Di = Dt.featureIndex),
                            oo.verticalTextFeatureIndex && (an = oo.verticalTextFeatureIndex);
                            const lr = Yi => {
                                Yi.tileID = this.retainedQueryData[y.bucketInstanceId].tileID;
                                const Qi = this.transform.elevation;
                                Yi.elevation = dt ? ko : ko + (Qi ? Qi.getAtTileOffset(Yi.tileID, Yi.tileAnchorX, Yi.tileAnchorY) : 0),
                                Yi.elevation += Dt.zOffset
                            }
                              , bn = oo.textBox;
                            if (bn) {
                                lr(bn);
                                const Yi = vi => {
                                    let dn = s.bq.horizontal;
                                    if (y.allowVerticalPlacement && !vi && this.prevPlacement) {
                                        const Vn = this.prevPlacement.placedOrientations[Po];
                                        Vn && (this.placedOrientations[Po] = Vn,
                                        dn = Vn,
                                        this.markUsedOrientation(y, dn, Dt))
                                    }
                                    return dn
                                }
                                  , Qi = (vi, dn) => {
                                    if (y.allowVerticalPlacement && Eo > 0 && oo.verticalTextBox) {
                                        for (const Vn of y.writingModes)
                                            if (Vn === s.bq.vertical ? (Ri = dn(),
                                            Ni = Ri) : Ri = vi(),
                                            Ri && Ri.box && Ri.box.length)
                                                break
                                    } else
                                        Ri = vi()
                                }
                                ;
                                if (M.get("text-variable-anchor")) {
                                    let vi = M.get("text-variable-anchor");
                                    if (this.prevPlacement && this.prevPlacement.variableOffsets[Po]) {
                                        const Wi = this.prevPlacement.variableOffsets[Po];
                                        vi.indexOf(Wi.anchor) > 0 && (vi = vi.filter(tr => tr !== Wi.anchor),
                                        vi.unshift(Wi.anchor))
                                    }
                                    const dn = (Wi, tr, Or) => {
                                        const Tr = y.getSymbolInstanceTextSize(Y, Dt, this.transform.zoom, bo)
                                          , zs = (Wi.x2 - Wi.x1) * Tr + 2 * Wi.padding
                                          , cr = (Wi.y2 - Wi.y1) * Tr + 2 * Wi.padding
                                          , ns = Dt.hasIconTextFit && !ke ? tr : null;
                                        ns && lr(ns);
                                        let Cr = {
                                            box: [],
                                            offscreen: !1,
                                            occluded: !1
                                        };
                                        const ya = De ? 2 * vi.length : vi.length;
                                        for (let ys = 0; ys < ya; ++ys) {
                                            const $a = this.attemptAnchorPlacement(vi[ys % vi.length], Wi, zs, cr, Tr, Le, Ge, k, S, he, ys >= vi.length, Dt, bo, y, Or, ns, Y, K);
                                            if ($a && (Cr = $a.placedGlyphBoxes,
                                            Cr && Cr.box && Cr.box.length)) {
                                                Uo = !0,
                                                on = $a.shift;
                                                break
                                            }
                                        }
                                        return Cr
                                    }
                                    ;
                                    Qi( () => dn(bn, oo.iconBox, s.bq.horizontal), () => {
                                        const Wi = oo.verticalTextBox;
                                        return Wi && lr(Wi),
                                        y.allowVerticalPlacement && !(Ri && Ri.box && Ri.box.length) && Eo > 0 && Wi ? dn(Wi, oo.verticalIconBox, s.bq.vertical) : {
                                            box: null,
                                            offscreen: null,
                                            occluded: null
                                        }
                                    }
                                    ),
                                    Ri && (Uo = Ri.box,
                                    yi = Ri.offscreen,
                                    li = Ri.occluded);
                                    const Vn = Yi(!(!Ri || !Ri.box));
                                    if (!Uo && this.prevPlacement) {
                                        const Wi = this.prevPlacement.variableOffsets[Po];
                                        Wi && (this.variableOffsets[Po] = Wi,
                                        this.markUsedJustification(y, Wi.anchor, Dt, Vn))
                                    }
                                } else {
                                    const vi = (dn, Vn) => {
                                        const Wi = y.getSymbolInstanceTextSize(Y, Dt, this.transform.zoom, bo, m)
                                          , tr = this.collisionIndex.placeCollisionBox(y, Wi, dn, new s.P(0,0), De, k, S, he.predicate);
                                        return tr && tr.box && tr.box.length && (this.markUsedOrientation(y, Vn, Dt),
                                        this.placedOrientations[Po] = Vn),
                                        tr
                                    }
                                    ;
                                    Qi( () => vi(bn, s.bq.horizontal), () => {
                                        const dn = oo.verticalTextBox;
                                        return y.allowVerticalPlacement && Eo > 0 && dn ? (lr(dn),
                                        vi(dn, s.bq.vertical)) : {
                                            box: null,
                                            offscreen: null,
                                            occluded: null
                                        }
                                    }
                                    ),
                                    Yi(!!(Ri && Ri.box && Ri.box.length))
                                }
                            }
                            if (ii = Ri,
                            Uo = ii && ii.box && ii.box.length > 0,
                            yi = ii && ii.offscreen,
                            li = ii && ii.occluded,
                            Dt.useRuntimeCollisionCircles) {
                                const Yi = y.text.placedSymbolArray.get(Dt.centerJustifiedTextSymbolIndex >= 0 ? Dt.centerJustifiedTextSymbolIndex : Dt.verticalPlacedTextSymbolIndex)
                                  , Qi = s.br(y.textSizeData, Y, Yi)
                                  , vi = M.get("text-padding");
                                No = this.collisionIndex.placeCollisionCircles(y, De, Yi, y.lineVertexArray, y.glyphOffsetArray, Qi, S, I, R, h, Ge, he.predicate, Dt.collisionCircleDiameter * Qi / s.bw, vi, this.retainedQueryData[y.bucketInstanceId].tileID),
                                Uo = De || No.circles.length > 0 && !No.collisionDetected,
                                yi = yi && No.offscreen,
                                li = No.occluded
                            }
                            if (oo.iconFeatureIndex && (jn = oo.iconFeatureIndex),
                            oo.iconBox) {
                                const Yi = Qi => {
                                    lr(Qi);
                                    const vi = Dt.hasIconTextFit && on ? Qa(on.x, on.y, Le, Ge, this.transform.angle) : new s.P(0,0)
                                      , dn = y.getSymbolInstanceIconSize(K, this.transform.zoom, Dt.placedIconSymbolIndex);
                                    return this.collisionIndex.placeCollisionBox(y, dn, Qi, vi, ke, k, S, he.predicate)
                                }
                                ;
                                Ni && Ni.box && Ni.box.length && oo.verticalIconBox ? (Ei = Yi(oo.verticalIconBox),
                                Zo = Ei.box.length > 0) : (Ei = Yi(oo.iconBox),
                                Zo = Ei.box.length > 0),
                                yi = yi && Ei.offscreen,
                                Ji = Ei.occluded
                            }
                            const Un = be || 0 === Dt.numHorizontalGlyphVertices && 0 === Eo
                              , er = Ue || 0 === Dt.numIconVertices;
                            if (Un || er ? er ? Un || (Zo = Zo && Uo) : Uo = Zo && Uo : Zo = Uo = Zo && Uo,
                            Uo && ii && ii.box && this.collisionIndex.insertCollisionBox(ii.box, M.get("text-ignore-placement"), y.bucketInstanceId, Ni && Ni.box && an ? an : Di, he.ID),
                            Zo && Ei && this.collisionIndex.insertCollisionBox(Ei.box, M.get("icon-ignore-placement"), y.bucketInstanceId, jn, he.ID),
                            No && (Uo && this.collisionIndex.insertCollisionCircles(No.circles, M.get("text-ignore-placement"), y.bucketInstanceId, Di, he.ID),
                            h)) {
                                const Yi = y.bucketInstanceId;
                                let Qi = this.collisionCircleArrays[Yi];
                                void 0 === Qi && (Qi = this.collisionCircleArrays[Yi] = new Ms);
                                for (let vi = 0; vi < No.circles.length; vi += 4)
                                    Qi.circles.push(No.circles[vi + 0]),
                                    Qi.circles.push(No.circles[vi + 1]),
                                    Qi.circles.push(No.circles[vi + 2]),
                                    Qi.circles.push(No.collisionDetected ? 1 : 0)
                            }
                            const pn = "globe" !== y.projection.name;
                            Gt = Gt && (pn || !li),
                            wt = wt && (pn || !Ji),
                            this.placements[Po] = new qs(Uo || Gt,Zo || wt,yi || y.justReloaded),
                            i.add(Po)
                        }
                        ;
                        if (qe && this.buildingIndex && (this.buildingIndex.updateZOffset(y, this.retainedQueryData[y.bucketInstanceId].tileID),
                        y.updateZOffset()),
                        y.sortFeaturesByY) {
                            const Dt = y.getSortedSymbolIndexes(this.transform.angle);
                            for (let bo = Dt.length - 1; bo >= 0; --bo) {
                                const oo = Dt[bo];
                                Ht(y.symbolInstances.get(oo), oo, y.collisionArrays[oo])
                            }
                            y.hasAnyZOffset && s.w("".concat(y.layerIds[0], " layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y"))
                        } else if (y.hasAnyZOffset) {
                            const Dt = y.getSortedIndexesByZOffset();
                            for (let bo = 0; bo < Dt.length; ++bo) {
                                const oo = Dt[bo];
                                Ht(y.symbolInstances.get(oo), oo, y.collisionArrays[oo])
                            }
                        } else
                            for (let Dt = t.symbolInstanceStart; Dt < t.symbolInstanceEnd; Dt++)
                                Ht(y.symbolInstances.get(Dt), Dt, y.collisionArrays[Dt]);
                        if (h && y.bucketInstanceId in this.collisionCircleArrays) {
                            const Dt = this.collisionCircleArrays[y.bucketInstanceId];
                            s.ab.mat4.invert(Dt.invProjMatrix, S),
                            Dt.viewportMatrix = this.collisionIndex.getViewportMatrix()
                        }
                        y.justReloaded = !1
                    }
                    markUsedJustification(t, i, h, d) {
                        const {leftJustifiedTextSymbolIndex: m, centerJustifiedTextSymbolIndex: y, rightJustifiedTextSymbolIndex: M, verticalPlacedTextSymbolIndex: E, crossTileID: S} = h
                          , I = s.bB(i)
                          , R = d === s.bq.vertical ? E : "left" === I ? m : "center" === I ? y : "right" === I ? M : -1;
                        m >= 0 && (t.text.placedSymbolArray.get(m).crossTileID = R >= 0 && m !== R ? 0 : S),
                        y >= 0 && (t.text.placedSymbolArray.get(y).crossTileID = R >= 0 && y !== R ? 0 : S),
                        M >= 0 && (t.text.placedSymbolArray.get(M).crossTileID = R >= 0 && M !== R ? 0 : S),
                        E >= 0 && (t.text.placedSymbolArray.get(E).crossTileID = R >= 0 && E !== R ? 0 : S)
                    }
                    markUsedOrientation(t, i, h) {
                        const d = i === s.bq.horizontal || i === s.bq.horizontalOnly ? i : 0
                          , m = i === s.bq.vertical ? i : 0
                          , {leftJustifiedTextSymbolIndex: y, centerJustifiedTextSymbolIndex: M, rightJustifiedTextSymbolIndex: E, verticalPlacedTextSymbolIndex: S} = h
                          , I = t.text.placedSymbolArray;
                        y >= 0 && (I.get(y).placedOrientation = d),
                        M >= 0 && (I.get(M).placedOrientation = d),
                        E >= 0 && (I.get(E).placedOrientation = d),
                        S >= 0 && (I.get(S).placedOrientation = m)
                    }
                    commit(t) {
                        this.commitTime = t,
                        this.zoomAtLastRecencyCheck = this.transform.zoom;
                        const i = this.prevPlacement;
                        let h = !1;
                        this.prevZoomAdjustment = i ? i.zoomAdjustment(this.transform.zoom) : 0;
                        const d = i ? i.symbolFadeChange(t) : 1
                          , m = i ? i.opacities : {}
                          , y = i ? i.variableOffsets : {}
                          , M = i ? i.placedOrientations : {};
                        for (const E in this.placements) {
                            const S = this.placements[E]
                              , I = m[E];
                            I ? (this.opacities[E] = new Yr(I,d,S.text,S.icon,null,S.clipped),
                            h = h || S.text !== I.text.placed || S.icon !== I.icon.placed) : (this.opacities[E] = new Yr(null,d,S.text,S.icon,S.skipFade,S.clipped),
                            h = h || S.text || S.icon)
                        }
                        for (const E in m) {
                            const S = m[E];
                            if (!this.opacities[E]) {
                                const I = new Yr(S,d,!1,!1);
                                I.isHidden() || (this.opacities[E] = I,
                                h = h || S.text.placed || S.icon.placed)
                            }
                        }
                        for (const E in y)
                            this.variableOffsets[E] || !this.opacities[E] || this.opacities[E].isHidden() || (this.variableOffsets[E] = y[E]);
                        for (const E in M)
                            this.placedOrientations[E] || !this.opacities[E] || this.opacities[E].isHidden() || (this.placedOrientations[E] = M[E]);
                        h ? this.lastPlacementChangeTime = t : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = i ? i.lastPlacementChangeTime : t)
                    }
                    updateLayerOpacities(t, i, h, d) {
                        const m = new Set;
                        for (const y of i) {
                            const M = y.getBucket(t);
                            M && y.latestFeatureIndex && t.fqid === M.layerIds[0] && (this.updateBucketOpacities(M, m, y, y.collisionBoxArray, h, d, y.tileID, t.scope),
                            M.layers[0].layout.get("symbol-z-elevate") && this.buildingIndex && (this.buildingIndex.updateZOffset(M, y.tileID),
                            M.updateZOffset()))
                        }
                    }
                    updateBucketOpacities(t, i, h, d, m, y, M, E) {
                        t.hasTextData() && t.text.opacityVertexArray.clear(),
                        t.hasIconData() && t.icon.opacityVertexArray.clear(),
                        t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(),
                        t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();
                        const S = t.layers[0].layout
                          , I = t.layers[0].paint
                          , R = !!t.layers[0].dynamicFilter()
                          , D = new Yr(null,0,!1,!1,!0)
                          , k = S.get("text-allow-overlap")
                          , H = S.get("icon-allow-overlap")
                          , j = S.get("text-variable-anchor")
                          , Y = "map" === S.get("text-rotation-alignment")
                          , K = "map" === S.get("text-pitch-alignment")
                          , he = I.get("symbol-z-offset")
                          , Te = "sea" === S.get("symbol-elevation-reference")
                          , be = !he.isConstant()
                          , Ue = new Yr(null,0,k && (H || !t.hasIconData() || S.get("icon-optional")),H && (k || !t.hasTextData() || S.get("text-optional")),!0);
                        !t.collisionArrays && d && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(d);
                        const De = (Le, Ge, qe) => {
                            for (let vt = 0; vt < Ge / 4; vt++)
                                Le.opacityVertexArray.emplaceBack(qe)
                        }
                        ;
                        let ke = 0;
                        y && t.updateReplacement(M, y);
                        for (let Le = 0; Le < t.symbolInstances.length; Le++) {
                            const Ge = t.symbolInstances.get(Le)
                              , {numHorizontalGlyphVertices: qe, numVerticalGlyphVertices: vt, crossTileID: dt, numIconVertices: Ze, tileAnchorX: nt, tileAnchorY: zt} = Ge;
                            let Yt = null;
                            const to = this.retainedQueryData[t.bucketInstanceId];
                            be && Ge && to && (Yt = h.latestFeatureIndex.loadFeature({
                                featureIndex: Ge.featureIndex,
                                bucketIndex: to.bucketIndex,
                                sourceLayerIndex: to.sourceLayerIndex,
                                layoutVertexArrayOffset: 0
                            }));
                            const ut = he.evaluate(Yt, {})
                              , Gt = i.has(dt);
                            let wt = this.opacities[dt];
                            Gt ? wt = D : wt || (wt = Ue,
                            this.opacities[dt] = wt),
                            i.add(dt);
                            const qt = qe > 0 || vt > 0
                              , Ht = Ze > 0
                              , Dt = this.placedOrientations[dt]
                              , bo = Dt === s.bq.vertical
                              , oo = Dt === s.bq.horizontal || Dt === s.bq.horizontalOnly;
                            !qt && !Ht || wt.isHidden() || ke++;
                            let Po = !1;
                            if ((qt || Ht) && y)
                                for (const Eo of t.activeReplacements) {
                                    if (s.bx(Eo, m, s.by.Symbol, E) || Eo.min.x > nt || nt > Eo.max.x || Eo.min.y > zt || zt > Eo.max.y)
                                        continue;
                                    const Yo = s.bz(nt, zt, M.canonical, Eo.footprintTileId.canonical);
                                    if (Po = s.bA(Yo, Eo.footprint),
                                    Po)
                                        break
                                }
                            if (qt) {
                                const Eo = Po ? vr : Zc(wt.text);
                                De(t.text, qe, bo ? vr : Eo),
                                De(t.text, vt, oo ? vr : Eo);
                                const Yo = wt.text.isHidden()
                                  , {leftJustifiedTextSymbolIndex: ko, centerJustifiedTextSymbolIndex: Uo, rightJustifiedTextSymbolIndex: Zo, verticalPlacedTextSymbolIndex: yi} = Ge
                                  , li = t.text.placedSymbolArray
                                  , Ji = Yo || bo ? 1 : 0;
                                ko >= 0 && (li.get(ko).hidden = Ji),
                                Uo >= 0 && (li.get(Uo).hidden = Ji),
                                Zo >= 0 && (li.get(Zo).hidden = Ji),
                                yi >= 0 && (li.get(yi).hidden = Yo || oo ? 1 : 0);
                                const on = this.variableOffsets[dt];
                                on && this.markUsedJustification(t, on.anchor, Ge, Dt);
                                const Ri = this.placedOrientations[dt];
                                Ri && (this.markUsedJustification(t, "left", Ge, Ri),
                                this.markUsedOrientation(t, Ri, Ge))
                            }
                            if (Ht) {
                                const Eo = Po ? vr : Zc(wt.icon)
                                  , {placedIconSymbolIndex: Yo, verticalPlacedIconSymbolIndex: ko} = Ge
                                  , Uo = t.icon.placedSymbolArray
                                  , Zo = wt.icon.isHidden() ? 1 : 0;
                                Yo >= 0 && (De(t.icon, Ze, bo ? vr : Eo),
                                Uo.get(Yo).hidden = Zo),
                                ko >= 0 && (De(t.icon, Ge.numVerticalIconVertices, oo ? vr : Eo),
                                Uo.get(ko).hidden = Zo)
                            }
                            if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {
                                const Eo = t.collisionArrays[Le];
                                if (Eo) {
                                    let Yo = new s.P(0,0)
                                      , ko = !0;
                                    if (Eo.textBox || Eo.verticalTextBox) {
                                        if (j) {
                                            const Zo = this.variableOffsets[dt];
                                            Zo ? (Yo = Xc(Zo.anchor, Zo.width, Zo.height, Zo.textOffset, Zo.textScale),
                                            Y && Yo._rotate(K ? this.transform.angle : -this.transform.angle)) : ko = !1
                                        }
                                        R && (ko = !wt.clipped),
                                        Eo.textBox && el(t.textCollisionBox.collisionVertexArray, wt.text.placed, !ko || bo, ut, Te, Yo.x, Yo.y),
                                        Eo.verticalTextBox && el(t.textCollisionBox.collisionVertexArray, wt.text.placed, !ko || oo, ut, Te, Yo.x, Yo.y)
                                    }
                                    const Uo = ko && !(oo || !Eo.verticalIconBox);
                                    Eo.iconBox && el(t.iconCollisionBox.collisionVertexArray, wt.icon.placed, Uo, ut, Te, Ge.hasIconTextFit ? Yo.x : 0, Ge.hasIconTextFit ? Yo.y : 0),
                                    Eo.verticalIconBox && el(t.iconCollisionBox.collisionVertexArray, wt.icon.placed, !Uo, ut, Te, Ge.hasIconTextFit ? Yo.x : 0, Ge.hasIconTextFit ? Yo.y : 0)
                                }
                            }
                        }
                        if (t.fullyClipped = 0 === ke,
                        t.sortFeatures(this.transform.angle),
                        this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder),
                        t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray),
                        t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray),
                        t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray),
                        t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray),
                        t.bucketInstanceId in this.collisionCircleArrays) {
                            const Le = this.collisionCircleArrays[t.bucketInstanceId];
                            t.placementInvProjMatrix = Le.invProjMatrix,
                            t.placementViewportMatrix = Le.viewportMatrix,
                            t.collisionCircleArray = Le.circles,
                            delete this.collisionCircleArrays[t.bucketInstanceId]
                        }
                    }
                    symbolFadeChange(t) {
                        return 0 === this.fadeDuration ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
                    }
                    zoomAdjustment(t) {
                        return Math.max(0, (this.transform.zoom - t) / 1.5)
                    }
                    hasTransitions(t) {
                        return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration
                    }
                    stillRecent(t, i) {
                        const h = this.zoomAtLastRecencyCheck === i ? 1 - this.zoomAdjustment(i) : 1;
                        return this.zoomAtLastRecencyCheck = i,
                        this.commitTime + this.fadeDuration * h > t
                    }
                    setStale() {
                        this.stale = !0
                    }
                }
                function el(c, t, i, h, d, m, y) {
                    c.emplaceBack(t ? 1 : 0, i ? 1 : 0, m || 0, y || 0, h, d ? 1 : 0),
                    c.emplaceBack(t ? 1 : 0, i ? 1 : 0, m || 0, y || 0, h, d ? 1 : 0),
                    c.emplaceBack(t ? 1 : 0, i ? 1 : 0, m || 0, y || 0, h, d ? 1 : 0),
                    c.emplaceBack(t ? 1 : 0, i ? 1 : 0, m || 0, y || 0, h, d ? 1 : 0)
                }
                const tl = Math.pow(2, 25)
                  , Yc = Math.pow(2, 24)
                  , Ta = Math.pow(2, 17)
                  , iu = Math.pow(2, 16)
                  , nu = Math.pow(2, 9)
                  , Ca = Math.pow(2, 8)
                  , Ea = Math.pow(2, 1);
                function Zc(c) {
                    if (0 === c.opacity && !c.placed)
                        return 0;
                    if (1 === c.opacity && c.placed)
                        return 4294967295;
                    const t = c.placed ? 1 : 0
                      , i = Math.floor(127 * c.opacity);
                    return i * tl + t * Yc + i * Ta + t * iu + i * nu + t * Ca + i * Ea + t
                }
                const vr = 0;
                class Kc {
                    constructor(t) {
                        this._sortAcrossTiles = "viewport-y" !== t.layout.get("symbol-z-order") && void 0 !== t.layout.get("symbol-sort-key").constantOr(1),
                        this._currentTileIndex = 0,
                        this._currentPartIndex = 0,
                        this._seenCrossTileIDs = new Set,
                        this._bucketParts = []
                    }
                    continuePlacement(t, i, h, d, m, y) {
                        const M = this._bucketParts;
                        for (; this._currentTileIndex < t.length; )
                            if (i.getBucketParts(M, d, t[this._currentTileIndex], this._sortAcrossTiles, y),
                            this._currentTileIndex++,
                            m())
                                return !0;
                        for (this._sortAcrossTiles && (this._sortAcrossTiles = !1,
                        M.sort( (E, S) => E.sortKey - S.sortKey)); this._currentPartIndex < M.length; ) {
                            const E = M[this._currentPartIndex];
                            if (i.placeLayerBucketPart(E, this._seenCrossTileIDs, h, 0 === E.symbolInstanceStart, y),
                            this._currentPartIndex++,
                            m())
                                return !0
                        }
                        return !1
                    }
                }
                class ol {
                    constructor(t, i, h, d, m, y, M, E, S) {
                        this.placement = new nr(t,m,y,M,E,S),
                        this._currentPlacementIndex = i.length - 1,
                        this._forceFullPlacement = h,
                        this._showCollisionBoxes = d,
                        this._done = !1
                    }
                    isDone() {
                        return this._done
                    }
                    continuePlacement(t, i, h, d, m) {
                        const y = s.q.now()
                          , M = () => {
                            const E = s.q.now() - y;
                            return !this._forceFullPlacement && E > 2
                        }
                        ;
                        for (; this._currentPlacementIndex >= 0; ) {
                            const E = i[t[this._currentPlacementIndex]]
                              , S = this.placement.collisionIndex.transform.zoom;
                            if ("symbol" === E.type && (!E.minzoom || E.minzoom <= S) && (!E.maxzoom || E.maxzoom > S)) {
                                const I = E
                                  , R = I.layout.get("symbol-z-elevate")
                                  , D = void 0 !== I.layout.get("symbol-sort-key").constantOr(1)
                                  , k = I.layout.get("symbol-z-order")
                                  , H = "viewport-y" === k || "auto" === k && !("viewport-y" !== k && D)
                                  , j = I.layout.get("text-allow-overlap") || I.layout.get("icon-allow-overlap") || I.layout.get("text-ignore-placement") || I.layout.get("icon-ignore-placement")
                                  , Y = H && j
                                  , K = this._inProgressLayer = this._inProgressLayer || new Kc(I)
                                  , he = s.aC(E.source, E.scope);
                                if (K.continuePlacement(R || Y ? d[he] : h[he], this.placement, this._showCollisionBoxes, E, M, m))
                                    return;
                                delete this._inProgressLayer
                            }
                            this._currentPlacementIndex--
                        }
                        this._done = !0
                    }
                    commit(t) {
                        return this.placement.commit(t),
                        this.placement
                    }
                }
                const kr = 512 / s.ag / 2;
                class qc {
                    constructor(t, i, h) {
                        this.tileID = t,
                        this.bucketInstanceId = h,
                        this.index = new s.bE(i.length,16,Int32Array),
                        this.keys = [],
                        this.crossTileIDs = [];
                        const d = t.canonical.x * s.ag
                          , m = t.canonical.y * s.ag;
                        for (let y = 0; y < i.length; y++) {
                            const {key: M, crossTileID: E, tileAnchorX: S, tileAnchorY: I} = i.get(y)
                              , R = Math.floor((d + S) * kr)
                              , D = Math.floor((m + I) * kr);
                            this.index.add(R, D),
                            this.keys.push(M),
                            this.crossTileIDs.push(E)
                        }
                        this.index.finish()
                    }
                    findMatches(t, i, h) {
                        const d = this.tileID.canonical.z < i.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i.canonical.z)
                          , m = kr / Math.pow(2, i.canonical.z - this.tileID.canonical.z)
                          , y = i.canonical.x * s.ag
                          , M = i.canonical.y * s.ag;
                        for (let E = 0; E < t.length; E++) {
                            const S = t.get(E);
                            if (S.crossTileID)
                                continue;
                            const {key: I, tileAnchorX: R, tileAnchorY: D} = S
                              , k = Math.floor((y + R) * m)
                              , H = Math.floor((M + D) * m)
                              , j = this.index.range(k - d, H - d, k + d, H + d);
                            for (const Y of j) {
                                const K = this.crossTileIDs[Y];
                                if (this.keys[Y] === I && !h.has(K)) {
                                    h.add(K),
                                    S.crossTileID = K;
                                    break
                                }
                            }
                        }
                    }
                }
                class Jc {
                    constructor() {
                        this.maxCrossTileID = 0
                    }
                    generate() {
                        return ++this.maxCrossTileID
                    }
                }
                class ru {
                    constructor() {
                        this.indexes = {},
                        this.usedCrossTileIDs = {},
                        this.lng = 0
                    }
                    handleWrapJump(t) {
                        const i = Math.round((t - this.lng) / 360);
                        if (0 !== i)
                            for (const h in this.indexes) {
                                const d = this.indexes[h]
                                  , m = {};
                                for (const y in d) {
                                    const M = d[y];
                                    M.tileID = M.tileID.unwrapTo(M.tileID.wrap + i),
                                    m[M.tileID.key] = M
                                }
                                this.indexes[h] = m
                            }
                        this.lng = t
                    }
                    addBucket(t, i, h) {
                        if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) {
                            if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === i.bucketInstanceId)
                                return !1;
                            this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key])
                        }
                        for (let m = 0; m < i.symbolInstances.length; m++)
                            i.symbolInstances.get(m).crossTileID = 0;
                        this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = new Set);
                        const d = this.usedCrossTileIDs[t.overscaledZ];
                        for (const m in this.indexes) {
                            const y = this.indexes[m];
                            if (Number(m) > t.overscaledZ)
                                for (const M in y) {
                                    const E = y[M];
                                    E.tileID.isChildOf(t) && E.findMatches(i.symbolInstances, t, d)
                                }
                            else {
                                const M = y[t.scaledTo(Number(m)).key];
                                M && M.findMatches(i.symbolInstances, t, d)
                            }
                        }
                        for (let m = 0; m < i.symbolInstances.length; m++) {
                            const y = i.symbolInstances.get(m);
                            y.crossTileID || (y.crossTileID = h.generate(),
                            d.add(y.crossTileID))
                        }
                        return void 0 === this.indexes[t.overscaledZ] && (this.indexes[t.overscaledZ] = {}),
                        this.indexes[t.overscaledZ][t.key] = new qc(t,i.symbolInstances,i.bucketInstanceId),
                        !0
                    }
                    removeBucketCrossTileIDs(t, i) {
                        for (const h of i.crossTileIDs)
                            this.usedCrossTileIDs[t].delete(h)
                    }
                    removeStaleBuckets(t) {
                        let i = !1;
                        for (const h in this.indexes) {
                            const d = this.indexes[h];
                            for (const m in d)
                                t[d[m].bucketInstanceId] || (this.removeBucketCrossTileIDs(h, d[m]),
                                delete d[m],
                                i = !0)
                        }
                        return i
                    }
                }
                class Yl {
                    constructor() {
                        this.layerIndexes = {},
                        this.crossTileIDs = new Jc,
                        this.maxBucketInstanceId = 0,
                        this.bucketsInCurrentPlacement = {}
                    }
                    addLayer(t, i, h, d) {
                        let m = this.layerIndexes[t.fqid];
                        void 0 === m && (m = this.layerIndexes[t.fqid] = new ru);
                        let y = !1;
                        const M = {};
                        "globe" !== d.name && m.handleWrapJump(h);
                        for (const E of i) {
                            const S = E.getBucket(t);
                            S && t.fqid === S.layerIds[0] && (S.bucketInstanceId || (S.bucketInstanceId = ++this.maxBucketInstanceId),
                            m.addBucket(E.tileID, S, this.crossTileIDs) && (y = !0),
                            M[S.bucketInstanceId] = !0)
                        }
                        return m.removeStaleBuckets(M) && (y = !0),
                        y
                    }
                    pruneUnusedLayers(t) {
                        const i = {};
                        t.forEach(h => {
                            i[h] = !0
                        }
                        );
                        for (const h in this.layerIndexes)
                            i[h] || delete this.layerIndexes[h]
                    }
                }
                class si {
                    constructor(t, i, h, d) {
                        this.blendFunction = t,
                        this.blendColor = i,
                        this.mask = h,
                        this.blendEquation = d
                    }
                }
                si.Replace = [1, 0, 1, 0],
                si.disabled = new si(si.Replace,s.aj.transparent,[!1, !1, !1, !1]),
                si.unblended = new si(si.Replace,s.aj.transparent,[!0, !0, !0, !0]),
                si.alphaBlended = new si([1, 771, 1, 771],s.aj.transparent,[!0, !0, !0, !0]),
                si.alphaBlendedNonPremultiplied = new si([770, 771, 770, 771],s.aj.transparent,[!0, !0, !0, !0]),
                si.multiply = new si([774, 0, 774, 0],s.aj.transparent,[!0, !0, !0, !0]);
                class Fo {
                    constructor(t, i, h) {
                        this.func = t,
                        this.mask = i,
                        this.range = h
                    }
                }
                Fo.ReadOnly = !1,
                Fo.ReadWrite = !0,
                Fo.disabled = new Fo(519,Fo.ReadOnly,[0, 1]);
                class Xo {
                    constructor(t, i, h, d, m, y) {
                        this.test = t,
                        this.ref = i,
                        this.mask = h,
                        this.fail = d,
                        this.depthFail = m,
                        this.pass = y
                    }
                }
                Xo.disabled = new Xo({
                    func: 519,
                    mask: 0
                },0,0,7680,7680,7680);
                class zo {
                    constructor(t, i, h) {
                        this.enable = t,
                        this.mode = i,
                        this.frontFace = h
                    }
                }
                function vn(c, t) {
                    const i = s.bG(c, 3);
                    s.ab.mat4.fromQuat(c, t),
                    s.bI(c, 3, i)
                }
                function nl(c, t) {
                    const i = s.ab.quat.identity([]);
                    return s.ab.quat.rotateZ(i, i, -t),
                    s.ab.quat.rotateX(i, i, -c),
                    i
                }
                function Qs(c, t) {
                    const i = [c[0], c[1], 0]
                      , h = [t[0], t[1], 0];
                    if (s.ab.vec3.length(i) >= 1e-15) {
                        const y = s.ab.vec3.normalize([], i);
                        s.ab.vec3.scale(h, y, s.ab.vec3.dot(h, y)),
                        t[0] = h[0],
                        t[1] = h[1]
                    }
                    const d = s.ab.vec3.cross([], t, c);
                    if (s.ab.vec3.len(d) < 1e-15)
                        return null;
                    const m = Math.atan2(-d[1], d[0]);
                    return nl(Math.atan2(Math.sqrt(c[0] * c[0] + c[1] * c[1]), -c[2]), m)
                }
                zo.disabled = new zo(!1,1029,2305),
                zo.backCCW = new zo(!0,1029,2305),
                zo.backCW = new zo(!0,1029,2304),
                zo.frontCW = new zo(!0,1028,2304),
                zo.frontCCW = new zo(!0,1028,2305);
                class Cs {
                    constructor(t, i) {
                        this.position = t,
                        this.orientation = i
                    }
                    get position() {
                        return this._position
                    }
                    set position(t) {
                        if (t) {
                            const i = t instanceof s.aa ? t : new s.aa(t[0],t[1],t[2]);
                            this._renderWorldCopies && (i.x = s.bF(i.x, 0, 1)),
                            this._position = i
                        } else
                            this._position = null
                    }
                    lookAtPoint(t, i) {
                        if (this.orientation = null,
                        !this.position)
                            return;
                        const h = this.position
                          , d = this._elevation ? this._elevation.getAtPointOrZero(s.aa.fromLngLat(t)) : 0
                          , m = s.aa.fromLngLat(t, d)
                          , y = [m.x - h.x, m.y - h.y, m.z - h.z];
                        i || (i = [0, 0, 1]),
                        i[2] = Math.abs(i[2]),
                        this.orientation = Qs(y, i)
                    }
                    setPitchBearing(t, i) {
                        this.orientation = nl(s.ai(t), s.ai(-i))
                    }
                }
                class ea {
                    constructor(t, i) {
                        this._transform = s.ab.mat4.identity([]),
                        this.orientation = i,
                        this.position = t
                    }
                    get mercatorPosition() {
                        const t = this.position;
                        return new s.aa(t[0],t[1],t[2])
                    }
                    get position() {
                        const t = s.bG(this._transform, 3);
                        return [t[0], t[1], t[2]]
                    }
                    set position(t) {
                        var i;
                        t && s.bI(this._transform, 3, [(i = t)[0], i[1], i[2], 1])
                    }
                    get orientation() {
                        return this._orientation
                    }
                    set orientation(t) {
                        this._orientation = t || s.ab.quat.identity([]),
                        t && vn(this._transform, this._orientation)
                    }
                    getPitchBearing() {
                        const t = this.forward()
                          , i = this.right();
                        return {
                            bearing: Math.atan2(-i[1], i[0]),
                            pitch: Math.atan2(Math.sqrt(t[0] * t[0] + t[1] * t[1]), -t[2])
                        }
                    }
                    setPitchBearing(t, i) {
                        this._orientation = nl(t, i),
                        vn(this._transform, this._orientation)
                    }
                    forward() {
                        const t = s.bG(this._transform, 2);
                        return [-t[0], -t[1], -t[2]]
                    }
                    up() {
                        const t = s.bG(this._transform, 1);
                        return [-t[0], -t[1], -t[2]]
                    }
                    right() {
                        const t = s.bG(this._transform, 0);
                        return [t[0], t[1], t[2]]
                    }
                    getCameraToWorld(t, i) {
                        const h = new Float64Array(16);
                        return s.ab.mat4.invert(h, this.getWorldToCamera(t, i)),
                        h
                    }
                    getCameraToWorldMercator() {
                        return this._transform
                    }
                    getWorldToCameraPosition(t, i, h) {
                        const d = this.position;
                        s.ab.vec3.scale(d, d, -t);
                        const m = new Float64Array(16);
                        return s.ab.mat4.fromScaling(m, [h, h, h]),
                        s.ab.mat4.translate(m, m, d),
                        m[10] *= i,
                        m
                    }
                    getWorldToCamera(t, i) {
                        const h = new Float64Array(16)
                          , d = new Float64Array(4)
                          , m = this.position;
                        return s.ab.quat.conjugate(d, this._orientation),
                        s.ab.vec3.scale(m, m, -t),
                        s.ab.mat4.fromQuat(h, d),
                        s.ab.mat4.translate(h, h, m),
                        h[1] *= -1,
                        h[5] *= -1,
                        h[9] *= -1,
                        h[13] *= -1,
                        h[8] *= i,
                        h[9] *= i,
                        h[10] *= i,
                        h[11] *= i,
                        h
                    }
                    getCameraToClipPerspective(t, i, h, d) {
                        const m = new Float64Array(16);
                        return s.ab.mat4.perspective(m, t, i, h, d),
                        m
                    }
                    getCameraToClipOrthographic(t, i, h, d, m, y) {
                        const M = new Float64Array(16);
                        return s.ab.mat4.ortho(M, t, i, h, d, m, y),
                        M
                    }
                    getDistanceToElevation(t, i=!1) {
                        const h = 0 === t ? 0 : s.bH(t, i ? s.aS(this.position[1]) : this.position[1])
                          , d = this.forward();
                        return (h - this.position[2]) / d[2]
                    }
                    clone() {
                        return new ea([...this.position],[...this.orientation])
                    }
                }
                const wn_BaseColor = 5
                  , wn_MetallicRoughness = 6
                  , wn_Normal = 7
                  , wn_Occlusion = 8
                  , wn_Emission = 9
                  , wn_LUT = 10
                  , wn_ShadowMap0 = 11;
                class Kn {
                    constructor(t=0, i=0, h=0, d=0) {
                        if (isNaN(t) || t < 0 || isNaN(i) || i < 0 || isNaN(h) || h < 0 || isNaN(d) || d < 0)
                            throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
                        this.top = t,
                        this.bottom = i,
                        this.left = h,
                        this.right = d
                    }
                    interpolate(t, i, h) {
                        return null != i.top && null != t.top && (this.top = s.af(t.top, i.top, h)),
                        null != i.bottom && null != t.bottom && (this.bottom = s.af(t.bottom, i.bottom, h)),
                        null != i.left && null != t.left && (this.left = s.af(t.left, i.left, h)),
                        null != i.right && null != t.right && (this.right = s.af(t.right, i.right, h)),
                        this
                    }
                    getCenter(t, i) {
                        const h = s.aw((this.left + t - this.right) / 2, 0, t)
                          , d = s.aw((this.top + i - this.bottom) / 2, 0, i);
                        return new s.P(h,d)
                    }
                    equals(t) {
                        return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right
                    }
                    clone() {
                        return new Kn(this.top,this.bottom,this.left,this.right)
                    }
                    toJSON() {
                        return {
                            top: this.top,
                            bottom: this.bottom,
                            left: this.left,
                            right: this.right
                        }
                    }
                }
                const rl = (c, t, i) => (1 - i) * c + i * t
                  , uo = c => c * c * c * c * c;
                class sl {
                    constructor(t, i, h, d, m, y, M) {
                        this.tileSize = 512,
                        this._renderWorldCopies = void 0 === m || m,
                        this._minZoom = t || 0,
                        this._maxZoom = i || 22,
                        this._minPitch = null != h ? h : 0,
                        this._maxPitch = null != d ? d : 60,
                        this.setProjection(y),
                        this.setMaxBounds(M),
                        this.width = 0,
                        this.height = 0,
                        this._center = new s.bO(0,0),
                        this.zoom = 0,
                        this.angle = 0,
                        this._fov = .6435011087932844,
                        this._pitch = 0,
                        this._nearZ = 0,
                        this._farZ = 0,
                        this._unmodified = !0,
                        this._edgeInsets = new Kn,
                        this._projMatrixCache = {},
                        this._alignedProjMatrixCache = {},
                        this._fogTileMatrixCache = {},
                        this._expandedProjMatrixCache = {},
                        this._distanceTileDataCache = {},
                        this._camera = new ea,
                        this._centerAltitude = 0,
                        this._averageElevation = 0,
                        this.cameraElevationReference = "ground",
                        this._pixelsPerMercatorPixel = 1,
                        this.globeRadius = 0,
                        this.globeCenterInViewSpace = [0, 0, 0],
                        this._tileCoverLift = 0,
                        this.freezeTileCoverage = !1,
                        this._horizonShift = .1,
                        this._orthographicProjectionAtLowPitch = !1
                    }
                    clone() {
                        const t = new sl(this._minZoom,this._maxZoom,this._minPitch,this.maxPitch,this._renderWorldCopies,this.getProjection());
                        return t._elevation = this._elevation,
                        t._centerAltitude = this._centerAltitude,
                        t._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration,
                        t.tileSize = this.tileSize,
                        t.mercatorFromTransition = this.mercatorFromTransition,
                        t.width = this.width,
                        t.height = this.height,
                        t.cameraElevationReference = this.cameraElevationReference,
                        t._center = this._center,
                        t._setZoom(this.zoom),
                        t._seaLevelZoom = this._seaLevelZoom,
                        t.angle = this.angle,
                        t._fov = this._fov,
                        t._pitch = this._pitch,
                        t._nearZ = this._nearZ,
                        t._farZ = this._farZ,
                        t._averageElevation = this._averageElevation,
                        t._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch,
                        t._unmodified = this._unmodified,
                        t._edgeInsets = this._edgeInsets.clone(),
                        t._camera = this._camera.clone(),
                        t._calcMatrices(),
                        t.freezeTileCoverage = this.freezeTileCoverage,
                        t.frustumCorners = this.frustumCorners,
                        t
                    }
                    get isOrthographic() {
                        return "globe" !== this.projection.name && this._orthographicProjectionAtLowPitch && this.pitch < 15
                    }
                    get elevation() {
                        return this._elevation
                    }
                    set elevation(t) {
                        this._elevation !== t && (this._elevation = t,
                        this._updateCameraOnTerrain(),
                        this._calcMatrices())
                    }
                    get depthOcclusionForSymbolsAndCircles() {
                        return "globe" !== this.projection.name && !this.isOrthographic
                    }
                    updateElevation(t, i=!1) {
                        const h = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
                        (null == this._seaLevelZoom || h) && this._updateCameraOnTerrain(),
                        (t || h) && this._constrainCamera(i),
                        this._calcMatrices()
                    }
                    getProjection() {
                        return s.ay(this.projection, ["name", "center", "parallels"])
                    }
                    setProjection(t) {
                        this.projectionOptions = t || {
                            name: "mercator"
                        };
                        const i = this.projection ? this.getProjection() : void 0;
                        this.projection = s.bP(this.projectionOptions);
                        const h = this.getProjection()
                          , d = !s.bn(i, h);
                        return d && this._calcMatrices(),
                        this.mercatorFromTransition = !1,
                        d
                    }
                    setOrthographicProjectionAtLowPitch(t) {
                        return this._orthographicProjectionAtLowPitch !== t && (this._orthographicProjectionAtLowPitch = t,
                        this._calcMatrices(),
                        !0)
                    }
                    setMercatorFromTransition() {
                        const t = this.projection.name;
                        this.mercatorFromTransition = !0,
                        this.projectionOptions = {
                            name: "mercator"
                        },
                        this.projection = s.bP({
                            name: "mercator"
                        });
                        const i = t !== this.projection.name;
                        return i && this._calcMatrices(),
                        i
                    }
                    get minZoom() {
                        return this._minZoom
                    }
                    set minZoom(t) {
                        this._minZoom !== t && (this._minZoom = t,
                        this.zoom = Math.max(this.zoom, t))
                    }
                    get maxZoom() {
                        return this._maxZoom
                    }
                    set maxZoom(t) {
                        this._maxZoom !== t && (this._maxZoom = t,
                        this.zoom = Math.min(this.zoom, t))
                    }
                    get minPitch() {
                        return this._minPitch
                    }
                    set minPitch(t) {
                        this._minPitch !== t && (this._minPitch = t,
                        this.pitch = Math.max(this.pitch, t))
                    }
                    get maxPitch() {
                        return this._maxPitch
                    }
                    set maxPitch(t) {
                        this._maxPitch !== t && (this._maxPitch = t,
                        this.pitch = Math.min(this.pitch, t))
                    }
                    get renderWorldCopies() {
                        return this._renderWorldCopies && !0 === this.projection.supportsWorldCopies
                    }
                    set renderWorldCopies(t) {
                        void 0 === t ? t = !0 : null === t && (t = !1),
                        this._renderWorldCopies = t
                    }
                    get worldSize() {
                        return this.tileSize * this.scale
                    }
                    get cameraWorldSizeForFog() {
                        const t = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
                        return this._worldSizeFromZoom(this._zoomFromMercatorZ(t))
                    }
                    get cameraWorldSize() {
                        const t = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);
                        return this._worldSizeFromZoom(this._zoomFromMercatorZ(t))
                    }
                    get pixelsPerMeter() {
                        return this.projection.pixelsPerMeter(this.center.lat, this.worldSize)
                    }
                    get cameraPixelsPerMeter() {
                        return s.bH(1, this.center.lat) * this.cameraWorldSizeForFog
                    }
                    get centerOffset() {
                        return this.centerPoint._sub(this.size._div(2))
                    }
                    get size() {
                        return new s.P(this.width,this.height)
                    }
                    get bearing() {
                        return s.bF(this.rotation, -180, 180)
                    }
                    set bearing(t) {
                        this.rotation = t
                    }
                    get rotation() {
                        return -this.angle / Math.PI * 180
                    }
                    set rotation(t) {
                        const i = -t * Math.PI / 180;
                        this.angle !== i && (this._unmodified = !1,
                        this.angle = i,
                        this._calcMatrices(),
                        this.rotationMatrix = s.ab.mat2.create(),
                        s.ab.mat2.rotate(this.rotationMatrix, this.rotationMatrix, this.angle))
                    }
                    get pitch() {
                        return this._pitch / Math.PI * 180
                    }
                    set pitch(t) {
                        const i = s.aw(t, this.minPitch, this.maxPitch) / 180 * Math.PI;
                        this._pitch !== i && (this._unmodified = !1,
                        this._pitch = i,
                        this._calcMatrices())
                    }
                    get aspect() {
                        return this.width / this.height
                    }
                    get fov() {
                        return this._fov / Math.PI * 180
                    }
                    get fovX() {
                        return this._fov
                    }
                    get fovY() {
                        const t = 1 / Math.tan(.5 * this.fovX);
                        return 2 * Math.atan(1 / this.aspect / t)
                    }
                    set fov(t) {
                        t = Math.max(.01, Math.min(60, t)),
                        this._fov !== t && (this._unmodified = !1,
                        this._fov = s.ai(t),
                        this._calcMatrices())
                    }
                    get averageElevation() {
                        return this._averageElevation
                    }
                    set averageElevation(t) {
                        this._averageElevation = t,
                        this._calcFogMatrices(),
                        this._distanceTileDataCache = {}
                    }
                    get zoom() {
                        return this._zoom
                    }
                    set zoom(t) {
                        const i = Math.min(Math.max(t, this.minZoom), this.maxZoom);
                        this._zoom !== i && (this._unmodified = !1,
                        this._setZoom(i),
                        this._updateSeaLevelZoom(),
                        this._constrain(),
                        this._calcMatrices())
                    }
                    _setZoom(t) {
                        this._zoom = t,
                        this.scale = this.zoomScale(t),
                        this.tileZoom = Math.floor(t),
                        this.zoomFraction = t - this.tileZoom
                    }
                    get tileCoverLift() {
                        return this._tileCoverLift
                    }
                    set tileCoverLift(t) {
                        this._tileCoverLift !== t && (this._tileCoverLift = t)
                    }
                    _updateCameraOnTerrain() {
                        const t = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY
                          , i = this.elevation && t === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;
                        if (!this._elevation || t === Number.NEGATIVE_INFINITY && (!i || !this._centerAltitude))
                            return this._centerAltitude = 0,
                            this._seaLevelZoom = null,
                            void (this._centerAltitudeValidForExaggeration = void 0);
                        const h = this._elevation;
                        i || this._centerAltitude && this._centerAltitudeValidForExaggeration && h.exaggeration() && this._centerAltitudeValidForExaggeration !== h.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * h.exaggeration(),
                        this._centerAltitudeValidForExaggeration = h.exaggeration()) : (this._centerAltitude = t || 0,
                        this._centerAltitudeValidForExaggeration = h.exaggeration()),
                        this._updateSeaLevelZoom()
                    }
                    _updateSeaLevelZoom() {
                        void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize))
                    }
                    sampleAverageElevation() {
                        if (!this._elevation)
                            return 0;
                        const t = this._elevation
                          , i = [[.5, .2], [.3, .5], [.5, .5], [.7, .5], [.5, .8]]
                          , h = this.horizonLineFromTop();
                        let d = 0
                          , m = 0;
                        for (let y = 0; y < i.length; y++) {
                            const M = new s.P(i[y][0] * this.width,h + i[y][1] * (this.height - h))
                              , E = t.pointCoordinate(M);
                            if (!E)
                                continue;
                            const S = 1 / Math.hypot(E[0] - this._camera.position[0], E[1] - this._camera.position[1]);
                            d += E[3] * S,
                            m += S
                        }
                        return 0 === m ? NaN : d / m
                    }
                    get center() {
                        return this._center
                    }
                    set center(t) {
                        t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = !1,
                        this._center = t,
                        this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()),
                        this._constrain(),
                        this._calcMatrices())
                    }
                    _updateZoomFromElevation() {
                        if (null == this._seaLevelZoom || !this._elevation)
                            return;
                        const t = this._seaLevelZoom
                          , i = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center))
                          , h = this.pixelsPerMeter / this.worldSize * i
                          , d = this._mercatorZfromZoom(t)
                          , m = this._mercatorZfromZoom(this._maxZoom)
                          , y = Math.max(d - h, m);
                        this._setZoom(this._zoomFromMercatorZ(y))
                    }
                    get padding() {
                        return this._edgeInsets.toJSON()
                    }
                    set padding(t) {
                        this._edgeInsets.equals(t) || (this._unmodified = !1,
                        this._edgeInsets.interpolate(this._edgeInsets, t, 1),
                        this._calcMatrices())
                    }
                    computeZoomRelativeTo(t) {
                        const i = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t.toAltitude()));
                        let h;
                        h = t.z < this._camera.position[2] ? [i.x, i.y, i.z] : [t.x, t.y, t.z];
                        const d = s.ab.vec3.length(s.ab.vec3.sub([], this._camera.position, h));
                        return s.aw(this._zoomFromMercatorZ(d), this._minZoom, this._maxZoom)
                    }
                    setFreeCameraOptions(t) {
                        if (!this.height || !t.position && !t.orientation)
                            return;
                        this._updateCameraState();
                        let i = !1;
                        if (t.orientation && !s.ab.quat.exactEquals(t.orientation, this._camera.orientation) && (i = this._setCameraOrientation(t.orientation)),
                        t.position) {
                            const h = [t.position.x, t.position.y, t.position.z];
                            s.ab.vec3.exactEquals(h, this._camera.position) || (this._setCameraPosition(h),
                            i = !0)
                        }
                        i && (this._updateStateFromCamera(),
                        this.recenterOnTerrain())
                    }
                    getFreeCameraOptions() {
                        this._updateCameraState();
                        const t = this._camera.position
                          , i = new Cs;
                        return i.position = new s.aa(t[0],t[1],t[2]),
                        i.orientation = this._camera.orientation,
                        i._elevation = this.elevation,
                        i._renderWorldCopies = this.renderWorldCopies,
                        i
                    }
                    _setCameraOrientation(t) {
                        if (!s.ab.quat.length(t))
                            return !1;
                        s.ab.quat.normalize(t, t);
                        const i = s.ab.vec3.transformQuat([], [0, 0, -1], t)
                          , h = s.ab.vec3.transformQuat([], [0, -1, 0], t);
                        if (h[2] < 0)
                            return !1;
                        const d = Qs(i, h);
                        return !!d && (this._camera.orientation = d,
                        !0)
                    }
                    _setCameraPosition(t) {
                        const i = this.zoomScale(this.minZoom) * this.tileSize
                          , h = this.zoomScale(this.maxZoom) * this.tileSize
                          , d = this.cameraToCenterDistance;
                        t[2] = s.aw(t[2], d / h, d / i),
                        this._camera.position = t
                    }
                    get centerPoint() {
                        return this._edgeInsets.getCenter(this.width, this.height)
                    }
                    get fovAboveCenter() {
                        return this._fov * (.5 + this.centerOffset.y / this.height)
                    }
                    isPaddingEqual(t) {
                        return this._edgeInsets.equals(t)
                    }
                    interpolatePadding(t, i, h) {
                        this._unmodified = !1,
                        this._edgeInsets.interpolate(t, i, h),
                        this._constrain(),
                        this._calcMatrices()
                    }
                    coveringZoomLevel(t) {
                        const i = (t.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t.tileSize));
                        return Math.max(0, i)
                    }
                    getVisibleUnwrappedCoordinates(t) {
                        const i = [new s.bQ(0,t)];
                        if (this.renderWorldCopies) {
                            const h = this.pointCoordinate(new s.P(0,0))
                              , d = this.pointCoordinate(new s.P(this.width,0))
                              , m = this.pointCoordinate(new s.P(this.width,this.height))
                              , y = this.pointCoordinate(new s.P(0,this.height))
                              , M = Math.floor(Math.min(h.x, d.x, m.x, y.x))
                              , E = Math.floor(Math.max(h.x, d.x, m.x, y.x))
                              , S = 1;
                            for (let I = M - S; I <= E + S; I++)
                                0 !== I && i.push(new s.bQ(I,t))
                        }
                        return i
                    }
                    isLODDisabled(t) {
                        return (!t || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace
                    }
                    extendTileCover(t, i, h) {
                        let d = [];
                        const m = void 0 !== h
                          , y = !m;
                        if (y && this.zoom < i || m && 0 === h[0] && 0 === h[1])
                            return d;
                        const M = new Set
                          , E = (I, R, D, k, H) => {
                            const j = s.c5(R, I, D, k, H);
                            M.has(j) || (d.push(new s.aG(I,R,D,k,H)),
                            M.add(j))
                        }
                        ;
                        for (let I = 0; I < t.length; I++) {
                            const R = t[I];
                            if (y && R.canonical.z !== i)
                                continue;
                            const D = R.canonical
                              , k = R.overscaledZ
                              , H = R.wrap
                              , j = 1 << D.z
                              , Y = D.x + 1 < j
                              , K = D.x > 0
                              , he = D.y + 1 < j
                              , Te = D.y > 0
                              , be = R.wrap - (K ? 0 : 1)
                              , Ue = R.wrap + (Y ? 0 : 1)
                              , De = K ? D.x - 1 : j - 1
                              , ke = Y ? D.x + 1 : 0;
                            if (m)
                                h[0] < 0 ? (E(k, Ue, D.z, ke, D.y),
                                h[1] < 0 && he && (E(k, H, D.z, D.x, D.y + 1),
                                E(k, Ue, D.z, ke, D.y + 1)),
                                h[1] > 0 && Te && (E(k, H, D.z, D.x, D.y - 1),
                                E(k, Ue, D.z, ke, D.y - 1))) : h[0] > 0 ? (E(k, be, D.z, De, D.y),
                                h[1] < 0 && he && (E(k, H, D.z, D.x, D.y + 1),
                                E(k, be, D.z, De, D.y + 1)),
                                h[1] > 0 && Te && (E(k, H, D.z, D.x, D.y - 1),
                                E(k, be, D.z, De, D.y - 1))) : h[1] < 0 && he ? E(k, H, D.z, D.x, D.y + 1) : Te && E(k, H, D.z, D.x, D.y - 1);
                            else {
                                const Le = R.visibleQuadrants;
                                1 & Le && (E(k, be, D.z, De, D.y),
                                Te && (E(k, H, D.z, D.x, D.y - 1),
                                E(k, be, D.z, De, D.y - 1))),
                                2 & Le && (E(k, Ue, D.z, ke, D.y),
                                Te && (E(k, H, D.z, D.x, D.y - 1),
                                E(k, Ue, D.z, ke, D.y - 1))),
                                4 & Le && (E(k, be, D.z, De, D.y),
                                he && (E(k, H, D.z, D.x, D.y + 1),
                                E(k, be, D.z, De, D.y + 1))),
                                8 & Le && (E(k, Ue, D.z, ke, D.y),
                                he && (E(k, H, D.z, D.x, D.y + 1),
                                E(k, Ue, D.z, ke, D.y + 1)))
                            }
                        }
                        const S = [];
                        for (const I of d)
                            d.some(R => I.isChildOf(R)) || S.push(I);
                        if (d = S.filter(I => !t.some(R => !!(I.overscaledZ < i && R.isChildOf(I)) || I.equals(R) || I.isChildOf(R))),
                        y) {
                            const I = 1 << i
                              , R = "globe" === this.projection.name ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint())
                              , D = [I * R.x, I * R.y]
                              , k = 4
                              , H = k * k;
                            d = d.filter(j => {
                                const Y = j.canonical.x + .5 - D[0]
                                  , K = j.canonical.y + .5 - D[1];
                                return Y * Y + K * K < H
                            }
                            )
                        }
                        return d
                    }
                    coveringTiles(t) {
                        let i = this.coveringZoomLevel(t);
                        const h = i
                          , d = this.elevation && this.elevation.exaggeration()
                          , m = d && !t.isTerrainDEM
                          , y = "mercator" === this.projection.name;
                        if (void 0 !== t.minzoom && i < t.minzoom)
                            return [];
                        void 0 !== t.maxzoom && i > t.maxzoom && (i = t.maxzoom);
                        const M = this.locationCoordinate(this.center)
                          , E = this.center.lat
                          , S = 1 << i
                          , I = [S * M.x, S * M.y, 0]
                          , R = "globe" === this.projection.name
                          , D = !R
                          , k = s.bR.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i, D)
                          , H = R ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint())
                          , j = S * s.bH(1, this.center.lat)
                          , Y = this._camera.position[2] / s.bH(1, this.center.lat)
                          , K = [S * H.x, S * H.y, Y * (D ? 1 : j)]
                          , he = R || d
                          , Te = this.cameraToCenterDistance / t.tileSize * (t.roundZoom ? 1 : .502)
                          , be = this.isLODDisabled(!0) ? i : 0;
                        let Ue;
                        if (this._elevation && t.isTerrainDEM)
                            Ue = 1e4 * this._elevation.exaggeration();
                        else if (this._elevation) {
                            const ut = this._elevation.getMinMaxForVisibleTiles();
                            Ue = ut ? ut.max : this._centerAltitude
                        } else
                            Ue = this._centerAltitude;
                        const De = t.isTerrainDEM ? -Ue : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0
                          , ke = this.projection.isReprojectedInTileSpace ? s.bS(this) : 1
                          , Le = ut => {
                            const wt = new s.aa(ut.x + 25e-6,ut.y,ut.z)
                              , qt = new s.aa(ut.x,ut.y + 25e-6,ut.z)
                              , Ht = ut.toLngLat()
                              , Dt = wt.toLngLat()
                              , bo = qt.toLngLat()
                              , oo = this.locationCoordinate(Ht)
                              , Po = this.locationCoordinate(Dt)
                              , Eo = this.locationCoordinate(bo)
                              , Yo = Math.hypot(Po.x - oo.x, Po.y - oo.y)
                              , ko = Math.hypot(Eo.x - oo.x, Eo.y - oo.y);
                            return Math.sqrt(Yo * ko) * ke / 25e-6
                        }
                          , Ge = ut => {
                            const Gt = Ue
                              , wt = De;
                            return {
                                aabb: s.bV(this, S, 0, 0, 0, ut, wt, Gt, this.projection),
                                zoom: 0,
                                x: 0,
                                y: 0,
                                minZ: wt,
                                maxZ: Gt,
                                wrap: ut,
                                fullyVisible: !1
                            }
                        }
                          , qe = [];
                        let vt = [];
                        const dt = i
                          , Ze = t.reparseOverscaled ? h : i
                          , nt = (Y - this._centerAltitude) * j
                          , zt = ut => {
                            if (!this._elevation || !ut.tileID || !y)
                                return;
                            const Gt = this._elevation.getMinMaxForTile(ut.tileID)
                              , wt = ut.aabb;
                            Gt ? (wt.min[2] = Gt.min,
                            wt.max[2] = Gt.max,
                            wt.center[2] = (wt.min[2] + wt.max[2]) / 2) : (ut.shouldSplit = to(ut),
                            ut.shouldSplit || (wt.min[2] = wt.max[2] = wt.center[2] = this._centerAltitude))
                        }
                          , Yt = (ut, Gt) => {
                            if (.707 * Gt < ut)
                                return 1;
                            const wt = Gt / ut;
                            return wt / (1.4144271570014144 + (Math.pow(1.1, wt - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1)
                        }
                          , to = ut => {
                            if (ut.zoom < be)
                                return !0;
                            if (ut.zoom === dt)
                                return !1;
                            if (null != ut.shouldSplit)
                                return ut.shouldSplit;
                            const Gt = ut.aabb.distanceX(K)
                              , wt = ut.aabb.distanceY(K);
                            let qt = nt
                              , Ht = 1;
                            if (R) {
                                qt = ut.aabb.distanceZ(K);
                                const ko = Math.pow(2, ut.zoom)
                                  , Uo = s.aS((ut.y + 1) / ko)
                                  , Zo = s.aS(ut.y / ko)
                                  , yi = Math.min(Math.max(E, Uo), Zo)
                                  , li = s.c9(yi) / s.c9(E);
                                if (Ht = yi === E ? 1 / Math.max(1, this._mercatorScaleRatio - .3) : Math.min(1, li / this._mercatorScaleRatio),
                                this.zoom <= s.c6 && ut.zoom === dt - 1 && li >= .9)
                                    return !0
                            } else if (m && (qt = ut.aabb.distanceZ(K) * j),
                            this.projection.isReprojectedInTileSpace && h <= 5) {
                                const ko = Math.pow(2, ut.zoom)
                                  , Uo = Le(new s.aa((ut.x + .5) / ko,(ut.y + .5) / ko));
                                Ht = Uo > .85 ? 1 : Uo
                            }
                            if (!y) {
                                const ko = Math.sqrt(Gt * Gt + wt * wt + qt * qt);
                                let Uo = (1 << dt - ut.zoom) * Te * Ht;
                                return Uo *= Yt(Math.max(qt, nt), ko),
                                ko < Uo
                            }
                            let Dt = Number.MAX_VALUE
                              , bo = 0;
                            const oo = ut.aabb.getCorners()
                              , Po = [];
                            for (const ko of oo) {
                                s.ab.vec3.sub(Po, ko, K),
                                R || (m ? Po[2] *= j : Po[2] = nt);
                                const Uo = s.ab.vec3.dot(Po, this._camera.forward());
                                Uo < Dt && (Dt = Uo,
                                bo = Math.abs(Po[2]))
                            }
                            let Eo = (1 << dt - ut.zoom) * Te * Ht;
                            if (Eo *= Yt(Math.max(bo, nt), Dt),
                            Dt < Eo)
                                return !0;
                            const Yo = ut.aabb.closestPoint(I);
                            return Yo[0] === I[0] && Yo[1] === I[1]
                        }
                        ;
                        if (this.renderWorldCopies)
                            for (let ut = 1; ut <= 3; ut++)
                                qe.push(Ge(-ut)),
                                qe.push(Ge(ut));
                        for (qe.push(Ge(0)); qe.length > 0; ) {
                            const ut = qe.pop()
                              , Gt = ut.x
                              , wt = ut.y;
                            let qt = ut.fullyVisible;
                            const Ht = () => "globe" === this.projection.name && (0 === ut.y || ut.y === (1 << ut.zoom) - 1);
                            if (!qt) {
                                let Dt = he ? ut.aabb.intersects(k) : ut.aabb.intersectsFlat(k);
                                if (0 === Dt && Ht()) {
                                    const bo = new s.bT(ut.zoom,Gt,wt);
                                    Dt = s.bU(this, S, bo, !0).intersects(k)
                                }
                                if (0 === Dt)
                                    continue;
                                qt = 2 === Dt
                            }
                            if (ut.zoom !== dt && to(ut))
                                for (let Dt = 0; Dt < 4; Dt++) {
                                    const bo = (Gt << 1) + Dt % 2
                                      , oo = (wt << 1) + (Dt >> 1)
                                      , Po = {
                                        aabb: y ? ut.aabb.quadrant(Dt) : s.bV(this, S, ut.zoom + 1, bo, oo, ut.wrap, ut.minZ, ut.maxZ, this.projection),
                                        zoom: ut.zoom + 1,
                                        x: bo,
                                        y: oo,
                                        wrap: ut.wrap,
                                        fullyVisible: qt,
                                        tileID: void 0,
                                        shouldSplit: void 0,
                                        minZ: ut.minZ,
                                        maxZ: ut.maxZ
                                    };
                                    m && !R && (Po.tileID = new s.aG(ut.zoom + 1 === dt ? Ze : ut.zoom + 1,ut.wrap,ut.zoom + 1,bo,oo),
                                    zt(Po)),
                                    qe.push(Po)
                                }
                            else {
                                const Dt = ut.zoom === dt ? Ze : ut.zoom;
                                if (t.minzoom && t.minzoom > Dt)
                                    continue;
                                let bo = 0;
                                if (!qt) {
                                    let Yo = he ? ut.aabb.intersectsPrecise(k) : ut.aabb.intersectsPreciseFlat(k);
                                    if (0 === Yo && Ht()) {
                                        const ko = new s.bT(ut.zoom,Gt,wt);
                                        Yo = s.bU(this, S, ko, !0).intersectsPrecise(k)
                                    }
                                    if (0 === Yo)
                                        continue;
                                    if (t.calculateQuadrantVisibility)
                                        if (k.containsPoint(ut.aabb.center))
                                            bo = 15;
                                        else
                                            for (let ko = 0; ko < 4; ko++)
                                                0 !== ut.aabb.quadrant(ko).intersects(k) && (bo |= 1 << ko)
                                }
                                const oo = I[0] - (.5 + Gt + (ut.wrap << ut.zoom)) * (1 << i - ut.zoom)
                                  , Po = I[1] - .5 - wt
                                  , Eo = ut.tileID ? ut.tileID : new s.aG(Dt,ut.wrap,ut.zoom,Gt,wt);
                                t.calculateQuadrantVisibility && (Eo.visibleQuadrants = bo),
                                vt.push({
                                    tileID: Eo,
                                    distanceSq: oo * oo + Po * Po
                                })
                            }
                        }
                        if (this.fogCullDistSq) {
                            const ut = this.fogCullDistSq
                              , Gt = this.horizonLineFromTop();
                            vt = vt.filter(wt => {
                                const qt = [0, 0, 0, 1]
                                  , Ht = [s.ag, s.ag, 0, 1]
                                  , Dt = this.calculateFogTileMatrix(wt.tileID.toUnwrapped());
                                s.ab.vec4.transformMat4(qt, qt, Dt),
                                s.ab.vec4.transformMat4(Ht, Ht, Dt);
                                const bo = s.ab.vec4.min([], qt, Ht)
                                  , oo = s.ab.vec4.max([], qt, Ht)
                                  , Po = s.bW(bo, oo);
                                if (0 === Po)
                                    return !0;
                                let Eo = !1;
                                const Yo = this._elevation;
                                if (Yo && Po > ut && 0 !== Gt) {
                                    const ko = this.calculateProjMatrix(wt.tileID.toUnwrapped());
                                    let Uo;
                                    t.isTerrainDEM || (Uo = Yo.getMinMaxForTile(wt.tileID)),
                                    Uo || (Uo = {
                                        min: De,
                                        max: Ue
                                    });
                                    const Zo = s.c7(this.rotation)
                                      , yi = [Zo[0] * s.ag, Zo[1] * s.ag, Uo.max];
                                    s.ab.vec3.transformMat4(yi, yi, ko),
                                    Eo = (1 - yi[1]) * this.height * .5 < Gt
                                }
                                return Po < ut || Eo
                            }
                            )
                        }
                        return vt.sort( (ut, Gt) => ut.distanceSq - Gt.distanceSq).map(ut => ut.tileID)
                    }
                    resize(t, i) {
                        this.width = t,
                        this.height = i,
                        this.pixelsToGLUnits = [2 / t, -2 / i],
                        this._constrain(),
                        this._calcMatrices()
                    }
                    get unmodified() {
                        return this._unmodified
                    }
                    zoomScale(t) {
                        return Math.pow(2, t)
                    }
                    scaleZoom(t) {
                        return Math.log(t) / Math.LN2
                    }
                    project(t) {
                        const i = s.aw(t.lat, -s.bX, s.bX)
                          , h = this.projection.project(t.lng, i);
                        return new s.P(h.x * this.worldSize,h.y * this.worldSize)
                    }
                    unproject(t) {
                        return this.projection.unproject(t.x / this.worldSize, t.y / this.worldSize)
                    }
                    get point() {
                        return this.project(this.center)
                    }
                    get pointMerc() {
                        return this.point._div(this.worldSize)
                    }
                    get pixelsPerMeterRatio() {
                        return this.pixelsPerMeter / s.bH(1, this.center.lat) / this.worldSize
                    }
                    setLocationAtPoint(t, i) {
                        let h, d;
                        const m = this.centerPoint;
                        if ("globe" === this.projection.name) {
                            const M = this.worldSize;
                            h = (i.x - m.x) / M,
                            d = (i.y - m.y) / M
                        } else {
                            const M = this.pointCoordinate(i)
                              , E = this.pointCoordinate(m);
                            h = M.x - E.x,
                            d = M.y - E.y
                        }
                        const y = this.locationCoordinate(t);
                        this.setLocation(new s.aa(y.x - h,y.y - d))
                    }
                    setLocation(t) {
                        this.center = this.coordinateLocation(t),
                        this.projection.wrap && (this.center = this.center.wrap())
                    }
                    locationPoint(t) {
                        return this.projection.locationPoint(this, t)
                    }
                    locationPoint3D(t) {
                        return this.projection.locationPoint(this, t, !0)
                    }
                    pointLocation(t) {
                        return this.coordinateLocation(this.pointCoordinate(t))
                    }
                    pointLocation3D(t) {
                        return this.coordinateLocation(this.pointCoordinate3D(t))
                    }
                    locationCoordinate(t, i) {
                        const h = i ? s.bH(i, t.lat) : void 0
                          , d = this.projection.project(t.lng, t.lat);
                        return new s.aa(d.x,d.y,h)
                    }
                    coordinateLocation(t) {
                        return this.projection.unproject(t.x, t.y)
                    }
                    pointRayIntersection(t, i) {
                        const h = null != i ? i : this._centerAltitude
                          , d = [t.x, t.y, 0, 1]
                          , m = [t.x, t.y, 1, 1];
                        s.ab.vec4.transformMat4(d, d, this.pixelMatrixInverse),
                        s.ab.vec4.transformMat4(m, m, this.pixelMatrixInverse);
                        const y = m[3];
                        s.ab.vec4.scale(d, d, 1 / d[3]),
                        s.ab.vec4.scale(m, m, 1 / y);
                        const M = d[2]
                          , E = m[2];
                        return {
                            p0: d,
                            p1: m,
                            t: M === E ? 0 : (h - M) / (E - M)
                        }
                    }
                    screenPointToMercatorRay(t) {
                        const i = [t.x, t.y, 0, 1]
                          , h = [t.x, t.y, 1, 1];
                        return s.ab.vec4.transformMat4(i, i, this.pixelMatrixInverse),
                        s.ab.vec4.transformMat4(h, h, this.pixelMatrixInverse),
                        s.ab.vec4.scale(i, i, 1 / i[3]),
                        s.ab.vec4.scale(h, h, 1 / h[3]),
                        i[2] = s.bH(i[2], this._center.lat) * this.worldSize,
                        h[2] = s.bH(h[2], this._center.lat) * this.worldSize,
                        s.ab.vec4.scale(i, i, 1 / this.worldSize),
                        s.ab.vec4.scale(h, h, 1 / this.worldSize),
                        new s.aq([i[0], i[1], i[2]],s.ab.vec3.normalize([], s.ab.vec3.sub([], h, i)))
                    }
                    rayIntersectionCoordinate(t) {
                        const {p0: i, p1: h, t: d} = t
                          , m = s.bH(i[2], this._center.lat)
                          , y = s.bH(h[2], this._center.lat);
                        return new s.aa(s.af(i[0], h[0], d) / this.worldSize,s.af(i[1], h[1], d) / this.worldSize,s.af(m, y, d))
                    }
                    pointCoordinate(t, i=this._centerAltitude) {
                        return this.projection.pointCoordinate(this, t.x, t.y, i)
                    }
                    pointCoordinate3D(t) {
                        if (!this.elevation)
                            return this.pointCoordinate(t);
                        let i = this.projection.pointCoordinate3D(this, t.x, t.y);
                        if (i)
                            return new s.aa(i[0],i[1],i[2]);
                        let h = 0
                          , d = this.horizonLineFromTop();
                        if (t.y > d)
                            return this.pointCoordinate(t);
                        const m = .02 * d
                          , y = t.clone();
                        for (let M = 0; M < 10 && d - h > m; M++) {
                            y.y = s.af(h, d, .66);
                            const E = this.projection.pointCoordinate3D(this, y.x, y.y);
                            E ? (d = y.y,
                            i = E) : h = y.y
                        }
                        return i ? new s.aa(i[0],i[1],i[2]) : this.pointCoordinate(t)
                    }
                    isPointAboveHorizon(t) {
                        return this.projection.isPointAboveHorizon(this, t)
                    }
                    isPointOnSurface(t) {
                        if (t.y < 0 || t.y > this.height || t.x < 0 || t.x > this.width)
                            return !1;
                        if (this.elevation || this.zoom >= s.bY)
                            return !this.isPointAboveHorizon(t);
                        const i = this.pointCoordinate(t);
                        return i.y >= 0 && i.y <= 1
                    }
                    _coordinatePoint(t, i) {
                        const h = i && this.elevation ? this.elevation.getAtPointOrZero(t, this._centerAltitude) : this._centerAltitude
                          , d = [t.x * this.worldSize, t.y * this.worldSize, h + t.toAltitude(), 1];
                        return s.ab.vec4.transformMat4(d, d, this.pixelMatrix),
                        d[3] > 0 ? new s.P(d[0] / d[3],d[1] / d[3]) : new s.P(Number.MAX_VALUE,Number.MAX_VALUE)
                    }
                    _getBoundsNonRectangular() {
                        const {top: t, left: i} = this._edgeInsets
                          , h = this.height - this._edgeInsets.bottom
                          , d = this.width - this._edgeInsets.right
                          , m = this.pointLocation3D(new s.P(i,t))
                          , y = this.pointLocation3D(new s.P(d,t))
                          , M = this.pointLocation3D(new s.P(d,h))
                          , E = this.pointLocation3D(new s.P(i,h));
                        let S = Math.min(m.lng, y.lng, M.lng, E.lng)
                          , I = Math.max(m.lng, y.lng, M.lng, E.lng)
                          , R = Math.min(m.lat, y.lat, M.lat, E.lat)
                          , D = Math.max(m.lat, y.lat, M.lat, E.lat);
                        const k = Math.pow(2, -this.zoom) / 16 * 270
                          , H = "globe" === this.projection.name ? 1 : 4
                          , j = (Y, K, he, Te, be) => {
                            const Ue = (Y + he) / 2
                              , De = (K + Te) / 2
                              , ke = new s.P(Ue,De)
                              , {lng: Le, lat: Ge} = this.pointLocation3D(ke)
                              , qe = Math.max(0, S - Le, R - Ge, Le - I, Ge - D);
                            S = Math.min(S, Le),
                            I = Math.max(I, Le),
                            R = Math.min(R, Ge),
                            D = Math.max(D, Ge),
                            (be < H || qe > k) && (j(Y, K, Ue, De, be + 1),
                            j(Ue, De, he, Te, be + 1))
                        }
                        ;
                        if (j(i, t, d, t, 1),
                        j(d, t, d, h, 1),
                        j(d, h, i, h, 1),
                        j(i, h, i, t, 1),
                        "globe" === this.projection.name) {
                            const [Y,K] = s.bZ(this);
                            Y ? (D = 90,
                            I = 180,
                            S = -180) : K && (R = -90,
                            I = 180,
                            S = -180)
                        }
                        return new s.az(new s.bO(S,R),new s.bO(I,D))
                    }
                    _getBoundsRectangular(t, i) {
                        const {top: h, left: d} = this._edgeInsets
                          , m = this.height - this._edgeInsets.bottom
                          , y = this.width - this._edgeInsets.right
                          , M = new s.P(d,h)
                          , E = new s.P(y,h)
                          , S = new s.P(y,m)
                          , I = new s.P(d,m);
                        let R = this.pointCoordinate(M, t)
                          , D = this.pointCoordinate(E, t);
                        const k = this.pointCoordinate(S, i)
                          , H = this.pointCoordinate(I, i)
                          , j = (Y, K) => (K.y - Y.y) / (K.x - Y.x);
                        return R.y > 1 && D.y >= 0 ? R = new s.aa((1 - H.y) / j(H, R) + H.x,1) : R.y < 0 && D.y <= 1 && (R = new s.aa(-H.y / j(H, R) + H.x,0)),
                        D.y > 1 && R.y >= 0 ? D = new s.aa((1 - k.y) / j(k, D) + k.x,1) : D.y < 0 && R.y <= 1 && (D = new s.aa(-k.y / j(k, D) + k.x,0)),
                        (new s.az).extend(this.coordinateLocation(R)).extend(this.coordinateLocation(D)).extend(this.coordinateLocation(H)).extend(this.coordinateLocation(k))
                    }
                    _getBoundsRectangularTerrain() {
                        const t = this.elevation;
                        if (!t.visibleDemTiles.length || t.isUsingMockSource())
                            return this._getBoundsRectangular(0, 0);
                        const i = t.visibleDemTiles.reduce( (h, d) => {
                            if (d.dem) {
                                const m = d.dem.tree;
                                h.min = Math.min(h.min, m.minimums[0]),
                                h.max = Math.max(h.max, m.maximums[0])
                            }
                            return h
                        }
                        , {
                            min: Number.MAX_VALUE,
                            max: 0
                        });
                        return this._getBoundsRectangular(i.min * t.exaggeration(), i.max * t.exaggeration())
                    }
                    getBounds() {
                        return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular()
                    }
                    horizonLineFromTop(t=!0) {
                        const i = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) - this.centerOffset.y
                          , h = this.height / 2 - i * (1 - this._horizonShift);
                        return t ? Math.max(0, h) : h
                    }
                    getMaxBounds() {
                        return this.maxBounds
                    }
                    setMaxBounds(t) {
                        this.maxBounds = t,
                        this.minLat = -s.bX,
                        this.maxLat = s.bX,
                        this.minLng = -180,
                        this.maxLng = 180,
                        t && (this.minLat = t.getSouth(),
                        this.maxLat = t.getNorth(),
                        this.minLng = t.getWest(),
                        this.maxLng = t.getEast(),
                        this.maxLng < this.minLng && (this.maxLng += 360)),
                        this.worldMinX = s.at(this.minLng) * this.tileSize,
                        this.worldMaxX = s.at(this.maxLng) * this.tileSize,
                        this.worldMinY = s.aA(this.maxLat) * this.tileSize,
                        this.worldMaxY = s.aA(this.minLat) * this.tileSize,
                        this._constrain()
                    }
                    calculatePosMatrix(t, i) {
                        return this.projection.createTileMatrix(this, i, t)
                    }
                    calculateDistanceTileData(t) {
                        const i = t.key
                          , h = this._distanceTileDataCache;
                        if (h[i])
                            return h[i];
                        const d = t.canonical
                          , m = 1 / this.height
                          , y = this.cameraWorldSize
                          , M = y / this.zoomScale(d.z)
                          , E = (d.x + Math.pow(2, d.z) * t.wrap) * M
                          , S = d.y * M
                          , I = this.point;
                        I.x *= y / this.worldSize,
                        I.y *= y / this.worldSize;
                        const R = this.angle
                          , D = Math.sin(-R)
                          , k = -Math.cos(-R);
                        return h[i] = {
                            bearing: [D, k],
                            center: [(I.x - E) * m, (I.y - S) * m],
                            scale: M / s.ag * m
                        },
                        h[i]
                    }
                    calculateFogTileMatrix(t) {
                        const i = t.key
                          , h = this._fogTileMatrixCache;
                        if (h[i])
                            return h[i];
                        const d = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t);
                        return s.ab.mat4.multiply(d, this.worldToFogMatrix, d),
                        h[i] = new Float32Array(d),
                        h[i]
                    }
                    calculateProjMatrix(t, i=!1, h=!1) {
                        const d = t.key;
                        let m;
                        if (m = h ? this._expandedProjMatrixCache : i ? this._alignedProjMatrixCache : this._projMatrixCache,
                        m[d])
                            return m[d];
                        const y = this.calculatePosMatrix(t, this.worldSize);
                        let M;
                        return M = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : h ? this.expandedFarZProjMatrix : i ? this.alignedProjMatrix : this.projMatrix,
                        s.ab.mat4.multiply(y, M, y),
                        m[d] = new Float32Array(y),
                        m[d]
                    }
                    calculatePixelsToTileUnitsMatrix(t) {
                        const i = t.tileID.key
                          , h = this._pixelsToTileUnitsCache;
                        if (h[i])
                            return h[i];
                        const d = s.b_(t, this);
                        return h[i] = d,
                        h[i]
                    }
                    customLayerMatrix() {
                        return this.mercatorMatrix.slice()
                    }
                    globeToMercatorMatrix() {
                        if ("globe" === this.projection.name) {
                            const t = 1 / this.worldSize
                              , i = s.ab.mat4.fromScaling([], [t, t, t]);
                            return s.ab.mat4.multiply(i, i, this.globeMatrix),
                            i
                        }
                    }
                    recenterOnTerrain() {
                        if (!this._elevation || "globe" === this.projection.name)
                            return;
                        const t = this._elevation;
                        this._updateCameraState();
                        const i = s.bH(1, this._center.lat) * this.worldSize
                          , h = this._computeCameraPosition(i)
                          , d = this._camera.forward()
                          , m = s.bH(1, this._center.lat);
                        h[2] /= m,
                        d[2] /= m,
                        s.ab.vec3.normalize(d, d);
                        const y = t.raycast(h, d, t.exaggeration());
                        if (y) {
                            const M = s.ab.vec3.scaleAndAdd([], h, d, y)
                              , E = new s.aa(M[0],M[1],s.bH(M[2], s.aS(M[1])))
                              , S = (E.z + s.ab.vec3.length([E.x - h[0], E.y - h[1], E.z - h[2] * m])) * this._pixelsPerMercatorPixel;
                            this._seaLevelZoom = this._zoomFromMercatorZ(S),
                            this._centerAltitude = E.toAltitude(),
                            this._center = this.coordinateLocation(E),
                            this._updateZoomFromElevation(),
                            this._constrain(),
                            this._calcMatrices()
                        }
                    }
                    _constrainCamera(t=!1) {
                        if (!this._elevation)
                            return;
                        const i = this._elevation
                          , h = s.bH(1, this._center.lat) * this.worldSize
                          , d = this._computeCameraPosition(h)
                          , m = i.getAtPointOrZero(new s.aa(...d))
                          , y = this.pixelsPerMeter / this.worldSize * m
                          , M = this._minimumHeightOverTerrain()
                          , E = d[2] - y;
                        if (E <= M)
                            if (E < 0 || t) {
                                const S = this.locationCoordinate(this._center, this._centerAltitude)
                                  , I = [d[0], d[1], S.z - d[2]]
                                  , R = s.ab.vec3.length(I);
                                I[2] -= (M - E) / this._pixelsPerMercatorPixel;
                                const D = s.ab.vec3.length(I);
                                if (0 === D)
                                    return;
                                s.ab.vec3.scale(I, I, R / D * this._pixelsPerMercatorPixel),
                                this._camera.position = [d[0], d[1], S.z * this._pixelsPerMercatorPixel - I[2]],
                                this._updateStateFromCamera()
                            } else
                                this._isCameraConstrained = !0
                    }
                    _constrain() {
                        if (!this.center || !this.width || !this.height || this._constraining)
                            return;
                        this._constraining = !0;
                        const t = "globe" === this.projection.name || this.mercatorFromTransition;
                        if (this.projection.isReprojectedInTileSpace || t) {
                            const D = this.center;
                            return D.lat = s.aw(D.lat, this.minLat, this.maxLat),
                            (this.maxBounds || !this.renderWorldCopies && !t) && (D.lng = s.aw(D.lng, this.minLng, this.maxLng)),
                            this.center = D,
                            void (this._constraining = !1)
                        }
                        const i = this._unmodified
                          , {x: h, y: d} = this.point;
                        let m = 0
                          , y = h
                          , M = d;
                        const E = this.width / 2
                          , S = this.height / 2
                          , I = this.worldMinY * this.scale
                          , R = this.worldMaxY * this.scale;
                        if (d - S < I && (M = I + S),
                        d + S > R && (M = R - S),
                        R - I < this.height && (m = Math.max(m, this.height / (R - I)),
                        M = (R + I) / 2),
                        this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
                            const D = this.worldMinX * this.scale
                              , k = this.worldMaxX * this.scale
                              , H = this.worldSize / 2 - (D + k) / 2;
                            y = (h + H + this.worldSize) % this.worldSize - H,
                            y - E < D && (y = D + E),
                            y + E > k && (y = k - E),
                            k - D < this.width && (m = Math.max(m, this.width / (k - D)),
                            y = (k + D) / 2)
                        }
                        y === h && M === d || (this.center = this.unproject(new s.P(y,M))),
                        m && (this.zoom += this.scaleZoom(m)),
                        this._constrainCamera(),
                        this._unmodified = i,
                        this._constraining = !1
                    }
                    _minZoomForBounds() {
                        let t = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
                        return this.maxBounds && (t = Math.max(t, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))),
                        t
                    }
                    _maxCameraBoundsDistance() {
                        return this._mercatorZfromZoom(this._minZoomForBounds())
                    }
                    _calcMatrices() {
                        if (!this.height)
                            return;
                        const t = this.centerOffset
                          , i = "globe" === this.projection.name
                          , h = this.pixelsPerMeter;
                        "globe" === this.projection.name && (this._mercatorScaleRatio = s.bH(1, this.center.lat) / s.bH(1, s.c8));
                        const d = s.b$(this.projection, this.zoom, this.width, this.height, 1024);
                        this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, d),
                        this.cameraToCenterDistance = .5 / Math.tan(.5 * this._fov) * this.height * this._pixelsPerMercatorPixel,
                        this._updateCameraState(),
                        this._farZ = this.projection.farthestPixelDistance(this),
                        this._nearZ = this.height / 50;
                        const m = "meters" === this.projection.zAxisUnit ? h : 1
                          , y = this._camera.getWorldToCamera(this.worldSize, m);
                        let M;
                        const E = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
                        if (E[8] = 2 * -t.x / this.width,
                        E[9] = 2 * t.y / this.height,
                        this.isOrthographic) {
                            let Ge = .5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(.5 * this._fov)
                              , qe = Ge * this.aspect
                              , vt = -qe
                              , dt = -Ge;
                            qe -= t.x,
                            vt -= t.x,
                            Ge += t.y,
                            dt += t.y,
                            M = this._camera.getCameraToClipOrthographic(vt, qe, dt, Ge, this._nearZ, this._farZ),
                            ( (Ze, nt, zt, Yt) => {
                                for (let to = 0; to < 16; to++)
                                    Ze[to] = rl(nt[to], zt[to], Yt)
                            }
                            )(M, M, E, uo(this.pitch >= 15 ? 1 : this.pitch / 15))
                        } else
                            M = E;
                        const S = s.ab.mat4.mul([], E, y);
                        let I = s.ab.mat4.mul([], M, y);
                        if (this.projection.isReprojectedInTileSpace) {
                            const Ge = this.locationCoordinate(this.center)
                              , qe = s.ab.mat4.identity([]);
                            s.ab.mat4.translate(qe, qe, [Ge.x * this.worldSize, Ge.y * this.worldSize, 0]),
                            s.ab.mat4.multiply(qe, qe, s.c0(this)),
                            s.ab.mat4.translate(qe, qe, [-Ge.x * this.worldSize, -Ge.y * this.worldSize, 0]),
                            s.ab.mat4.multiply(I, I, qe),
                            s.ab.mat4.multiply(S, S, qe),
                            this.inverseAdjustmentMatrix = s.c1(this)
                        } else
                            this.inverseAdjustmentMatrix = [1, 0, 0, 1];
                        if (this.mercatorMatrix = s.ab.mat4.scale([], I, [this.worldSize, this.worldSize, this.worldSize / m, 1]),
                        this.projMatrix = I,
                        this.invProjMatrix = s.ab.mat4.invert(new Float64Array(16), this.projMatrix),
                        i) {
                            const Ge = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);
                            Ge[8] = 2 * -t.x / this.width,
                            Ge[9] = 2 * t.y / this.height,
                            this.expandedFarZProjMatrix = s.ab.mat4.mul([], Ge, y)
                        } else
                            this.expandedFarZProjMatrix = this.projMatrix;
                        const R = s.ab.mat4.invert([], M);
                        this.frustumCorners = s.c2.fromInvProjectionMatrix(R, this.horizonLineFromTop(), this.height),
                        this.cameraFrustum = s.bR.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !i);
                        const D = new Float32Array(16);
                        s.ab.mat4.identity(D),
                        s.ab.mat4.scale(D, D, [1, -1, 1]),
                        s.ab.mat4.rotateX(D, D, this._pitch),
                        s.ab.mat4.rotateZ(D, D, this.angle);
                        const k = s.ab.mat4.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);
                        this.starsProjMatrix = s.ab.mat4.clone(k);
                        const H = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
                        k[8] = 2 * -t.x / this.width,
                        k[9] = 2 * (t.y + H) / this.height,
                        this.skyboxMatrix = s.ab.mat4.multiply(D, k, D);
                        const j = this.point
                          , Y = j.x
                          , K = j.y
                          , he = this.width % 2 / 2
                          , Te = this.height % 2 / 2
                          , be = Math.cos(this.angle)
                          , Ue = Math.sin(this.angle)
                          , De = Y - Math.round(Y) + be * he + Ue * Te
                          , ke = K - Math.round(K) + be * Te + Ue * he
                          , Le = new Float64Array(I);
                        if (s.ab.mat4.translate(Le, Le, [De > .5 ? De - 1 : De, ke > .5 ? ke - 1 : ke, 0]),
                        this.alignedProjMatrix = Le,
                        I = s.ab.mat4.create(),
                        s.ab.mat4.scale(I, I, [this.width / 2, -this.height / 2, 1]),
                        s.ab.mat4.translate(I, I, [1, -1, 0]),
                        this.labelPlaneMatrix = I,
                        I = s.ab.mat4.create(),
                        s.ab.mat4.scale(I, I, [1, -1, 1]),
                        s.ab.mat4.translate(I, I, [-1, -1, 0]),
                        s.ab.mat4.scale(I, I, [2 / this.width, 2 / this.height, 1]),
                        this.glCoordMatrix = I,
                        this.pixelMatrix = s.ab.mat4.multiply(new Float64Array(16), this.labelPlaneMatrix, S),
                        this._calcFogMatrices(),
                        this._distanceTileDataCache = {},
                        I = s.ab.mat4.invert(new Float64Array(16), this.pixelMatrix),
                        !I)
                            throw new Error("failed to invert matrix");
                        if (this.pixelMatrixInverse = I,
                        "globe" === this.projection.name || this.mercatorFromTransition) {
                            this.globeMatrix = s.c3(this);
                            const Ge = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
                            this.globeCenterInViewSpace = s.ab.vec3.transformMat4(Ge, Ge, y),
                            this.globeRadius = this.worldSize / 2 / Math.PI - 1
                        } else
                            this.globeMatrix = I;
                        this._projMatrixCache = {},
                        this._alignedProjMatrixCache = {},
                        this._pixelsToTileUnitsCache = {},
                        this._expandedProjMatrixCache = {}
                    }
                    _calcFogMatrices() {
                        this._fogTileMatrixCache = {};
                        const t = this.cameraWorldSizeForFog
                          , i = this.cameraPixelsPerMeter
                          , h = this._camera.position
                          , d = 1 / this.height / this._pixelsPerMercatorPixel
                          , m = [t, t, i];
                        s.ab.vec3.scale(m, m, d),
                        s.ab.vec3.scale(h, h, -1),
                        s.ab.vec3.multiply(h, h, m);
                        const y = s.ab.mat4.create();
                        s.ab.mat4.translate(y, y, h),
                        s.ab.mat4.scale(y, y, m),
                        this.mercatorFogMatrix = y,
                        this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t, i, d)
                    }
                    _computeCameraPosition(t) {
                        const i = (t = t || this.pixelsPerMeter) / this.pixelsPerMeter
                          , h = this._camera.forward()
                          , d = this.point
                          , m = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * i - t / this.worldSize * this._centerAltitude;
                        return [d.x / this.worldSize - h[0] * m, d.y / this.worldSize - h[1] * m, t / this.worldSize * this._centerAltitude - h[2] * m]
                    }
                    _updateCameraState() {
                        this.height && (this._camera.setPitchBearing(this._pitch, this.angle),
                        this._camera.position = this._computeCameraPosition())
                    }
                    _translateCameraConstrained(t) {
                        const i = this._maxCameraBoundsDistance() * Math.cos(this._pitch)
                          , h = this._camera.position[2]
                          , d = t[2];
                        let m = 1;
                        this.projection.wrap && (this.center = this.center.wrap()),
                        d > 0 && (m = Math.min((i - h) / d, 1)),
                        this._camera.position = s.ab.vec3.scaleAndAdd([], this._camera.position, t, m),
                        this._updateStateFromCamera()
                    }
                    _updateStateFromCamera() {
                        const t = this._camera.position
                          , i = this._camera.forward()
                          , {pitch: h, bearing: d} = this._camera.getPitchBearing()
                          , m = s.bH(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel
                          , y = this._mercatorZfromZoom(this._maxZoom) * Math.cos(s.ai(this._maxPitch))
                          , M = Math.max((t[2] - m) / Math.cos(h), y)
                          , E = this._zoomFromMercatorZ(M);
                        s.ab.vec3.scaleAndAdd(t, t, i, M),
                        this._pitch = s.aw(h, s.ai(this.minPitch), s.ai(this.maxPitch)),
                        this.angle = s.bF(d, -Math.PI, Math.PI),
                        this._setZoom(s.aw(E, this._minZoom, this._maxZoom)),
                        this._updateSeaLevelZoom(),
                        this._center = this.coordinateLocation(new s.aa(t[0],t[1],t[2])),
                        this._unmodified = !1,
                        this._constrain(),
                        this._calcMatrices()
                    }
                    _worldSizeFromZoom(t) {
                        return Math.pow(2, t) * this.tileSize
                    }
                    _mercatorZfromZoom(t) {
                        return this.cameraToCenterDistance / this._worldSizeFromZoom(t)
                    }
                    _minimumHeightOverTerrain() {
                        const t = Math.min(null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom, this._maxZoom) + 4;
                        return this._mercatorZfromZoom(t)
                    }
                    _zoomFromMercatorZ(t) {
                        return this.scaleZoom(this.cameraToCenterDistance / (t * this.tileSize))
                    }
                    zoomFromMercatorZAdjusted(t) {
                        let i = 0
                          , h = s.bY
                          , d = 0
                          , m = 1 / 0;
                        for (; h - i > 1e-6 && h > i; ) {
                            const y = i + .5 * (h - i)
                              , M = this.tileSize * Math.pow(2, y)
                              , E = this.getCameraToCenterDistance(this.projection, y, M)
                              , S = this.scaleZoom(E / (t * this.tileSize))
                              , I = Math.abs(y - S);
                            I < m && (m = I,
                            d = y),
                            y < S ? i = y : h = y
                        }
                        return d
                    }
                    _terrainEnabled() {
                        return !(!this._elevation || !this.projection.supportsTerrain && (s.w("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."),
                        1))
                    }
                    anyCornerOffEdge(t, i) {
                        const h = Math.min(t.x, i.x)
                          , d = Math.max(t.x, i.x)
                          , m = Math.min(t.y, i.y)
                          , y = Math.max(t.y, i.y);
                        if (m < this.horizonLineFromTop(!1))
                            return !0;
                        if ("mercator" !== this.projection.name)
                            return !1;
                        const M = [new s.P(h,m), new s.P(d,y), new s.P(h,y), new s.P(d,m)]
                          , E = this.renderWorldCopies ? -3 : 0
                          , S = this.renderWorldCopies ? 4 : 1;
                        for (const I of M) {
                            const R = this.pointRayIntersection(I);
                            if (R.t < 0)
                                return !0;
                            const D = this.rayIntersectionCoordinate(R);
                            if (D.x < E || D.y < 0 || D.x > S || D.y > 1)
                                return !0
                        }
                        return !1
                    }
                    isHorizonVisible() {
                        return this.pitch + s.c4(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new s.P(0,0), new s.P(this.width,this.height))
                    }
                    zoomDeltaToMovement(t, i) {
                        const h = s.ab.vec3.length(s.ab.vec3.sub([], this._camera.position, t))
                          , d = this._zoomFromMercatorZ(h) + i;
                        return h - this._mercatorZfromZoom(d)
                    }
                    getCameraPoint() {
                        if ("globe" === this.projection.name) {
                            const t = function([i,h,d], m) {
                                const y = [i, h, d, 1];
                                s.ab.vec4.transformMat4(y, y, m);
                                const M = y[3] = Math.max(y[3], 1e-6);
                                return y[0] /= M,
                                y[1] /= M,
                                y[2] /= M,
                                y
                            }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
                            return new s.P(t[0],t[1])
                        }
                        {
                            const t = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                            return this.centerPoint.add(new s.P(0,t))
                        }
                    }
                    getCameraToCenterDistance(t, i=this.zoom, h=this.worldSize) {
                        const d = s.b$(t, i, this.width, this.height, 1024)
                          , m = t.pixelSpaceConversion(this.center.lat, h, d);
                        let y = .5 / Math.tan(.5 * this._fov) * this.height * m;
                        return this.isOrthographic && (y = rl(1, y, uo(this.pitch >= 15 ? 1 : this.pitch / 15))),
                        y
                    }
                    getWorldToCameraMatrix() {
                        const t = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
                        return "globe" === this.projection.name && s.ab.mat4.multiply(t, t, this.globeMatrix),
                        t
                    }
                    getFrustum(t) {
                        return s.bR.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t, "meters" === this.projection.zAxisUnit)
                    }
                }
                const Kr = (c, t) => {
                    if (t > 0 && c.terrain && s.w("Cutoff is currently disabled on terrain"),
                    t <= 0 || c.terrain)
                        return {
                            shouldRenderCutoff: !1,
                            uniformValues: {
                                u_cutoff_params: [0, 0, 0, 1]
                            }
                        };
                    const i = c.transform
                      , h = Math.max(Math.abs(i._zoom - (c.minCutoffZoom - 1)), 1)
                      , d = i.isLODDisabled(!1) ? s.ac(60, 45, i.pitch) : s.ac(30, 15, i.pitch)
                      , m = i._farZ - i._nearZ
                      , y = t * i.height
                      , M = ((1 - (E = d)) * i.cameraToCenterDistance + E * (i._farZ + y)) * h;
                    var E;
                    return {
                        shouldRenderCutoff: d < 1,
                        uniformValues: {
                            u_cutoff_params: [i._nearZ, i._farZ, (M - i._nearZ) / m, (M - y - i._nearZ) / m]
                        }
                    }
                }
                  , kn = {
                    cascadeCount: 2,
                    normalOffset: 3,
                    shadowMapResolution: 2048
                };
                class Qc {
                    constructor(t, i) {
                        this.aabb = t,
                        this.lastCascade = i
                    }
                }
                class ta {
                    add(t, i) {
                        const h = this.receivers[t.key];
                        void 0 !== h ? (h.aabb.min[0] = Math.min(h.aabb.min[0], i.min[0]),
                        h.aabb.min[1] = Math.min(h.aabb.min[1], i.min[1]),
                        h.aabb.min[2] = Math.min(h.aabb.min[2], i.min[2]),
                        h.aabb.max[0] = Math.max(h.aabb.max[0], i.max[0]),
                        h.aabb.max[1] = Math.max(h.aabb.max[1], i.max[1]),
                        h.aabb.max[2] = Math.max(h.aabb.max[2], i.max[2])) : this.receivers[t.key] = new Qc(i,null)
                    }
                    clear() {
                        this.receivers = {}
                    }
                    get(t) {
                        return this.receivers[t.key]
                    }
                    computeRequiredCascades(t, i, h) {
                        const d = s.cd.fromPoints(t.points);
                        let m = 0;
                        for (const y in this.receivers) {
                            const M = this.receivers[y];
                            if (!M || !d.intersectsAabb(M.aabb))
                                continue;
                            M.aabb.min = d.closestPoint(M.aabb.min),
                            M.aabb.max = d.closestPoint(M.aabb.max);
                            const E = M.aabb.getCorners();
                            for (let S = 0; S < h.length; S++) {
                                let I = !0;
                                for (const R of E) {
                                    const D = [R[0] * i, R[1] * i, R[2]];
                                    if (s.ab.vec3.transformMat4(D, D, h[S].matrix),
                                    D[0] < -1 || D[0] > 1 || D[1] < -1 || D[1] > 1) {
                                        I = !1;
                                        break
                                    }
                                }
                                if (M.lastCascade = S,
                                m = Math.max(m, S),
                                I)
                                    break
                            }
                        }
                        return m + 1
                    }
                }
                class Br {
                    constructor(t) {
                        this.painter = t,
                        this._enabled = !1,
                        this._shadowLayerCount = 0,
                        this._numCascadesToRender = 0,
                        this._cascades = [],
                        this._groundShadowTiles = [],
                        this._receivers = new ta,
                        this._depthMode = new Fo(t.context.gl.LEQUAL,Fo.ReadWrite,[0, 1]),
                        this._uniformValues = {
                            u_light_matrix_0: new Float32Array(16),
                            u_light_matrix_1: new Float32Array(16),
                            u_shadow_intensity: 0,
                            u_fade_range: [0, 0],
                            u_shadow_normal_offset: [1, 1, 1],
                            u_shadow_texel_size: 1,
                            u_shadow_map_resolution: 1,
                            u_shadow_direction: [0, 0, 1],
                            u_shadow_bias: [36e-5, .0012, .012],
                            u_shadowmap_0: 0,
                            u_shadowmap_1: 0
                        },
                        this._forceDisable = !1,
                        this.useNormalOffset = !1,
                        t.tp.registerParameter(this, ["Shadows"], "_forceDisable", {
                            label: "forceDisable"
                        }, () => {
                            this.painter.style.map.triggerRepaint()
                        }
                        ),
                        t.tp.registerParameter(kn, ["Shadows"], "cascadeCount", {
                            min: 1,
                            max: 2,
                            step: 1
                        }),
                        t.tp.registerParameter(kn, ["Shadows"], "normalOffset", {
                            min: 0,
                            max: 10,
                            step: .05
                        }),
                        t.tp.registerParameter(kn, ["Shadows"], "shadowMapResolution", {
                            min: 32,
                            max: 2048,
                            step: 32
                        }),
                        t.tp.registerBinding(this, ["Shadows"], "_numCascadesToRender", {
                            readonly: !0,
                            label: "numCascadesToRender"
                        })
                    }
                    destroy() {
                        for (const t of this._cascades)
                            t.texture.destroy(),
                            t.framebuffer.destroy();
                        this._cascades = []
                    }
                    updateShadowParameters(t, i) {
                        const h = this.painter;
                        if (this._enabled = !1,
                        this._shadowLayerCount = 0,
                        this._receivers.clear(),
                        !i || !i.properties)
                            return;
                        const d = i.properties.get("shadow-intensity");
                        if (!i.shadowsEnabled() || d <= 0 || (this._shadowLayerCount = h.style.order.reduce( (H, j) => {
                            const Y = h.style._mergedLayers[j];
                            return H + (Y.hasShadowPass() && !Y.isHidden(t.zoom) ? 1 : 0)
                        }
                        , 0),
                        this._enabled = this._shadowLayerCount > 0,
                        !this.enabled))
                            return;
                        const m = h.context
                          , y = kn.shadowMapResolution
                          , M = kn.shadowMapResolution;
                        if (0 === this._cascades.length || kn.shadowMapResolution !== this._cascades[0].texture.size[0]) {
                            this._cascades = [];
                            for (let H = 0; H < kn.cascadeCount; ++H) {
                                const j = h._shadowMapDebug
                                  , Y = m.gl
                                  , K = m.createFramebuffer(y, M, j, "texture")
                                  , he = new s.T(m,{
                                    width: y,
                                    height: M,
                                    data: null
                                },Y.DEPTH_COMPONENT16);
                                if (K.depthAttachment.set(he.texture),
                                j) {
                                    const Te = new s.T(m,{
                                        width: y,
                                        height: M,
                                        data: null
                                    },Y.RGBA8);
                                    K.colorAttachment.set(Te.texture)
                                }
                                this._cascades.push({
                                    framebuffer: K,
                                    texture: he,
                                    matrix: [],
                                    far: 0,
                                    boundingSphereRadius: 0,
                                    frustum: new s.bR,
                                    scale: 0
                                })
                            }
                        }
                        this.shadowDirection = Ss(i);
                        let E = 0;
                        if (t.elevation) {
                            const H = t.elevation
                              , j = [1e4, -1e4];
                            H.visibleDemTiles.filter(Y => Y.dem).forEach(Y => {
                                const K = Y.dem.tree;
                                j[0] = Math.min(j[0], K.minimums[0]),
                                j[1] = Math.max(j[1], K.maximums[0])
                            }
                            ),
                            1e4 !== j[0] && (E = (j[1] - j[0]) * H.exaggeration())
                        }
                        const S = 1.5 * t.cameraToCenterDistance
                          , I = 3 * S
                          , R = new Float64Array(16);
                        for (let H = 0; H < this._cascades.length; ++H) {
                            const j = this._cascades[H];
                            let Y = t.height / 50
                              , K = 1;
                            1 === kn.cascadeCount ? K = I : 0 === H ? K = S : (Y = S,
                            K = I);
                            const [he,Te] = Sa(t, this.shadowDirection, Y, K, kn.shadowMapResolution, E);
                            j.scale = t.scale,
                            j.matrix = he,
                            j.boundingSphereRadius = Te,
                            s.ab.mat4.invert(R, j.matrix),
                            j.frustum = s.bR.fromInvProjectionMatrix(R, 1, 0, !0),
                            j.far = K
                        }
                        const D = this._cascades.length - 1;
                        this._uniformValues.u_fade_range = [.75 * this._cascades[D].far, this._cascades[D].far],
                        this._uniformValues.u_shadow_intensity = d,
                        this._uniformValues.u_shadow_direction = [this.shadowDirection[0], this.shadowDirection[1], this.shadowDirection[2]],
                        this._uniformValues.u_shadow_texel_size = 1 / kn.shadowMapResolution,
                        this._uniformValues.u_shadow_map_resolution = kn.shadowMapResolution,
                        this._uniformValues.u_shadowmap_0 = wn_ShadowMap0,
                        this._uniformValues.u_shadowmap_1 = wn_ShadowMap0 + 1,
                        this._groundShadowTiles = h.transform.coveringTiles({
                            tileSize: 512,
                            renderWorldCopies: !0
                        });
                        const k = h.transform.elevation;
                        for (const H of this._groundShadowTiles) {
                            let j = {
                                min: 0,
                                max: 0
                            };
                            if (k) {
                                const Y = k.getMinMaxForTile(H);
                                Y && (j = Y)
                            }
                            this.addShadowReceiver(H.toUnwrapped(), j.min, j.max)
                        }
                    }
                    get enabled() {
                        return this._enabled && !this._forceDisable
                    }
                    set enabled(t) {
                        this._enabled = t
                    }
                    drawShadowPass(t, i) {
                        if (!this.enabled)
                            return;
                        const h = this.painter
                          , d = h.context;
                        this._numCascadesToRender = this._receivers.computeRequiredCascades(h.transform.getFrustum(0), h.transform.worldSize, this._cascades),
                        d.viewport.set([0, 0, kn.shadowMapResolution, kn.shadowMapResolution]);
                        for (let m = 0; m < this._numCascadesToRender; ++m) {
                            h.currentShadowCascade = m,
                            d.bindFramebuffer.set(this._cascades[m].framebuffer.framebuffer),
                            d.clear({
                                color: s.aj.white,
                                depth: 1
                            });
                            for (const y of t.order) {
                                const M = t._mergedLayers[y];
                                if (!M.hasShadowPass() || M.isHidden(h.transform.zoom))
                                    continue;
                                const E = t.getLayerSourceCache(M)
                                  , S = E ? i[E.id] : void 0;
                                ("model" === M.type || S && S.length) && h.renderLayer(h, E, M, S)
                            }
                        }
                        h.currentShadowCascade = 0
                    }
                    drawGroundShadows() {
                        if (!this.enabled)
                            return;
                        const t = this.painter
                          , i = t.style
                          , h = t.context
                          , d = i.directionalLight
                          , m = i.ambientLight;
                        if (!d || !m)
                            return;
                        const y = []
                          , M = Kr(t, t.longestCutoffRange);
                        M.shouldRenderCutoff && y.push("RENDER_CUTOFF"),
                        y.push("RENDER_SHADOWS", "DEPTH_TEXTURE"),
                        this.useNormalOffset && y.push("NORMAL_OFFSET");
                        const E = oa(i, d, m)
                          , S = new Fo(h.gl.LEQUAL,Fo.ReadOnly,t.depthRangeFor3D);
                        for (const I of this._groundShadowTiles) {
                            const R = I.toUnwrapped()
                              , D = t.isTileAffectedByFog(I)
                              , k = t.getOrCreateProgram("groundShadow", {
                                defines: y,
                                overrideFog: D
                            });
                            this.setupShadows(R, k),
                            t.uploadCommonUniforms(h, k, R, null, M);
                            const H = {
                                u_matrix: t.transform.calculateProjMatrix(R),
                                u_ground_shadow_factor: E
                            };
                            k.draw(t, h.gl.TRIANGLES, S, Xo.disabled, si.multiply, zo.disabled, H, "ground_shadow", t.tileExtentBuffer, t.quadTriangleIndexBuffer, t.tileExtentSegments, {}, t.transform.zoom, null, null)
                        }
                    }
                    getShadowPassColorMode() {
                        return this.painter._shadowMapDebug ? si.unblended : si.disabled
                    }
                    getShadowPassDepthMode() {
                        return this._depthMode
                    }
                    getShadowCastingLayerCount() {
                        return this._shadowLayerCount
                    }
                    calculateShadowPassMatrixFromTile(t) {
                        const i = this.painter.transform
                          , h = i.calculatePosMatrix(t, i.worldSize);
                        return s.ab.mat4.multiply(h, this._cascades[this.painter.currentShadowCascade].matrix, h),
                        Float32Array.from(h)
                    }
                    calculateShadowPassMatrixFromMatrix(t) {
                        return s.ab.mat4.multiply(t, this._cascades[this.painter.currentShadowCascade].matrix, t),
                        Float32Array.from(t)
                    }
                    setupShadows(t, i, h, d=0) {
                        if (!this.enabled)
                            return;
                        const m = this.painter.transform
                          , y = this.painter.context
                          , M = y.gl
                          , E = this._uniformValues
                          , S = new Float64Array(16)
                          , I = m.calculatePosMatrix(t, m.worldSize);
                        for (let R = 0; R < this._cascades.length; R++)
                            s.ab.mat4.multiply(S, this._cascades[R].matrix, I),
                            E[0 === R ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(S),
                            y.activeTexture.set(M.TEXTURE0 + wn_ShadowMap0 + R),
                            this._cascades[R].texture.bind(M.NEAREST, M.CLAMP_TO_EDGE);
                        if (this.useNormalOffset = !!h,
                        this.useNormalOffset) {
                            const R = s.cc(t.canonical)
                              , D = 2 / m.tileSize * s.ag / kn.shadowMapResolution
                              , k = D * this._cascades[0].boundingSphereRadius
                              , H = D * this._cascades[this._cascades.length - 1].boundingSphereRadius
                              , j = ("vector-tile" === h ? 1 : 3) / Math.pow(2, d - t.canonical.z - (1 - m.zoom + Math.floor(m.zoom)));
                            E.u_shadow_normal_offset = [R, k * j, H * j],
                            E.u_shadow_bias = [6e-5, .0012, .012]
                        } else
                            E.u_shadow_bias = [36e-5, .0012, .012];
                        i.setShadowUniformValues(y, E)
                    }
                    setupShadowsFromMatrix(t, i, h=!1) {
                        if (!this.enabled)
                            return;
                        const d = this.painter.context
                          , m = d.gl
                          , y = this._uniformValues
                          , M = new Float64Array(16);
                        for (let E = 0; E < kn.cascadeCount; E++)
                            s.ab.mat4.multiply(M, this._cascades[E].matrix, t),
                            y[0 === E ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(M),
                            d.activeTexture.set(m.TEXTURE0 + wn_ShadowMap0 + E),
                            this._cascades[E].texture.bind(m.NEAREST, m.CLAMP_TO_EDGE);
                        if (this.useNormalOffset = h,
                        h) {
                            const E = kn.normalOffset;
                            y.u_shadow_normal_offset = [1, E, E],
                            y.u_shadow_bias = [6e-5, .0012, .012]
                        } else
                            y.u_shadow_bias = [36e-5, .0012, .012];
                        i.setShadowUniformValues(d, y)
                    }
                    getShadowUniformValues() {
                        return this._uniformValues
                    }
                    getCurrentCascadeFrustum() {
                        return this._cascades[this.painter.currentShadowCascade].frustum
                    }
                    computeSimplifiedTileShadowVolume(t, i, h, d) {
                        if (d[2] >= 0)
                            return {};
                        const m = function(E, S, I) {
                            const R = I / (1 << E.canonical.z);
                            return new s.cd([E.canonical.x * R + E.wrap * I, E.canonical.y * R + E.wrap * I, 0],[(E.canonical.x + 1) * R + E.wrap * I, (E.canonical.y + 1) * R + E.wrap * I, S])
                        }(t, i, h).getCorners()
                          , y = i / -d[2];
                        d[0] < 0 ? (s.ab.vec3.add(m[0], m[0], [d[0] * y, 0, 0]),
                        s.ab.vec3.add(m[3], m[3], [d[0] * y, 0, 0])) : d[0] > 0 && (s.ab.vec3.add(m[1], m[1], [d[0] * y, 0, 0]),
                        s.ab.vec3.add(m[2], m[2], [d[0] * y, 0, 0])),
                        d[1] < 0 ? (s.ab.vec3.add(m[0], m[0], [0, d[1] * y, 0]),
                        s.ab.vec3.add(m[1], m[1], [0, d[1] * y, 0])) : d[1] > 0 && (s.ab.vec3.add(m[2], m[2], [0, d[1] * y, 0]),
                        s.ab.vec3.add(m[3], m[3], [0, d[1] * y, 0]));
                        const M = {};
                        return M.vertices = m,
                        M.planes = [Es(m[1], m[0], m[4]), Es(m[2], m[1], m[5]), Es(m[3], m[2], m[6]), Es(m[0], m[3], m[7])],
                        M
                    }
                    addShadowReceiver(t, i, h) {
                        this._receivers.add(t, s.cd.fromTileIdAndHeight(t, i, h))
                    }
                    getMaxCascadeForTile(t) {
                        const i = this._receivers.get(t);
                        return i && i.lastCascade ? i.lastCascade : 0
                    }
                }
                function Es(c, t, i) {
                    const h = s.ab.vec3.sub([], i, t)
                      , d = s.ab.vec3.sub([], c, t)
                      , m = s.ab.vec3.cross([], h, d)
                      , y = s.ab.vec3.length(m);
                    return 0 === y ? [0, 0, 1, 0] : (s.ab.vec3.scale(m, m, 1 / y),
                    [m[0], m[1], m[2], -s.ab.vec3.dot(m, t)])
                }
                function Ss(c) {
                    const t = c.properties.get("direction")
                      , i = s.cb(t.x, t.y, t.z);
                    i[2] = s.aw(i[2], 0, 75);
                    const h = s.ce([i[0], i[1], i[2]]);
                    return s.ab.vec3.fromValues(h.x, h.y, h.z)
                }
                function oa(c, t, i) {
                    const h = "none" === t.properties.get("color-use-theme")
                      , d = t.properties.get("color")
                      , m = t.properties.get("intensity")
                      , y = t.properties.get("direction")
                      , M = [y.x, y.y, y.z]
                      , E = "none" === i.properties.get("color-use-theme")
                      , S = i.properties.get("color")
                      , I = i.properties.get("intensity")
                      , R = Math.max(s.ab.vec3.dot([0, 0, 1], M), 0)
                      , D = [0, 0, 0];
                    s.ab.vec3.scale(D, S.toRenderColor(E ? null : c.getLut(t.scope)).toArray01Linear().slice(0, 3), I);
                    const k = [0, 0, 0];
                    return s.ab.vec3.scale(k, d.toRenderColor(h ? null : c.getLut(i.scope)).toArray01Linear().slice(0, 3), R * m),
                    s.cf([D[0] > 0 ? D[0] / (D[0] + k[0]) : 0, D[1] > 0 ? D[1] / (D[1] + k[1]) : 0, D[2] > 0 ? D[2] / (D[2] + k[2]) : 0])
                }
                function Sa(c, t, i, h, d, m) {
                    const y = c.zoom
                      , M = c.scale
                      , E = c.worldSize
                      , S = 1 / E
                      , I = c.aspect
                      , R = Math.sqrt(1 + I * I) * Math.tan(.5 * c.fovX)
                      , D = R * R
                      , k = h - i
                      , H = h + i;
                    let j, Y;
                    D > k / H ? (j = h,
                    Y = h * R) : (j = .5 * H * (1 + D),
                    Y = .5 * Math.sqrt(k * k + 2 * (h * h + i * i) * D + H * H * D * D));
                    const K = c.projection.pixelsPerMeter(c.center.lat, E)
                      , he = c._camera.getCameraToWorldMercator()
                      , Te = [0, 0, -j * S];
                    s.ab.vec3.transformMat4(Te, Te, he);
                    let be = Y * S;
                    const Ue = c._edgeInsets;
                    if (!(0 === Ue.left && 0 === Ue.top && 0 === Ue.right && 0 === Ue.bottom || Ue.left === Ue.right && Ue.top === Ue.bottom)) {
                        const qt = c._camera.getWorldToCamera(c.worldSize, "meters" === c.projection.zAxisUnit ? K : 1)
                          , Ht = c._camera.getCameraToClipPerspective(c._fov, c.width / c.height, i, h);
                        Ht[8] = 2 * -c.centerOffset.x / c.width,
                        Ht[9] = 2 * c.centerOffset.y / c.height;
                        const Dt = new Float64Array(16);
                        s.ab.mat4.mul(Dt, Ht, qt);
                        const bo = new Float64Array(16);
                        s.ab.mat4.invert(bo, Dt);
                        const oo = s.bR.fromInvProjectionMatrix(bo, E, y, !0);
                        for (const Po of oo.points) {
                            const Eo = ((De = Po)[0] /= M,
                            De[1] /= M,
                            De[2] = s.bH(De[2], c._center.lat),
                            De);
                            be = Math.max(be, s.ab.vec3.len(s.ab.vec3.subtract([], Te, Eo)))
                        }
                    }
                    var De;
                    be *= d / (d - 1);
                    const ke = Math.acos(t[2])
                      , Le = Math.atan2(-t[0], -t[1])
                      , Ge = new ea;
                    Ge.position = Te,
                    Ge.setPitchBearing(ke, Le);
                    const qe = Ge.getWorldToCamera(E, K)
                      , vt = be * E
                      , dt = Math.min(c._mercatorZfromZoom(17) * E * -2, -2 * vt)
                      , Ze = Ge.getCameraToClipOrthographic(-vt, vt, -vt, vt, dt, (vt + m * K) / t[2])
                      , nt = new Float64Array(16);
                    s.ab.mat4.multiply(nt, Ze, qe);
                    const zt = s.ab.vec3.fromValues(Math.floor(1e6 * Te[0]) / 1e6 * E, Math.floor(1e6 * Te[1]) / 1e6 * E, 0)
                      , Yt = .5 * d
                      , to = [0, 0, 0];
                    s.ab.vec3.transformMat4(to, zt, nt),
                    s.ab.vec3.scale(to, to, Yt);
                    const ut = [Math.floor(to[0]), Math.floor(to[1]), Math.floor(to[2])]
                      , Gt = [0, 0, 0];
                    s.ab.vec3.sub(Gt, to, ut),
                    s.ab.vec3.scale(Gt, Gt, -1 / Yt);
                    const wt = new Float64Array(16);
                    return s.ab.mat4.identity(wt),
                    s.ab.mat4.translate(wt, wt, Gt),
                    s.ab.mat4.multiply(nt, wt, nt),
                    [nt, vt]
                }
                class su extends s.E {
                    constructor(t) {
                        super(),
                        this.requestManager = t,
                        this.models = {
                            "": {}
                        },
                        this.numModelsLoading = {}
                    }
                    loadModel(t, i) {
                        return s.aM(this.requestManager.transformRequest(i, s.R.Model).url).then(h => {
                            if (!h)
                                return;
                            const d = s.aN(h)
                              , m = new s.aO(t,void 0,void 0,d);
                            return m.computeBoundsAndApplyParent(),
                            m
                        }
                        ).catch(h => {
                            if (h && 404 === h.status)
                                return null;
                            this.fire(new s.y(new Error("Could not load model ".concat(t, " from ").concat(i, ": ").concat(h.message))))
                        }
                        )
                    }
                    load(t, i) {
                        this.models[i] || (this.models[i] = {});
                        const h = Object.keys(t);
                        this.numModelsLoading[i] = (this.numModelsLoading[i] || 0) + h.length;
                        const d = [];
                        for (const m of h)
                            d.push(this.loadModel(m, t[m]));
                        Promise.allSettled(d).then(m => {
                            for (let y = 0; y < m.length; y++) {
                                const {status: M, value: E} = m[y];
                                "fulfilled" === M && E && (this.models[i][h[y]] = {
                                    model: E,
                                    numReferences: 1
                                })
                            }
                            this.numModelsLoading[i] -= h.length,
                            this.fire(new s.z("data",{
                                dataType: "style"
                            }))
                        }
                        ).catch(m => {
                            this.fire(new s.y(new Error("Could not load models: ".concat(m.message))))
                        }
                        )
                    }
                    isLoaded() {
                        for (const t in this.numModelsLoading)
                            if (this.numModelsLoading[t] > 0)
                                return !1;
                        return !0
                    }
                    hasModel(t, i) {
                        return !!this.getModel(t, i)
                    }
                    getModel(t, i) {
                        return this.models[i] || (this.models[i] = {}),
                        this.models[i][t] ? this.models[i][t].model : void 0
                    }
                    addModel(t, i, h) {
                        this.models[h] || (this.models[h] = {}),
                        this.hasModel(t, h) && this.models[h][t].numReferences++,
                        this.load({
                            [t]: this.requestManager.normalizeModelURL(i)
                        }, h)
                    }
                    addModels(t, i) {
                        this.models[i] || (this.models[i] = {});
                        const h = {};
                        for (const d in t)
                            this.models[i][d] = {},
                            h[d] = this.requestManager.normalizeModelURL(t[d]);
                        this.load(h, i)
                    }
                    addModelsFromBucket(t, i) {
                        this.models[i] || (this.models[i] = {});
                        const h = {};
                        for (const d of t)
                            this.hasModel(d, i) ? this.models[i][d].numReferences++ : h[d] = this.requestManager.normalizeModelURL(d);
                        this.load(h, i)
                    }
                    removeModel(t, i) {
                        if (this.models[i] && this.models[i][t] && (this.models[i][t].numReferences--,
                        0 === this.models[i][t].numReferences)) {
                            const h = this.models[i][t].model;
                            delete this.models[i][t],
                            h.destroy()
                        }
                    }
                    listModels(t) {
                        return this.models[t] || (this.models[t] = {}),
                        Object.keys(this.models[t])
                    }
                    upload(t, i) {
                        this.models[i] || (this.models[i] = {});
                        for (const h in this.models[i])
                            this.models[i][h].model && this.models[i][h].model.upload(t.context)
                    }
                }
                const eh = new s.a5({
                    data: new s.a6(s.a3.colorTheme.data)
                })
                  , th = {
                    "mbx-indoor-active-floorplans": {
                        default: ["literal", []]
                    },
                    "mbx-indoor-underground": {
                        default: ["literal", !1]
                    },
                    "mbx-indoor-loaded-levels": {
                        default: ["literal", []]
                    },
                    "mbx-indoor-level-height": {
                        default: ["literal", {}]
                    },
                    "mbx-indoor-level-base": {
                        default: ["literal", {}]
                    },
                    "mbx-indoor-level-selected": {
                        default: ["literal", {}]
                    },
                    "mbx-indoor-level-overlapped": {
                        default: ["literal", {}]
                    }
                };
                function oh(c) {
                    return c = c || {},
                    Object.assign(c, th)
                }
                class au extends s.E {
                    constructor(t) {
                        super(),
                        this.mergeFloors = !0,
                        this._scope = void 0,
                        this._queryFeatureSetId = void 0,
                        this._buildingEntryFeatureSetId = void 0,
                        this._selectedFloorplan = void 0,
                        this._indoorData = void 0,
                        this._selectedLevel = void 0,
                        this._floorplanStates = {},
                        s.aP(["_onLoad", "_onMove", "_checkFloorplanVisible"], this),
                        this._map = t,
                        this._checkFloorplanVisible(!0),
                        this._map.on("load", this._onLoad),
                        this._map.on("move", this._onMove)
                    }
                    destroy() {
                        this._map.indoor.off("load", this._onLoad),
                        this._map.indoor.off("move", this._onMove),
                        this._map = void 0
                    }
                    _onLoad() {
                        this._map.style.forEachFragmentStyle(t => {
                            t.stylesheet.indoor && (this._queryFeatureSetId ? this.fire(new s.y(new Error("Multiple indoor map styles detected, simultaneous usage is not allowed currently."))) : (this._queryFeatureSetId = t.stylesheet.indoor.floorplanFeaturesetId,
                            this._buildingEntryFeatureSetId = t.stylesheet.indoor.buildingFeaturesetId,
                            this._scope = t.scope))
                        }
                        ),
                        this._queryFeatureSetId && this._buildingEntryFeatureSetId && this._map.addInteraction("mbx-indoor-buildingclick", {
                            type: "click",
                            target: {
                                featuresetId: this._buildingEntryFeatureSetId,
                                importId: this._scope
                            },
                            handler: t => (t.feature && t.feature.properties.floorplan && this.selectFloorplan(t.feature.properties.floorplan),
                            !0)
                        }),
                        this._checkFloorplanVisible(!0)
                    }
                    _onMove() {
                        this._checkFloorplanVisible(!1)
                    }
                    _checkFloorplanVisible(t) {
                        if (!this._queryFeatureSetId || !this._map.isStyleLoaded() || this._map.transform.zoom < 13)
                            return;
                        this._indoorData && !function(y, M) {
                            const [E,S] = y
                              , {center: I, radius: R} = M
                              , [D,k] = I
                              , H = Math.abs(E - D);
                            return Math.sqrt((H > 180 ? 360 - H : H) ** 2 + (S - k) ** 2) <= R
                        }([this._map.getCenter().lng, this._map.getCenter().lat], this._indoorData.circumCircle) && (this._indoorData = void 0,
                        this._selectedFloorplan = void 0,
                        this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !1),
                        this._map.setConfigProperty(this._scope, "mbx-indoor-active-floorplans", ["literal", []]),
                        this.fire(new s.z("floorplangone")));
                        const i = {
                            target: {
                                featuresetId: this._queryFeatureSetId,
                                importId: this._scope
                            }
                        }
                          , h = new s.P(this._map.transform.width / 2,this._map.transform.height / 2)
                          , d = [new s.P(0,0), new s.P(this._map.transform.width,this._map.transform.height)]
                          , m = this._map.queryRenderedFeatures(t ? d : h, i);
                        m.length > 0 && (this._selectedFloorplan && m[0].properties.id === this._selectedFloorplan.properties.id || (this._selectedFloorplan = m[0],
                        this._floorplanSelected(!1)))
                    }
                    _floorplanSelected(t) {
                        this._indoorData = JSON.parse(this._selectedFloorplan.properties["indoor-data"]),
                        this._indoorData.id = this._selectedFloorplan.properties.id,
                        this._indoorData.circumCircle = function(m) {
                            const [[y,M],[E,S]] = m
                              , I = (E - y + 360) % 360
                              , R = I > 180 ? 360 - I : I;
                            return {
                                center: [(y + R / 2 + 360) % 360, (M + S) / 2],
                                radius: Math.sqrt(R ** 2 + (S - M) ** 2) / 2
                            }
                        }(this._indoorData.extent),
                        this._floorplanStates[this._indoorData.id] || (this._floorplanStates[this._indoorData.id] = {});
                        const i = this._floorplanStates[this._indoorData.id].selectedBuilding
                          , h = this._floorplanStates[this._indoorData.id].selectedLevel;
                        let d;
                        if (this._map.setConfigProperty(this._scope, "mbx-indoor-active-floorplans", this._indoorData.floorplanIDs),
                        this._selectedLevel)
                            for (const m of this._indoorData.levels)
                                m.id === this._selectedLevel.id && (d = m.id);
                        if (this.fire(new s.z("floorplanselected",{
                            buildings: this._indoorData.buildings,
                            levels: this._indoorData.levels,
                            selectedLevelId: d
                        })),
                        i) {
                            const m = this._indoorData.buildings.find(y => y.id === i);
                            this._buildingSelected(m, !1)
                        } else
                            this._indoorData.buildings.length > 0 && this._buildingSelected(this._indoorData.buildings[0], !1);
                        if (h) {
                            const m = this._indoorData.levels.find(y => y.id === h);
                            this._updateLevels(m, t)
                        } else
                            t && this._indoorData["default-levels"].length > 0 && this.selectLevel(this._indoorData["default-levels"][0])
                    }
                    _buildingSelected(t, i) {
                        i && t && t.extent && this._map.fitBounds(t.extent, {
                            pitch: this._map.getPitch(),
                            bearing: this._map.getBearing()
                        }),
                        this._floorplanStates[this._indoorData.id].selectedBuilding = t ? t.id : void 0;
                        const h = this._indoorData.levels.filter(d => t.levels.includes(d.id));
                        this.fire(new s.z("buildingselected",{
                            buildingId: t.id,
                            levels: h
                        }))
                    }
                    _levelSelected(t) {
                        if ("overview" === t)
                            this._updateLevels(void 0, !0);
                        else {
                            const i = this._indoorData.levels.find(h => h.id === t);
                            this._updateLevels(i, !0)
                        }
                        this.fire(new s.z("levelselected",{
                            levelId: "overview" === t ? void 0 : t
                        }))
                    }
                    _updateLevels(t, i) {
                        if (!t)
                            return this._map.setConfigProperty(this._scope, "mbx-indoor-loaded-levels", ["literal", []]),
                            this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !1),
                            this._floorplanStates[this._indoorData.id].selectedLevel = void 0,
                            void (i && this._indoorData.extent && this._map.fitBounds(this._indoorData.extent, {
                                pitch: this._map.getPitch(),
                                bearing: this._map.getBearing()
                            }));
                        function h(S) {
                            const I = S.indexOf("/floor/");
                            if (-1 === I)
                                return S;
                            const R = I + 7
                              , D = S.indexOf("/", R);
                            return -1 === D ? S.slice(R) : S.slice(R, D)
                        }
                        this._selectedLevel = t,
                        this._floorplanStates[this._indoorData.id].selectedLevel = t ? t.id : void 0;
                        const d = []
                          , m = {}
                          , y = {}
                          , M = {}
                          , E = {};
                        for (const S of this._indoorData.levels)
                            if (d.push(S.id),
                            m[S.id] = S.height,
                            y[S.id] = S.base,
                            t) {
                                if (this.mergeFloors) {
                                    const I = h(t.id)
                                      , R = h(S.id);
                                    M[S.id] = R === I ? "true" : "false"
                                } else
                                    M[S.id] = S.id === t.id ? "true" : "false";
                                E[S.id] = S.base < t.base ? "true" : "false"
                            } else
                                E[S.id] = !0;
                        if (this._map.setConfigProperty(this._scope, "mbx-indoor-loaded-levels", ["literal", d]),
                        this._map.setConfigProperty(this._scope, "mbx-indoor-level-height", ["literal", m]),
                        this._map.setConfigProperty(this._scope, "mbx-indoor-level-base", ["literal", y]),
                        this._map.setConfigProperty(this._scope, "mbx-indoor-level-selected", ["literal", M]),
                        this._map.setConfigProperty(this._scope, "mbx-indoor-level-overlapped", ["literal", E]),
                        t && (this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !!t.isUnderground),
                        i && t.extent)) {
                            const S = this._map.cameraForBounds(t.extent, {
                                pitch: this._map.getPitch(),
                                bearing: this._map.getBearing()
                            })
                              , I = this._map.getZoom()
                              , R = S.zoom ? Math.abs(I - S.zoom) : 0;
                            this._map.fitBounds(t.extent, R >= 1 ? {
                                pitch: this._map.getPitch(),
                                bearing: this._map.getBearing()
                            } : {
                                pitch: this._map.getPitch(),
                                bearing: this._map.getBearing(),
                                zoom: I
                            })
                        }
                    }
                    selectFloorplan(t) {
                        const i = {
                            target: {
                                featuresetId: this._queryFeatureSetId,
                                importId: this._scope
                            }
                        }
                          , h = [new s.P(0,0), new s.P(this._map.transform.width,this._map.transform.height)]
                          , d = this._map.queryRenderedFeatures(h, i);
                        if (d.length > 0)
                            for (const m of d)
                                if (JSON.parse(m.properties["indoor-data"]).floorplanIDs.includes(t)) {
                                    this._selectedFloorplan = m,
                                    this._floorplanSelected(!0);
                                    break
                                }
                    }
                    selectBuilding(t) {
                        const i = this._indoorData.buildings.find(h => h.id === t);
                        this._buildingSelected(i, !0)
                    }
                    selectLevel(t) {
                        this._levelSelected(t)
                    }
                }
                function lu(c) {
                    if (!c.metadata || !c.metadata.content_area)
                        return;
                    const t = s.q.devicePixelRatio
                      , {left: i, top: h, width: d, height: m} = c.metadata.content_area
                      , y = i * t
                      , M = h * t;
                    return [y, M, y + d * t, M + m * t]
                }
                function al(c) {
                    if (c)
                        return c.map( ([t,i]) => [t * s.q.devicePixelRatio, i * s.q.devicePixelRatio])
                }
                const ia = (c, t) => q(c, t && t.filter(i => "source.canvas" !== i.identifier))
                  , cu = s.ay(xi, ["addLayer", "removeLayer", "setLights", "setPaintProperty", "setLayoutProperty", "setSlot", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setSnow", "setRain", "setProjection", "setCamera", "addImport", "removeImport", "updateImport"])
                  , dp = s.ay(xi, ["setCenter", "setZoom", "setBearing", "setPitch"])
                  , Zl = new Set(["background", "sky", "slot", "custom"])
                  , ih = {
                    version: 8,
                    layers: [],
                    sources: {}
                }
                  , nh = {
                    duration: 300,
                    delay: 0
                };
                class pr extends s.E {
                    constructor(t, i={}) {
                        super(),
                        this.map = t,
                        this.scope = i.scope || "",
                        this.globalId = null,
                        this.fragments = [],
                        this.importDepth = i.importDepth || 0,
                        this.importsCache = i.importsCache || new Map,
                        this.resolvedImports = i.resolvedImports || new Set,
                        this.transition = s.l({}, nh),
                        this._buildingIndex = new pp(this),
                        this.crossTileSymbolIndex = new Yl,
                        this._mergedOrder = [],
                        this._drapedFirstOrder = [],
                        this._mergedLayers = {},
                        this._mergedSourceCaches = {},
                        this._mergedOtherSourceCaches = {},
                        this._mergedSymbolSourceCaches = {},
                        this._clipLayerPresent = !1,
                        this._has3DLayers = !1,
                        this._hasCircleLayers = !1,
                        this._hasSymbolLayers = !1,
                        this._changes = i.styleChanges || new St,
                        this.dispatcher = i.dispatcher ? i.dispatcher : new s.D(s.ci(),this),
                        i.imageManager ? this.imageManager = i.imageManager : (this.imageManager = new $t(this.map._spriteFormat),
                        this.imageManager.setEventedParent(this)),
                        this.imageManager.createScope(this.scope),
                        this.glyphManager = i.glyphManager ? i.glyphManager : new s.cj(t._requestManager,i.localFontFamily ? s.ck.all : i.localIdeographFontFamily ? s.ck.ideographs : s.ck.none,i.localFontFamily || i.localIdeographFontFamily),
                        i.modelManager ? this.modelManager = i.modelManager : (this.modelManager = new su(t._requestManager),
                        this.modelManager.setEventedParent(this)),
                        this._layers = {},
                        this._sourceCaches = {},
                        this._otherSourceCaches = {},
                        this._symbolSourceCaches = {},
                        this._loaded = !1,
                        this._precompileDone = !1,
                        this._shouldPrecompile = !1,
                        this._availableImages = [],
                        this._order = [],
                        this._markersNeedUpdate = !1,
                        this.options = i.configOptions ? i.configOptions : new Map,
                        this._configDependentLayers = i.configDependentLayers ? i.configDependentLayers : new Set,
                        this._config = i.config,
                        this._styleColorTheme = {
                            lut: null,
                            lutLoading: !1,
                            lutLoadingCorrelationID: 0,
                            colorTheme: null,
                            colorThemeOverride: i.colorThemeOverride
                        },
                        this._styleColorThemeForScope = {},
                        this._initialConfig = i.initialConfig,
                        this.dispatcher.broadcast("setReferrer", s.cl());
                        const h = this;
                        this._rtlTextPluginCallback = pr.registerForPluginStateChange(d => {
                            h.dispatcher.broadcast("syncRTLPluginState", {
                                pluginStatus: d.pluginStatus,
                                pluginURL: d.pluginURL
                            }, (m, y) => {
                                if (s.cm(m),
                                y && y.every(M => M))
                                    for (const M in h._sourceCaches) {
                                        const E = h._sourceCaches[M]
                                          , S = E.getSource().type;
                                        "vector" !== S && "geojson" !== S || E.reload()
                                    }
                            }
                            )
                        }
                        ),
                        this.on("data", d => {
                            if ("source" !== d.dataType || "metadata" !== d.sourceDataType)
                                return;
                            const m = this.getOwnSource(d.sourceId);
                            if (m && m.vectorLayerIds)
                                for (const y in this._layers) {
                                    const M = this._layers[y];
                                    M.source === m.id && this._validateLayer(M)
                                }
                        }
                        )
                    }
                    load(t) {
                        return t ? ("string" == typeof t ? this.loadURL(t) : this.loadJSON(t),
                        this) : this
                    }
                    _getGlobalId(t) {
                        if (!t)
                            return null;
                        if ("string" == typeof t) {
                            if (s.f(t))
                                return t;
                            const i = s.cn(t);
                            if (!i.startsWith("http"))
                                try {
                                    return new URL(i,location.href).toString()
                                } catch {
                                    return i
                                }
                            return i
                        }
                        return "json://".concat(s.co(JSON.stringify(t)))
                    }
                    _diffStyle(t, i, h) {
                        this.globalId = this._getGlobalId(t);
                        const d = (m, y) => {
                            try {
                                y(null, this.setState(m, h))
                            } catch (M) {
                                y(M, !1)
                            }
                        }
                        ;
                        if ("string" == typeof t) {
                            const m = this.map._requestManager.normalizeStyleURL(t)
                              , y = this.map._requestManager.transformRequest(m, s.R.Style);
                            s.n(y, (M, E) => {
                                M ? this.fire(new s.y(M)) : E && d(E, i)
                            }
                            )
                        } else
                            "object" == typeof t && d(t, i)
                    }
                    loadURL(t, i={}) {
                        this.fire(new s.z("dataloading",{
                            dataType: "style"
                        }));
                        const h = "boolean" == typeof i.validate ? i.validate : !s.f(t);
                        this.globalId = this._getGlobalId(t),
                        t = this.map._requestManager.normalizeStyleURL(t, i.accessToken),
                        this.resolvedImports.add(t);
                        const d = this.importsCache.get(t);
                        if (d)
                            return this._load(d, h);
                        const m = this.map._requestManager.transformRequest(t, s.R.Style);
                        this._request = s.n(m, (y, M) => {
                            if (this._request = null,
                            y)
                                this.fire(new s.y(y));
                            else if (M)
                                return this.importsCache.set(t, M),
                                this._load(M, h)
                        }
                        )
                    }
                    loadJSON(t, i={}) {
                        this.fire(new s.z("dataloading",{
                            dataType: "style"
                        })),
                        this.globalId = this._getGlobalId(t),
                        this._request = s.q.frame( () => {
                            this._request = null,
                            this._load(t, !1 !== i.validate)
                        }
                        )
                    }
                    loadEmpty() {
                        this.fire(new s.z("dataloading",{
                            dataType: "style"
                        })),
                        this._load(ih, !1)
                    }
                    _loadImports(t, i, h) {
                        if (this.importDepth >= 4)
                            return s.w("Style doesn't support nesting deeper than 5"),
                            Promise.resolve();
                        const d = [];
                        for (const m of t) {
                            const y = this._createFragmentStyle(m)
                              , M = new Promise(I => {
                                y.once("style.import.load", I),
                                y.once("error", I)
                            }
                            ).then( () => this.mergeAll());
                            if (d.push(M),
                            this.resolvedImports.has(m.url)) {
                                y.loadEmpty();
                                continue
                            }
                            const E = m.data || this.importsCache.get(m.url);
                            E ? (y.loadJSON(E, {
                                validate: i
                            }),
                            this._isInternalStyle(E) && (y.globalId = null)) : m.url ? y.loadURL(m.url, {
                                validate: i
                            }) : y.loadEmpty();
                            const S = {
                                style: y,
                                id: m.id,
                                config: m.config
                            };
                            if (h) {
                                const I = this.fragments.findIndex( ({id: R}) => R === h);
                                this.fragments = this.fragments.slice(0, I).concat(S).concat(this.fragments.slice(I))
                            } else
                                this.fragments.push(S)
                        }
                        return Promise.allSettled(d)
                    }
                    getImportGlobalIds(t=this, i=new Set) {
                        for (const h of t.fragments)
                            h.style.globalId && i.add(h.style.globalId),
                            this.getImportGlobalIds(h.style, i);
                        return [...i.values()]
                    }
                    _createFragmentStyle(t) {
                        const i = this.scope ? s.aC(t.id, this.scope) : t.id;
                        let h;
                        const d = this._initialConfig && this._initialConfig[i];
                        (t.config || d) && (h = s.l({}, t.config, d));
                        const m = new pr(this.map,{
                            scope: i,
                            styleChanges: this._changes,
                            importDepth: this.importDepth + 1,
                            importsCache: this.importsCache,
                            resolvedImports: new Set(this.resolvedImports),
                            dispatcher: this.dispatcher,
                            imageManager: this.imageManager,
                            glyphManager: this.glyphManager,
                            modelManager: this.modelManager,
                            config: h,
                            configOptions: this.options,
                            colorThemeOverride: t["color-theme"],
                            configDependentLayers: this._configDependentLayers
                        });
                        return m.setEventedParent(this.map, {
                            style: m
                        }),
                        m
                    }
                    _reloadImports() {
                        this.mergeAll(),
                        this._updateMapProjection(),
                        this.updateConfigDependencies(),
                        this.map._triggerCameraUpdate(this.camera),
                        this.dispatcher.broadcast("setLayers", {
                            layers: this._serializeLayers(this._order),
                            scope: this.scope,
                            options: this.options
                        }),
                        this._shouldPrecompile = this.map._precompilePrograms && this.isRootStyle()
                    }
                    _isInternalStyle(t) {
                        return this.isRootStyle() && (t.fragment || !!t.schema && !1 !== t.fragment)
                    }
                    _load(t, i) {
                        const h = t.indoor ? oh(t.schema) : t.schema;
                        if (this._isInternalStyle(t)) {
                            const y = s.l({}, ih, {
                                imports: [{
                                    id: "basemap",
                                    data: t,
                                    url: ""
                                }]
                            });
                            return void this._load(y, i)
                        }
                        if (this.updateConfig(this._config, h),
                        i && ia(this, ci(t)))
                            return;
                        this._loaded = !0,
                        this.stylesheet = s.cp(t);
                        const d = () => {
                            for (const S in t.sources)
                                this.addSource(S, t.sources[S], {
                                    validate: !1,
                                    isInitialLoad: !0
                                });
                            t.sprite ? this._loadIconset(t.sprite) : (this.imageManager.setLoaded(!0, this.scope),
                            this.dispatcher.broadcast("spriteLoaded", {
                                scope: this.scope,
                                isLoaded: !0
                            })),
                            this.glyphManager.setURL(t.glyphs, this.scope);
                            const y = Vl(this.stylesheet.layers);
                            if (this._order = y.map(S => S.id),
                            this.stylesheet.light && s.w("The `light` root property is deprecated, prefer using `lights` with `flat` light type instead."),
                            this.stylesheet.lights)
                                if (1 === this.stylesheet.lights.length && "flat" === this.stylesheet.lights[0].type) {
                                    const S = this.stylesheet.lights[0];
                                    this.light = new Se(S.properties,S.id)
                                } else
                                    this.setLights(this.stylesheet.lights);
                            this.light || (this.light = new Se(this.stylesheet.light)),
                            this._layers = {};
                            for (const S of y) {
                                const I = s.cu(S, this.scope, this._styleColorTheme.lut, this.options);
                                0 !== I.configDependencies.size && this._configDependentLayers.add(I.fqid),
                                I.setEventedParent(this, {
                                    layer: {
                                        id: I.id
                                    }
                                }),
                                this._layers[I.id] = I;
                                const R = this.getOwnLayerSourceCache(I)
                                  , D = !!this.directionalLight && this.directionalLight.shadowsEnabled();
                                R && I.canCastShadows() && D && (R.castsShadows = !0)
                            }
                            this.stylesheet.featuresets && this.setFeaturesetSelectors(this.stylesheet.featuresets),
                            this.stylesheet.models && this.modelManager.addModels(this.stylesheet.models, this.scope);
                            const M = this.stylesheet.terrain;
                            M && (this.checkCanvasFingerprintNoise(),
                            this.disableElevatedTerrain || this.terrainSetForDrapingOnly() || this._createTerrain(M, 1)),
                            this.stylesheet.fog && this._createFog(this.stylesheet.fog),
                            this.stylesheet.snow && this._createSnow(this.stylesheet.snow),
                            this.stylesheet.rain && this._createRain(this.stylesheet.rain),
                            this.stylesheet.transition && this.setTransition(this.stylesheet.transition),
                            this.fire(new s.z("data",{
                                dataType: "style"
                            }));
                            const E = this.isRootStyle();
                            t.imports ? this._loadImports(t.imports, i).then( () => {
                                this._reloadImports(),
                                this.fire(new s.z(E ? "style.load" : "style.import.load"))
                            }
                            ) : (this._reloadImports(),
                            this.fire(new s.z(E ? "style.load" : "style.import.load")))
                        }
                        ;
                        this._styleColorTheme.colorTheme = this.stylesheet["color-theme"];
                        const m = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
                        if (m) {
                            const y = this._evaluateColorThemeData(m);
                            this._loadColorTheme(y).then( () => {
                                d()
                            }
                            ).catch(M => {
                                s.w("Couldn't load color theme from the stylesheet: ".concat(M)),
                                d()
                            }
                            )
                        } else
                            this._styleColorTheme.lut = null,
                            d()
                    }
                    isRootStyle() {
                        return 0 === this.importDepth
                    }
                    mergeAll() {
                        let t, i, h, d, m, y, M, E, S, I;
                        const R = {};
                        this.terrain && this.terrain.scope !== this.scope && delete this.terrain,
                        this.forEachFragmentStyle(D => {
                            if (D.stylesheet) {
                                if (null != D.light && (t = D.light),
                                D.stylesheet.lights)
                                    for (const k of D.stylesheet.lights)
                                        "ambient" === k.type && null != D.ambientLight && (i = D.ambientLight),
                                        "directional" === k.type && null != D.directionalLight && (h = D.directionalLight);
                                d = this._prioritizeTerrain(d, D.terrain, D.stylesheet.terrain),
                                D.stylesheet.fog && null != D.fog && (m = D.fog),
                                D.stylesheet.snow && null != D.snow && (y = D.snow),
                                D.stylesheet.rain && null != D.rain && (M = D.rain),
                                null != D.stylesheet.camera && (I = D.stylesheet.camera),
                                null != D.stylesheet.projection && (E = D.stylesheet.projection),
                                null != D.stylesheet.transition && (S = D.stylesheet.transition),
                                R[D.scope] = D._styleColorTheme
                            }
                        }
                        ),
                        this.light = t,
                        this.ambientLight = i,
                        this.directionalLight = h,
                        this.fog = m,
                        this.snow = y,
                        this.rain = M,
                        this._styleColorThemeForScope = R,
                        null === d ? delete this.terrain : this.terrain = d,
                        this.camera = I || {
                            "camera-projection": "perspective"
                        },
                        this.projection = E || {
                            name: "mercator"
                        },
                        this.transition = s.l({}, nh, S),
                        this.mergeSources(),
                        this.mergeLayers()
                    }
                    forEachFragmentStyle(t) {
                        const i = h => {
                            for (const d of h.fragments)
                                i(d.style);
                            t(h)
                        }
                        ;
                        i(this)
                    }
                    _prioritizeTerrain(t, i, h) {
                        const d = t && 0 === t.drapeRenderMode;
                        return null === h ? i && 0 === i.drapeRenderMode ? i : d ? t : null : null != i && (!t || d || i && 1 === i.drapeRenderMode) ? i : t
                    }
                    mergeTerrain() {
                        let t;
                        this.terrain && this.terrain.scope !== this.scope && delete this.terrain,
                        this.forEachFragmentStyle(i => {
                            t = this._prioritizeTerrain(t, i.terrain, i.stylesheet.terrain)
                        }
                        ),
                        null === t ? delete this.terrain : this.terrain = t
                    }
                    mergeProjection() {
                        let t;
                        this.forEachFragmentStyle(i => {
                            null != i.stylesheet.projection && (t = i.stylesheet.projection)
                        }
                        ),
                        this.projection = t || {
                            name: "mercator"
                        }
                    }
                    mergeSources() {
                        const t = {}
                          , i = {}
                          , h = {};
                        this.forEachFragmentStyle(d => {
                            for (const m in d._sourceCaches) {
                                const y = s.aC(m, d.scope);
                                t[y] = d._sourceCaches[m]
                            }
                            for (const m in d._otherSourceCaches) {
                                const y = s.aC(m, d.scope);
                                i[y] = d._otherSourceCaches[m]
                            }
                            for (const m in d._symbolSourceCaches) {
                                const y = s.aC(m, d.scope);
                                h[y] = d._symbolSourceCaches[m]
                            }
                        }
                        ),
                        this._mergedSourceCaches = t,
                        this._mergedOtherSourceCaches = i,
                        this._mergedSymbolSourceCaches = h
                    }
                    mergeLayers() {
                        const t = {}
                          , i = []
                          , h = {};
                        this._mergedSlots = [],
                        this._has3DLayers = !1,
                        this._hasCircleLayers = !1,
                        this._hasSymbolLayers = !1,
                        this.forEachFragmentStyle(m => {
                            for (const y of m._order) {
                                const M = m._layers[y];
                                if ("slot" === M.type) {
                                    const E = s.cq(y);
                                    if (t[E])
                                        continue;
                                    t[E] = []
                                }
                                M.slot && t[M.slot] ? t[M.slot].push(M) : i.push(M)
                            }
                        }
                        ),
                        this._mergedOrder = [];
                        const d = (m=[]) => {
                            for (const y of m)
                                if ("slot" === y.type) {
                                    const M = s.cq(y.id);
                                    t[M] && d(t[M]),
                                    this._mergedSlots.push(M)
                                } else {
                                    const M = s.aC(y.id, y.scope);
                                    this._mergedOrder.push(M),
                                    h[M] = y,
                                    y.is3D() && (this._has3DLayers = !0),
                                    "circle" === y.type && (this._hasCircleLayers = !0),
                                    "symbol" === y.type && (this._hasSymbolLayers = !0),
                                    "clip" === y.type && (this._clipLayerPresent = !0)
                                }
                        }
                        ;
                        d(i),
                        this._mergedOrder.sort( (m, y) => {
                            const M = h[m]
                              , E = h[y];
                            return M.hasInitialOcclusionOpacityProperties ? E.is3D() ? 1 : 0 : M.is3D() && E.hasInitialOcclusionOpacityProperties ? -1 : 0
                        }
                        ),
                        this._mergedLayers = h,
                        this.updateDrapeFirstLayers(),
                        this._buildingIndex.processLayersChanged()
                    }
                    terrainSetForDrapingOnly() {
                        return !!this.terrain && 0 === this.terrain.drapeRenderMode
                    }
                    getCamera() {
                        return this.stylesheet.camera
                    }
                    setCamera(t) {
                        return this.stylesheet.camera = s.l({}, this.stylesheet.camera, t),
                        this.camera = this.stylesheet.camera,
                        this
                    }
                    _evaluateColorThemeData(t) {
                        return t.data ? function(i, h, d) {
                            const m = s.l({}, h);
                            for (const M of Object.keys(s.a3.colorTheme))
                                void 0 === m[M] && (m[M] = s.a3.colorTheme[M].default);
                            const y = new s.a4(eh,i,new Map(d));
                            return y.setTransitionOrValue(m, d),
                            y.untransitioned().possiblyEvaluate(new s.a8(0))
                        }(this.scope, t, this.options).get("data") : null
                    }
                    _loadColorTheme(t) {
                        this._styleColorTheme.lutLoading = !0,
                        this._styleColorTheme.lutLoadingCorrelationID += 1;
                        const i = this._styleColorTheme.lutLoadingCorrelationID;
                        return new Promise( (h, d) => {
                            const m = "data:image/png;base64,";
                            if (!t || 0 === t.length)
                                return this._styleColorTheme.lut = null,
                                this._styleColorTheme.lutLoading = !1,
                                void h();
                            let y = t;
                            y.startsWith(m) || (y = m + y);
                            const M = "mapbox-reserved-lut"
                              , E = new Image;
                            E.src = y,
                            E.onerror = () => {
                                this._styleColorTheme.lutLoading = !1,
                                d(new Error("Failed to load image data"))
                            }
                            ,
                            E.onload = () => {
                                if (this._styleColorTheme.lutLoadingCorrelationID !== i)
                                    return void h();
                                this._styleColorTheme.lutLoading = !1;
                                const {width: S, height: I, data: R} = s.q.getImageData(E);
                                if (I > 32)
                                    return void d(new Error("The height of the image must be less than or equal to 32 pixels."));
                                if (S !== I * I)
                                    return void d(new Error("The width of the image must be equal to the height squared."));
                                this.getImage(M) && this.removeImage(M),
                                this.addImage(M, {
                                    data: new s.r({
                                        width: S,
                                        height: I
                                    },R),
                                    pixelRatio: 1,
                                    sdf: !1,
                                    usvg: !1,
                                    version: 0
                                });
                                const D = this.imageManager.getImage(M, this.scope);
                                D ? (this._styleColorTheme.lut = {
                                    image: D.data,
                                    data: t
                                },
                                h()) : d(new Error("Missing LUT image."))
                            }
                        }
                        )
                    }
                    getLut(t) {
                        const i = this._styleColorThemeForScope[t];
                        return i ? i.lut : null
                    }
                    setProjection(t) {
                        t ? this.stylesheet.projection = t : delete this.stylesheet.projection,
                        this.mergeProjection(),
                        this._updateMapProjection()
                    }
                    applyProjectionUpdate() {
                        this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions),
                        this.map.transform.projection.requiresDraping ? (this.getTerrain() || this.stylesheet.terrain) && !this.disableElevatedTerrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null, 0))
                    }
                    _updateMapProjection() {
                        this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection))
                    }
                    _loadSprite(t) {
                        this._spriteRequest = function(i, h, d) {
                            let m, y, M;
                            const E = s.q.devicePixelRatio > 1 ? "@2x" : "";
                            let S = s.n(h.transformRequest(h.normalizeSpriteURL(i, E, ".json"), s.R.SpriteJSON), (D, k) => {
                                S = null,
                                M || (M = D,
                                m = k,
                                R())
                            }
                            )
                              , I = s.o(h.transformRequest(h.normalizeSpriteURL(i, E, ".png"), s.R.SpriteImage), (D, k) => {
                                I = null,
                                M || (M = D,
                                y = k,
                                R())
                            }
                            );
                            function R() {
                                if (M)
                                    d(M);
                                else if (m && y) {
                                    const D = s.q.getImageData(y)
                                      , k = {};
                                    for (const H in m) {
                                        const {width: j, height: Y, x: K, y: he, sdf: Te, pixelRatio: be, stretchX: Ue, stretchY: De, content: ke} = m[H]
                                          , Le = new s.r({
                                            width: j,
                                            height: Y
                                        });
                                        s.r.copy(D, Le, {
                                            x: K,
                                            y: he
                                        }, {
                                            x: 0,
                                            y: 0
                                        }, {
                                            width: j,
                                            height: Y
                                        }, null),
                                        k[H] = {
                                            data: Le,
                                            pixelRatio: be,
                                            sdf: Te,
                                            stretchX: Ue,
                                            stretchY: De,
                                            content: ke,
                                            usvg: !1
                                        }
                                    }
                                    d(null, k)
                                }
                            }
                            return {
                                cancel() {
                                    S && (S.cancel(),
                                    S = null),
                                    I && (I.cancel(),
                                    I = null)
                                }
                            }
                        }(t, this.map._requestManager, (i, h) => {
                            if (this._spriteRequest = null,
                            i)
                                this.fire(new s.y(i));
                            else if (h)
                                for (const d in h)
                                    this.imageManager.addImage(d, this.scope, h[d]);
                            this.imageManager.setLoaded(!0, this.scope),
                            this._availableImages = this.imageManager.listImages(this.scope),
                            this.dispatcher.broadcast("setImages", {
                                scope: this.scope,
                                images: this._availableImages
                            }),
                            this.dispatcher.broadcast("spriteLoaded", {
                                scope: this.scope,
                                isLoaded: !0
                            }),
                            this.fire(new s.z("data",{
                                dataType: "style"
                            }))
                        }
                        )
                    }
                    _loadIconset(t) {
                        if (!s.f(t) && "icon_set" !== this.map._spriteFormat || "raster" === this.map._spriteFormat)
                            return void this._loadSprite(t);
                        const i = "auto" === this.map._spriteFormat;
                        var h, d;
                        this._spriteRequest = (d = (m, y) => {
                            if (this._spriteRequest = null,
                            m)
                                i ? this._loadSprite(t) : this.fire(new s.y(m));
                            else if (y)
                                for (const M in y)
                                    this.imageManager.addImage(M, this.scope, y[M]);
                            this.imageManager.setLoaded(!0, this.scope),
                            this._availableImages = this.imageManager.listImages(this.scope),
                            this.dispatcher.broadcast("setImages", {
                                scope: this.scope,
                                images: this._availableImages
                            }),
                            this.dispatcher.broadcast("spriteLoaded", {
                                scope: this.scope,
                                isLoaded: !0
                            }),
                            this.fire(new s.z("data",{
                                dataType: "style"
                            }))
                        }
                        ,
                        s.bi((h = this.map._requestManager).transformRequest(h.normalizeIconsetURL(t), s.R.Iconset), (m, y) => {
                            if (m)
                                return void d(m);
                            const M = {}
                              , E = s.cg(new s.bh(y));
                            for (const S of E.icons) {
                                const I = {
                                    version: 1,
                                    pixelRatio: s.q.devicePixelRatio,
                                    content: lu(S),
                                    stretchX: S.metadata ? al(S.metadata.stretch_x_areas) : void 0,
                                    stretchY: S.metadata ? al(S.metadata.stretch_y_areas) : void 0,
                                    sdf: !1,
                                    usvg: !0,
                                    icon: S
                                };
                                M[S.name] = I
                            }
                            d(null, M)
                        }
                        ))
                    }
                    _validateLayer(t) {
                        const i = this.getOwnSource(t.source);
                        if (!i)
                            return;
                        const h = t.sourceLayer;
                        h && ("geojson" === i.type || i.vectorLayerIds && -1 === i.vectorLayerIds.indexOf(h)) && this.fire(new s.y(new Error('Source layer "'.concat(h, '" does not exist on source "').concat(i.id, '" as specified by style layer "').concat(t.id, '"'))))
                    }
                    loaded() {
                        if (!this._loaded || Object.keys(this._changes.getUpdatedSourceCaches()).length)
                            return !1;
                        for (const t in this._sourceCaches)
                            if (!this._sourceCaches[t].loaded())
                                return !1;
                        if (!this.imageManager.isLoaded() || !this.modelManager.isLoaded() || this._styleColorTheme.lutLoading)
                            return !1;
                        for (const {style: t} of this.fragments)
                            if (!t.loaded())
                                return !1;
                        return !0
                    }
                    _serializeImports() {
                        if (this.stylesheet.imports)
                            return this.stylesheet.imports.map( (t, i) => {
                                const h = this.fragments[i];
                                return h && h.style && (t.data = h.style.serialize()),
                                t
                            }
                            )
                    }
                    _serializeSources() {
                        const t = {};
                        for (const i in this._sourceCaches) {
                            const h = this._sourceCaches[i].getSource();
                            t[h.id] || (t[h.id] = h.serialize())
                        }
                        return t
                    }
                    _serializeLayers(t) {
                        const i = [];
                        for (const h of t) {
                            const d = this._layers[h];
                            d && "custom" !== d.type && i.push(d.serialize())
                        }
                        return i
                    }
                    hasLightTransitions() {
                        return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition())
                    }
                    hasFogTransition() {
                        return !!this.fog && this.fog.hasTransition()
                    }
                    hasSnowTransition() {
                        return !!this.snow && this.snow.hasTransition()
                    }
                    hasRainTransition() {
                        return !!this.rain && this.rain.hasTransition()
                    }
                    hasTransitions() {
                        if (this.hasLightTransitions() || this.hasFogTransition() || this.hasSnowTransition() || this.hasRainTransition())
                            return !0;
                        for (const t in this._sourceCaches)
                            if (this._sourceCaches[t].hasTransition())
                                return !0;
                        for (const t in this._layers)
                            if (this._layers[t].hasTransition())
                                return !0;
                        return !1
                    }
                    get order() {
                        return this.terrain ? this._drapedFirstOrder : this._mergedOrder
                    }
                    _getOrder(t) {
                        return t ? this.order : this._mergedOrder
                    }
                    isLayerDraped(t) {
                        return !!this.terrain && t.isDraped(this.getLayerSourceCache(t))
                    }
                    _checkLoaded() {
                        if (!this._loaded)
                            throw new Error("Style is not done loading")
                    }
                    _checkLayer(t) {
                        const i = this.getOwnLayer(t);
                        if (i)
                            return i;
                        this.fire(new s.y(new Error("The layer '".concat(t, "' does not exist in the map's style."))))
                    }
                    _checkSource(t) {
                        const i = this.getOwnSource(t);
                        if (i)
                            return i;
                        this.fire(new s.y(new Error("The source '".concat(t, "' does not exist in the map's style."))))
                    }
                    precompilePrograms(t, i) {
                        const h = this.map.painter;
                        if (h)
                            for (let d = t.minzoom || 0; d < (t.maxzoom || 25.5); d++) {
                                const m = t.getProgramIds();
                                if (m)
                                    for (const y of m) {
                                        const M = t.getDefaultProgramParams(y, i.zoom, this._styleColorTheme.lut);
                                        M && (h.style = this,
                                        this.fog && (h._fogVisible = !0,
                                        M.overrideFog = !0,
                                        h.getOrCreateProgram(y, M)),
                                        h._fogVisible = !1,
                                        M.overrideFog = !1,
                                        h.getOrCreateProgram(y, M),
                                        (this.stylesheet.terrain || this.stylesheet.projection && "globe" === this.stylesheet.projection.name) && (M.overrideRtt = !0,
                                        h.getOrCreateProgram(y, M)))
                                    }
                            }
                    }
                    update(t) {
                        if (!this._loaded)
                            return;
                        this.ambientLight && this.ambientLight.recalculate(t),
                        this.directionalLight && this.directionalLight.recalculate(t);
                        const i = this.calculateLightsBrightness();
                        t.brightness = i || 0,
                        i !== this._brightness && (this._brightness = i,
                        this.dispatcher.broadcast("setBrightness", i));
                        const h = this._changes.isDirty();
                        let d = !1;
                        if (this._changes.isDirty()) {
                            const y = this._changes.getLayerUpdatesByScope();
                            for (const M in y) {
                                const {updatedIds: E, removedIds: S} = y[M];
                                (E || S) && (this._updateWorkerLayers(M, E, S),
                                d = !0)
                            }
                            this.updateSourceCaches(),
                            this._updateTilesForChangedImages(),
                            this.updateLayers(t),
                            this.light && this.light.updateTransitions(t),
                            this.ambientLight && this.ambientLight.updateTransitions(t),
                            this.directionalLight && this.directionalLight.updateTransitions(t),
                            this.fog && this.fog.updateTransitions(t),
                            this.snow && this.snow.updateTransitions(t),
                            this.rain && this.rain.updateTransitions(t),
                            this._changes.reset()
                        }
                        const m = {};
                        for (const y in this._mergedSourceCaches) {
                            const M = this._mergedSourceCaches[y];
                            m[y] = M.used,
                            M.used = !1,
                            M.tileCoverLift = 0
                        }
                        for (const y of this._mergedOrder) {
                            const M = this._mergedLayers[y];
                            if (M.recalculate(t, this._availableImages),
                            !M.isHidden(t.zoom)) {
                                const E = this.getLayerSourceCache(M);
                                E && (E.used = !0,
                                E.tileCoverLift = Math.max(E.tileCoverLift, M.tileCoverLift()))
                            }
                            !this._precompileDone && this._shouldPrecompile && ("requestIdleCallback"in window ? requestIdleCallback( () => {
                                this.precompilePrograms(M, t)
                            }
                            ) : this.precompilePrograms(M, t))
                        }
                        this._shouldPrecompile && (this._precompileDone = !0),
                        this.terrain && d && this.mergeLayers();
                        for (const y in m) {
                            const M = this._mergedSourceCaches[y];
                            m[y] !== M.used && M.getSource().fire(new s.z("data",{
                                sourceDataType: "visibility",
                                dataType: "source",
                                sourceId: M.getSource().id
                            }))
                        }
                        this.light && this.light.recalculate(t),
                        this.terrain && this.terrain.recalculate(t),
                        this.fog && this.fog.recalculate(t),
                        this.snow && this.snow.recalculate(t),
                        this.rain && this.rain.recalculate(t),
                        this.z = t.zoom,
                        this._markersNeedUpdate && (this._updateMarkersOpacity(),
                        this._markersNeedUpdate = !1),
                        h && this.fire(new s.z("data",{
                            dataType: "style"
                        }))
                    }
                    _updateTilesForChangedImages() {
                        const t = this._changes.getUpdatedImages();
                        if (t.length) {
                            for (const i in this._sourceCaches)
                                this._sourceCaches[i].reloadTilesForDependencies(["icons", "patterns"], t);
                            this._changes.resetUpdatedImages()
                        }
                    }
                    _updateWorkerLayers(t, i, h) {
                        const d = this.getFragmentStyle(t);
                        d && this.dispatcher.broadcast("updateLayers", {
                            layers: i ? d._serializeLayers(i) : [],
                            scope: t,
                            removedIds: h || [],
                            options: d.options
                        })
                    }
                    setState(t, i) {
                        if (this._checkLoaded(),
                        ia(this, ci(t)))
                            return !1;
                        (t = s.cp(t)).layers = Vl(t.layers);
                        const h = function(y, M) {
                            if (!y)
                                return [{
                                    command: xi.setStyle,
                                    args: [M]
                                }];
                            let E = [];
                            try {
                                if (!s.bn(y.version, M.version))
                                    return [{
                                        command: xi.setStyle,
                                        args: [M]
                                    }];
                                if (s.bn(y.center, M.center) || E.push({
                                    command: xi.setCenter,
                                    args: [M.center]
                                }),
                                s.bn(y.zoom, M.zoom) || E.push({
                                    command: xi.setZoom,
                                    args: [M.zoom]
                                }),
                                s.bn(y.bearing, M.bearing) || E.push({
                                    command: xi.setBearing,
                                    args: [M.bearing]
                                }),
                                s.bn(y.pitch, M.pitch) || E.push({
                                    command: xi.setPitch,
                                    args: [M.pitch]
                                }),
                                s.bn(y.sprite, M.sprite) || E.push({
                                    command: xi.setSprite,
                                    args: [M.sprite]
                                }),
                                s.bn(y.glyphs, M.glyphs) || E.push({
                                    command: xi.setGlyphs,
                                    args: [M.glyphs]
                                }),
                                s.bn(y.imports, M.imports) || function(k=[], H=[], j) {
                                    H = H || [];
                                    const Y = (k = k || []).map(Pi)
                                      , K = H.map(Pi)
                                      , he = k.reduce(bi, {})
                                      , Te = H.reduce(bi, {})
                                      , be = Y.slice();
                                    let Ue, De, ke, Le;
                                    for (Ue = 0,
                                    De = 0; Ue < Y.length; Ue++)
                                        ke = Y[Ue],
                                        Te.hasOwnProperty(ke) ? De++ : (j.push({
                                            command: xi.removeImport,
                                            args: [ke]
                                        }),
                                        be.splice(be.indexOf(ke, De), 1));
                                    for (Ue = 0,
                                    De = 0; Ue < K.length; Ue++)
                                        ke = K[K.length - 1 - Ue],
                                        be[be.length - 1 - Ue] !== ke && (he.hasOwnProperty(ke) ? (j.push({
                                            command: xi.removeImport,
                                            args: [ke]
                                        }),
                                        be.splice(be.lastIndexOf(ke, be.length - De), 1)) : De++,
                                        Le = be[be.length - Ue],
                                        j.push({
                                            command: xi.addImport,
                                            args: [Te[ke], Le]
                                        }),
                                        be.splice(be.length - Ue, 0, ke));
                                    for (const Ge of H) {
                                        const qe = he[Ge.id];
                                        qe && !s.bn(qe, Ge) && j.push({
                                            command: xi.updateImport,
                                            args: [Ge.id, Ge]
                                        })
                                    }
                                }(y.imports, M.imports, E),
                                s.bn(y.transition, M.transition) || E.push({
                                    command: xi.setTransition,
                                    args: [M.transition]
                                }),
                                s.bn(y.light, M.light) || E.push({
                                    command: xi.setLight,
                                    args: [M.light]
                                }),
                                s.bn(y.fog, M.fog) || E.push({
                                    command: xi.setFog,
                                    args: [M.fog]
                                }),
                                s.bn(y.snow, M.snow) || E.push({
                                    command: xi.setSnow,
                                    args: [M.snow]
                                }),
                                s.bn(y.rain, M.rain) || E.push({
                                    command: xi.setRain,
                                    args: [M.rain]
                                }),
                                s.bn(y.projection, M.projection) || E.push({
                                    command: xi.setProjection,
                                    args: [M.projection]
                                }),
                                s.bn(y.lights, M.lights) || E.push({
                                    command: xi.setLights,
                                    args: [M.lights]
                                }),
                                s.bn(y.camera, M.camera) || E.push({
                                    command: xi.setCamera,
                                    args: [M.camera]
                                }),
                                !s.bn(y["color-theme"], M["color-theme"]))
                                    return [{
                                        command: xi.setStyle,
                                        args: [M]
                                    }];
                                const S = {}
                                  , I = [];
                                !function(k, H, j, Y) {
                                    let K;
                                    for (K in H = H || {},
                                    k = k || {})
                                        k.hasOwnProperty(K) && (H.hasOwnProperty(K) || Zn(K, j, Y));
                                    for (K in H) {
                                        if (!H.hasOwnProperty(K))
                                            continue;
                                        const he = H[K];
                                        k.hasOwnProperty(K) ? s.bn(k[K], he) || ("geojson" === k[K].type && "geojson" === he.type && Ws(k, H, K) ? j.push({
                                            command: xi.setGeoJSONSourceData,
                                            args: [K, he.data]
                                        }) : Wl(K, H, j, Y)) : Hl(K, H, j)
                                    }
                                }(y.sources, M.sources, I, S);
                                const R = [];
                                y.layers && y.layers.forEach(k => {
                                    k.source && S[k.source] ? E.push({
                                        command: xi.removeLayer,
                                        args: [k.id]
                                    }) : R.push(k)
                                }
                                );
                                let D = y.terrain;
                                D && S[D.source] && (E.push({
                                    command: xi.setTerrain,
                                    args: [void 0]
                                }),
                                D = void 0),
                                E = E.concat(I),
                                s.bn(D, M.terrain) || E.push({
                                    command: xi.setTerrain,
                                    args: [M.terrain]
                                }),
                                function(k, H, j) {
                                    H = H || [];
                                    const Y = (k = k || []).map(Pi)
                                      , K = H.map(Pi)
                                      , he = k.reduce(bi, {})
                                      , Te = H.reduce(bi, {})
                                      , be = Y.slice()
                                      , Ue = Object.create(null);
                                    let De, ke, Le, Ge, qe, vt, dt;
                                    for (De = 0,
                                    ke = 0; De < Y.length; De++)
                                        Le = Y[De],
                                        Te.hasOwnProperty(Le) ? ke++ : (j.push({
                                            command: xi.removeLayer,
                                            args: [Le]
                                        }),
                                        be.splice(be.indexOf(Le, ke), 1));
                                    for (De = 0,
                                    ke = 0; De < K.length; De++)
                                        Le = K[K.length - 1 - De],
                                        be[be.length - 1 - De] !== Le && (he.hasOwnProperty(Le) ? (j.push({
                                            command: xi.removeLayer,
                                            args: [Le]
                                        }),
                                        be.splice(be.lastIndexOf(Le, be.length - ke), 1)) : ke++,
                                        vt = be[be.length - De],
                                        j.push({
                                            command: xi.addLayer,
                                            args: [Te[Le], vt]
                                        }),
                                        be.splice(be.length - De, 0, Le),
                                        Ue[Le] = !0);
                                    for (De = 0; De < K.length; De++)
                                        if (Le = K[De],
                                        Ge = he[Le],
                                        qe = Te[Le],
                                        !Ue[Le] && !s.bn(Ge, qe))
                                            if (s.bn(Ge.source, qe.source) && s.bn(Ge["source-layer"], qe["source-layer"]) && s.bn(Ge.type, qe.type)) {
                                                for (dt in To(Ge.layout, qe.layout, j, Le, null, xi.setLayoutProperty),
                                                To(Ge.paint, qe.paint, j, Le, null, xi.setPaintProperty),
                                                s.bn(Ge.slot, qe.slot) || j.push({
                                                    command: xi.setSlot,
                                                    args: [Le, qe.slot]
                                                }),
                                                s.bn(Ge.filter, qe.filter) || j.push({
                                                    command: xi.setFilter,
                                                    args: [Le, qe.filter]
                                                }),
                                                s.bn(Ge.minzoom, qe.minzoom) && s.bn(Ge.maxzoom, qe.maxzoom) || j.push({
                                                    command: xi.setLayerZoomRange,
                                                    args: [Le, qe.minzoom, qe.maxzoom]
                                                }),
                                                Ge)
                                                    Ge.hasOwnProperty(dt) && "layout" !== dt && "paint" !== dt && "filter" !== dt && "metadata" !== dt && "minzoom" !== dt && "maxzoom" !== dt && "slot" !== dt && (0 === dt.indexOf("paint.") ? To(Ge[dt], qe[dt], j, Le, dt.slice(6), xi.setPaintProperty) : s.bn(Ge[dt], qe[dt]) || j.push({
                                                        command: xi.setLayerProperty,
                                                        args: [Le, dt, qe[dt]]
                                                    }));
                                                for (dt in qe)
                                                    qe.hasOwnProperty(dt) && !Ge.hasOwnProperty(dt) && "layout" !== dt && "paint" !== dt && "filter" !== dt && "metadata" !== dt && "minzoom" !== dt && "maxzoom" !== dt && "slot" !== dt && (0 === dt.indexOf("paint.") ? To(Ge[dt], qe[dt], j, Le, dt.slice(6), xi.setPaintProperty) : s.bn(Ge[dt], qe[dt]) || j.push({
                                                        command: xi.setLayerProperty,
                                                        args: [Le, dt, qe[dt]]
                                                    }))
                                            } else
                                                j.push({
                                                    command: xi.removeLayer,
                                                    args: [Le]
                                                }),
                                                vt = be[be.lastIndexOf(Le) + 1],
                                                j.push({
                                                    command: xi.addLayer,
                                                    args: [qe, vt]
                                                })
                                }(R, M.layers, E)
                            } catch (S) {
                                console.warn("Unable to compute style diff:", S),
                                E = [{
                                    command: xi.setStyle,
                                    args: [M]
                                }]
                            }
                            return E
                        }(this.serialize(), t).filter(y => !(y.command in dp));
                        if (0 === h.length)
                            return !1;
                        const d = h.filter(y => !(y.command in cu));
                        if (d.length > 0)
                            throw new Error("Unimplemented: ".concat(d.map(y => y.command).join(", "), "."));
                        const m = [];
                        return h.forEach(y => {
                            m.push(this[y.command].apply(this, y.args))
                        }
                        ),
                        i && Promise.all(m).then(i),
                        this.stylesheet = t,
                        this.mergeAll(),
                        this.dispatcher.broadcast("setLayers", {
                            layers: this._serializeLayers(this._order),
                            scope: this.scope,
                            options: this.options
                        }),
                        !0
                    }
                    addImage(t, i) {
                        return this.getImage(t) ? this.fire(new s.y(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t, this.scope, i),
                        this._afterImageUpdated(t),
                        this)
                    }
                    updateImage(t, i, h=!1) {
                        this.imageManager.updateImage(t, this.scope, i),
                        h && this._afterImageUpdated(t)
                    }
                    getImage(t) {
                        return this.imageManager.getImage(t, this.scope)
                    }
                    removeImage(t) {
                        return this.getImage(t) ? (this.imageManager.removeImage(t, this.scope),
                        this._afterImageUpdated(t),
                        this) : this.fire(new s.y(new Error("No image with this name exists.")))
                    }
                    _afterImageUpdated(t) {
                        this._availableImages = this.imageManager.listImages(this.scope),
                        this._changes.updateImage(t),
                        this.dispatcher.broadcast("setImages", {
                            scope: this.scope,
                            images: this._availableImages
                        }),
                        this.fire(new s.z("data",{
                            dataType: "style"
                        }))
                    }
                    listImages() {
                        return this._checkLoaded(),
                        this._availableImages.slice()
                    }
                    addModel(t, i, h={}) {
                        return this._checkLoaded(),
                        this._validate(ue, "models.".concat(t), i, null, h) || (this.modelManager.addModel(t, i, this.scope),
                        this._changes.setDirty()),
                        this
                    }
                    hasModel(t) {
                        return this.modelManager.hasModel(t, this.scope)
                    }
                    removeModel(t) {
                        return this.hasModel(t) ? (this.modelManager.removeModel(t, this.scope),
                        this) : this.fire(new s.y(new Error("No model with this ID exists.")))
                    }
                    listModels() {
                        return this._checkLoaded(),
                        this.modelManager.listModels(this.scope)
                    }
                    addSource(t, i, h={}) {
                        if (this._checkLoaded(),
                        void 0 !== this.getOwnSource(t))
                            throw new Error('There is already a source with ID "'.concat(t, '".'));
                        if (!i.type)
                            throw new Error("The type property must be defined, but only the following properties were given: ".concat(Object.keys(i).join(", "), "."));
                        if (["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(ji, "sources.".concat(t), i, null, h))
                            return;
                        this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);
                        const d = jc(t, i, this.dispatcher, this);
                        d.scope = this.scope,
                        d.setEventedParent(this, () => ({
                            isSourceLoaded: this._isSourceCacheLoaded(d.id),
                            source: d.serialize(),
                            sourceId: d.id
                        }));
                        const m = y => {
                            const M = (y ? "symbol:" : "other:") + d.id
                              , E = s.aC(M, this.scope)
                              , S = this._sourceCaches[M] = new Ir(E,d,y);
                            (y ? this._symbolSourceCaches : this._otherSourceCaches)[d.id] = S,
                            S.onAdd(this.map)
                        }
                        ;
                        m(!1),
                        "vector" !== i.type && "geojson" !== i.type || m(!0),
                        d.onAdd && d.onAdd(this.map),
                        h.isInitialLoad || (this.mergeSources(),
                        this._changes.setDirty())
                    }
                    removeSource(t) {
                        this._checkLoaded();
                        const i = this.getOwnSource(t);
                        if (!i)
                            throw new Error("There is no source with this ID");
                        for (const d in this._layers)
                            if (this._layers[d].source === t)
                                return this.fire(new s.y(new Error('Source "'.concat(t, '" cannot be removed while layer "').concat(d, '" is using it.'))));
                        if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t)
                            return this.fire(new s.y(new Error('Source "'.concat(t, '" cannot be removed while terrain is using it.'))));
                        const h = this.getOwnSourceCaches(t);
                        for (const d of h) {
                            const m = s.cq(d.id);
                            delete this._sourceCaches[m],
                            this._changes.discardSourceCacheUpdate(d.id),
                            d.fire(new s.z("data",{
                                sourceDataType: "metadata",
                                dataType: "source",
                                sourceId: d.getSource().id
                            })),
                            d.setEventedParent(null),
                            d.clearTiles()
                        }
                        return delete this._otherSourceCaches[t],
                        delete this._symbolSourceCaches[t],
                        this.mergeSources(),
                        i.setEventedParent(null),
                        i.onRemove && i.onRemove(this.map),
                        this._changes.setDirty(),
                        this
                    }
                    setGeoJSONSourceData(t, i) {
                        this._checkLoaded(),
                        this.getOwnSource(t).setData(i),
                        this._changes.setDirty()
                    }
                    getOwnSource(t) {
                        const i = this.getOwnSourceCache(t);
                        return i && i.getSource()
                    }
                    getOwnSources() {
                        const t = [];
                        for (const i in this._otherSourceCaches) {
                            const h = this.getOwnSourceCache(i);
                            h && t.push(h.getSource())
                        }
                        return t
                    }
                    areTilesLoaded() {
                        const t = this._mergedSourceCaches;
                        for (const i in t) {
                            const h = t[i]._tiles;
                            for (const d in h) {
                                const m = h[d];
                                if ("loaded" !== m.state && "errored" !== m.state)
                                    return !1
                            }
                        }
                        return !0
                    }
                    setLights(t) {
                        if (this._checkLoaded(),
                        !t)
                            return delete this.ambientLight,
                            void delete this.directionalLight;
                        const i = this._getTransitionParameters();
                        for (const d of t) {
                            if (this._validate(Dr, "lights", d))
                                return;
                            switch (d.type) {
                            case "ambient":
                                if (this.ambientLight) {
                                    const m = this.ambientLight;
                                    m.set(d),
                                    m.updateTransitions(i)
                                } else
                                    this.ambientLight = new Sn(d,Ai || (Ai = new s.a5({
                                        color: new s.a6(s.a3.properties_light_ambient.color),
                                        "color-use-theme": new s.a6({
                                            type: "string",
                                            default: "default",
                                            "property-type": "data-constant"
                                        }),
                                        intensity: new s.a6(s.a3.properties_light_ambient.intensity)
                                    })),this.scope,this.options);
                                break;
                            case "directional":
                                if (this.directionalLight) {
                                    const m = this.directionalLight;
                                    m.set(d),
                                    m.updateTransitions(i)
                                } else
                                    this.directionalLight = new Sn(d,Fi || (Fi = new s.a5({
                                        direction: new s.ak(s.a3.properties_light_directional.direction),
                                        color: new s.a6(s.a3.properties_light_directional.color),
                                        "color-use-theme": new s.a6({
                                            type: "string",
                                            default: "default",
                                            "property-type": "data-constant"
                                        }),
                                        intensity: new s.a6(s.a3.properties_light_directional.intensity),
                                        "cast-shadows": new s.a6(s.a3.properties_light_directional["cast-shadows"]),
                                        "shadow-quality": new s.a6(s.a3.properties_light_directional["shadow-quality"]),
                                        "shadow-intensity": new s.a6(s.a3.properties_light_directional["shadow-intensity"])
                                    })),this.scope,this.options)
                            }
                        }
                        const h = new s.a8(this.z || 0,i);
                        this.ambientLight && this.ambientLight.recalculate(h),
                        this.directionalLight && this.directionalLight.recalculate(h),
                        this._brightness = this.calculateLightsBrightness(),
                        this.dispatcher.broadcast("setBrightness", this._brightness)
                    }
                    calculateLightsBrightness() {
                        const t = this.directionalLight
                          , i = this.ambientLight;
                        if (!t || !i)
                            return;
                        const h = D => .2126 * (D[0] <= .03928 ? D[0] / 12.92 : Math.pow((D[0] + .055) / 1.055, 2.4)) + .7152 * (D[1] <= .03928 ? D[1] / 12.92 : Math.pow((D[1] + .055) / 1.055, 2.4)) + .0722 * (D[2] <= .03928 ? D[2] / 12.92 : Math.pow((D[2] + .055) / 1.055, 2.4))
                          , d = t.properties.get("color").toRenderColor(null).toArray01()
                          , m = t.properties.get("intensity")
                          , y = t.properties.get("direction")
                          , M = 1 - s.cb(y.x, y.y, y.z)[2] / 90
                          , E = h(d) * m * M
                          , S = i.properties.get("color").toRenderColor(null).toArray01()
                          , I = i.properties.get("intensity")
                          , R = h(S) * I;
                        return Number(((E + R) / 2).toFixed(6))
                    }
                    getBrightness() {
                        return this._brightness
                    }
                    getLights() {
                        if (!this.enable3dLights())
                            return null;
                        const t = [];
                        return this.directionalLight && t.push(this.directionalLight.get()),
                        this.ambientLight && t.push(this.ambientLight.get()),
                        t
                    }
                    enable3dLights() {
                        return !!this.ambientLight && !!this.directionalLight
                    }
                    getFragmentStyle(t) {
                        if (!t)
                            return this;
                        if (s.cr(t)) {
                            const i = s.cs(t)
                              , h = this.fragments.find( ({id: m}) => m === i);
                            if (!h)
                                throw new Error("Style import '".concat(t, "' not found"));
                            const d = s.cq(t);
                            return h.style.getFragmentStyle(d)
                        }
                        {
                            const i = this.fragments.find( ({id: h}) => h === t);
                            if (!i)
                                throw new Error("Style import '".concat(t, "' not found"));
                            return i.style
                        }
                    }
                    setFeaturesetSelectors(t) {
                        if (!t)
                            return;
                        const i = {}
                          , h = (d, m="") => "".concat(d, "::").concat(m);
                        this.featuresetSelectors = {};
                        for (const d in t) {
                            const m = this.featuresetSelectors[d] = [];
                            for (const y of t[d].selectors) {
                                if (y.featureNamespace) {
                                    const E = this.getOwnLayer(y.layer);
                                    if (!E) {
                                        s.w("Layer is undefined for selector: ".concat(y.layer));
                                        continue
                                    }
                                    const S = h(E.source, E.sourceLayer);
                                    if (S in i && i[S] !== y.featureNamespace) {
                                        s.w('"featureNamespace '.concat(y.featureNamespace, " of featureset ").concat(d, "'s selector is not associated to the same source, skip this selector"));
                                        continue
                                    }
                                    i[S] = y.featureNamespace
                                }
                                let M;
                                if (y.properties)
                                    for (const E in y.properties) {
                                        const S = s.U(y.properties[E]);
                                        "success" === S.result && (M = M || {},
                                        M[E] = S.value)
                                    }
                                m.push({
                                    layerId: y.layer,
                                    namespace: y.featureNamespace,
                                    properties: M
                                })
                            }
                        }
                    }
                    getFeaturesetDescriptors(t) {
                        const i = this.getFragmentStyle(t);
                        if (!i || !i.stylesheet.featuresets)
                            return [];
                        const h = [];
                        for (const d in i.stylesheet.featuresets)
                            h.push({
                                featuresetId: d,
                                importId: i.scope ? i.scope : void 0
                            });
                        return h
                    }
                    getFeaturesetLayers(t, i) {
                        const h = this.getFragmentStyle(i)
                          , d = h.stylesheet.featuresets;
                        if (!d || !d[t])
                            return this.fire(new s.y(new Error("The featureset '".concat(t, "' does not exist in the map's style and cannot be queried.")))),
                            [];
                        const m = [];
                        for (const y of d[t].selectors) {
                            const M = h.getOwnLayer(y.layer);
                            M && m.push(M)
                        }
                        return m
                    }
                    getConfigProperty(t, i) {
                        const h = this.getFragmentStyle(t);
                        if (!h)
                            return null;
                        const d = s.aC(i, h.scope)
                          , m = h.options.get(d)
                          , y = m ? m.value || m.default : null;
                        return y ? y.serialize() : null
                    }
                    setConfigProperty(t, i, h) {
                        const d = this.getFragmentStyle(t);
                        if (!d)
                            return;
                        const m = d.stylesheet.indoor ? oh(d.stylesheet.schema) : d.stylesheet.schema;
                        if (!m || !m[i])
                            return;
                        const y = s.U(h);
                        if ("success" !== y.result)
                            return void ia(this, y.value);
                        const M = y.value.expression
                          , E = s.aC(i, d.scope)
                          , S = d.options.get(E);
                        if (!S)
                            return;
                        let I;
                        const {minValue: R, maxValue: D, stepValue: k, type: H, values: j} = m[i]
                          , Y = s.U(m[i].default);
                        "success" === Y.result && (I = Y.value.expression),
                        I ? (this.options.set(E, {
                            ...S,
                            value: M,
                            default: I,
                            minValue: R,
                            maxValue: D,
                            stepValue: k,
                            type: H,
                            values: j
                        }),
                        this.updateConfigDependencies(i)) : this.fire(new s.y(new Error('No schema defined for the config option "'.concat(i, '" in the "').concat(t, '" fragment.'))))
                    }
                    getConfig(t) {
                        const i = this.getFragmentStyle(t);
                        if (!i)
                            return null;
                        const h = i.stylesheet.schema;
                        if (!h)
                            return null;
                        const d = {};
                        for (const m in h) {
                            const y = s.aC(m, i.scope)
                              , M = i.options.get(y)
                              , E = M ? M.value || M.default : null;
                            d[m] = E ? E.serialize() : null
                        }
                        return d
                    }
                    setConfig(t, i) {
                        const h = this.getFragmentStyle(t);
                        h && (h.updateConfig(i, h.stylesheet.schema),
                        this.updateConfigDependencies())
                    }
                    getSchema(t) {
                        const i = this.getFragmentStyle(t);
                        return i ? i.stylesheet.schema : null
                    }
                    setSchema(t, i) {
                        const h = this.getFragmentStyle(t);
                        h && (h.stylesheet.schema = i,
                        h.updateConfig(h._config, i),
                        this.updateConfigDependencies())
                    }
                    updateConfig(t, i) {
                        if (this._config = t,
                        t || i)
                            if (i)
                                for (const h in i) {
                                    let d, m;
                                    const y = s.U(i[h].default);
                                    if ("success" === y.result && (d = y.value.expression),
                                    t && void 0 !== t[h]) {
                                        const D = s.U(t[h]);
                                        "success" === D.result && (m = D.value.expression)
                                    }
                                    const {minValue: M, maxValue: E, stepValue: S, type: I, values: R} = i[h];
                                    if (d) {
                                        const D = s.aC(h, this.scope);
                                        this.options.set(D, {
                                            default: d,
                                            value: m,
                                            minValue: M,
                                            maxValue: E,
                                            stepValue: S,
                                            type: I,
                                            values: R
                                        })
                                    } else
                                        this.fire(new s.y(new Error('No schema defined for config option "'.concat(h, '".'))))
                                }
                            else
                                this.fire(new s.y(new Error("Attempting to set config for a style without schema.")))
                    }
                    updateConfigDependencies(t) {
                        for (const i of this._configDependentLayers) {
                            const h = this.getLayer(i);
                            if (h) {
                                if (t && !h.configDependencies.has(t))
                                    continue;
                                h.possiblyEvaluateVisibility(),
                                this._updateLayer(h)
                            }
                        }
                        this.ambientLight && this.ambientLight.updateConfig(this.options),
                        this.directionalLight && this.directionalLight.updateConfig(this.options),
                        this.fog && this.fog.updateConfig(this.options),
                        this.snow && this.snow.updateConfig(this.options),
                        this.rain && this.rain.updateConfig(this.options),
                        this.forEachFragmentStyle(i => {
                            const h = i._styleColorTheme.colorThemeOverride ? i._styleColorTheme.colorThemeOverride : i._styleColorTheme.colorTheme;
                            if (h) {
                                const d = i._evaluateColorThemeData(h);
                                (!i._styleColorTheme.lut && "" !== d || i._styleColorTheme.lut && d !== i._styleColorTheme.lut.data) && i.setColorTheme(h)
                            }
                        }
                        ),
                        this._changes.setDirty()
                    }
                    addLayer(t, i, h={}) {
                        this._checkLoaded();
                        const d = t.id;
                        if (this._layers[d])
                            return void this.fire(new s.y(new Error('Layer with id "'.concat(d, '" already exists on this map'))));
                        let m;
                        if ("custom" === t.type) {
                            if (ia(this, s.ct(t)))
                                return;
                            m = s.cu(t, this.scope, this._styleColorTheme.lut, this.options)
                        } else {
                            if ("object" == typeof t.source && (this.addSource(d, t.source),
                            t = s.cp(t),
                            t = s.l(t, {
                                source: d
                            })),
                            this._validate(se, "layers.".concat(d), t, {
                                arrayIndex: -1
                            }, h))
                                return;
                            m = s.cu(t, this.scope, this._styleColorTheme.lut, this.options),
                            this._validateLayer(m),
                            m.setEventedParent(this, {
                                layer: {
                                    id: d
                                }
                            })
                        }
                        0 !== m.configDependencies.size && this._configDependentLayers.add(m.fqid);
                        let y = this._order.length;
                        if (i) {
                            const I = this._order.indexOf(i);
                            if (-1 === I)
                                return void this.fire(new s.y(new Error('Layer with id "'.concat(i, '" does not exist on this map.'))));
                            m.slot === this._layers[i].slot ? y = I : s.w('Layer with id "'.concat(i, '" has a different slot. Layers can only be rearranged within the same slot.'))
                        }
                        this._order.splice(y, 0, d),
                        this._layerOrderChanged = !0,
                        this._layers[d] = m;
                        const M = this.getOwnLayerSourceCache(m)
                          , E = !!this.directionalLight && this.directionalLight.shadowsEnabled();
                        M && m.canCastShadows() && E && (M.castsShadows = !0);
                        const S = this._changes.getRemovedLayer(m);
                        if (S && m.source && M && "custom" !== m.type) {
                            this._changes.discardLayerRemoval(m);
                            const I = s.aC(m.source, m.scope);
                            S.type !== m.type ? this._changes.updateSourceCache(I, "clear") : (this._changes.updateSourceCache(I, "reload"),
                            M.pause())
                        }
                        this._updateLayer(m),
                        m.onAdd && m.onAdd(this.map),
                        m.scope = this.scope,
                        this.mergeLayers()
                    }
                    moveLayer(t, i) {
                        this._checkLoaded();
                        const h = this._checkLayer(t);
                        if (!h || t === i)
                            return;
                        const d = this._order.indexOf(t);
                        this._order.splice(d, 1);
                        let m = this._order.length;
                        if (i) {
                            const y = this._order.indexOf(i);
                            if (-1 === y)
                                return void this.fire(new s.y(new Error('Layer with id "'.concat(i, '" does not exist on this map.'))));
                            h.slot === this._layers[i].slot ? m = y : s.w('Layer with id "'.concat(i, '" has a different slot. Layers can only be rearranged within the same slot.'))
                        }
                        this._order.splice(m, 0, t),
                        this._changes.setDirty(),
                        this._layerOrderChanged = !0,
                        this.mergeLayers()
                    }
                    removeLayer(t) {
                        this._checkLoaded();
                        const i = this._checkLayer(t);
                        if (!i)
                            return;
                        i.setEventedParent(null);
                        const h = this._order.indexOf(t);
                        this._order.splice(h, 1),
                        delete this._layers[t],
                        this._changes.setDirty(),
                        this._layerOrderChanged = !0,
                        this._configDependentLayers.delete(i.fqid),
                        this._changes.removeLayer(i);
                        const d = this.getOwnLayerSourceCache(i);
                        if (d && d.castsShadows) {
                            let m = !1;
                            for (const y in this._layers)
                                if (this._layers[y].source === i.source && this._layers[y].canCastShadows()) {
                                    m = !0;
                                    break
                                }
                            d.castsShadows = m
                        }
                        i.onRemove && i.onRemove(this.map),
                        this.mergeLayers()
                    }
                    getOwnLayer(t) {
                        return this._layers[t]
                    }
                    hasLayer(t) {
                        return t in this._mergedLayers
                    }
                    hasLayerType(t) {
                        for (const i in this._layers)
                            if (this._layers[i].type === t)
                                return !0;
                        return !1
                    }
                    setLayerZoomRange(t, i, h) {
                        this._checkLoaded();
                        const d = this._checkLayer(t);
                        d && (d.minzoom === i && d.maxzoom === h || (null != i && (d.minzoom = i),
                        null != h && (d.maxzoom = h),
                        this._updateLayer(d)))
                    }
                    getSlots() {
                        return this._checkLoaded(),
                        this._mergedSlots
                    }
                    setSlot(t, i) {
                        this._checkLoaded();
                        const h = this._checkLayer(t);
                        h && h.slot !== i && (h.slot = i,
                        this._updateLayer(h))
                    }
                    setFilter(t, i, h={}) {
                        this._checkLoaded();
                        const d = this._checkLayer(t);
                        if (d && !s.bn(d.filter, i))
                            return null == i ? (d.filter = void 0,
                            void this._updateLayer(d)) : void (this._validate(Ee, "layers.".concat(d.id, ".filter"), i, {
                                layerType: d.type
                            }, h) || (d.filter = s.cp(i),
                            this._updateLayer(d)))
                    }
                    getFilter(t) {
                        const i = this._checkLayer(t);
                        if (i)
                            return s.cp(i.filter)
                    }
                    setLayoutProperty(t, i, h, d={}) {
                        this._checkLoaded();
                        const m = this._checkLayer(t);
                        if (m && !s.bn(m.getLayoutProperty(i), h)) {
                            if (null != h && (!d || !1 !== d.validate) && ia(m, oe.call(ci, {
                                key: "layers.".concat(t, ".layout.").concat(i),
                                layerType: m.type,
                                objectKey: i,
                                value: h,
                                styleSpec: s.a3,
                                style: {
                                    glyphs: !0,
                                    sprite: !0
                                }
                            })))
                                return;
                            m.setLayoutProperty(i, h),
                            0 !== m.configDependencies.size && this._configDependentLayers.add(m.fqid),
                            this._updateLayer(m)
                        }
                    }
                    getLayoutProperty(t, i) {
                        const h = this._checkLayer(t);
                        if (h)
                            return h.getLayoutProperty(i)
                    }
                    setPaintProperty(t, i, h, d={}) {
                        this._checkLoaded();
                        const m = this._checkLayer(t);
                        if (!m || s.bn(m.getPaintProperty(i), h) || null != h && (!d || !1 !== d.validate) && ia(m, He.call(ci, {
                            key: "layers.".concat(t, ".paint.").concat(i),
                            layerType: m.type,
                            objectKey: i,
                            value: h,
                            styleSpec: s.a3
                        })))
                            return;
                        const y = m.setPaintProperty(i, h);
                        0 !== m.configDependencies.size && this._configDependentLayers.add(m.fqid),
                        y && this._updateLayer(m),
                        this._changes.updatePaintProperties(m)
                    }
                    getPaintProperty(t, i) {
                        const h = this._checkLayer(t);
                        if (h)
                            return h.getPaintProperty(i)
                    }
                    setFeatureState(t, i) {
                        if (this._checkLoaded(),
                        "target"in t) {
                            if ("featuresetId"in t.target) {
                                const {featuresetId: E, importId: S} = t.target
                                  , I = this.getFragmentStyle(S)
                                  , R = I.getFeaturesetLayers(E);
                                for (const {source: D, sourceLayer: k} of R)
                                    I.setFeatureState({
                                        id: t.id,
                                        source: D,
                                        sourceLayer: k
                                    }, i)
                            } else if ("layerId"in t.target) {
                                const {layerId: E} = t.target
                                  , S = this.getLayer(E);
                                this.setFeatureState({
                                    id: t.id,
                                    source: S.source,
                                    sourceLayer: S.sourceLayer
                                }, i)
                            }
                            return
                        }
                        const h = t.source
                          , d = t.sourceLayer
                          , m = this._checkSource(h);
                        if (!m)
                            return;
                        const y = m.type;
                        if ("geojson" === y && d)
                            return void this.fire(new s.y(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
                        if ("vector" === y && !d)
                            return void this.fire(new s.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
                        void 0 === t.id && this.fire(new s.y(new Error("The feature id parameter must be provided.")));
                        const M = this.getOwnSourceCaches(h);
                        for (const E of M)
                            E.setFeatureState(d, t.id, i)
                    }
                    removeFeatureState(t, i) {
                        if (this._checkLoaded(),
                        "target"in t) {
                            if ("featuresetId"in t.target) {
                                const {featuresetId: E, importId: S} = t.target
                                  , I = this.getFragmentStyle(S)
                                  , R = I.getFeaturesetLayers(E);
                                for (const {source: D, sourceLayer: k} of R)
                                    I.removeFeatureState({
                                        id: t.id,
                                        source: D,
                                        sourceLayer: k
                                    }, i)
                            } else if ("layerId"in t.target) {
                                const {layerId: E} = t.target
                                  , S = this.getLayer(E);
                                this.removeFeatureState({
                                    id: t.id,
                                    source: S.source,
                                    sourceLayer: S.sourceLayer
                                }, i)
                            }
                            return
                        }
                        const h = t.source
                          , d = this._checkSource(h);
                        if (!d)
                            return;
                        const m = d.type
                          , y = "vector" === m ? t.sourceLayer : void 0;
                        if ("vector" === m && !y)
                            return void this.fire(new s.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
                        if (i && "string" != typeof t.id && "number" != typeof t.id)
                            return void this.fire(new s.y(new Error("A feature id is required to remove its specific state property.")));
                        const M = this.getOwnSourceCaches(h);
                        for (const E of M)
                            E.removeFeatureState(y, t.id, i)
                    }
                    getFeatureState(t) {
                        if (this._checkLoaded(),
                        "target"in t) {
                            let m;
                            if ("featuresetId"in t.target) {
                                const {featuresetId: y, importId: M} = t.target
                                  , E = this.getFragmentStyle(M)
                                  , S = E.getFeaturesetLayers(y);
                                for (const {source: I, sourceLayer: R} of S) {
                                    const D = E.getFeatureState({
                                        id: t.id,
                                        source: I,
                                        sourceLayer: R
                                    });
                                    if (D && !m)
                                        m = D;
                                    else if (!s.bn(m, D))
                                        return void this.fire(new s.y(new Error("The same feature id exists in multiple sources in the featureset, but their feature states are not consistent through the sources.")))
                                }
                            } else if ("layerId"in t.target) {
                                const {layerId: y} = t.target
                                  , M = this.getLayer(y);
                                m = this.getFeatureState({
                                    id: t.id,
                                    source: M.source,
                                    sourceLayer: M.sourceLayer
                                })
                            }
                            return m
                        }
                        const i = t.source
                          , h = t.sourceLayer
                          , d = this._checkSource(i);
                        if (d) {
                            if ("vector" !== d.type || h)
                                return void 0 === t.id && this.fire(new s.y(new Error("The feature id parameter must be provided."))),
                                this.getOwnSourceCaches(i)[0].getFeatureState(h, t.id);
                            this.fire(new s.y(new Error("The sourceLayer parameter must be provided for vector source types.")))
                        }
                    }
                    setTransition(t) {
                        return this.stylesheet.transition = s.l({}, this.stylesheet.transition, t),
                        this.transition = this.stylesheet.transition,
                        this
                    }
                    getTransition() {
                        return s.l({}, this.stylesheet.transition)
                    }
                    serialize() {
                        this._checkLoaded();
                        const t = this.getTerrain()
                          , i = t && this.terrain && this.terrain.scope === this.scope ? t : this.stylesheet.terrain;
                        return s.cv({
                            version: this.stylesheet.version,
                            name: this.stylesheet.name,
                            metadata: this.stylesheet.metadata,
                            fragment: this.stylesheet.fragment,
                            imports: this._serializeImports(),
                            schema: this.stylesheet.schema,
                            camera: this.stylesheet.camera,
                            light: this.stylesheet.light,
                            lights: this.stylesheet.lights,
                            terrain: i,
                            fog: this.stylesheet.fog,
                            snow: this.stylesheet.snow,
                            rain: this.stylesheet.rain,
                            center: this.stylesheet.center,
                            "color-theme": this.stylesheet["color-theme"],
                            zoom: this.stylesheet.zoom,
                            bearing: this.stylesheet.bearing,
                            pitch: this.stylesheet.pitch,
                            sprite: this.stylesheet.sprite,
                            glyphs: this.stylesheet.glyphs,
                            transition: this.stylesheet.transition,
                            projection: this.stylesheet.projection,
                            sources: this._serializeSources(),
                            layers: this._serializeLayers(this._order)
                        }, h => void 0 !== h)
                    }
                    _updateFilteredLayers(t) {
                        for (const i of Object.values(this._mergedLayers))
                            t(i) && this._updateLayer(i)
                    }
                    _updateLayer(t) {
                        this._changes.updateLayer(t);
                        const i = this.getLayerSourceCache(t)
                          , h = s.aC(t.source, t.scope)
                          , d = this._changes.getUpdatedSourceCaches();
                        t.source && !d[h] && i && "raster" !== i.getSource().type && (this._changes.updateSourceCache(h, "reload"),
                        i.pause()),
                        t.invalidateCompiledFilter()
                    }
                    _flattenAndSortRenderedFeatures(t) {
                        const i = M => this._mergedLayers[M].is3D()
                          , h = this.order
                          , d = {}
                          , m = [];
                        for (let M = h.length - 1; M >= 0; M--) {
                            const E = h[M];
                            if (i(E)) {
                                d[E] = M;
                                for (const S of t) {
                                    const I = S[E];
                                    if (I)
                                        for (const R of I)
                                            m.push(R)
                                }
                            }
                        }
                        m.sort( (M, E) => E.intersectionZ - M.intersectionZ);
                        const y = [];
                        for (let M = h.length - 1; M >= 0; M--) {
                            const E = h[M];
                            if (i(E))
                                for (let S = m.length - 1; S >= 0; S--) {
                                    const I = m[S].feature;
                                    if (I.layer && d[I.layer.id] < M)
                                        break;
                                    y.push(I),
                                    m.pop()
                                }
                            else
                                for (const S of t) {
                                    const I = S[E];
                                    if (I)
                                        for (const R of I)
                                            y.push(R.feature)
                                }
                        }
                        return y
                    }
                    queryRenderedFeatures(t, i, h) {
                        let d;
                        i && !Array.isArray(i) && i.filter && (this._validate(Ee, "queryRenderedFeatures.filter", i.filter, null, i),
                        d = s.aZ(i.filter));
                        const m = {}
                          , y = I => {
                            if (Zl.has(I.type))
                                return;
                            const R = this.getOwnLayerSourceCache(I)
                              , D = m[R.id] = m[R.id] || {
                                sourceCache: R,
                                layers: {},
                                has3DLayers: !1
                            };
                            I.is3D() && (D.has3DLayers = !0),
                            D.layers[I.fqid] = D.layers[I.fqid] || {
                                styleLayer: I,
                                targets: []
                            },
                            D.layers[I.fqid].targets.push({
                                filter: d
                            })
                        }
                        ;
                        if (i && i.layers) {
                            if (!Array.isArray(i.layers))
                                return this.fire(new s.y(new Error("parameters.layers must be an Array."))),
                                [];
                            for (const I of i.layers) {
                                const R = this._layers[I];
                                if (!R)
                                    return this.fire(new s.y(new Error("The layer '".concat(I, "' does not exist in the map's style and cannot be queried for features.")))),
                                    [];
                                y(R)
                            }
                        } else
                            for (const I in this._layers)
                                y(this._layers[I]);
                        const M = this._queryRenderedFeatures(t, m, h)
                          , E = this._flattenAndSortRenderedFeatures(M)
                          , S = [];
                        for (const I of E)
                            s.cs(I.layer.id) === this.scope && S.push(I);
                        return S
                    }
                    queryRenderedFeatureset(t, i, h) {
                        let d;
                        i && !Array.isArray(i) && i.filter && (this._validate(Ee, "queryRenderedFeatures.filter", i.filter, null, i),
                        d = s.aZ(i.filter));
                        const m = "mock"
                          , y = [];
                        if (i && i.target)
                            y.push({
                                ...i,
                                targetId: m,
                                filter: d
                            });
                        else {
                            const S = this.getFeaturesetDescriptors();
                            for (const I of S)
                                y.push({
                                    targetId: m,
                                    filter: d,
                                    target: I
                                });
                            for (const {style: I} of this.fragments) {
                                const R = I.getFeaturesetDescriptors();
                                for (const D of R)
                                    y.push({
                                        targetId: m,
                                        filter: d,
                                        target: D
                                    })
                            }
                        }
                        const M = this.queryRenderedTargets(t, y, h)
                          , E = [];
                        for (const S of M)
                            for (const I of S.variants[m])
                                E.push(new s.cw(S,I));
                        return E
                    }
                    queryRenderedTargets(t, i, h) {
                        const d = {}
                          , m = (M, E, S, I) => {
                            const R = d[E.id] = d[E.id] || {
                                sourceCache: E,
                                layers: {},
                                has3DLayers: !1
                            };
                            R.layers[M.fqid] = R.layers[M.fqid] || {
                                styleLayer: M,
                                targets: []
                            },
                            M.is3D() && (R.has3DLayers = !0),
                            R.layers[M.fqid].targets.push(I ? {
                                ...S,
                                namespace: I.namespace,
                                properties: I.properties
                            } : S)
                        }
                        ;
                        for (const M of i)
                            if ("featuresetId"in M.target) {
                                const {featuresetId: E, importId: S} = M.target
                                  , I = this.getFragmentStyle(S)
                                  , R = I.featuresetSelectors[E];
                                if (!R) {
                                    this.fire(new s.y(new Error("The featureset '".concat(E, "' does not exist in the map's style and cannot be queried for features."))));
                                    continue
                                }
                                for (const D of R) {
                                    const k = I.getOwnLayer(D.layerId);
                                    k && !Zl.has(k.type) && m(k, I.getOwnLayerSourceCache(k), M, D)
                                }
                            } else if ("layerId"in M.target) {
                                const {layerId: E} = M.target
                                  , S = this.getLayer(E);
                                if (!S || Zl.has(S.type))
                                    continue;
                                m(S, this.getLayerSourceCache(S), M)
                            }
                        const y = this._queryRenderedFeatures(t, d, h);
                        return this._flattenAndSortRenderedFeatures(y)
                    }
                    _queryRenderedFeatures(t, i, h) {
                        const d = []
                          , m = !!this.map._showQueryGeometry
                          , y = Fn.createFromScreenPoints(t, h);
                        for (const M in i) {
                            const E = Vc(y, i[M], this._availableImages, h, m);
                            Object.keys(E).length && d.push(E)
                        }
                        if (this.placement)
                            for (const M in i) {
                                if (!i[M].sourceCache._onlySymbols)
                                    continue;
                                const E = Ha(y.screenGeometry, i[M], this._availableImages, this.placement.collisionIndex, this.placement.retainedQueryData);
                                Object.keys(E).length && d.push(E)
                            }
                        return d
                    }
                    querySourceFeatures(t, i) {
                        const h = i && i.filter;
                        h && this._validate(Ee, "querySourceFeatures.filter", h, null, i);
                        let d = [];
                        const m = this.getOwnSourceCaches(t);
                        for (const y of m)
                            d = d.concat(wa(y, i));
                        return d
                    }
                    addSourceType(t, i, h) {
                        return pr.getSourceType(t) ? h(new Error('A source type called "'.concat(t, '" already exists.'))) : (pr.setSourceType(t, i),
                        i.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", {
                            name: t,
                            url: i.workerSourceURL
                        }, h) : h(null, null))
                    }
                    getFlatLight() {
                        return this.light.getLight()
                    }
                    setFlatLight(t, i, h={}) {
                        this._checkLoaded();
                        const d = this.light.getLight();
                        let m = !1;
                        for (const M in t)
                            if (!s.bn(t[M], d[M])) {
                                m = !0;
                                break
                            }
                        if (!m)
                            return;
                        const y = this._getTransitionParameters();
                        this.light.setLight(t, i, h),
                        this.light.updateTransitions(y)
                    }
                    getTerrain() {
                        return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null
                    }
                    setTerrainForDraping() {
                        this.setTerrain({
                            source: "",
                            exaggeration: 0
                        }, 0)
                    }
                    checkCanvasFingerprintNoise() {
                        void 0 === this.disableElevatedTerrain && (this.disableElevatedTerrain = s.q.hasCanvasFingerprintNoise(),
                        this.disableElevatedTerrain && s.w("Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode)."))
                    }
                    setTerrain(t, i=1) {
                        if (this._checkLoaded(),
                        !t)
                            return this.terrainSetForDrapingOnly() || (delete this.terrain,
                            this.map.transform.projection.requiresDraping && this.setTerrainForDraping()),
                            0 === i && delete this.terrain,
                            null === t ? this.stylesheet.terrain = null : delete this.stylesheet.terrain,
                            this._force3DLayerUpdate(),
                            void (this._markersNeedUpdate = !0);
                        this.checkCanvasFingerprintNoise();
                        let h = t;
                        const d = null == t.source;
                        if (1 === i) {
                            if (this.disableElevatedTerrain)
                                return;
                            if ("object" == typeof h.source) {
                                const M = "terrain-dem-src";
                                this.addSource(M, h.source),
                                h = s.cp(h),
                                h = s.l(h, {
                                    source: M
                                })
                            }
                            const m = s.l({}, h)
                              , y = {};
                            if (this.terrain && d) {
                                m.source = this.terrain.get().source;
                                const M = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;
                                M && (y.style = M.serialize())
                            }
                            if (this._validate(Ln, "terrain", m, y))
                                return
                        }
                        if (!this.terrain || this.terrain.scope !== this.scope && !d || this.terrain && i !== this.terrain.drapeRenderMode) {
                            if (!h)
                                return;
                            this._createTerrain(h, i),
                            this.fire(new s.z("data",{
                                dataType: "style"
                            }))
                        } else {
                            const m = this.terrain
                              , y = m.get();
                            for (const M of Object.keys(s.a3.terrain))
                                !h.hasOwnProperty(M) && s.a3.terrain[M].default && (h[M] = s.a3.terrain[M].default);
                            for (const M in t)
                                if (!s.bn(t[M], y[M])) {
                                    m.set(t, this.options),
                                    this.stylesheet.terrain = t;
                                    const E = this._getTransitionParameters({
                                        duration: 0
                                    });
                                    m.updateTransitions(E),
                                    this.fire(new s.z("data",{
                                        dataType: "style"
                                    }));
                                    break
                                }
                        }
                        this.mergeTerrain(),
                        this.updateDrapeFirstLayers(),
                        this._markersNeedUpdate = !0
                    }
                    _createFog(t) {
                        const i = this.fog = new Ii(t,this.map.transform,this.scope,this.options);
                        this.stylesheet.fog = i.get();
                        const h = this._getTransitionParameters({
                            duration: 0
                        });
                        i.updateTransitions(h)
                    }
                    _createSnow(t) {
                        const i = this.snow = new fn(t,this.map.transform,this.scope,this.options);
                        this.stylesheet.snow = i.get();
                        const h = this._getTransitionParameters({
                            duration: 0
                        });
                        i.updateTransitions(h)
                    }
                    _createRain(t) {
                        const i = this.rain = new Yn(t,this.map.transform,this.scope,this.options);
                        this.stylesheet.rain = i.get();
                        const h = this._getTransitionParameters({
                            duration: 0
                        });
                        i.updateTransitions(h)
                    }
                    _updateMarkersOpacity() {
                        0 !== this.map._markers.length && this.map._requestDomTask( () => {
                            for (const t of this.map._markers)
                                t._evaluateOpacity()
                        }
                        )
                    }
                    getFog() {
                        return this.fog ? this.fog.get() : null
                    }
                    setFog(t) {
                        if (this._checkLoaded(),
                        !t)
                            return delete this.fog,
                            delete this.stylesheet.fog,
                            void (this._markersNeedUpdate = !0);
                        if (this.fog) {
                            const i = this.fog;
                            if (!s.bn(i.get(), t)) {
                                i.set(t, this.options),
                                this.stylesheet.fog = i.get();
                                const h = this._getTransitionParameters({
                                    duration: 0
                                });
                                i.updateTransitions(h)
                            }
                        } else
                            this._createFog(t);
                        this._markersNeedUpdate = !0
                    }
                    getSnow() {
                        return this.snow ? this.snow.get() : null
                    }
                    setSnow(t) {
                        if (this._checkLoaded(),
                        !t)
                            return delete this.snow,
                            void delete this.stylesheet.snow;
                        if (this.snow) {
                            const i = this.snow;
                            if (!s.bn(i.get(), t)) {
                                i.set(t, this.options),
                                this.stylesheet.snow = i.get();
                                const h = this._getTransitionParameters({
                                    duration: 0
                                });
                                i.updateTransitions(h)
                            }
                        } else
                            this._createSnow(t);
                        this._markersNeedUpdate = !0
                    }
                    getRain() {
                        return this.rain ? this.rain.get() : null
                    }
                    setRain(t) {
                        if (this._checkLoaded(),
                        !t)
                            return delete this.rain,
                            void delete this.stylesheet.rain;
                        if (this.rain) {
                            const i = this.rain;
                            if (!s.bn(i.get(), t)) {
                                i.set(t, this.options),
                                this.stylesheet.rain = i.get();
                                const h = this._getTransitionParameters({
                                    duration: 0
                                });
                                i.updateTransitions(h)
                            }
                        } else
                            this._createRain(t);
                        this._markersNeedUpdate = !0
                    }
                    _reloadColorTheme() {
                        const t = () => {
                            for (const d in this._layers)
                                this._layers[d].lut = this._styleColorTheme.lut;
                            for (const d in this._sourceCaches)
                                this._sourceCaches[d].clearTiles()
                        }
                          , i = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
                        if (!i)
                            return this._styleColorTheme.lut = null,
                            void t();
                        const h = this._evaluateColorThemeData(i);
                        this._loadColorTheme(h).then( () => {
                            this.fire(new s.z("colorthemeset")),
                            t()
                        }
                        ).catch(d => {
                            s.w("Couldn't set color theme: ".concat(d))
                        }
                        )
                    }
                    setColorTheme(t) {
                        this._checkLoaded(),
                        this._styleColorTheme.colorThemeOverride && s.w("Note: setColorTheme is called on a style with a color-theme override, the passed color-theme won't be visible."),
                        this._styleColorTheme.colorTheme = t,
                        this._reloadColorTheme()
                    }
                    setImportColorTheme(t, i) {
                        const h = this.getFragmentStyle(t);
                        h && (h._styleColorTheme.colorThemeOverride = i,
                        h._reloadColorTheme())
                    }
                    _getTransitionParameters(t) {
                        return {
                            now: s.q.now(),
                            transition: s.l(this.transition, t)
                        }
                    }
                    updateDrapeFirstLayers() {
                        if (!this.terrain)
                            return;
                        const t = []
                          , i = [];
                        for (const h of this._mergedOrder)
                            this.isLayerDraped(this._mergedLayers[h]) ? t.push(h) : i.push(h);
                        this._drapedFirstOrder = [],
                        this._drapedFirstOrder.push(...t),
                        this._drapedFirstOrder.push(...i)
                    }
                    _createTerrain(t, i) {
                        const h = this.terrain = new st(t,i,this.scope,this.options);
                        1 === i && (this.stylesheet.terrain = t),
                        this.mergeTerrain(),
                        this.updateDrapeFirstLayers(),
                        this._force3DLayerUpdate();
                        const d = this._getTransitionParameters({
                            duration: 0
                        });
                        h.updateTransitions(d)
                    }
                    _force3DLayerUpdate() {
                        for (const t in this._layers) {
                            const i = this._layers[t];
                            "fill-extrusion" === i.type && this._updateLayer(i)
                        }
                    }
                    _forceSymbolLayerUpdate() {
                        for (const t in this._layers) {
                            const i = this._layers[t];
                            "symbol" === i.type && this._updateLayer(i)
                        }
                    }
                    _validate(t, i, h, d, m={}) {
                        if (m && !1 === m.validate)
                            return !1;
                        const y = s.l({}, this.serialize());
                        return ia(this, t.call(ci, s.l({
                            key: i,
                            style: y,
                            value: h,
                            styleSpec: s.a3
                        }, d)))
                    }
                    _remove() {
                        this._request && (this._request.cancel(),
                        this._request = null),
                        this._spriteRequest && (this._spriteRequest.cancel(),
                        this._spriteRequest = null),
                        s.cx.off("pluginStateChange", this._rtlTextPluginCallback);
                        for (const t in this._mergedLayers)
                            this._mergedLayers[t].setEventedParent(null);
                        for (const t in this._mergedSourceCaches)
                            this._mergedSourceCaches[t].clearTiles(),
                            this._mergedSourceCaches[t].setEventedParent(null);
                        this.setEventedParent(null),
                        delete this.fog,
                        delete this.snow,
                        delete this.rain,
                        delete this.terrain,
                        delete this.ambientLight,
                        delete this.directionalLight,
                        this.isRootStyle() && (this.imageManager.setEventedParent(null),
                        this.modelManager.setEventedParent(null),
                        this.dispatcher.remove())
                    }
                    clearSource(t) {
                        const i = this.getSourceCaches(t);
                        for (const h of i)
                            h.clearTiles()
                    }
                    clearSources() {
                        for (const t in this._mergedSourceCaches)
                            this._mergedSourceCaches[t].clearTiles()
                    }
                    reloadSource(t) {
                        const i = this.getSourceCaches(t);
                        for (const h of i)
                            h.resume(),
                            h.reload()
                    }
                    reloadSources() {
                        for (const t of this.getSources())
                            t.reload && t.reload()
                    }
                    updateSources(t) {
                        let i;
                        this.directionalLight && (i = Ss(this.directionalLight));
                        for (const h in this._mergedSourceCaches)
                            this._mergedSourceCaches[h].update(t, void 0, void 0, i)
                    }
                    _generateCollisionBoxes() {
                        for (const t in this._sourceCaches) {
                            const i = this._sourceCaches[t];
                            i.resume(),
                            i.reload()
                        }
                    }
                    _updatePlacement(t, i, h, d, m, y, M=!1) {
                        let E = !1
                          , S = !1;
                        const I = {}
                          , R = {};
                        for (const D of this._mergedOrder) {
                            const k = this._mergedLayers[D];
                            if ("symbol" !== k.type)
                                continue;
                            const H = s.aC(k.source, k.scope);
                            let j = I[H];
                            if (!j) {
                                const K = this.getLayerSourceCache(k);
                                if (!K)
                                    continue;
                                const he = K.getRenderableIds(!0).map(Te => K.getTileByID(Te));
                                R[H] = he.slice(),
                                j = I[H] = he.sort( (Te, be) => be.tileID.overscaledZ - Te.tileID.overscaledZ || (Te.tileID.isLessThan(be.tileID) ? -1 : 1))
                            }
                            const Y = this.crossTileSymbolIndex.addLayer(k, j, i.center.lng, i.projection);
                            E = E || Y
                        }
                        if (this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder),
                        M = M || this._layerOrderChanged || 0 === d,
                        this._layerOrderChanged && this.fire(new s.z("neworder")),
                        (M || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(s.q.now(), i.zoom)) && (this.pauseablePlacement = new ol(i,this._mergedOrder,M,h,d,m,this.placement,this.fog && i.projection.supportsFog ? this.fog.state : null,this._buildingIndex),
                        this._layerOrderChanged = !1),
                        this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, I, R, this.map.painter.scaleFactor),
                        this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(s.q.now()),
                        S = !0),
                        E && this.pauseablePlacement.placement.setStale()),
                        S || E) {
                            this._buildingIndex.onNewFrame(i.zoom);
                            for (let D = 0; D < this._mergedOrder.length; D++) {
                                const k = this._mergedLayers[this._mergedOrder[D]];
                                if ("symbol" !== k.type)
                                    continue;
                                const H = this.isLayerClipped(k);
                                this.placement.updateLayerOpacities(k, I[s.aC(k.source, k.scope)], D, H ? y : null)
                            }
                        }
                        return {
                            needsRerender: !this.pauseablePlacement.isDone() || this.placement.hasTransitions(s.q.now())
                        }
                    }
                    _releaseSymbolFadeTiles() {
                        for (const t in this._sourceCaches)
                            this._sourceCaches[t].releaseSymbolFadeTiles()
                    }
                    addImport(t, i) {
                        this._checkLoaded();
                        const h = this.stylesheet.imports = this.stylesheet.imports || [];
                        if (-1 !== h.findIndex( ({id: m}) => m === t.id))
                            return void this.fire(new s.y(new Error("Import with id '".concat(t.id, "' already exists in the map's style."))));
                        if (!i)
                            return h.push(t),
                            this._loadImports([t], !0);
                        const d = h.findIndex( ({id: m}) => m === i);
                        return -1 === d && this.fire(new s.y(new Error('Import with id "'.concat(i, '" does not exist on this map.')))),
                        this.stylesheet.imports = h.slice(0, d).concat(t).concat(h.slice(d)),
                        this._loadImports([t], !0, i)
                    }
                    updateImport(t, i) {
                        this._checkLoaded();
                        const h = this.stylesheet.imports || []
                          , d = this.getImportIndex(t);
                        return -1 === d ? this : "string" == typeof i ? (this.setImportUrl(t, i),
                        this) : (i.url && i.url !== h[d].url && this.setImportUrl(t, i.url),
                        s.bn(i.config, h[d].config) || this.setImportConfig(t, i.config),
                        s.bn(i.data, h[d].data) || this.setImportData(t, i.data),
                        this)
                    }
                    moveImport(t, i) {
                        this._checkLoaded();
                        let h = this.stylesheet.imports || [];
                        const d = this.getImportIndex(t);
                        if (-1 === d)
                            return this;
                        const m = this.getImportIndex(i);
                        if (-1 === m)
                            return this;
                        const y = h[d]
                          , M = this.fragments[d];
                        return h = h.filter( ({id: E}) => E !== t),
                        this.fragments = this.fragments.filter( ({id: E}) => E !== t),
                        this.stylesheet.imports = h.slice(0, m).concat(y).concat(h.slice(m)),
                        this.fragments = this.fragments.slice(0, m).concat(M).concat(this.fragments.slice(m)),
                        this.mergeLayers(),
                        this
                    }
                    setImportUrl(t, i) {
                        this._checkLoaded();
                        const h = this.stylesheet.imports || []
                          , d = this.getImportIndex(t);
                        if (-1 === d)
                            return this;
                        h[d].url = i;
                        const m = this.fragments[d];
                        return m.style = this._createFragmentStyle(h[d]),
                        m.style.on("style.import.load", () => this.mergeAll()),
                        m.style.loadURL(i),
                        this
                    }
                    setImportData(t, i) {
                        this._checkLoaded();
                        const h = this.getImportIndex(t)
                          , d = this.stylesheet.imports || [];
                        return -1 === h ? this : i ? (this.fragments[h].style.setState(i),
                        this._reloadImports(),
                        this) : (delete d[h].data,
                        this.setImportUrl(t, d[h].url))
                    }
                    setImportConfig(t, i) {
                        this._checkLoaded();
                        const h = this.getImportIndex(t)
                          , d = this.stylesheet.imports || [];
                        if (-1 === h)
                            return this;
                        i ? d[h].config = i : delete d[h].config;
                        const m = this.fragments[h]
                          , y = m.style.stylesheet && m.style.stylesheet.schema;
                        return m.config = i,
                        m.style.updateConfig(i, y),
                        this.updateConfigDependencies(),
                        this
                    }
                    removeImport(t) {
                        this._checkLoaded();
                        const i = this.stylesheet.imports || []
                          , h = this.getImportIndex(t);
                        -1 !== h && (i.splice(h, 1),
                        this.fragments[h].style._remove(),
                        this.fragments.splice(h, 1),
                        this._reloadImports())
                    }
                    getImportIndex(t) {
                        const i = (this.stylesheet.imports || []).findIndex(h => h.id === t);
                        return -1 === i && this.fire(new s.y(new Error("Import '".concat(t, "' does not exist in the map's style and cannot be updated.")))),
                        i
                    }
                    getLayer(t) {
                        return this._mergedLayers[t]
                    }
                    getSources() {
                        const t = [];
                        for (const i in this._mergedOtherSourceCaches) {
                            const h = this._mergedOtherSourceCaches[i];
                            h && t.push(h.getSource())
                        }
                        return t
                    }
                    getSource(t, i) {
                        const h = this.getSourceCache(t, i);
                        return h && h.getSource()
                    }
                    getLayerSource(t) {
                        const i = this.getLayerSourceCache(t);
                        return i && i.getSource()
                    }
                    getSourceCache(t, i) {
                        const h = s.aC(t, i);
                        return this._mergedOtherSourceCaches[h]
                    }
                    getLayerSourceCache(t) {
                        const i = s.aC(t.source, t.scope);
                        return "symbol" === t.type ? this._mergedSymbolSourceCaches[i] : this._mergedOtherSourceCaches[i]
                    }
                    getSourceCaches(t) {
                        if (null == t)
                            return Object.values(this._mergedSourceCaches);
                        const i = [];
                        return this._mergedOtherSourceCaches[t] && i.push(this._mergedOtherSourceCaches[t]),
                        this._mergedSymbolSourceCaches[t] && i.push(this._mergedSymbolSourceCaches[t]),
                        i
                    }
                    updateSourceCaches() {
                        const t = this._changes.getUpdatedSourceCaches();
                        for (const i in t) {
                            const h = t[i];
                            "reload" === h ? this.reloadSource(i) : "clear" === h && this.clearSource(i)
                        }
                    }
                    updateLayers(t) {
                        const i = this._changes.getUpdatedPaintProperties();
                        for (const h of i) {
                            const d = this.getLayer(h);
                            d && d.updateTransitions(t)
                        }
                    }
                    getImages(t, i, h) {
                        this.imageManager.getImages(i.icons, i.scope, h),
                        this._updateTilesForChangedImages();
                        const d = m => {
                            m && m.setDependencies(i.tileID.key, i.type, i.icons)
                        }
                        ;
                        d(this._otherSourceCaches[i.source]),
                        d(this._symbolSourceCaches[i.source])
                    }
                    rasterizeImages(t, i, h) {
                        this.imageManager.rasterizeImages(i, h)
                    }
                    getGlyphs(t, i, h) {
                        this.glyphManager.getGlyphs(i.stacks, i.scope, h)
                    }
                    getResource(t, i, h) {
                        return s.cy(i, h)
                    }
                    getOwnSourceCache(t) {
                        return this._otherSourceCaches[t]
                    }
                    getOwnLayerSourceCache(t) {
                        return "symbol" === t.type ? this._symbolSourceCaches[t.source] : this._otherSourceCaches[t.source]
                    }
                    getOwnSourceCaches(t) {
                        const i = [];
                        return this._otherSourceCaches[t] && i.push(this._otherSourceCaches[t]),
                        this._symbolSourceCaches[t] && i.push(this._symbolSourceCaches[t]),
                        i
                    }
                    _isSourceCacheLoaded(t) {
                        const i = this.getOwnSourceCaches(t);
                        return 0 === i.length ? (this.fire(new s.y(new Error("There is no source with ID '".concat(t, "'")))),
                        !1) : i.every(h => h.loaded())
                    }
                    has3DLayers() {
                        return this._has3DLayers
                    }
                    hasSymbolLayers() {
                        return this._hasSymbolLayers
                    }
                    hasCircleLayers() {
                        return this._hasCircleLayers
                    }
                    isLayerClipped(t, i) {
                        if (!this._clipLayerPresent && "fill-extrusion" !== t.type)
                            return !1;
                        const h = "fill-extrusion" === t.type && "building" === t.sourceLayer;
                        if (t.is3D()) {
                            if (h || i && "batched-model" === i.type || "model" === t.type)
                                return !0
                        } else if ("symbol" === t.type)
                            return !0;
                        return !1
                    }
                    _clearWorkerCaches() {
                        this.dispatcher.broadcast("clearCaches")
                    }
                    destroy() {
                        this._clearWorkerCaches(),
                        this.fragments.forEach(t => {
                            t.style._remove()
                        }
                        ),
                        this.terrainSetForDrapingOnly() && (delete this.terrain,
                        delete this.stylesheet.terrain)
                    }
                }
                pr.getSourceType = function(c) {
                    return fr[c]
                }
                ,
                pr.setSourceType = function(c, t) {
                    fr[c] = t
                }
                ,
                pr.registerForPluginStateChange = s.ch;
                var Kl = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#ifdef RENDER_CUTOFF\nfloat cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}\n#endif"
                  , rh = "\nout vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\n#ifdef INDICATOR_CUTOUT\nuniform vec3 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;\n#endif\nvec4 applyCutout(vec4 color,float height) {\n#ifdef INDICATOR_CUTOUT\nfloat verticalFadeRange=u_indicator_cutout_centers.z*0.25;float holeMinOpacity=mix(1.0,u_indicator_cutout_params.x,smoothstep(u_indicator_cutout_centers.z,u_indicator_cutout_centers.z+verticalFadeRange,height));float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);\n#else\nreturn color;\n#endif\n}\n#ifdef DEBUG_WIREFRAME\n#define HANDLE_WIREFRAME_DEBUG \\\nglFragColor=vec4(0.7,0.0,0.0,0.7); \\\ngl_FragDepth=gl_FragCoord.z-0.0001;\n#else\n#define HANDLE_WIREFRAME_DEBUG\n#endif\n#ifdef RENDER_CUTOFF\nuniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;\n#endif\nvec4 textureLodCustom(sampler2D image,highp vec2 pos,highp vec2 lod_coord) {highp vec2 size=vec2(textureSize(image,0));highp vec2 dx=dFdx(lod_coord.xy*size);highp vec2 dy=dFdy(lod_coord.xy*size);highp float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));highp float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}vec4 applyLUT(highp sampler3D lut,vec4 col) {vec3 size=vec3(textureSize(lut,0));vec3 uvw=(col.rbg*float(size-1.0)+0.5)/size;return vec4(texture(lut,uvw).rgb,col.a);}vec3 applyLUT(highp sampler3D lut,vec3 col) {return applyLUT(lut,vec4(col,1.0)).rgb;}"
                  , ll = "\n#define EXTENT 8192.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const vec2 units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (units_to_pixels*pos+offset)/pattern_size;}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {return get_pattern_pos(pixel_coord_upper,pixel_coord_lower,pattern_size,vec2(tile_units_to_pixels),pos);}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}\n#ifdef RENDER_CUTOFF\nuniform vec4 u_cutoff_params;out float v_cutoff_opacity;\n#endif\nconst vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}"
                  , Is = "in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}"
                  , ql = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nvec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }\n#endif\n#ifdef DEPTH_OCCLUSION\nuniform highp sampler2D u_depth;uniform highp vec2 u_depth_size_inv;uniform highp vec2 u_depth_range_unpack;uniform highp float u_occluder_half_size;uniform highp float u_occlusion_depth_offset;\n#ifdef DEPTH_D24\nfloat unpack_depth(float depth) {return depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}vec4 unpack_depth4(vec4 depth) {return depth*u_depth_range_unpack.x+vec4(u_depth_range_unpack.y);}\n#else\nhighp float unpack_depth_rgba(vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\n#endif\nbool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;\n#ifdef DEPTH_D24\nfloat depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5).r);\n#else\nfloat depth=unpack_depth_rgba(texture(u_depth,(coord.xy+1.0)*0.5));\n#endif\nreturn coord.z+u_occlusion_depth_offset > depth;}highp vec4 getCornerDepths(vec2 coord) {highp vec3 df=vec3(u_occluder_half_size*u_depth_size_inv,0.0);highp vec2 uv=0.5*coord.xy+0.5;\n#ifdef DEPTH_D24\nhighp vec4 depth=vec4(\ntexture(u_depth,uv-df.xz).r,texture(u_depth,uv+df.xz).r,texture(u_depth,uv-df.zy).r,texture(u_depth,uv+df.zy).r\n);depth=unpack_depth4(depth);\n#else\nhighp vec4 depth=vec4(\nunpack_depth_rgba(texture(u_depth,uv-df.xz)),unpack_depth_rgba(texture(u_depth,uv+df.xz)),unpack_depth_rgba(texture(u_depth,uv-df.zy)),unpack_depth_rgba(texture(u_depth,uv+df.zy))\n);\n#endif\nreturn depth;}highp float occlusionFadeMultiSample(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec2 uv=0.5*coord.xy+0.5;int NX=3;int NY=4;highp vec2 df=u_occluder_half_size*u_depth_size_inv;highp vec2 oneStep=2.0*u_occluder_half_size*u_depth_size_inv/vec2(NX-1,NY-1);highp float res=0.0;for (int y=0; y < NY;++y) {for (int x=0; x < NX;++x) {\n#ifdef DEPTH_D24\nhighp float depth=unpack_depth(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)).r);\n#else\nhighp float depth=unpack_depth_rgba(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)));\n#endif\nres+=1.0-clamp(300.0*(coord.z+u_occlusion_depth_offset-depth),0.0,1.0);}}res=clamp(2.0*res/float(NX*NY)-0.5,0.0,1.0);return res;}highp float occlusionFade(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec4 depth=getCornerDepths(coord.xy);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z+u_occlusion_depth_offset)-depth),0.0,1.0));}\n#else\nbool isOccluded(vec4 frag) { return false; }highp float occlusionFade(vec4 frag) { return 1.0; }highp float occlusionFadeMultiSample(vec4 frag) { return 1.0; }\n#endif//DEPTH_OCCLUSION"
                  , us = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif"
                  , Jl = "highp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}\n#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {\n#ifdef FOG_DITHERING\nvec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);\n#else\nreturn color;\n#endif\n}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif"
                  , cl = "#ifdef RASTER_ARRAY\nuniform highp sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)\n);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)\n);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}\n#endif"
                  , qn = "#ifdef RASTER_ARRAY\nuniform sampler2D u_velocity;uniform mediump vec2 u_velocity_res;uniform mediump float u_max_speed;const vec4 NO_DATA=vec4(1);const vec2 INVALID_VELOCITY=vec2(-1);uniform highp vec2 u_uv_offset;uniform highp float u_data_offset;uniform highp vec2 u_data_scale;ivec4 rasterArrayLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}highp vec2 lookup_velocity(highp vec2 uv) {uv=u_uv_offset.x+u_uv_offset.y*uv;highp vec2 fxy;ivec4 c=rasterArrayLinearCoord(uv,u_velocity_res,fxy);highp vec4 tl=texelFetch(u_velocity,c.yz,0);highp vec4 tr=texelFetch(u_velocity,c.xz,0);highp vec4 bl=texelFetch(u_velocity,c.yw,0);highp vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NO_DATA) {return INVALID_VELOCITY;}if (tr==NO_DATA) {return INVALID_VELOCITY;}if (bl==NO_DATA) {return INVALID_VELOCITY;}if (br==NO_DATA) {return INVALID_VELOCITY;}highp vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);highp vec2 velocity=u_data_offset+vec2(dot(t.rg,u_data_scale),dot(t.ba,u_data_scale));velocity.y=-velocity.y;velocity/=max(u_max_speed,length(velocity));return velocity;}\n#endif\nuniform highp float u_particle_pos_scale;uniform highp vec2 u_particle_pos_offset;highp vec4 pack_pos_to_rgba(highp vec2 p) {highp vec2 v=(p+u_particle_pos_offset)/u_particle_pos_scale;highp vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}highp vec2 unpack_pos_from_rgba(highp vec4 v) {v=floor(v*255.0+0.5)/255.0;highp vec2 p=vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));return u_particle_pos_scale*p-u_particle_pos_offset;}"
                  , Wn = "#ifdef RENDER_SHADOWS\nuniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {vec3 transformed_normal=vec3(-normal.xy,normal.z);float NDotL=dot(normalize(transformed_normal),u_shadow_direction);float dotScale=min(1.0-NDotL,1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}\n#endif//RENDER_SHADOWS"
                  , ps = "#ifdef RENDER_SHADOWS\n#ifdef DEPTH_TEXTURE\nuniform highp sampler2D u_shadowmap_0;uniform highp sampler2D u_shadowmap_1;\n#else\nuniform sampler2D u_shadowmap_0;uniform sampler2D u_shadowmap_1;\n#endif\nuniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;highp float shadow_sample_1(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_1,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_1,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}highp float shadow_sample_0(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_0,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_0,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}float shadow_occlusion_1(highp vec4 pos,highp float bias) {highp vec2 uv=pos.xy;return shadow_sample_1(uv,pos.z-bias);}float shadow_occlusion_0(highp vec4 pos,highp float bias) {highp float compare0=pos.z-bias;\n#ifdef TEXTURE_GATHER\nhighp vec2 uv=pos.xy;highp vec4 samples=textureGather(u_shadowmap_0,uv,0);lowp vec4 stepSamples=step(samples,vec4(compare0));\n#else\nhighp vec2 uv00=pos.xy-vec2(0.5*u_shadow_texel_size);highp vec2 uv10=uv00+vec2(u_shadow_texel_size,0.0);highp vec2 uv01=uv00+vec2(0.0,u_shadow_texel_size);highp vec2 uv11=uv01+vec2(u_shadow_texel_size,0.0);lowp vec4 stepSamples=vec4(\nshadow_sample_0(uv01,compare0),shadow_sample_0(uv11,compare0),shadow_sample_0(uv10,compare0),shadow_sample_0(uv00,compare0)\n);\n#endif\nvec2 f=fract(pos.xy*u_shadow_map_resolution-vec2(0.5));lowp vec2 lerpx=mix(stepSamples.wx,stepSamples.zy,f.xx);return mix(lerpx.x,lerpx.y,f.y);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {\n#ifdef SHADOWS_SINGLE_CASCADE\nlight_view_pos0.xyz/=light_view_pos0.w;vec2 abs_bounds=abs(light_view_pos0.xy);if (abs_bounds.x >=1.0 || abs_bounds.y >=1.0) {return 0.0;}light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);\n#else\nlight_view_pos0.xyz/=light_view_pos0.w;light_view_pos1.xyz/=light_view_pos1.w;vec4 uv=vec4(light_view_pos0.xy,light_view_pos1.xy);vec4 abs_bounds=abs(uv);if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}light_view_pos1.xyz=light_view_pos1.xyz*0.5+0.5;float occlusion1=shadow_occlusion_1(light_view_pos1,bias);return mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth));\n#endif\n}highp float calculate_shadow_bias(float NDotL) {\n#ifdef NORMAL_OFFSET\nreturn 0.5*u_shadow_bias.x;\n#else\nreturn 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));\n#endif\n}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_opacity(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,float shadow_opacity) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias)*shadow_opacity;return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}highp vec2 compute_receiver_plane_depth_bias(highp vec3 pos_dx,highp vec3 pos_dy)\n{highp vec2 biasUV=vec2(\npos_dy.y*pos_dx.z-pos_dx.y*pos_dy.z,pos_dx.x*pos_dy.z-pos_dy.x*pos_dx.z);biasUV*=1.0/((pos_dx.x*pos_dy.y)-(pos_dx.y*pos_dy.x));return biasUV;}float shadowed_light_factor_plane_bias(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {highp vec3 light_view_pos0_xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;highp vec3 light_view_pos0_ddx=dFdx(light_view_pos0_xyz);highp vec3 light_view_pos0_ddy=dFdy(light_view_pos0_xyz);highp vec2 plane_depth_bias=compute_receiver_plane_depth_bias(light_view_pos0_ddx,light_view_pos0_ddy);highp float bias=dot(vec2(u_shadow_texel_size,u_shadow_texel_size),plane_depth_bias)+0.0001;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}\n#endif";
                const zn = [];
                Ur(Kl, zn),
                Ur(ll, zn),
                Ur(rh, zn);
                const rr = {
                    "_prelude_fog.vertex.glsl": us,
                    "_prelude_terrain.vertex.glsl": ql,
                    "_prelude_shadow.vertex.glsl": Wn,
                    "_prelude_fog.fragment.glsl": Jl,
                    "_prelude_shadow.fragment.glsl": ps,
                    "_prelude_lighting.glsl": "\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}\n#endif//LIGHTING_3D_MODE",
                    "_prelude_raster_array.glsl": cl,
                    "_prelude_raster_particle.glsl": qn
                }
                  , qr = {};
                mi("", ql),
                mi(Jl, us),
                mi(ps, Wn),
                mi(cl, ""),
                mi(qn, "");
                const As = mi(rh, ll)
                  , ds = Kl;
                var Ia = {
                    background: mi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nin vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_lighting.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
                    backgroundPattern: mi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in highp vec2 v_pos;void main() {highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec2 u_pattern_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_pattern_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
                    circle: mi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float blur_positive=blur < 0.0 ? 0.0 : 1.0;lowp float antialiasblur=v_data.z;float extrude_length=length(extrude)+antialiasblur*(1.0-blur_positive);float antialiased_blur=-max(abs(blur),antialiasblur);float opacity_t=smoothstep((1.0-blur_positive)*antialiased_blur,blur_positive*antialiased_blur,extrude_length-1.0)-smoothstep(0.0,antialiasblur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\nglFragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}'),
                    clippingMask: mi("void main() {glFragColor=vec4(1.0);}", "in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
                    heatmap: mi('#include "_prelude_fog.fragment.glsl"\nuniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'),
                    heatmapTexture: mi("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(0.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"),
                    collisionBox: mi("in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", '#include "_prelude_terrain.vertex.glsl"\nin vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in vec2 a_elevation_from_sea;in float a_size_scale;in vec2 a_padding;in float a_auto_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;out float v_placed;out float v_notUsed;void main() {float feature_elevation=a_elevation_from_sea.x+a_auto_z_offset;float terrain_elevation=(a_elevation_from_sea.y==1.0 ? 0.0 : elevation(a_anchor_pos));vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*(feature_elevation+terrain_elevation),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}'),
                    collisionCircle: mi("in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}", "in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
                    debug: mi("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}", '#include "_prelude_terrain.vertex.glsl"\nin vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;\n#endif\nout vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}'),
                    fill: mi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nuniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=opacity;\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_z_offset);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\nuniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp float z_offset\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=z_offset;\n#endif\n}'),
                    fillOutline: mi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nin highp vec2 v_pos;uniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nuniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp float z_offset\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
                    fillOutlinePattern: mi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\nin highp vec2 v_pos;in highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nout highp vec2 v_pos;out highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize highp float z_offset\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
                    fillPattern: mi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;in highp vec2 v_pos;uniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nout highp vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize highp float z_offset\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
                    fillExtrusion: mi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec4 v_color;in vec4 v_flat;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;\n#endif\nuniform lowp float u_opacity;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec2 v_ao;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nin vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nin highp vec3 v_normal;\n#endif\nuniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nin float v_flood_radius;in float v_has_floodlight;\n#endif\nin float v_height;\n#pragma mapbox: define highp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp float emissive_strength\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nvec3 normal=normalize(v_normal);\n#endif\nfloat z;vec4 color=v_color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);\n#ifdef LIGHTING_3D_MODE\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#else\ncolor=mix(v_color,v_roof_color,z);\n#endif\n#endif\nfloat h=max(0.0,v_height);float ao_shade=1.0;\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\ncolor.rgb*=mix(ao_shade,1.0,v_has_floodlight);\n#else\ncolor.rgb*=ao_shade;\n#endif\n#else\ncolor.rgb*=ao_shade;\n#endif\n#endif\n#ifdef LIGHTING_3D_MODE\nfloat flood_radiance=0.0;\n#ifdef FLOOD_LIGHT\nflood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef FLOOD_LIGHT\nfloat ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);\n#else\nfloat shadowed_lighting_factor;\n#ifdef RENDER_CUTOFF\nshadowed_lighting_factor=shadowed_light_factor_normal_opacity(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}\n#else\nshadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);\n#endif\ncolor.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\n#endif\n#else\ncolor.rgb=apply_lighting(color.rgb,normal);\n#ifdef FLOOD_LIGHT\ncolor.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);\n#endif\n#endif\ncolor.rgb=mix(color.rgb,v_flat.rgb,emissive_strength);color*=u_opacity;\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));\n#endif\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color,h);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;uniform float u_width_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nuniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nout vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nout highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec2 v_ao;\n#endif\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nout float v_flood_radius;out float v_has_floodlight;\n#endif\nout float v_height;vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define highp float flood_light_wall_radius\n#pragma mapbox: define highp float line_width\n#pragma mapbox: define highp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize highp float flood_light_wall_radius\n#pragma mapbox: initialize highp float line_width\n#pragma mapbox: initialize highp float emissive_strength\nbase*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nv_normal=normal;\n#endif\nbase=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat cutoff=1.0;vec3 scaled_pos=pos;\n#ifdef RENDER_CUTOFF\nvec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);cutoff=cutoff_opacity(u_cutoff_params,ground.z);if (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;v_cutoff_opacity=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff==0.0 && centroid_pos.x !=0.0) || (color.a==0.0));\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);scaled_pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;scaled_pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\ngl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifndef LIGHTING_3D_MODE\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#endif\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\nfloat is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;\n#endif\nv_color=vec4(color.rgb,1.0);float ndotl=calculate_NdotL(normal);v_flat.rgb=sRGBToLinear(color.rgb);v_flat.rgb=v_flat.rgb*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);v_flat=vec4(linearTosRGB(v_flat.rgb),1.0);\n#else\nv_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'),
                    fillExtrusionDepth: mi("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_width_scale;uniform float u_vertical_scale;\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nin vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp float line_width\n#pragma mapbox: define highp vec4 color\nout highp float v_depth;void main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp float line_width\n#pragma mapbox: initialize highp vec4 color\nbase*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nvec3 pos;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;float ele=elevation(pos_nx.xy);float c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);float h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);\n#else\npos=vec3(pos_nx.xy,t > 0.0 ? height : base);\n#endif\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}'),
                    fillExtrusionPattern: mi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nin vec3 v_normal;\n#endif\nin highp vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,height);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_width_scale;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nout highp vec2 v_pos;out vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nout vec3 v_normal;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define highp float pixel_ratio\n#pragma mapbox: define highp float line_width\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize highp float pixel_ratio\n#pragma mapbox: initialize highp float line_width\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);p.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;p.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_normal=normal;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}'),
                    groundShadow: mi('#include "_prelude_shadow.fragment.glsl"\nprecision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\nvoid main() {float light=shadowed_light_factor_plane_bias(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);\n#ifdef RENDER_CUTOFF\nshadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));\n#endif\n#ifdef FOG\nshadow=mix(shadow,vec3(1.0),v_fog_opacity);\n#endif\n#ifdef INDICATOR_CUTOUT\nshadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0),0.0).r);\n#endif\nglFragColor=vec4(shadow,1.0);}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);\n#endif\n}'),
                    fillExtrusionGroundEffect: mi("uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;\n#ifdef SDF_SUBPASS\nin highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}\n#ifdef FOG\nin highp float v_fog;\n#endif\n#endif\nvoid main() {\n#ifdef CLEAR_SUBPASS\nvec4 color=vec4(1.0);\n#ifdef CLEAR_FROM_TEXTURE\ncolor=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));\n#endif\nglFragColor=color;\n#else\n#ifdef SDF_SUBPASS\nhighp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;\n#ifdef FOG\nfog=v_fog;\n#endif\n#ifdef RENDER_CUTOFF\nfog*=v_cutoff_opacity;\n#endif\nglFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));\n#else\nvec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);\n#ifdef OVERDRAW_INSPECTOR\ncolor=vec4(1.0);\n#endif\nglFragColor=color;\n#endif\nHANDLE_WIREFRAME_DEBUG;\n#endif\n}", '#include "_prelude_fog.vertex.glsl"\nin highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;\n#ifdef SDF_SUBPASS\nout highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;\n#ifdef FOG\nout highp float v_fog;\n#endif\n#endif\nuniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp float u_dynamic_offset;uniform highp vec2 u_ao;\n#pragma mapbox: define highp float flood_light_ground_radius\nconst float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {\n#pragma mapbox: initialize highp float flood_light_ground_radius\nvec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(u_dynamic_offset,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;\n#ifdef SDF_SUBPASS\nv_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);\n#ifdef FOG\nv_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);\n#endif\n#endif\nfloat hidden_by_landmark=0.0;\n#ifdef HAS_CENTROID\nhidden_by_landmark=a_hidden_by_landmark;\n#endif\nfloat isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}'),
                    hillshadePrepare: mi("precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
                    hillshade: mi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\nglFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);\n#endif\n#ifdef FOG\nglFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
                    line: mi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform lowp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_floor_width_scale;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec4 v_uv;\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;in vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\nfloat luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;float scaled_floorwidth=(floorwidth*u_floor_width_scale);alpha*=linearstep(0.5-sdfgamma/scaled_floorwidth,0.5+sdfgamma/scaled_floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trim_alpha=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);out_color=mix(out_color,u_trim_color,transition_factor);trim_alpha=1.0-transition_factor;}\n#endif\nif (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=((border_width*u_width_scale)+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color=mix(border_color*trim_alpha,out_color,smoothAlpha);}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef ELEVATED_ROADS\nout_color.rgb*=mix(v_road_z_offset > 0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#else\nout_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_z_offset);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define EXTRUDE_SCALE 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS) || defined(VARIABLE_LINE_WIDTH)\nin vec2 a_z_offset_width;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nin highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nin float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;uniform float u_width_scale;uniform highp float u_floor_width_scale;\n#ifdef ELEVATED\nuniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {\n#ifdef ELEVATION_REFERENCE_SEA\nreturn 0.0;\n#else\nreturn elevation(apos);\n#endif\n}\n#endif\nout vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec4 v_uv;\n#ifdef ELEVATED_ROADS\nout highp float v_road_z_offset;\n#endif\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat a_z_offset;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\na_z_offset=a_z_offset_width.x;\n#endif\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth;\n#ifdef VARIABLE_LINE_WIDTH\nhalfwidth=(u_width_scale*a_z_offset_width.y)/2.0;\n#else\nhalfwidth=(u_width_scale*width)/2.0;\n#endif\noffset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;\n#ifdef ELEVATED_ROADS\nv_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset+0.01*step(0.01,a_z_offset),1.0)+projected_extrude;\n#else\n#ifdef ELEVATED\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;\n#ifdef CROSS_SLOPE_VERTICAL\nfloat top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);\n#else\n#ifdef CROSS_SLOPE_HORIZONTAL\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;\n#else\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;\n#endif\n#endif\ngl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\n#else\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\n#endif\n#endif\n#ifdef ELEVATED_ROADS\n#ifdef RENDER_SHADOWS\nvec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;\n#ifdef NORMAL_OFFSET\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#endif\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/(floorwidth*u_floor_width_scale),(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=a_z_offset;\n#endif\n}'),
                    linePattern: mi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform highp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_alpha_discard_threshold;uniform highp vec2 u_texsize;uniform highp float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in highp float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec4 v_uv;\n#endif\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef LINE_JOIN_NONE\nin vec2 v_pattern_data;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\nuniform float u_emissive_strength;\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define mediump float pixel_ratio\n#pragma mapbox: define mediump float blur\n#pragma mapbox: define mediump float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize mediump float pixel_ratio\n#pragma mapbox: initialize mediump float blur\n#pragma mapbox: initialize mediump float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;highp float pattern_size=display_size.x/u_tile_units_to_pixels;float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);highp float pattern_x=v_linesofar/pattern_size*aspect;highp float x=mod(pattern_x,1.0);highp float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;highp vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));highp vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);color=mix(color,color.a*u_trim_color,transition_factor);}\n#endif\n#ifdef LINE_JOIN_NONE\nhighp float pattern_len=pattern_size/aspect;highp float segment_phase=pattern_len-mod(v_linesofar-v_pattern_data.x+pattern_len,pattern_len);highp float visible_start=segment_phase-step(pattern_len*0.5,segment_phase)*pattern_len;highp float visible_end=floor((v_pattern_data.y-segment_phase)/pattern_len)*pattern_len+segment_phase;visible_end+=step(pattern_len*0.5,v_pattern_data.y-visible_end)*pattern_len;if (v_pattern_data.x < visible_start || v_pattern_data.x >=visible_end) {color=vec4(0.0);}\n#endif\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting_with_emission_ground(color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef ELEVATED_ROADS\ncolor.rgb*=mix(v_road_z_offset > 0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#else\ncolor.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=(alpha*opacity);if (u_alpha_discard_threshold !=0.0) {if (color.a < u_alpha_discard_threshold) {discard;}}\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color,v_z_offset);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\nin vec2 a_z_offset_width;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec4 a_packed;\n#endif\nin highp float a_linesofar;\n#ifdef LINE_JOIN_NONE\nin highp vec3 a_pattern_data;out vec2 v_pattern_data;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\nuniform mat4 u_matrix;uniform float u_tile_units_to_pixels;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform float u_device_pixel_ratio;uniform float u_width_scale;uniform float u_floor_width_scale;\n#ifdef ELEVATED\nuniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {\n#ifdef ELEVATION_REFERENCE_SEA\nreturn 0.0;\n#else\nreturn elevation(apos);\n#endif\n}\n#endif\nout vec2 v_normal;out vec2 v_width2;out highp float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nout highp vec4 v_uv;\n#endif\n#ifdef ELEVATED_ROADS\nout highp float v_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#pragma mapbox: define mediump float blur\n#pragma mapbox: define mediump float opacity\n#pragma mapbox: define mediump float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define mediump float floorwidth\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define mediump float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize mediump float blur\n#pragma mapbox: initialize mediump float opacity\n#pragma mapbox: initialize mediump float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize mediump float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize mediump float pixel_ratio\nfloat a_z_offset;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\na_z_offset=a_z_offset_width.x;\n#endif\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=(u_width_scale*width)/2.0;offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);vec2 dist=outset*a_extrude*scale;float u=0.5*a_direction;float t=1.0-abs(u);vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;\n#ifdef ELEVATED_ROADS\nv_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset+0.01*step(0.01,a_z_offset),1.0)+projected_extrude;\n#else\n#ifdef ELEVATED\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;\n#ifdef CROSS_SLOPE_VERTICAL\nfloat top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);\n#else\n#ifdef CROSS_SLOPE_HORIZONTAL\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;\n#else\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;\n#endif\n#endif\ngl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\n#else\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\n#endif\n#endif\n#ifdef ELEVATED_ROADS\n#ifdef RENDER_SHADOWS\nvec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;\n#ifdef NORMAL_OFFSET\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#endif\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));\n#else\nv_gamma_scale=1.0;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nfloat a_uv_x=a_packed[0];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];v_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=(floorwidth*u_floor_width_scale);\n#ifdef LINE_JOIN_NONE\nv_width=(floorwidth*u_floor_width_scale)+ANTIALIASING;mediump float pixels_to_tile_units=1.0/u_tile_units_to_pixels;mediump float pixel_ratio_inverse=1.0/pixel_ratio;mediump float aspect=v_width/((pattern.w-pattern.y)*pixel_ratio_inverse);highp float subt_multiple=(pattern.z-pattern.x)*pixel_ratio_inverse*pixels_to_tile_units*aspect*32.0;highp float subt=floor(a_pattern_data.z/subt_multiple)*subt_multiple;float offset_sign=(fract(a_pattern_data.x)-0.5)*4.0;float line_progress_offset=offset_sign*v_width*0.5*pixels_to_tile_units;v_linesofar=(a_pattern_data.z-subt)+a_linesofar+line_progress_offset;v_pattern_data=vec2(a_pattern_data.x+line_progress_offset,a_pattern_data.y);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=a_z_offset;\n#endif\n}'),
                    raster: mi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_raster_array.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nin float v_split_fade;\n#endif\nuniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;\n#ifndef RASTER_ARRAY\nuniform highp sampler2D u_image0;uniform sampler2D u_image1;\n#endif\n#ifdef RASTER_COLOR\nuniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;\n#endif\nvoid main() {vec4 color0,color1,color;vec2 value;\n#ifdef RASTER_COLOR\n#ifdef RASTER_ARRAY\n#ifdef RASTER_ARRAY_LINEAR\nvalue=mix(\nraTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#else\nvalue=mix(\nraTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#endif\nif (value.y > 0.0) value.x/=value.y;\n#else\ncolor=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);\n#endif\ncolor=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;\n#else\ncolor0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);\n#endif\ncolor.a*=u_opacity;\n#ifdef GLOBE_POLES\ncolor.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);\n#endif\nvec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef PROJECTION_GLOBE_VIEW\nglFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));\n#endif\n#ifdef RENDER_CUTOFF\nglFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;in vec2 a_texture_pos;\n#endif\nout vec2 v_pos0;out vec2 v_pos1;out float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nout float v_split_fade;\n#endif\nvoid main() {vec2 uv;\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);\n#endif\n#else\nfloat w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    \nv_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\ngl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;\n#ifdef RENDER_CUTOFF\nv_depth=gl_Position.z;\n#endif\n}'),
                    rasterParticle: mi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),0.0).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\nin vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;vec2 uv;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\nuv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}'),
                    rasterParticleDraw: mi("uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}", '#include "_prelude_raster_particle.glsl"\nin float a_index;uniform sampler2D u_particle_texture;uniform float u_particle_texture_side_len;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {ivec2 pixel_coord=ivec2(\nmod(a_index,u_particle_texture_side_len),a_index/u_particle_texture_side_len);vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);vec2 pos=unpack_pos_from_rgba(pixel)+u_tile_offset;vec2 tex_coord=fract(pos);vec2 velocity=lookup_velocity(tex_coord);if (velocity==INVALID_VELOCITY) {gl_Position=AWAY;v_particle_speed=0.0;} else {gl_Position=vec4(2.0*pos-1.0,0,1);v_particle_speed=length(velocity);}gl_PointSize=1.0;}'),
                    rasterParticleTexture: mi("uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}", "in vec2 a_pos;out vec2 v_tex_pos;void main() {vec2 uv=0.5*a_pos+vec2(0.5);v_tex_pos=uv;gl_Position=vec4(a_pos,0.0,1.0);}"),
                    rasterParticleUpdate: mi('#include "_prelude_raster_particle.glsl"\nuniform sampler2D u_particle_texture;uniform mediump float u_particle_texture_side_len;uniform mediump float u_speed_factor;uniform highp float u_reset_rate;uniform highp float u_rand_seed;in highp vec2 v_tex_coord;vec2 linearstep(vec2 edge0,vec2 edge1,vec2 x) {return  clamp((x-edge0)/(edge1-edge0),vec2(0),vec2(1));}const highp vec3 rand_constants=vec3(12.9898,78.233,4375.85453);highp float rand(const highp vec2 co) {highp float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {ivec2 pixel_coord=ivec2(v_tex_coord*u_particle_texture_side_len);highp vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);highp vec2 pos=unpack_pos_from_rgba(pixel);highp vec2 velocity=lookup_velocity(clamp(pos,0.0,1.0));highp vec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;pos=pos+dp;highp vec2 seed=(pos+v_tex_coord)*u_rand_seed;highp vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));highp vec2 persist_rate=pow(\nlinearstep(vec2(-u_particle_pos_offset),vec2(0),pos)*linearstep(vec2(1.0+u_particle_pos_offset),vec2(1),pos),vec2(4)\n);highp vec2 per_frame_persist=pow(persist_rate,abs(dp)/u_particle_pos_offset);highp float drop_rate=1.0-per_frame_persist.x*per_frame_persist.y;drop_rate=any(greaterThanEqual(abs(pos-0.5),vec2(0.5+u_particle_pos_offset))) ? 1.0 : drop_rate;highp float drop=step(1.0-drop_rate-u_reset_rate,rand(seed));highp vec2 next_pos=mix(pos,random_pos,drop);glFragColor=pack_pos_to_rgba(next_pos);}', "in vec2 a_pos;out vec2 v_tex_coord;void main() {v_tex_coord=0.5*(a_pos+vec2(1.0));gl_Position=vec4(a_pos,0.0,1.0);}"),
                    symbol: mi('#include "_prelude_lighting.glsl"\n#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;uniform lowp float u_scale_factor;\n#ifdef ICON_TRANSITION\nuniform float u_icon_transition;\n#endif\n#ifdef COLOR_ADJUSTMENT\nuniform mat4 u_color_adj_mat;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\nin vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nin vec2 v_tex_b;\n#endif\nin float v_draw_halo;in vec3 v_gamma_scale_size_fade_opacity;\n#ifdef RENDER_TEXT_AND_SYMBOL\nin float is_sdf;in vec2 v_tex_a_icon;\n#endif\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nvec4 out_color;float fade_opacity=v_gamma_scale_size_fade_opacity[2];\n#ifdef RENDER_TEXT_AND_SYMBOL\nif (is_sdf==ICON) {vec2 tex_icon=v_tex_a_icon;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nreturn;}\n#endif\n#ifdef RENDER_SDF\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_gamma_scale_size_fade_opacity.x;float size=v_gamma_scale_size_fade_opacity.y;float fontScale=u_is_text ? size/24.0 : size;out_color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {out_color=halo_color;gamma=(halo_blur*u_scale_factor*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width*u_scale_factor/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,v_tex_a).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);out_color*=alpha;\n#else\n#ifdef ICON_TRANSITION\nvec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b);\n#else\nout_color=texture(u_texture,v_tex_a);\n#endif\n#ifdef COLOR_ADJUSTMENT\nout_color=u_color_adj_mat*out_color;\n#endif\n#endif\nout_color*=opacity*fade_opacity;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_z_offset);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_auto_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\n#ifdef ICON_TRANSITION\nin vec2 a_texb;\n#endif\n#ifdef OCCLUSION_QUERIES\nin float a_occlusion_query_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_elevation_from_sea;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nout vec2 v_tex_b;\n#endif\nout float v_draw_halo;out vec3 v_gamma_scale_size_fade_opacity;\n#ifdef RENDER_TEXT_AND_SYMBOL\nout float is_sdf;out vec2 v_tex_a_icon;\n#endif\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\n#pragma mapbox: define lowp float occlusion_opacity\n#pragma mapbox: define lowp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\n#pragma mapbox: initialize lowp float occlusion_opacity\n#pragma mapbox: initialize lowp float z_offset\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=u_elevation_from_sea ? z_offset : z_offset+elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_auto_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;vec3 world_pos_globe;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos_globe=a_globe_anchor+h;world_pos=mix_globe_mercator(world_pos_globe,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;vec2 a;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);vec4 projected_point_globe=u_matrix*vec4(world_pos_globe,1);a=projected_point_globe.xy/projected_point_globe.w;\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);a=projected_point.xy/projected_point.w;\n#endif\nvec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\n#ifdef Z_OFFSET\nz+=u_pitch_with_map ? a_auto_z_offset+(u_elevation_from_sea ? z_offset : z_offset) : 0.0;\n#else\nz+=u_pitch_with_map ? (u_elevation_from_sea ? z_offset : z_offset) : 0.0;\n#endif\nfloat occlusion_fade=globe_occlusion_fade;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;\n#ifdef DEPTH_OCCLUSION\nfloat depth_occlusion=occlusionFadeMultiSample(projected_point);float depth_occlusion_multplier=mix(occlusion_opacity,1.0,depth_occlusion);out_fade_opacity*=depth_occlusion_multplier;\n#endif\n#ifdef OCCLUSION_QUERIES\nfloat occludedFadeMultiplier=mix(occlusion_opacity,1.0,a_occlusion_query_opacity);out_fade_opacity*=occludedFadeMultiplier;\n#endif\nfloat alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nfloat gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_gamma_scale_size_fade_opacity=vec3(gamma_scale,size,out_fade_opacity);v_tex_a=a_tex/u_texsize;\n#ifdef RENDER_TEXT_AND_SYMBOL\nis_sdf=a_size[0]-2.0*a_size_min;v_tex_a_icon=a_tex/u_texsize_icon;\n#endif\n#ifdef ICON_TRANSITION\nv_tex_b=a_texb/u_texsize;\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=e;\n#endif\n}'),
                    terrainRaster: mi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;in vec2 v_pos0;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#endif\nuniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;\n#ifdef LIGHTING_3D_MODE\nconst vec3 normal=vec3(0.0,0.0,1.0);\n#ifdef RENDER_SHADOWS\nfloat cutoffOpacity=1.0;\n#ifdef RENDER_CUTOFF\ncutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);\n#endif\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nvec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;\n#else\nfloat lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));\n#endif\n#else\nfloat lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;\n#endif\n#endif\n#else\ncolor=image_color;\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;\n#endif\nvoid main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);\n#endif\n}'),
                    terrainDepth: mi("precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}'),
                    skybox: mi('#include "_prelude_fog.fragment.glsl"\nin lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', Is),
                    skyboxGradient: mi('#include "_prelude_fog.fragment.glsl"\nin highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', Is),
                    skyboxCapture: mi("\nin highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}", "in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"),
                    globeRaster: mi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;uniform float u_far_z_cutoff;in vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nraster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(raster.rgb*antialias,antialias);\n#else\nraster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;\n#else\ncolor=apply_lighting_ground(color);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;\n#endif\nout vec2 v_pos0;void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);globe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}'),
                    globeAtmosphere: mi('#include "_prelude_fog.fragment.glsl"\nuniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {\n#ifdef ALPHA_PASS\nglFragColor=vec4(0,0,0,0);return;\n#else\n#ifdef NATIVE\nglFragColor=vec4(1,1,1,1);\n#else\nglFragColor=vec4(0,0,0,1);\n#endif\nreturn;\n#endif\n}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;\n#ifdef ALPHA_PASS\nfloat a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);\n#else\nvec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;\n#ifndef NATIVE\nc=dither(c,gl_FragCoord.xy+u_temporal_offset);\n#endif\nglFragColor=vec4(c*t,t);\n#endif\n}', "in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}"),
                    model: mi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;\n#endif\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nuniform vec4 u_occlusionTextureTransform;\n#endif\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#ifdef HAS_ATTRIBUTE_a_pbr\nin lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;\n#endif\n#ifdef HAS_TEXTURE_u_baseColorTexture\nuniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;\n#endif\n#ifdef HAS_TEXTURE_u_metallicRoughnessTexture\nuniform sampler2D u_metallicRoughnessTexture;\n#endif\n#ifdef HAS_TEXTURE_u_occlusionTexture\nuniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;\n#endif\n#ifdef HAS_TEXTURE_u_normalTexture\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef HAS_TEXTURE_u_emissionTexture\nuniform sampler2D u_emissionTexture;\n#endif\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nin highp float v_depth;uniform highp sampler2D u_depthTexture;uniform highp vec2 u_inv_depth_size;uniform highp vec2 u_depth_range_unpack;\n#ifdef DEPTH_D24\nhighp float unpack_depth(highp float depth) {return  depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}\n#else\nhighp float unpack_depth_rgba(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\n#endif\nbool isOccluded() {highp vec2 coord=gl_FragCoord.xy*u_inv_depth_size;\n#ifdef DEPTH_D24\nhighp float depth=unpack_depth(texture(u_depthTexture,coord).r);\n#else\nhighp float depth=unpack_depth_rgba(texture(u_depthTexture,coord));\n#endif\nreturn v_depth > depth+0.0005;}\n#endif\n#define saturate(_x) clamp(_x,0.,1.)\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)\n{\n#ifdef LIGHTING_3D_MODE\nvec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));\n#endif\nreturn apply_lighting(albedo,transformed_normal,lighting_factor);\n#else\nvec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;\n#endif\n}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;\n#ifdef HAS_ATTRIBUTE_a_color_3f\nalbedo*=vec4(color_3f,1.0);\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#else\n#ifdef HAS_ATTRIBUTE_a_color_4f\nalbedo*=color_4f;\n#endif\n#endif\n#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)\nvec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}\n#ifdef UNPREMULT_TEXTURE_IN_SHADER\nif(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;\n#endif\nif(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}\n#endif\nvec4 color=vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);\n#ifdef APPLY_LUT_ON_GPU\ncolor=applyLUT(u_lutTexture,color);\n#endif\nreturn color;}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {\n#ifdef HAS_TEXTURE_u_normalTexture\nhighp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;\n#else\nreturn mat3(1.0);\n#endif\n}highp vec3 getNormal(){highp vec3 n;\n#ifdef HAS_ATTRIBUTE_a_normal_3f\nn=normalize(normal_3f);\n#else\nhighp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));n=normalize(cross(fdx,fdy))*-1.0;\n#endif\n#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nvec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);\n#endif\nreturn n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;\n#ifdef HAS_ATTRIBUTE_a_pbr\nmat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;\n#endif\n#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) \nvec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;\n#endif\nconst float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)\n{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)\n{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)\n{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)\n{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)\n{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)\n{\n#ifdef LIGHTING_3D_MODE\nreturn mat.diffuseColor;\n#else\nreturn mat.diffuseColor/PI;\n#endif\n}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)\n{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)\n{vec3 env_light=vec3(0.65,0.65,0.65);\n#ifdef LIGHTING_3D_MODE\nfloat ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;\n#endif\nvec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)\n{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=NdotL;\n#endif\nvec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;\n#if !defined(LIGHTING_3D_MODE)\nconst vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);\n#endif\ncolor*=intensityFactor;return color;}void main() {\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nif (isOccluded()) {discard;}\n#endif\nvec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;\n#ifdef LIGHTING_3D_MODE\nlightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;\n#endif\nvec4 finalColor;\n#ifdef DIFFUSE_SHADED\nvec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);\n#ifdef HAS_TEXTURE_u_occlusionTexture\nfloat ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;\n#endif\nfinalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;\n#else\nMaterial mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;\n#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nvec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;\n#else\nvec2 uv=uv_2f;\n#endif\nao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;\n#endif\nvec4 emissive=u_emissiveFactor;\n#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nemissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);\n#endif\n#ifdef APPLY_LUT_ON_GPU\nfloat emissiveFactorLength=max(length(u_emissiveFactor.rgb),0.001);emissive.rgb=sRGBToLinear(applyLUT(u_lutTexture,linearTosRGB(emissive.rgb/emissiveFactorLength).rbg))*emissiveFactorLength;\n#endif\ncolor+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;\n#ifdef HAS_ATTRIBUTE_a_pbr\nfloat resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);vec3 color_mix=v_color_mix.rgb;\n#ifdef APPLY_LUT_ON_GPU\ncolor_mix=applyLUT(u_lutTexture,color_mix);\n#endif\ncolor=mix(color,color_mix,min(1.0,resEmission));\n#ifdef HAS_ATTRIBUTE_a_color_4f\nfloat distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);\n#endif\n#endif\nvec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);\n#endif\n#ifdef FOG\nfinalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));\n#endif\n#ifdef RENDER_CUTOFF\nfinalColor*=v_cutoff_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\nfinalColor=applyCutout(finalColor,v_position_height.w);\n#endif\nglFragColor=finalColor;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec3 a_pos_3f;\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr\n#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength\nuniform mat4 u_matrix;uniform mat4 u_node_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_normal_matrix;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;\n#endif\nout vec4 v_position_height;out lowp vec4 v_color_mix;\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nout highp float v_depth;\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\nout lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;\n#endif\nvec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute-custom highp vec4 pbr\n#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength\nhighp mat4 normal_matrix;\n#ifdef INSTANCED_ARRAYS\nnormal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\nnormal_matrix=u_normal_matrix;\n#endif\nvec3 local_pos;mat3 rs;\n#ifdef MODEL_POSITION_ON_GPU\nvec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float hidden=float(pos_a.x > EXTENT);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=mix(u_matrix*pos,AWAY,hidden);pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;\n#else\nlocal_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);\n#endif\nv_position_height.w=a_pos_3f.z;\n#ifdef HAS_ATTRIBUTE_a_pbr\nvec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(local_pos);\n#endif\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nfloat x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);\n#else\nnormal_3f=vec3(normal_matrix*vec4(normal_3f,0));\n#endif\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#ifdef HAS_ATTRIBUTE_a_color_4f\nv_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec4 shadow_pos=u_node_matrix*vec4(local_pos,1.0);\n#ifdef NORMAL_OFFSET\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nvec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#else\nvec3 offset=shadow_normal_offset_model(normal_3f);shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#endif\n#endif\n#endif\nv_pos_light_view_0=u_light_matrix_0*shadow_pos;v_pos_light_view_1=u_light_matrix_1*shadow_pos;v_depth_shadows=gl_Position.w;\n#endif\n}'),
                    modelDepth: mi("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;\n#ifdef MODEL_POSITION_ON_GPU\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_instance;\n#endif\nuniform highp mat4 u_node_matrix;\n#endif\nvoid main() {\n#ifdef MODEL_POSITION_ON_GPU\nhighp mat4 instance;\n#ifdef INSTANCED_ARRAYS\ninstance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\ninstance=u_instance;\n#endif\nvec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float hidden=float(pos_a.x > EXTENT);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=mix(u_matrix*pos,AWAY,hidden);\n#else\ngl_Position=u_matrix*vec4(a_pos_3f,1);\n#endif\nv_depth=gl_Position.z/gl_Position.w;}"),
                    stars: mi("in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)\n{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}", "\nin vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}"),
                    snowParticle: mi("in highp vec2 uv;in highp float alphaMultiplier;uniform vec4 u_particleColor;uniform vec2 u_simpleShapeParameters;void main() {float t=clamp((length(uv)-u_simpleShapeParameters.x)/(1.0-u_simpleShapeParameters.x),0.0,1.0);float alpha=1.0-pow(t,pow(10.0,u_simpleShapeParameters.y));alpha*=alphaMultiplier;alpha*=u_particleColor.a;vec3 color=u_particleColor.rgb*alpha;glFragColor=vec4(color,alpha) ;HANDLE_WIREFRAME_DEBUG;}", "\nin highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_snowParticleData;in highp vec4 a_snowParticleDataHorizontalOscillation;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform vec2 u_screenSize;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; \nuniform float u_velocity;uniform vec3 u_direction;uniform float u_horizontalOscillationRadius; \nuniform float u_horizontalOscillationRate; \nuniform float u_billboardSize;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;out highp vec2 uv;out highp float alphaMultiplier;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos.xyz*=halfBoxSize;pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_snowParticleData.z;float coneAngleHeadingRad=a_snowParticleData.w*radians(360.0);vec3 localZ=normalize(u_direction);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 direction;direction.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.z=cos(coneAnglePichRad);direction=normalize(direction);vec3 simPosLocal=vec3(0,0,0);float velocityScale=(1.0+3.0*a_snowParticleData.y)*u_velocity;simPosLocal+=direction*velocityScale*u_time;float horizontalOscillationRadius=u_horizontalOscillationRadius*a_snowParticleDataHorizontalOscillation.x;float horizontalOscillationAngle=u_horizontalOscillationRate*u_time*(-1.0+2.0*a_snowParticleDataHorizontalOscillation.y);simPosLocal.xy+=horizontalOscillationRadius*vec2(cos(horizontalOscillationAngle),sin(horizontalOscillationAngle));vec3 simPos=localX*simPosLocal.x+\nlocalY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);float clipZ=-u_cam_pos.z+pos.z;vec4 posView=u_modelview*vec4(pos,1.0);float size=u_billboardSize;alphaMultiplier=1.0;vec4 posScreen=u_projection*posView;posScreen/=posScreen.w;posScreen.xy=vec2(0.5)+posScreen.xy*0.5;posScreen.xy*=u_screenSize;vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=u_screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-posScreen.xy)/(0.5*u_screenSize));screenDist+=a_snowParticleData.x*u_thinningParticleOffset;float scaleFactorMode=0.0;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);if (a_snowParticleData.x < u_thinningAffectedRatio) {scaleFactorMode=1.0-thinningFadeRatio;alphaMultiplier=thinningFadeRatio;}}vec4 posScreen1=u_projection*vec4(posView.x-size,posView.yzw);posScreen1/=posScreen1.w;vec4 posScreen2=u_projection*vec4(posView.x+size,posView.yzw);posScreen2/=posScreen2.w;posScreen1.xy=vec2(0.5)+posScreen1.xy*0.5;posScreen1.xy*=u_screenSize;posScreen2.xy=vec2(0.5)+posScreen2.xy*0.5;posScreen2.xy*=u_screenSize;float screenLength=length(posScreen1.xy-posScreen2.xy);float screenEpsilon=3.0;float scaleFactor=1.0;if (screenLength < screenEpsilon) {scaleFactor=screenEpsilon/max(screenLength,0.01);scaleFactor=mix(scaleFactor,1.0,scaleFactorMode);}float screenEpsilon2=15.0;if (screenLength > screenEpsilon2) {scaleFactor=screenEpsilon2/max(screenLength,0.01);}size*=scaleFactor;vec2 right=size*vec2(1,0);vec2 up=size*vec2(0,1);posView.xy+=right*a_uv.x;posView.xy+=up*a_uv.y;uv=a_uv;gl_Position=u_projection*posView;}"),
                    rainParticle: mi("in highp vec2 uv;in highp float particleRandomValue;uniform sampler2D u_texScreen;uniform float u_distortionStrength;uniform vec4 u_color;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;uniform float u_shapeDirectionalPower;uniform float u_mode;void main() {vec2 st=uv*0.5+vec2(0.5);vec2 uvm=uv;uvm.y=-1.0+2.0*pow(st.y,u_shapeDirectionalPower);float shape=clamp(1.0-length(uvm),0.0,1.0);float alpha=abs(shape)*u_color.a;vec2 screenSize=vec2(textureSize(u_texScreen,0));vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-gl_FragCoord.xy)/(0.5*screenSize));screenDist+=(0.5+0.5*particleRandomValue)*u_thinningParticleOffset;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;float thinningAlpha=1.0;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);thinningAlpha*=thinningFadeRatio;}vec2 offsetXY=normalize(uvm)*abs(shape);vec2 stScreen=(gl_FragCoord.xy+offsetXY*u_distortionStrength*thinningAlpha)/screenSize;vec3 colorScreen=texture(u_texScreen,stScreen).rgb;alpha*=thinningAlpha;glFragColor=mix(vec4(colorScreen,1.0),vec4(u_color.rgb*alpha,alpha),u_mode);HANDLE_WIREFRAME_DEBUG;}", "\nin highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_rainParticleData;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; \nuniform float u_velocity; \nuniform vec2 u_rainDropletSize;uniform vec3 u_rainDirection;out highp vec2 uv;out highp float particleRandomValue;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos*=halfBoxSize; \npos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_rainParticleData.z;float coneAngleHeadingRad=a_rainParticleData.w*radians(360.0);vec3 localZ=normalize(u_rainDirection);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 directionLocal;directionLocal.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.z=cos(coneAnglePichRad);directionLocal=normalize(directionLocal);vec3 directionWorld=localX*directionLocal.x+localY*directionLocal.y+localZ*directionLocal.z;float velocityScale=(1.0+3.0*a_rainParticleData.y)*u_velocity;vec3 simPosLocal=vec3(0,0,0);simPosLocal+=directionLocal*velocityScale*u_time;vec3 simPos=localX*simPosLocal.x+\nlocalY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);vec4 posView=u_modelview*vec4(pos,1.0);vec3 directionView=normalize((u_modelview*vec4(directionWorld,0.0)).xyz);vec3 side=cross(directionView,normalize(posView.xyz));posView.xyz+=side*a_uv.x*u_rainDropletSize.x;posView.xyz+=directionView*a_uv.y*u_rainDropletSize.y;uv=a_uv;particleRandomValue=a_rainParticleData.x;gl_Position=u_projection*posView;}"),
                    vignette: mi("uniform vec3 u_vignetteShape;uniform vec4 u_vignetteColor;in vec2 st;void main() {float screenDist=length(st);float alpha=clamp((screenDist-u_vignetteShape.x)/u_vignetteShape.y,0.0,1.0);alpha=pow(alpha,u_vignetteShape.z)*u_vignetteColor.a;vec3 color=u_vignetteColor.rgb;glFragColor=vec4(color*alpha,alpha) ;}", "in vec2 a_pos_2f;out vec2 st;void main() {st=a_pos_2f;gl_Position=vec4(a_pos_2f,0,1);}"),
                    occlusion: mi("uniform vec4 u_color;void main() {glFragColor=u_color;}", '#include "_prelude_terrain.vertex.glsl"\nin highp vec2 a_offset_xy;uniform highp vec3 u_anchorPos;uniform mat4 u_matrix;uniform vec2 u_screenSizePx;uniform vec2 u_occluderSizePx;void main() {vec3 world_pos=u_anchorPos;\n#ifdef TERRAIN\nfloat e=elevation(world_pos.xy);world_pos.z+=e;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1.0);projected_point.xy+=projected_point.w*a_offset_xy*0.5*u_occluderSizePx/u_screenSizePx;gl_Position=projected_point;}')
                };
                function Ur(c, t) {
                    const i = c.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
                    for (let h of i)
                        if (h = h.trim(),
                        "#" === h[0] && h.includes("if") && !h.includes("endif")) {
                            h = h.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
                            const d = h.split(" ");
                            for (const m of d)
                                t.includes(m) || t.push(m)
                        }
                }
                function mi(c, t) {
                    const i = /#include\s+"([^"]+)"/g
                      , h = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;
                    let d = t.match(/(attribute(\S*)|(^\s*|;)in) (highp |mediump |lowp )?([\w]+) ([\w]+)/gm);
                    d && (d = d.map(S => {
                        const I = S.split(" ");
                        return I[I.length - 1]
                    }
                    ),
                    d = [...new Set(d)]);
                    const m = {}
                      , y = []
                      , M = [];
                    if (c = c.replace(i, (S, I) => (M.push(I),
                    "")),
                    (t = t.replace(i, (S, I) => (y.push(I),
                    ""))).includes("flat out"))
                        return void console.error('The usage of "flat" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071');
                    let E = [...zn];
                    Ur(c, E),
                    Ur(t, E);
                    for (const S of [...y, ...M])
                        rr[S] || console.error("Undefined include: ".concat(S)),
                        qr[S] || (qr[S] = [],
                        Ur(rr[S], qr[S])),
                        E = [...E, ...qr[S]];
                    return {
                        fragmentSource: c = c.replace(h, (S, I, R, D, k) => (m[k] = !0,
                        "define" === I ? "\n#ifndef HAS_UNIFORM_u_".concat(k, "\nin ").concat(R, " ").concat(D, " ").concat(k, ";\n#else\nuniform ").concat(R, " ").concat(D, " u_").concat(k, ";\n#endif\n") : "initialize" === I ? "\n#ifdef HAS_UNIFORM_u_".concat(k, "\n    ").concat(R, " ").concat(D, " ").concat(k, " = u_").concat(k, ";\n#endif\n") : "define-attribute" === I ? "\n#ifdef HAS_ATTRIBUTE_a_".concat(k, "\n    in ").concat(R, " ").concat(D, " ").concat(k, ";\n#endif\n") : "initialize-attribute" === I ? "" : void 0)),
                        vertexSource: t = t.replace(h, (S, I, R, D, k) => {
                            const H = "float" === D ? "vec2" : D
                              , j = k.match(/color/) ? "color" : H;
                            return "define-attribute-vertex-shader-only" === I ? "\n#ifdef HAS_ATTRIBUTE_a_".concat(k, "\nin ").concat(R, " ").concat(D, " a_").concat(k, ";\n#endif\n") : m[k] ? "define" === I ? "\n#ifndef HAS_UNIFORM_u_".concat(k, "\nuniform lowp float u_").concat(k, "_t;\nin ").concat(R, " ").concat(H, " a_").concat(k, ";\nout ").concat(R, " ").concat(D, " ").concat(k, ";\n#else\nuniform ").concat(R, " ").concat(D, " u_").concat(k, ";\n#endif\n") : "initialize" === I ? "vec4" === j ? "\n#ifndef HAS_UNIFORM_u_".concat(k, "\n    ").concat(k, " = a_").concat(k, ";\n#else\n    ").concat(R, " ").concat(D, " ").concat(k, " = u_").concat(k, ";\n#endif\n") : "\n#ifndef HAS_UNIFORM_u_".concat(k, "\n    ").concat(k, " = unpack_mix_").concat(j, "(a_").concat(k, ", u_").concat(k, "_t);\n#else\n    ").concat(R, " ").concat(D, " ").concat(k, " = u_").concat(k, ";\n#endif\n") : "define-attribute" === I ? "\n#ifdef HAS_ATTRIBUTE_a_".concat(k, "\n    in ").concat(R, " ").concat(D, " a_").concat(k, ";\n    out ").concat(R, " ").concat(D, " ").concat(k, ";\n#endif\n") : "initialize-attribute" === I ? "\n#ifdef HAS_ATTRIBUTE_a_".concat(k, "\n    ").concat(k, " = a_").concat(k, ";\n#endif\n") : void 0 : "define" === I ? "\n#ifndef HAS_UNIFORM_u_".concat(k, "\nuniform lowp float u_").concat(k, "_t;\nin ").concat(R, " ").concat(H, " a_").concat(k, ";\n#else\nuniform ").concat(R, " ").concat(D, " u_").concat(k, ";\n#endif\n") : "define-instanced" === I ? "mat4" === j ? "\n#ifdef INSTANCED_ARRAYS\nin vec4 a_".concat(k, "0;\nin vec4 a_").concat(k, "1;\nin vec4 a_").concat(k, "2;\nin vec4 a_").concat(k, "3;\n#else\nuniform ").concat(R, " ").concat(D, " u_").concat(k, ";\n#endif\n") : "\n#ifdef INSTANCED_ARRAYS\nin ".concat(R, " ").concat(H, " a_").concat(k, ";\n#else\nuniform ").concat(R, " ").concat(D, " u_").concat(k, ";\n#endif\n") : "initialize-attribute-custom" === I ? "\n#ifdef HAS_ATTRIBUTE_a_".concat(k, "\n    ").concat(R, " ").concat(D, " ").concat(k, " = a_").concat(k, ";\n#endif\n") : "vec4" === j ? "\n#ifndef HAS_UNIFORM_u_".concat(k, "\n    ").concat(R, " ").concat(D, " ").concat(k, " = a_").concat(k, ";\n#else\n    ").concat(R, " ").concat(D, " ").concat(k, " = u_").concat(k, ";\n#endif\n") : "\n#ifndef HAS_UNIFORM_u_".concat(k, "\n    ").concat(R, " ").concat(D, " ").concat(k, " = unpack_mix_").concat(j, "(a_").concat(k, ", u_").concat(k, "_t);\n#else\n    ").concat(R, " ").concat(D, " ").concat(k, " = u_").concat(k, ";\n#endif\n")
                        }
                        ),
                        staticAttributes: d,
                        usedDefines: E,
                        vertexIncludes: y,
                        fragmentIncludes: M
                    }
                }
                class Ql {
                    constructor() {
                        this.boundProgram = null,
                        this.boundLayoutVertexBuffer = null,
                        this.boundPaintVertexBuffers = [],
                        this.boundIndexBuffer = null,
                        this.boundVertexOffset = null,
                        this.boundDynamicVertexBuffers = [],
                        this.vao = null
                    }
                    bind(t, i, h, d, m, y, M, E) {
                        this.context = t;
                        let S = this.boundPaintVertexBuffers.length !== d.length;
                        for (let R = 0; !S && R < d.length; R++)
                            this.boundPaintVertexBuffers[R] !== d[R] && (S = !0);
                        let I = this.boundDynamicVertexBuffers.length !== M.length;
                        for (let R = 0; !I && R < M.length; R++)
                            this.boundDynamicVertexBuffers[R] !== M[R] && (I = !0);
                        if (!this.vao || this.boundProgram !== i || this.boundLayoutVertexBuffer !== h || S || I || this.boundIndexBuffer !== m || this.boundVertexOffset !== y)
                            this.freshBind(i, h, d, m, y, M, E);
                        else {
                            t.bindVertexArrayOES.set(this.vao);
                            for (const R of M)
                                R && (R.bind(),
                                E && R.instanceCount && R.setVertexAttribDivisor(t.gl, i, E));
                            m && m.dynamicDraw && m.bind()
                        }
                    }
                    freshBind(t, i, h, d, m, y, M) {
                        const E = t.numAttributes
                          , S = this.context
                          , I = S.gl;
                        this.vao && this.destroy(),
                        this.vao = S.gl.createVertexArray(),
                        S.bindVertexArrayOES.set(this.vao),
                        this.boundProgram = t,
                        this.boundLayoutVertexBuffer = i,
                        this.boundPaintVertexBuffers = h,
                        this.boundIndexBuffer = d,
                        this.boundVertexOffset = m,
                        this.boundDynamicVertexBuffers = y,
                        i.enableAttributes(I, t),
                        i.bind(),
                        i.setVertexAttribPointers(I, t, m);
                        for (const R of h)
                            R.enableAttributes(I, t),
                            R.bind(),
                            R.setVertexAttribPointers(I, t, m);
                        for (const R of y)
                            R && (R.enableAttributes(I, t),
                            R.bind(),
                            R.setVertexAttribPointers(I, t, m),
                            M && R.instanceCount && R.setVertexAttribDivisor(I, t, M));
                        d && d.bind(),
                        S.currentNumAttributes = E
                    }
                    destroy() {
                        this.vao && (this.context.gl.deleteVertexArray(this.vao),
                        this.vao = null)
                    }
                }
                function ec(c, t) {
                    const i = Math.pow(2, t.canonical.z)
                      , h = t.canonical.y;
                    return [new s.aa(0,h / i).toLngLat().lat, new s.aa(0,(h + 1) / i).toLngLat().lat]
                }
                function tc(c, t, i, h, d, m, y) {
                    const M = c.context
                      , E = M.gl
                      , S = i.hillshadeFBO;
                    if (!S)
                        return;
                    c.prepareDrawTile();
                    const I = c.isTileAffectedByFog(t)
                      , R = c.getOrCreateProgram("hillshade", {
                        overrideFog: I
                    });
                    M.activeTexture.set(E.TEXTURE0),
                    E.bindTexture(E.TEXTURE_2D, S.colorAttachment.get());
                    const D = ( (Y, K, he, Te) => {
                        const be = he.paint.get("hillshade-shadow-color")
                          , Ue = "none" === he.paint.get("hillshade-shadow-color-use-theme").constantOr("default")
                          , De = he.paint.get("hillshade-highlight-color")
                          , ke = "none" === he.paint.get("hillshade-highlight-color-use-theme").constantOr("default")
                          , Le = he.paint.get("hillshade-accent-color")
                          , Ge = "none" === he.paint.get("hillshade-accent-color-use-theme").constantOr("default")
                          , qe = he.paint.get("hillshade-emissive-strength");
                        let vt = s.ai(he.paint.get("hillshade-illumination-direction"));
                        if ("viewport" === he.paint.get("hillshade-illumination-anchor"))
                            vt -= Y.transform.angle;
                        else if (Y.style && Y.style.enable3dLights() && Y.style.directionalLight) {
                            const Ze = Y.style.directionalLight.properties.get("direction")
                              , nt = s.cb(Ze.x, Ze.y, Ze.z);
                            vt = s.ai(nt[1])
                        }
                        const dt = !Y.options.moving;
                        return {
                            u_matrix: Te || Y.transform.calculateProjMatrix(K.tileID.toUnwrapped(), dt),
                            u_image: 0,
                            u_latrange: ec(0, K.tileID),
                            u_light: [he.paint.get("hillshade-exaggeration"), vt],
                            u_shadow: be.toRenderColor(Ue ? null : he.lut),
                            u_highlight: De.toRenderColor(ke ? null : he.lut),
                            u_emissive_strength: qe,
                            u_accent: Le.toRenderColor(Ge ? null : he.lut)
                        }
                    }
                    )(c, i, h, c.terrain ? t.projMatrix : null);
                    c.uploadCommonUniforms(M, R, t.toUnwrapped());
                    const {tileBoundsBuffer: k, tileBoundsIndexBuffer: H, tileBoundsSegments: j} = c.getTileBoundsBuffers(i);
                    R.draw(c, E.TRIANGLES, d, m, y, zo.disabled, D, h.id, k, H, j)
                }
                function ms(c, t, i) {
                    if (!t.needsDEMTextureUpload)
                        return;
                    const h = c.context
                      , d = h.gl;
                    h.pixelStoreUnpackPremultiplyAlpha.set(!1),
                    t.demTexture = t.demTexture || c.getTileTexture(i.stride);
                    const m = i.getPixels();
                    t.demTexture ? t.demTexture.update(m, {
                        premultiply: !1
                    }) : t.demTexture = new s.T(h,m,d.R32F,{
                        premultiply: !1
                    }),
                    t.needsDEMTextureUpload = !1
                }
                function oc(c, t, i) {
                    const h = c.context
                      , d = h.gl;
                    if (!t.dem)
                        return;
                    const m = t.dem;
                    if (h.activeTexture.set(d.TEXTURE1),
                    ms(c, t, m),
                    !t.demTexture)
                        return;
                    t.demTexture.bind(d.NEAREST, d.CLAMP_TO_EDGE);
                    const y = m.dim;
                    h.activeTexture.set(d.TEXTURE0);
                    let M = t.hillshadeFBO;
                    if (!M) {
                        const D = new s.T(h,{
                            width: y,
                            height: y,
                            data: null
                        },d.RGBA8);
                        D.bind(d.LINEAR, d.CLAMP_TO_EDGE),
                        M = t.hillshadeFBO = h.createFramebuffer(y, y, !0, "renderbuffer"),
                        M.colorAttachment.set(D.texture)
                    }
                    h.bindFramebuffer.set(M.framebuffer),
                    h.viewport.set([0, 0, y, y]);
                    const {tileBoundsBuffer: E, tileBoundsIndexBuffer: S, tileBoundsSegments: I} = c.getMercatorTileBoundsBuffers()
                      , R = [];
                    c.linearFloatFilteringSupported() && R.push("TERRAIN_DEM_FLOAT_FORMAT"),
                    c.getOrCreateProgram("hillshadePrepare", {
                        defines: R
                    }).draw(c, d.TRIANGLES, Fo.disabled, Xo.disabled, si.unblended, zo.disabled, ( (D, k) => {
                        const H = k.stride
                          , j = s.ab.mat4.create();
                        return s.ab.mat4.ortho(j, 0, s.ag, -s.ag, 0, 0, 1),
                        s.ab.mat4.translate(j, j, [0, -s.ag, 0]),
                        {
                            u_matrix: j,
                            u_image: 1,
                            u_dimension: [H, H],
                            u_zoom: D.overscaledZ
                        }
                    }
                    )(t.tileID, m), i.id, E, S, I),
                    t.needsHillshadePrepare = !1
                }
                class qi {
                    constructor(t) {
                        this.gl = t.gl,
                        this.default = this.getDefault(),
                        this.current = this.default,
                        this.dirty = !1
                    }
                    get() {
                        return this.current
                    }
                    set(t) {}
                    getDefault() {
                        return this.default
                    }
                    setDefault() {
                        this.set(this.default)
                    }
                }
                class sh extends qi {
                    getDefault() {
                        return s.aj.transparent
                    }
                    set(t) {
                        const i = this.current;
                        (t.r !== i.r || t.g !== i.g || t.b !== i.b || t.a !== i.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class ah extends qi {
                    getDefault() {
                        return 1
                    }
                    set(t) {
                        (t !== this.current || this.dirty) && (this.gl.clearDepth(t),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class fs extends qi {
                    getDefault() {
                        return 0
                    }
                    set(t) {
                        (t !== this.current || this.dirty) && (this.gl.clearStencil(t),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class xn extends qi {
                    getDefault() {
                        return [!0, !0, !0, !0]
                    }
                    set(t) {
                        const i = this.current;
                        (t[0] !== i[0] || t[1] !== i[1] || t[2] !== i[2] || t[3] !== i[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class $n extends qi {
                    getDefault() {
                        return !0
                    }
                    set(t) {
                        (t !== this.current || this.dirty) && (this.gl.depthMask(t),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class hl extends qi {
                    getDefault() {
                        return 255
                    }
                    set(t) {
                        (t !== this.current || this.dirty) && (this.gl.stencilMask(t),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class ic extends qi {
                    getDefault() {
                        return {
                            func: this.gl.ALWAYS,
                            ref: 0,
                            mask: 255
                        }
                    }
                    set(t) {
                        const i = this.current;
                        (t.func !== i.func || t.ref !== i.ref || t.mask !== i.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class lh extends qi {
                    getDefault() {
                        const t = this.gl;
                        return [t.KEEP, t.KEEP, t.KEEP]
                    }
                    set(t) {
                        const i = this.current;
                        (t[0] !== i[0] || t[1] !== i[1] || t[2] !== i[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class hu extends qi {
                    getDefault() {
                        return !1
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        const i = this.gl;
                        t ? i.enable(i.STENCIL_TEST) : i.disable(i.STENCIL_TEST),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class Aa extends qi {
                    getDefault() {
                        return [0, 1]
                    }
                    set(t) {
                        const i = this.current;
                        (t[0] !== i[0] || t[1] !== i[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class _s extends qi {
                    getDefault() {
                        return !1
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        const i = this.gl;
                        t ? i.enable(i.DEPTH_TEST) : i.disable(i.DEPTH_TEST),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class uu extends qi {
                    getDefault() {
                        return this.gl.LESS
                    }
                    set(t) {
                        (t !== this.current || this.dirty) && (this.gl.depthFunc(t),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class Jn extends qi {
                    getDefault() {
                        return !1
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        const i = this.gl;
                        t ? i.enable(i.BLEND) : i.disable(i.BLEND),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class nc extends qi {
                    getDefault() {
                        const t = this.gl;
                        return [t.ONE, t.ZERO, t.ONE, t.ZERO]
                    }
                    set(t) {
                        const i = this.current;
                        (t[0] !== i[0] || t[1] !== i[1] || t[2] !== i[2] || t[3] !== i[3] || this.dirty) && (this.gl.blendFuncSeparate(t[0], t[1], t[2], t[3]),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class rc extends qi {
                    getDefault() {
                        return s.aj.transparent
                    }
                    set(t) {
                        const i = this.current;
                        (t.r !== i.r || t.g !== i.g || t.b !== i.b || t.a !== i.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class ul extends qi {
                    getDefault() {
                        return this.gl.FUNC_ADD
                    }
                    set(t) {
                        (t !== this.current || this.dirty) && (this.gl.blendEquationSeparate(t, t),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class Oa extends qi {
                    getDefault() {
                        return !1
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        const i = this.gl;
                        t ? i.enable(i.CULL_FACE) : i.disable(i.CULL_FACE),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class ch extends qi {
                    getDefault() {
                        return this.gl.BACK
                    }
                    set(t) {
                        (t !== this.current || this.dirty) && (this.gl.cullFace(t),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class sc extends qi {
                    getDefault() {
                        return this.gl.CCW
                    }
                    set(t) {
                        (t !== this.current || this.dirty) && (this.gl.frontFace(t),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                let ac = class extends qi {
                    getDefault() {
                        return null
                    }
                    set(c) {
                        (c !== this.current || this.dirty) && (this.gl.useProgram(c),
                        this.current = c,
                        this.dirty = !1)
                    }
                }
                ;
                class lc extends qi {
                    getDefault() {
                        return this.gl.TEXTURE0
                    }
                    set(t) {
                        (t !== this.current || this.dirty) && (this.gl.activeTexture(t),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class pl extends qi {
                    getDefault() {
                        const t = this.gl;
                        return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight]
                    }
                    set(t) {
                        const i = this.current;
                        (t[0] !== i[0] || t[1] !== i[1] || t[2] !== i[2] || t[3] !== i[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class dl extends qi {
                    getDefault() {
                        return null
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        const i = this.gl;
                        i.bindFramebuffer(i.FRAMEBUFFER, t),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class hh extends qi {
                    getDefault() {
                        return null
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        const i = this.gl;
                        i.bindRenderbuffer(i.RENDERBUFFER, t),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class na extends qi {
                    getDefault() {
                        return null
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        const i = this.gl;
                        i.bindTexture(i.TEXTURE_2D, t),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class cc extends qi {
                    getDefault() {
                        return null
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        const i = this.gl;
                        i.bindBuffer(i.ARRAY_BUFFER, t),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class pu extends qi {
                    getDefault() {
                        return null
                    }
                    set(t) {
                        const i = this.gl;
                        i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, t),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class du extends qi {
                    getDefault() {
                        return null
                    }
                    set(t) {
                        this.gl && (t !== this.current || this.dirty) && (this.gl.bindVertexArray(t),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class mu extends qi {
                    getDefault() {
                        return 4
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        const i = this.gl;
                        i.pixelStorei(i.UNPACK_ALIGNMENT, t),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class uh extends qi {
                    getDefault() {
                        return !1
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        const i = this.gl;
                        i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class fu extends qi {
                    getDefault() {
                        return !1
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        const i = this.gl;
                        i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, t),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class xr extends qi {
                    constructor(t, i) {
                        super(t),
                        this.context = t,
                        this.parent = i
                    }
                    getDefault() {
                        return null
                    }
                }
                class hc extends xr {
                    setDirty() {
                        this.dirty = !0
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        this.context.bindFramebuffer.set(this.parent);
                        const i = this.gl;
                        i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, t, 0),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class uc extends xr {
                    attachment() {
                        return this.gl.DEPTH_ATTACHMENT
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        this.context.bindFramebuffer.set(this.parent);
                        const i = this.gl;
                        i.framebufferRenderbuffer(i.FRAMEBUFFER, this.attachment(), i.RENDERBUFFER, t),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class ra extends xr {
                    attachment() {
                        return this.gl.DEPTH_ATTACHMENT
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        this.context.bindFramebuffer.set(this.parent);
                        const i = this.gl;
                        i.framebufferTexture2D(i.FRAMEBUFFER, this.attachment(), i.TEXTURE_2D, t, 0),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class ph extends uc {
                    attachment() {
                        return this.gl.DEPTH_STENCIL_ATTACHMENT
                    }
                }
                const dh = (c, t, i) => ({
                    u_matrix: c,
                    u_image0: 0,
                    u_skirt_height: t,
                    u_ground_shadow_factor: i
                })
                  , ml = (c, t, i, h, d, m, y, M, E, S, I, R, D, k, H, j) => ({
                    u_proj_matrix: Float32Array.from(c),
                    u_globe_matrix: t,
                    u_normalize_matrix: Float32Array.from(h),
                    u_merc_matrix: i,
                    u_zoom_transition: d,
                    u_merc_center: m,
                    u_image0: 0,
                    u_frustum_tl: y,
                    u_frustum_tr: M,
                    u_frustum_br: E,
                    u_frustum_bl: S,
                    u_globe_pos: I,
                    u_globe_radius: R,
                    u_viewport: D,
                    u_grid_matrix: j ? Float32Array.from(j) : new Float32Array(9),
                    u_skirt_height: k,
                    u_far_z_cutoff: H
                });
                function Ra(c, t) {
                    return null != c && null != t && !(!c.hasData() || !t.hasData()) && null != c.demTexture && null != t.demTexture && c.tileID.key !== t.tileID.key
                }
                const br = new class {
                    constructor() {
                        this.operations = {}
                    }
                    newMorphing(c, t, i, h, d) {
                        if (c in this.operations) {
                            const m = this.operations[c];
                            m.to.tileID.key !== i.tileID.key && (m.queued = i)
                        } else
                            this.operations[c] = {
                                startTime: h,
                                phase: 0,
                                duration: d,
                                from: t,
                                to: i,
                                queued: null
                            }
                    }
                    getMorphValuesForProxy(c) {
                        if (!(c in this.operations))
                            return null;
                        const t = this.operations[c];
                        return {
                            from: t.from,
                            to: t.to,
                            phase: t.phase
                        }
                    }
                    update(c) {
                        for (const t in this.operations) {
                            const i = this.operations[t];
                            for (i.phase = (c - i.startTime) / i.duration; i.phase >= 1 || !this._validOp(i); )
                                if (!this._nextOp(i, c)) {
                                    delete this.operations[t];
                                    break
                                }
                        }
                    }
                    _nextOp(c, t) {
                        return !!c.queued && (c.from = c.to,
                        c.to = c.queued,
                        c.queued = null,
                        c.phase = 0,
                        c.startTime = t,
                        !0)
                    }
                    _validOp(c) {
                        return c.from.hasData() && c.to.hasData()
                    }
                }
                  , pc = {
                    0: null,
                    1: "TERRAIN_VERTEX_MORPHING"
                };
                function Jr(c, t, i) {
                    if (0 === t)
                        return 0;
                    const h = t < 1 && 514 === i ? .25 / t : 1;
                    return 6 * Math.pow(1.5, 22 - c) * Math.max(t, 1) * h
                }
                function dc(c, t) {
                    const i = 1 << c.z;
                    return !t && (0 === c.x || c.x === i - 1) || 0 === c.y || c.y === i - 1
                }
                const sa = c => ({
                    u_matrix: c
                });
                function fl(c, t, i, h, d) {
                    if (d > 0) {
                        const m = s.q.now()
                          , y = (m - c.timeAdded) / d
                          , M = t ? (m - t.timeAdded) / d : -1
                          , E = i.getSource()
                          , S = h.coveringZoomLevel({
                            tileSize: E.tileSize,
                            roundZoom: E.roundZoom
                        })
                          , I = !t || Math.abs(t.tileID.overscaledZ - S) > Math.abs(c.tileID.overscaledZ - S)
                          , R = I && c.refreshedUponExpiration ? 1 : s.aw(I ? y : 1 - M, 0, 1);
                        return c.refreshedUponExpiration && y >= 1 && (c.refreshedUponExpiration = !1),
                        t ? {
                            opacity: 1,
                            mix: 1 - R
                        } : {
                            opacity: R,
                            mix: 0
                        }
                    }
                    return {
                        opacity: 1,
                        mix: 0
                    }
                }
                class mh extends Ir {
                    constructor(t) {
                        const i = {
                            type: "raster-dem",
                            maxzoom: t.transform.maxZoom
                        }
                          , h = new s.D(s.ci(),null)
                          , d = jc("mock-dem", i, h, t.style);
                        super("mock-dem", d, !1),
                        d.setEventedParent(this),
                        this._sourceLoaded = !0
                    }
                    _loadTile(t, i) {
                        t.state = "loaded",
                        i(null)
                    }
                }
                class mc extends Ir {
                    constructor(t) {
                        const i = jc("proxy", {
                            type: "geojson",
                            maxzoom: t.transform.maxZoom
                        }, new s.D(s.ci(),null), t.style);
                        super("proxy", i, !1),
                        i.setEventedParent(this),
                        this.map = this.getSource().map = t,
                        this.used = this._sourceLoaded = !0,
                        this.renderCache = [],
                        this.renderCachePool = [],
                        this.proxyCachedFBO = {}
                    }
                    update(t, i, h) {
                        if (t.freezeTileCoverage)
                            return;
                        this.transform = t;
                        const d = t.coveringTiles({
                            tileSize: this._source.tileSize,
                            minzoom: this._source.minzoom,
                            maxzoom: this._source.maxzoom,
                            roundZoom: this._source.roundZoom,
                            reparseOverscaled: this._source.reparseOverscaled
                        }).reduce( (m, y) => {
                            if (m[y.key] = "",
                            !this._tiles[y.key]) {
                                const M = new hs(y,this._source.tileSize * y.overscaleFactor(),t.tileZoom);
                                M.state = "loaded",
                                this._tiles[y.key] = M
                            }
                            return m
                        }
                        , {});
                        for (const m in this._tiles)
                            m in d || (this.freeFBO(m),
                            this._tiles[m].unloadVectorData(),
                            delete this._tiles[m])
                    }
                    freeFBO(t) {
                        const i = this.proxyCachedFBO[t];
                        if (void 0 !== i) {
                            const h = Object.values(i);
                            this.renderCachePool.push(...h),
                            delete this.proxyCachedFBO[t]
                        }
                    }
                    deallocRenderCache() {
                        this.renderCache.forEach(t => t.fb.destroy()),
                        this.renderCache = [],
                        this.renderCachePool = [],
                        this.proxyCachedFBO = {}
                    }
                }
                class _l extends s.aG {
                    constructor(t, i, h) {
                        super(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y),
                        this.proxyTileKey = i,
                        this.projMatrix = h
                    }
                }
                class fh extends s.cJ {
                    constructor(t, i) {
                        super(),
                        this._debugParams = {
                            sortTilesHiZFirst: !0,
                            disableRenderCache: !1
                        },
                        t.tp.registerParameter(this._debugParams, ["Terrain"], "sortTilesHiZFirst", {}, () => {
                            this._style.map.triggerRepaint()
                        }
                        ),
                        t.tp.registerParameter(this._debugParams, ["Terrain"], "disableRenderCache", {}, () => {
                            this._style.map.triggerRepaint()
                        }
                        ),
                        t.tp.registerButton(["Terrain"], "Invalidate Render Cache", () => {
                            this.invalidateRenderCache = !0,
                            this._style.map.triggerRepaint()
                        }
                        ),
                        this.painter = t,
                        this.terrainTileForTile = {},
                        this.prevTerrainTileForTile = {};
                        const [h,d,m] = function() {
                            const S = new s.b4
                              , I = new s.aU
                              , R = 131;
                            S.reserve(17161),
                            I.reserve(33800);
                            const D = s.ag / 128
                              , k = s.ag + D / 2
                              , H = k + D;
                            for (let Y = -D; Y < H; Y += D)
                                for (let K = -D; K < H; K += D) {
                                    const he = K < 0 || K > k || Y < 0 || Y > k ? 24575 : 0
                                      , Te = s.aw(Math.round(K), 0, s.ag)
                                      , be = s.aw(Math.round(Y), 0, s.ag);
                                    S.emplaceBack(Te + he, be)
                                }
                            const j = (Y, K) => {
                                const he = K * R + Y;
                                I.emplaceBack(he + 1, he, he + R),
                                I.emplaceBack(he + R, he + R + 1, he + 1)
                            }
                            ;
                            for (let Y = 1; Y < 129; Y++)
                                for (let K = 1; K < 129; K++)
                                    j(K, Y);
                            return [0, 129].forEach(Y => {
                                for (let K = 0; K < 130; K++)
                                    j(K, Y),
                                    j(Y, K)
                            }
                            ),
                            [S, I, 32768]
                        }()
                          , y = t.context;
                        this.gridBuffer = y.createVertexBuffer(h, s.b6.members),
                        this.gridIndexBuffer = y.createIndexBuffer(d),
                        this.gridSegments = s.b7.simpleSegment(0, 0, h.length, d.length),
                        this.gridNoSkirtSegments = s.b7.simpleSegment(0, 0, h.length, m),
                        this.proxyCoords = [],
                        this.proxiedCoords = {},
                        this._visibleDemTiles = [],
                        this._drapedRenderBatches = [],
                        this._sourceTilesOverlap = {},
                        this.proxySourceCache = new mc(i.map),
                        this.orthoMatrix = s.ab.mat4.create(),
                        s.ab.mat4.ortho(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? .015 : 0, s.ag, 0, s.ag, 0, 1);
                        const M = y.gl;
                        this._overlapStencilMode = new Xo({
                            func: M.GEQUAL,
                            mask: 255
                        },0,255,M.KEEP,M.KEEP,M.REPLACE),
                        this._previousZoom = t.transform.zoom,
                        this.pool = [],
                        this._findCoveringTileCache = {},
                        this._tilesDirty = {},
                        this.style = i,
                        this._useVertexMorphing = !0,
                        this._exaggeration = 1,
                        this._mockSourceCache = new mh(i.map),
                        this._pendingGroundEffectLayers = []
                    }
                    set style(t) {
                        t.on("data", this._onStyleDataEvent.bind(this)),
                        this._style = t,
                        this._style.map.on("moveend", () => {
                            this._clearLineLayersFromRenderCache()
                        }
                        )
                    }
                    update(t, i, h) {
                        if (t && t.terrain) {
                            this._style !== t && (this.style = t,
                            this._evaluationZoom = void 0);
                            const d = t.terrain.properties
                              , m = 0 === t.terrain.drapeRenderMode
                              , y = t.terrain.isZoomDependent();
                            this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0,
                            this._updateTimestamp = s.q.now();
                            const M = t.terrain && t.terrain.scope
                              , E = d.get("source")
                              , S = m ? this._mockSourceCache : t.getSourceCache(E, M);
                            if (!S)
                                return void s.w("Couldn't find terrain source \"".concat(E, '".'));
                            if (this.sourceCache = S,
                            this._attenuationRange = t.terrain.getAttenuationRange(),
                            this._exaggeration = y ? this.calculateExaggeration(i) : d.get("exaggeration"),
                            !i.projection.requiresDraping && y && 0 === this._exaggeration)
                                return void this._disable();
                            this.enabled = !0;
                            const I = () => {
                                this.sourceCache.used && s.w("Raster DEM source '".concat(this.sourceCache.id, "' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source."));
                                const R = this.getScaledDemTileSize();
                                this.sourceCache.update(i, R, !0),
                                this.resetTileLookupCache(this.sourceCache.id)
                            }
                            ;
                            this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id),
                            this.sourceCache.usedForTerrain = !0,
                            I(),
                            this._initializing = !0),
                            I(),
                            i.updateElevation(!0, h),
                            this.resetTileLookupCache(this.proxySourceCache.id),
                            this.proxySourceCache.update(i),
                            this._emptyDEMTextureDirty = !0,
                            this._previousZoom = i.zoom
                        } else
                            this._disable()
                    }
                    calculateExaggeration(t) {
                        if (this._attenuationRange && t.zoom >= Math.ceil(this._attenuationRange[1]))
                            return this._style.terrain.getExaggeration(t.zoom);
                        const i = this._previousCameraAltitude
                          , h = t.getFreeCameraOptions().position.z / t.pixelsPerMeter * t.worldSize;
                        this._previousCameraAltitude = h;
                        const d = null != i ? h - i : Number.MAX_VALUE;
                        if (Math.abs(d) < 2)
                            return this._exaggeration;
                        const m = t.zoom
                          , y = this._style.terrain;
                        if (!this._previousUpdateTimestamp)
                            return y.getExaggeration(m);
                        let M = m - this._previousZoom;
                        const E = this._previousUpdateTimestamp;
                        let S = m;
                        null != this._evaluationZoom && (S = this._evaluationZoom,
                        Math.abs(m - S) > .5 && (M = .5 * (m - S + M)),
                        M * d < 0 && (S += M)),
                        this._evaluationZoom = S;
                        const I = y.getExaggeration(S)
                          , R = I === y.getExaggeration(Math.max(0, S - .1));
                        if (R && Math.abs(I - this._exaggeration) < .01)
                            return I;
                        let D = Math.min(.1, .00375 * (this._updateTimestamp - E));
                        return (R || I < .1 || Math.abs(M) < 1e-4) && (D = Math.min(.2, 4 * D)),
                        s.af(this._exaggeration, I, D)
                    }
                    resetTileLookupCache(t) {
                        this._findCoveringTileCache[t] = {}
                    }
                    attenuationRange() {
                        return this._attenuationRange
                    }
                    getDemUpscale() {
                        return this.proxySourceCache.getSource().tileSize / 128
                    }
                    getScaledDemTileSize() {
                        return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize
                    }
                    _onStyleDataEvent(t) {
                        t.coord && "source" === t.dataType ? this._clearRenderCacheForTile(t.sourceCacheId, t.coord) : "style" === t.dataType && (this.invalidateRenderCache = !0,
                        this._evaluationZoom = void 0,
                        this._previousUpdateTimestamp = void 0,
                        this._previousCameraAltitude = void 0)
                    }
                    _disable() {
                        if (this.enabled && (this.enabled = !1,
                        this._emptyDEMTextureDirty = !0,
                        this._sharedDepthStencil = void 0,
                        this._evaluationZoom = void 0,
                        this._previousUpdateTimestamp = void 0,
                        this.proxySourceCache.deallocRenderCache(),
                        this._style))
                            for (const t in this._style._mergedSourceCaches)
                                this._style._mergedSourceCaches[t].usedForTerrain = !1
                    }
                    destroy() {
                        this._disable(),
                        this._emptyDEMTexture && this._emptyDEMTexture.destroy(),
                        this.pool.forEach(t => t.fb.destroy()),
                        this.pool = [],
                        this.framebufferCopyTexture && this.framebufferCopyTexture.destroy()
                    }
                    _source() {
                        return this.enabled ? this.sourceCache : null
                    }
                    isUsingMockSource() {
                        return this.sourceCache === this._mockSourceCache
                    }
                    exaggeration() {
                        return this.enabled ? this._exaggeration : 0
                    }
                    get visibleDemTiles() {
                        return this._visibleDemTiles
                    }
                    get drapeBufferSize() {
                        const t = 2 * this.proxySourceCache.getSource().tileSize;
                        return [t, t]
                    }
                    set useVertexMorphing(t) {
                        this._useVertexMorphing = t
                    }
                    updateTileBinding(t) {
                        if (!this.enabled)
                            return;
                        this.prevTerrainTileForTile = this.terrainTileForTile;
                        const i = this.proxySourceCache
                          , h = this.painter.transform;
                        this._initializing && (this._initializing = 0 === h._centerAltitude && -1 === this.getAtPointOrZero(s.aa.fromLngLat(h.center), -1),
                        this._emptyDEMTextureDirty = !this._initializing);
                        const d = this.proxyCoords = i.getIds().map(E => {
                            const S = i.getTileByID(E).tileID;
                            return S.projMatrix = h.calculateProjMatrix(S.toUnwrapped()),
                            S
                        }
                        );
                        !function(E, S) {
                            const I = S.transform.pointCoordinate(S.transform.getCameraPoint())
                              , R = new s.P(I.x,I.y);
                            E.sort( (D, k) => {
                                if (k.overscaledZ - D.overscaledZ)
                                    return k.overscaledZ - D.overscaledZ;
                                const H = new s.P(D.canonical.x + (1 << D.canonical.z) * D.wrap,D.canonical.y)
                                  , j = new s.P(k.canonical.x + (1 << k.canonical.z) * k.wrap,k.canonical.y)
                                  , Y = R.mult(1 << D.canonical.z);
                                return Y.x -= .5,
                                Y.y -= .5,
                                Y.distSqr(H) - Y.distSqr(j)
                            }
                            )
                        }(d, this.painter);
                        const m = this.proxyToSource || {};
                        this.proxyToSource = {},
                        d.forEach(E => {
                            this.proxyToSource[E.key] = {}
                        }
                        ),
                        this.terrainTileForTile = {};
                        const y = this._style._mergedSourceCaches;
                        for (const E in y) {
                            const S = y[E];
                            if (!S.used || (S !== this.sourceCache && this.resetTileLookupCache(S.id),
                            this._setupProxiedCoordsForOrtho(S, t[E], m),
                            S.usedForTerrain))
                                continue;
                            const I = t[E];
                            S.getSource().reparseOverscaled && this._assignTerrainTiles(I)
                        }
                        this.proxiedCoords[i.id] = d.map(E => new _l(E,E.key,this.orthoMatrix)),
                        this._assignTerrainTiles(d),
                        this._prepareDEMTextures(),
                        this._setupDrapedRenderBatches(),
                        this._initFBOPool(),
                        this._setupRenderCache(m),
                        this.renderingToTexture = !1;
                        const M = {};
                        this._visibleDemTiles = [];
                        for (const E of this.proxyCoords) {
                            const S = this.terrainTileForTile[E.key];
                            if (!S)
                                continue;
                            const I = S.tileID.key;
                            I in M || (this._visibleDemTiles.push(S),
                            M[I] = I)
                        }
                    }
                    _assignTerrainTiles(t) {
                        this._initializing || t.forEach(i => {
                            if (this.terrainTileForTile[i.key])
                                return;
                            const h = this._findTileCoveringTileID(i, this.sourceCache);
                            h && (this.terrainTileForTile[i.key] = h)
                        }
                        )
                    }
                    _prepareDEMTextures() {
                        const t = this.painter.context
                          , i = t.gl;
                        for (const h in this.terrainTileForTile) {
                            const d = this.terrainTileForTile[h]
                              , m = d.dem;
                            !m || d.demTexture && !d.needsDEMTextureUpload || (t.activeTexture.set(i.TEXTURE1),
                            ms(this.painter, d, m))
                        }
                    }
                    _prepareDemTileUniforms(t, i, h, d) {
                        if (!i || null == i.demTexture)
                            return !1;
                        const m = t.tileID.canonical
                          , y = Math.pow(2, i.tileID.canonical.z - m.z)
                          , M = d || "";
                        return h["u_dem_tl".concat(M)] = [m.x * y % 1, m.y * y % 1],
                        h["u_dem_scale".concat(M)] = y,
                        !0
                    }
                    get emptyDEMTexture() {
                        return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture()
                    }
                    _getLoadedAreaMinimum() {
                        if (!this.enabled)
                            return 0;
                        let t = 0;
                        const i = this._visibleDemTiles.reduce( (h, d) => {
                            if (!d.dem)
                                return h;
                            const m = d.dem.tree.minimums[0];
                            return m > 0 && t++,
                            h + m
                        }
                        , 0);
                        return t ? i / t : 0
                    }
                    _updateEmptyDEMTexture() {
                        const t = this.painter.context
                          , i = t.gl;
                        t.activeTexture.set(i.TEXTURE2);
                        const h = this._getLoadedAreaMinimum()
                          , d = new s.cK({
                            width: 1,
                            height: 1
                        },new Float32Array([h]));
                        this._emptyDEMTextureDirty = !1;
                        let m = this._emptyDEMTexture;
                        return m ? m.update(d, {
                            premultiply: !1
                        }) : m = this._emptyDEMTexture = new s.T(t,d,i.R32F,{
                            premultiply: !1
                        }),
                        m
                    }
                    setupElevationDraw(t, i, h) {
                        const d = this.painter.context
                          , m = d.gl
                          , y = {
                            u_dem: 2,
                            u_dem_prev: 4,
                            u_dem_tl: [0, 0],
                            u_dem_tl_prev: [0, 0],
                            u_dem_scale: 0,
                            u_dem_scale_prev: 0,
                            u_dem_size: 0,
                            u_dem_lerp: 1,
                            u_depth: 3,
                            u_depth_size_inv: [0, 0],
                            u_depth_range_unpack: [0, 1],
                            u_occluder_half_size: 16,
                            u_occlusion_depth_offset: -1e-4,
                            u_exaggeration: 0
                        };
                        y.u_exaggeration = this.exaggeration();
                        let M = null
                          , E = null
                          , S = 1;
                        if (h && h.morphing && this._useVertexMorphing) {
                            const k = h.morphing.srcDemTile
                              , H = h.morphing.dstDemTile;
                            S = h.morphing.phase,
                            k && H && (this._prepareDemTileUniforms(t, k, y, "_prev") && (E = k),
                            this._prepareDemTileUniforms(t, H, y) && (M = H))
                        }
                        const I = k => k && k.demTexture && this.painter.linearFloatFilteringSupported() ? m.LINEAR : m.NEAREST;
                        let R = null;
                        var D;
                        if (this.enabled ? E && M ? (R = M.demTexture,
                        d.activeTexture.set(m.TEXTURE4),
                        E.demTexture.bind(I(E), m.CLAMP_TO_EDGE),
                        y.u_dem_lerp = S) : (M = this.terrainTileForTile[t.tileID.key],
                        R = this._prepareDemTileUniforms(t, M, y) ? M.demTexture : this.emptyDEMTexture) : R = this.emptyDEMTexture,
                        d.activeTexture.set(m.TEXTURE2),
                        R && (y.u_dem_size = 1 === (D = R).size[0] ? 1 : D.size[0] - 2,
                        R.bind(I(M), m.CLAMP_TO_EDGE)),
                        this.painter.setupDepthForOcclusion(h && h.useDepthForOcclusion, i, y),
                        h && h.useMeterToDem && M) {
                            const k = (1 << M.tileID.canonical.z) * s.bH(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
                            y.u_meter_to_dem = k
                        }
                        if (h && h.labelPlaneMatrixInv && (y.u_label_plane_matrix_inv = h.labelPlaneMatrixInv),
                        i.setTerrainUniformValues(d, y),
                        "globe" === this.painter.transform.projection.name) {
                            const k = this.globeUniformValues(this.painter.transform, t.tileID.canonical, h && h.useDenormalizedUpVectorScale);
                            i.setGlobeUniformValues(d, k)
                        }
                    }
                    globeUniformValues(t, i, h) {
                        const d = t.projection;
                        return {
                            u_tile_tl_up: d.upVector(i, 0, 0),
                            u_tile_tr_up: d.upVector(i, s.ag, 0),
                            u_tile_br_up: d.upVector(i, s.ag, s.ag),
                            u_tile_bl_up: d.upVector(i, 0, s.ag),
                            u_tile_up_scale: h ? s.cL(1) : d.upVectorScale(i, t.center.lat, t.worldSize).metersToTile
                        }
                    }
                    renderToBackBuffer(t) {
                        const i = this.painter
                          , h = this.painter.context;
                        0 !== t.length && (h.bindFramebuffer.set(null),
                        h.viewport.set([0, 0, i.width, i.height]),
                        i.gpuTimingDeferredRenderStart(),
                        this.renderingToTexture = !1,
                        function(d, m, y, M, E) {
                            if ("globe" === d.transform.projection.name)
                                !function(S, I, R, D, k) {
                                    const H = S.context
                                      , j = H.gl;
                                    let Y, K;
                                    const he = S.transform
                                      , Te = s.cC(S, H, he)
                                      , be = (Ze, nt) => {
                                        if (K === nt)
                                            return;
                                        const zt = [pc[nt], "PROJECTION_GLOBE_VIEW"];
                                        Te && zt.push("CUSTOM_ANTIALIASING");
                                        const Yt = S.isTileAffectedByFog(Ze);
                                        Y = S.getOrCreateProgram("globeRaster", {
                                            defines: zt,
                                            overrideFog: Yt
                                        }),
                                        K = nt
                                    }
                                      , Ue = S.colorModeForRenderPass()
                                      , De = new Fo(j.LEQUAL,Fo.ReadWrite,S.depthRangeFor3D);
                                    br.update(k);
                                    const ke = s.cD(he)
                                      , Le = [s.at(he.center.lng), s.aA(he.center.lat)]
                                      , Ge = S.globeSharedBuffers
                                      , qe = [he.width * s.q.devicePixelRatio, he.height * s.q.devicePixelRatio]
                                      , vt = Float32Array.from(he.globeMatrix)
                                      , dt = {
                                        useDenormalizedUpVectorScale: !0
                                    };
                                    {
                                        const Ze = S.transform
                                          , nt = Jr(Ze.zoom, I.exaggeration(), I.sourceCache._source.tileSize);
                                        K = -1;
                                        const zt = j.TRIANGLES;
                                        for (const Yt of D) {
                                            const to = R.getTile(Yt)
                                              , ut = Xo.disabled
                                              , Gt = I.prevTerrainTileForTile[Yt.key]
                                              , wt = I.terrainTileForTile[Yt.key];
                                            Ra(Gt, wt) && br.newMorphing(Yt.key, Gt, wt, k, 250),
                                            H.activeTexture.set(j.TEXTURE0),
                                            to.texture && to.texture.bind(j.LINEAR, j.CLAMP_TO_EDGE);
                                            const qt = br.getMorphValuesForProxy(Yt.key)
                                              , Ht = qt ? 1 : 0;
                                            qt && s.J(dt, {
                                                morphing: {
                                                    srcDemTile: qt.from,
                                                    dstDemTile: qt.to,
                                                    phase: s.cB(qt.phase)
                                                }
                                            });
                                            const Dt = s.cE(Yt.canonical)
                                              , bo = s.cF(Dt.getCenter().lat)
                                              , oo = s.cG(Yt.canonical, Dt, bo, Ze.worldSize / Ze._pixelsPerMercatorPixel)
                                              , Po = s.bb(s.cH(Yt.canonical))
                                              , Eo = ml(Ze.expandedFarZProjMatrix, vt, ke, Po, s.ae(Ze.zoom), Le, Ze.frustumCorners.TL, Ze.frustumCorners.TR, Ze.frustumCorners.BR, Ze.frustumCorners.BL, Ze.globeCenterInViewSpace, Ze.globeRadius, qe, nt, Ze._farZ, oo);
                                            if (be(Yt, Ht),
                                            Y && (I.setupElevationDraw(to, Y, dt),
                                            S.uploadCommonUniforms(H, Y, Yt.toUnwrapped()),
                                            Ge)) {
                                                const [Yo,ko,Uo] = Ge.getGridBuffers(bo, 0 !== nt);
                                                Y.draw(S, zt, De, ut, Ue, zo.backCCW, Eo, "globe_raster", Yo, ko, Uo)
                                            }
                                        }
                                    }
                                    if (Ge && (S.renderDefaultNorthPole || S.renderDefaultSouthPole)) {
                                        const Ze = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                                        Te && Ze.push("CUSTOM_ANTIALIASING"),
                                        Y = S.getOrCreateProgram("globeRaster", {
                                            defines: Ze
                                        });
                                        for (const nt of D) {
                                            const {x: zt, y: Yt, z: to} = nt.canonical
                                              , ut = 0 === Yt
                                              , Gt = Yt === (1 << to) - 1
                                              , [wt,qt,Ht,Dt] = Ge.getPoleBuffers(to, !1);
                                            if (Dt && (ut || Gt)) {
                                                const bo = R.getTile(nt);
                                                H.activeTexture.set(j.TEXTURE0),
                                                bo.texture && bo.texture.bind(j.LINEAR, j.CLAMP_TO_EDGE);
                                                let oo = s.cI(to, zt, he);
                                                const Po = s.bb(s.cH(nt.canonical))
                                                  , Eo = (Yo, ko) => Yo.draw(S, j.TRIANGLES, De, Xo.disabled, Ue, zo.disabled, ml(he.expandedFarZProjMatrix, oo, oo, Po, 0, Le, he.frustumCorners.TL, he.frustumCorners.TR, he.frustumCorners.BR, he.frustumCorners.BL, he.globeCenterInViewSpace, he.globeRadius, qe, 0, he._farZ), "globe_pole_raster", ko, Ht, Dt);
                                                I.setupElevationDraw(bo, Y, dt),
                                                S.uploadCommonUniforms(H, Y, nt.toUnwrapped()),
                                                ut && S.renderDefaultNorthPole && Eo(Y, wt),
                                                Gt && S.renderDefaultSouthPole && (oo = s.ab.mat4.scale(s.ab.mat4.create(), oo, [1, -1, 1]),
                                                Eo(Y, qt))
                                            }
                                        }
                                    }
                                }(d, m, y, M, E);
                            else {
                                const S = d.context
                                  , I = S.gl;
                                let R, D;
                                const k = d.shadowRenderer
                                  , H = Kr(d, d.longestCutoffRange)
                                  , j = Ue => {
                                    if (D === Ue)
                                        return;
                                    const De = [];
                                    De.push(pc[Ue]),
                                    H.shouldRenderCutoff && De.push("RENDER_CUTOFF"),
                                    k && (De.push("RENDER_SHADOWS", "DEPTH_TEXTURE"),
                                    k.useNormalOffset && De.push("NORMAL_OFFSET")),
                                    R = d.getOrCreateProgram("terrainRaster", {
                                        defines: De
                                    }),
                                    D = Ue
                                }
                                  , Y = d.colorModeForRenderPass()
                                  , K = new Fo(I.LEQUAL,Fo.ReadWrite,d.depthRangeFor3D);
                                br.update(E);
                                const he = d.transform
                                  , Te = Jr(he.zoom, m.exaggeration(), m.sourceCache._source.tileSize);
                                let be = [0, 0, 0];
                                if (k) {
                                    const Ue = d.style.directionalLight
                                      , De = d.style.ambientLight;
                                    Ue && De && (be = oa(d.style, Ue, De))
                                }
                                {
                                    D = -1;
                                    const Ue = I.TRIANGLES
                                      , [De,ke] = [m.gridIndexBuffer, m.gridSegments];
                                    for (const Le of M) {
                                        const Ge = y.getTile(Le)
                                          , qe = Xo.disabled
                                          , vt = m.prevTerrainTileForTile[Le.key]
                                          , dt = m.terrainTileForTile[Le.key];
                                        Ra(vt, dt) && br.newMorphing(Le.key, vt, dt, E, 250),
                                        S.activeTexture.set(I.TEXTURE0),
                                        Ge.texture && Ge.texture.bind(I.LINEAR, I.CLAMP_TO_EDGE);
                                        const Ze = br.getMorphValuesForProxy(Le.key)
                                          , nt = Ze ? 1 : 0;
                                        let zt;
                                        Ze && (zt = {
                                            morphing: {
                                                srcDemTile: Ze.from,
                                                dstDemTile: Ze.to,
                                                phase: s.cB(Ze.phase)
                                            }
                                        });
                                        const Yt = dh(Le.projMatrix, dc(Le.canonical, he.renderWorldCopies) ? Te / 10 : Te, be);
                                        if (j(nt),
                                        !R)
                                            continue;
                                        m.setupElevationDraw(Ge, R, zt);
                                        const to = Le.toUnwrapped();
                                        k && k.setupShadows(to, R),
                                        d.uploadCommonUniforms(S, R, to, null, H),
                                        R.draw(d, Ue, K, qe, Y, zo.backCCW, Yt, "terrain_raster", m.gridBuffer, De, ke)
                                    }
                                }
                            }
                        }(i, this, this.proxySourceCache, t, this._updateTimestamp),
                        this.renderingToTexture = !0,
                        i.gpuTimingDeferredRenderEnd(),
                        t.splice(0, t.length))
                    }
                    renderBatch(t) {
                        if (0 === this._drapedRenderBatches.length)
                            return t + 1;
                        this.renderingToTexture = !0;
                        const i = this.painter
                          , h = this.painter.context
                          , d = this.proxySourceCache
                          , m = this.proxiedCoords[d.id]
                          , y = this._drapedRenderBatches.shift()
                          , M = i.style.order
                          , E = [];
                        let S = 0;
                        for (const I of m) {
                            const R = d.getTileByID(I.proxyTileKey)
                              , D = d.proxyCachedFBO[I.key] ? d.proxyCachedFBO[I.key][t] : void 0
                              , k = void 0 !== D ? d.renderCache[D] : this.pool[S++]
                              , H = void 0 !== D;
                            if (R.texture = k.tex,
                            H && !k.dirty) {
                                E.push(R.tileID);
                                continue
                            }
                            let j;
                            h.bindFramebuffer.set(k.fb.framebuffer),
                            this.renderedToTile = !1,
                            k.dirty && (h.clear({
                                color: s.aj.transparent,
                                stencil: 0
                            }),
                            k.dirty = !1);
                            for (let Y = y.start; Y <= y.end; ++Y) {
                                const K = i.style._mergedLayers[M[Y]];
                                if (K.isHidden(i.transform.zoom))
                                    continue;
                                const he = i.style.getLayerSourceCache(K)
                                  , Te = he ? this.proxyToSource[I.key][he.id] : [I];
                                if (!Te)
                                    continue;
                                const be = Te;
                                h.viewport.set([0, 0, k.fb.width, k.fb.height]),
                                j !== (he ? he.id : null) && (this._setupStencil(k, Te, K, he),
                                j = he ? he.id : null),
                                i.renderLayer(i, he, K, be)
                            }
                            if (0 === this._drapedRenderBatches.length)
                                for (const Y of this._pendingGroundEffectLayers) {
                                    const K = i.style._mergedLayers[M[Y]];
                                    if (K.isHidden(i.transform.zoom))
                                        continue;
                                    const he = i.style.getLayerSourceCache(K)
                                      , Te = he ? this.proxyToSource[I.key][he.id] : [I];
                                    if (!Te)
                                        continue;
                                    const be = Te;
                                    h.viewport.set([0, 0, k.fb.width, k.fb.height]),
                                    j !== (he ? he.id : null) && (this._setupStencil(k, Te, K, he),
                                    j = he ? he.id : null),
                                    i.renderLayer(i, he, K, be)
                                }
                            this.renderedToTile ? (k.dirty = !0,
                            E.push(R.tileID)) : H || --S,
                            5 === S && (S = 0,
                            this.renderToBackBuffer(E))
                        }
                        return this.renderToBackBuffer(E),
                        this.renderingToTexture = !1,
                        h.bindFramebuffer.set(null),
                        h.viewport.set([0, 0, i.width, i.height]),
                        y.end + 1
                    }
                    postRender() {}
                    isLayerOrderingCorrect(t) {
                        const i = t.order.length;
                        let h = -1
                          , d = i;
                        for (let m = 0; m < i; ++m)
                            this._style.isLayerDraped(t._mergedLayers[t.order[m]]) ? h = Math.max(h, m) : d = Math.min(d, m);
                        return d > h
                    }
                    getMinElevationBelowMSL() {
                        let t = 0;
                        return this._visibleDemTiles.filter(i => i.dem).forEach(i => {
                            t = Math.min(t, i.dem.tree.minimums[0])
                        }
                        ),
                        0 === t ? t : (t - 30) * this._exaggeration
                    }
                    raycast(t, i, h) {
                        if (!this._visibleDemTiles)
                            return null;
                        const d = this._visibleDemTiles.filter(m => m.dem).map(m => {
                            const y = m.tileID
                              , M = 1 << y.overscaledZ
                              , {x: E, y: S} = y.canonical
                              , I = E / M
                              , R = (E + 1) / M
                              , D = S / M
                              , k = (S + 1) / M;
                            return {
                                minx: I,
                                miny: D,
                                maxx: R,
                                maxy: k,
                                t: m.dem.tree.raycastRoot(I, D, R, k, t, i, h),
                                tile: m
                            }
                        }
                        );
                        d.sort( (m, y) => (null !== m.t ? m.t : Number.MAX_VALUE) - (null !== y.t ? y.t : Number.MAX_VALUE));
                        for (const m of d) {
                            if (null == m.t)
                                return null;
                            const y = m.tile.dem.tree.raycast(m.minx, m.miny, m.maxx, m.maxy, t, i, h);
                            if (null != y)
                                return y
                        }
                        return null
                    }
                    _createFBO() {
                        const t = this.painter.context
                          , i = t.gl
                          , h = this.drapeBufferSize;
                        t.activeTexture.set(i.TEXTURE0);
                        const d = new s.T(t,{
                            width: h[0],
                            height: h[1],
                            data: null
                        },i.RGBA8);
                        d.bind(i.LINEAR, i.CLAMP_TO_EDGE);
                        const m = t.createFramebuffer(h[0], h[1], !0, null);
                        return m.colorAttachment.set(d.texture),
                        m.depthAttachment = new ph(t,m.framebuffer),
                        void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t.createRenderbuffer(t.gl.DEPTH_STENCIL, h[0], h[1]),
                        this._stencilRef = 0,
                        m.depthAttachment.set(this._sharedDepthStencil),
                        t.clear({
                            stencil: 0
                        })) : m.depthAttachment.set(this._sharedDepthStencil),
                        t.extTextureFilterAnisotropic && i.texParameterf(i.TEXTURE_2D, t.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t.extTextureFilterAnisotropicMax),
                        {
                            fb: m,
                            tex: d,
                            dirty: !1
                        }
                    }
                    _initFBOPool() {
                        for (; this.pool.length < Math.min(5, this.proxyCoords.length); )
                            this.pool.push(this._createFBO())
                    }
                    _shouldDisableRenderCache() {
                        if (this._debugParams.disableRenderCache || this._style.hasLightTransitions())
                            return !0;
                        for (const t in this._style._mergedSourceCaches)
                            if (this._style._mergedSourceCaches[t].hasTransition())
                                return !0;
                        return this._style.order.some(t => {
                            const i = this._style._mergedLayers[t]
                              , h = i.isHidden(this.painter.transform.zoom);
                            return "hillshade" === i.type || "custom" === i.type ? !h && i.shouldRedrape() : !h && i.hasTransition()
                        }
                        )
                    }
                    _clearLineLayersFromRenderCache() {
                        let t = !1;
                        for (const h of this._style.getSources())
                            if (h instanceof Va) {
                                t = !0;
                                break
                            }
                        if (!t)
                            return;
                        const i = {};
                        for (let h = 0; h < this._style.order.length; ++h) {
                            const d = this._style._mergedLayers[this._style.order[h]]
                              , m = this._style.getLayerSourceCache(d);
                            if (m && !i[m.id] && !d.isHidden(this.painter.transform.zoom) && "line" === d.type && d.widthExpression()instanceof s.a9) {
                                i[m.id] = !0;
                                for (const y of this.proxyCoords) {
                                    const M = this.proxyToSource[y.key][m.id];
                                    if (M)
                                        for (const E of M)
                                            this._clearRenderCacheForTile(m.id, E)
                                }
                            }
                        }
                    }
                    _clearRasterLayersFromRenderCache() {
                        let t = !1;
                        for (const h in this._style._mergedSourceCaches)
                            if (this._style._mergedSourceCaches[h]._source instanceof js) {
                                t = !0;
                                break
                            }
                        if (!t)
                            return;
                        const i = {};
                        for (let h = 0; h < this._style.order.length; ++h) {
                            const d = this._style._mergedLayers[this._style.order[h]]
                              , m = this._style.getLayerSourceCache(d);
                            if (!m || i[m.id] || d.isHidden(this.painter.transform.zoom) || "raster" !== d.type)
                                continue;
                            const y = d.paint.get("raster-fade-duration");
                            for (const M of this.proxyCoords) {
                                const E = this.proxyToSource[M.key][m.id];
                                if (E)
                                    for (const S of E) {
                                        const I = fl(m.getTile(S), m.findLoadedParent(S, 0), m, this.painter.transform, y);
                                        (1 !== I.opacity || 0 !== I.mix) && this._clearRenderCacheForTile(m.id, S)
                                    }
                            }
                        }
                    }
                    _setupDrapedRenderBatches() {
                        this._style.updateDrapeFirstLayers();
                        const t = this._style.order
                          , i = t.length;
                        if (0 === i)
                            return;
                        const h = [];
                        this._pendingGroundEffectLayers = [];
                        let d, m = 0, y = this._style._mergedLayers[t[m]];
                        for (; !this._style.isLayerDraped(y) && y.isHidden(this.painter.transform.zoom) && ++m < i; )
                            y = this._style._mergedLayers[t[m]];
                        for (; m < i; ++m) {
                            const M = this._style._mergedLayers[t[m]];
                            M.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(M) ? void 0 === d && (d = m) : ("fill-extrusion" === M.type && this._pendingGroundEffectLayers.push(m),
                            void 0 !== d && (h.push({
                                start: d,
                                end: m - 1
                            }),
                            d = void 0)))
                        }
                        if (void 0 !== d && h.push({
                            start: d,
                            end: m - 1
                        }),
                        0 !== h.length) {
                            const M = h[h.length - 1];
                            this._pendingGroundEffectLayers.every(E => E > M.end) || s.w("fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.")
                        }
                        this._drapedRenderBatches = h
                    }
                    _setupRenderCache(t) {
                        const i = this.proxySourceCache;
                        if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {
                            if (this.invalidateRenderCache = !1,
                            i.renderCache.length > i.renderCachePool.length) {
                                const y = Object.values(i.proxyCachedFBO);
                                i.proxyCachedFBO = {};
                                for (let M = 0; M < y.length; ++M) {
                                    const E = Object.values(y[M]);
                                    i.renderCachePool.push(...E)
                                }
                            }
                            return
                        }
                        this._clearRasterLayersFromRenderCache();
                        const h = this.proxyCoords
                          , d = this._tilesDirty;
                        for (let y = h.length - 1; y >= 0; y--) {
                            const M = h[y];
                            if (i.getTileByID(M.key),
                            void 0 !== i.proxyCachedFBO[M.key]) {
                                const E = t[M.key]
                                  , S = this.proxyToSource[M.key];
                                let I = 0;
                                for (const R in S) {
                                    const D = S[R]
                                      , k = E[R];
                                    if (!k || k.length !== D.length || D.some( (H, j) => H !== k[j] || d[R] && d[R].hasOwnProperty(H.key))) {
                                        I = -1;
                                        break
                                    }
                                    ++I
                                }
                                for (const R in i.proxyCachedFBO[M.key])
                                    i.renderCache[i.proxyCachedFBO[M.key][R]].dirty = I < 0 || I !== Object.values(E).length
                            }
                        }
                        const m = [...this._drapedRenderBatches];
                        m.sort( (y, M) => M.end - M.start - (y.end - y.start));
                        for (const y of m)
                            for (const M of h) {
                                if (i.proxyCachedFBO[M.key])
                                    continue;
                                let E = i.renderCachePool.pop();
                                void 0 === E && i.renderCache.length < 50 && (E = i.renderCache.length,
                                i.renderCache.push(this._createFBO())),
                                void 0 !== E && (i.proxyCachedFBO[M.key] = {},
                                i.proxyCachedFBO[M.key][y.start] = E,
                                i.renderCache[E].dirty = !0)
                            }
                        this._tilesDirty = {}
                    }
                    _setupStencil(t, i, h, d) {
                        if (!d || !this._sourceTilesOverlap[d.id])
                            return void (this._overlapStencilType && (this._overlapStencilType = !1));
                        const m = this.painter.context
                          , y = m.gl;
                        if (i.length <= 1)
                            return void (this._overlapStencilType = !1);
                        let M;
                        if (h.isTileClipped())
                            M = i.length,
                            this._overlapStencilMode.test = {
                                func: y.EQUAL,
                                mask: 255
                            },
                            this._overlapStencilType = "Clip";
                        else {
                            if (!(i[0].overscaledZ > i[i.length - 1].overscaledZ))
                                return void (this._overlapStencilType = !1);
                            M = 1,
                            this._overlapStencilMode.test = {
                                func: y.GREATER,
                                mask: 255
                            },
                            this._overlapStencilType = "Mask"
                        }
                        this._stencilRef + M > 255 && (m.clear({
                            stencil: 0
                        }),
                        this._stencilRef = 0),
                        this._stencilRef += M,
                        this._overlapStencilMode.ref = this._stencilRef,
                        h.isTileClipped() && this._renderTileClippingMasks(i, this._overlapStencilMode.ref)
                    }
                    clipOrMaskOverlapStencilType() {
                        return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType
                    }
                    stencilModeForRTTOverlap(t) {
                        return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t.key]),
                        this._overlapStencilMode) : Xo.disabled
                    }
                    _renderTileClippingMasks(t, i) {
                        const h = this.painter
                          , d = this.painter.context
                          , m = d.gl;
                        h._tileClippingMaskIDs = {},
                        d.setColorMode(si.disabled),
                        d.setDepthMode(Fo.disabled);
                        const y = h.getOrCreateProgram("clippingMask");
                        for (const M of t) {
                            const E = h._tileClippingMaskIDs[M.key] = --i;
                            y.draw(h, m.TRIANGLES, Fo.disabled, new Xo({
                                func: m.ALWAYS,
                                mask: 0
                            },E,255,m.KEEP,m.KEEP,m.REPLACE), si.disabled, zo.disabled, sa(M.projMatrix), "$clipping", h.tileExtentBuffer, h.quadTriangleIndexBuffer, h.tileExtentSegments)
                        }
                    }
                    pointCoordinate(t) {
                        const i = this.painter.transform;
                        if (t.x < 0 || t.x > i.width || t.y < 0 || t.y > i.height)
                            return null;
                        const h = [t.x, t.y, 1, 1];
                        s.ab.vec4.transformMat4(h, h, i.pixelMatrixInverse),
                        s.ab.vec4.scale(h, h, 1 / h[3]),
                        h[0] /= i.worldSize,
                        h[1] /= i.worldSize;
                        const d = i._camera.position
                          , m = s.bH(1, i.center.lat)
                          , y = [d[0], d[1], d[2] / m, 0]
                          , M = s.ab.vec3.subtract([], h.slice(0, 3), y);
                        s.ab.vec3.normalize(M, M);
                        const E = this.raycast(y, M, this._exaggeration);
                        return null !== E && E ? (s.ab.vec3.scaleAndAdd(y, y, M, E),
                        y[3] = y[2],
                        y[2] *= m,
                        y) : null
                    }
                    _setupProxiedCoordsForOrtho(t, i, h) {
                        if (t.getSource()instanceof s.aJ)
                            return this._setupProxiedCoordsForImageSource(t, i, h);
                        this._findCoveringTileCache[t.id] = this._findCoveringTileCache[t.id] || {};
                        const d = this.proxiedCoords[t.id] = []
                          , m = this.proxyCoords;
                        for (let E = 0; E < m.length; E++) {
                            const S = m[E]
                              , I = this._findTileCoveringTileID(S, t);
                            if (I) {
                                const R = this._createProxiedId(S, I, h[S.key] && h[S.key][t.id]);
                                d.push(R),
                                this.proxyToSource[S.key][t.id] = [R]
                            }
                        }
                        let y = !1;
                        const M = new Set;
                        for (let E = 0; E < i.length; E++) {
                            const S = t.getTile(i[E]);
                            if (!S || !S.hasData())
                                continue;
                            const I = this._findTileCoveringTileID(S.tileID, this.proxySourceCache);
                            if (I && I.tileID.canonical.z !== S.tileID.canonical.z) {
                                const R = this.proxyToSource[I.tileID.key][t.id]
                                  , D = this._createProxiedId(I.tileID, S, h[I.tileID.key] && h[I.tileID.key][t.id]);
                                R ? R.splice(R.length - 1, 0, D) : this.proxyToSource[I.tileID.key][t.id] = [D];
                                const k = this.proxyToSource[I.tileID.key][t.id];
                                M.has(k) || M.add(k),
                                d.push(D),
                                y = !0
                            }
                        }
                        if (this._sourceTilesOverlap[t.id] = y,
                        y && this._debugParams.sortTilesHiZFirst)
                            for (const E of M)
                                E.sort( (S, I) => I.overscaledZ - S.overscaledZ)
                    }
                    _setupProxiedCoordsForImageSource(t, i, h) {
                        if (!t.getSource().loaded())
                            return;
                        const d = this.proxiedCoords[t.id] = []
                          , m = this.proxyCoords
                          , y = t.getSource()
                          , M = y.tileID;
                        if (!M)
                            return;
                        const E = new s.P(M.x,M.y)._div(1 << M.z)
                          , S = y.coordinates.map(s.aa.fromLngLat).reduce( (R, D) => (R.min.x = Math.min(R.min.x, D.x - E.x),
                        R.min.y = Math.min(R.min.y, D.y - E.y),
                        R.max.x = Math.max(R.max.x, D.x - E.x),
                        R.max.y = Math.max(R.max.y, D.y - E.y),
                        R), {
                            min: new s.P(Number.MAX_VALUE,Number.MAX_VALUE),
                            max: new s.P(-Number.MAX_VALUE,-Number.MAX_VALUE)
                        })
                          , I = (R, D) => {
                            const k = R.wrap + R.canonical.x / (1 << R.canonical.z)
                              , H = R.canonical.y / (1 << R.canonical.z)
                              , j = s.ag / (1 << R.canonical.z)
                              , Y = D.wrap + D.canonical.x / (1 << D.canonical.z)
                              , K = D.canonical.y / (1 << D.canonical.z);
                            return k + j < Y + S.min.x || k > Y + S.max.x || H + j < K + S.min.y || H > K + S.max.y
                        }
                        ;
                        for (let R = 0; R < m.length; R++) {
                            const D = m[R];
                            for (let k = 0; k < i.length; k++) {
                                const H = t.getTile(i[k]);
                                if (!H || !H.hasData() || I(D, H.tileID))
                                    continue;
                                const j = this._createProxiedId(D, H, h[D.key] && h[D.key][t.id])
                                  , Y = this.proxyToSource[D.key][t.id];
                                Y ? Y.push(j) : this.proxyToSource[D.key][t.id] = [j],
                                d.push(j)
                            }
                        }
                    }
                    _createProxiedId(t, i, h) {
                        let d = this.orthoMatrix;
                        if (h) {
                            const m = h.find(y => y.key === i.tileID.key);
                            if (m)
                                return m
                        }
                        if (i.tileID.key !== t.key) {
                            const m = t.canonical.z - i.tileID.canonical.z;
                            let y, M, E;
                            d = s.ab.mat4.create();
                            const S = i.tileID.wrap - t.wrap << t.overscaledZ;
                            m > 0 ? (y = s.ag >> m,
                            M = y * ((i.tileID.canonical.x << m) - t.canonical.x + S),
                            E = y * ((i.tileID.canonical.y << m) - t.canonical.y)) : (y = s.ag << -m,
                            M = s.ag * (i.tileID.canonical.x - (t.canonical.x + S << -m)),
                            E = s.ag * (i.tileID.canonical.y - (t.canonical.y << -m))),
                            s.ab.mat4.ortho(d, 0, y, 0, y, 0, 1),
                            s.ab.mat4.translate(d, d, [M, E, 0])
                        }
                        return new _l(i.tileID,t.key,d)
                    }
                    _findTileCoveringTileID(t, i) {
                        let h = i.getTile(t);
                        if (h && h.hasData())
                            return h;
                        const d = this._findCoveringTileCache[i.id]
                          , m = d[t.key];
                        if (h = m ? i.getTileByID(m) : null,
                        h && h.hasData() || null === m)
                            return h;
                        let y = h ? h.tileID : t
                          , M = y.overscaledZ;
                        const E = i.getSource().minzoom
                          , S = [];
                        if (!m) {
                            const R = i.getSource().maxzoom;
                            if (t.canonical.z >= R) {
                                const D = t.canonical.z - R;
                                i.getSource().reparseOverscaled ? (M = Math.max(t.canonical.z + 2, i.transform.tileZoom),
                                y = new s.aG(M,t.wrap,R,t.canonical.x >> D,t.canonical.y >> D)) : 0 !== D && (M = R,
                                y = new s.aG(M,t.wrap,R,t.canonical.x >> D,t.canonical.y >> D))
                            }
                            y.key !== t.key && (S.push(y.key),
                            h = i.getTile(y))
                        }
                        const I = R => {
                            S.forEach(D => {
                                d[D] = R
                            }
                            ),
                            S.length = 0
                        }
                        ;
                        for (M -= 1; M >= E && (!h || !h.hasData()); M--) {
                            h && I(h.tileID.key);
                            const R = y.calculateScaledKey(M);
                            if (h = i.getTileByID(R),
                            h && h.hasData())
                                break;
                            const D = d[R];
                            if (null === D)
                                break;
                            void 0 === D ? S.push(R) : h = i.getTileByID(D)
                        }
                        return I(h ? h.tileID.key : null),
                        h && h.hasData() ? h : null
                    }
                    findDEMTileFor(t) {
                        return this.enabled ? this._findTileCoveringTileID(t, this.sourceCache) : null
                    }
                    prepareDrawTile() {
                        this.renderedToTile = !0
                    }
                    _clearRenderCacheForTile(t, i) {
                        let h = this._tilesDirty[t];
                        h || (h = this._tilesDirty[t] = {}),
                        h[i.key] = !0
                    }
                }
                function _h(c, t, i) {
                    const h = function(M, E, S) {
                        const I = s.ab.vec3.dot(E, M)
                          , R = s.ab.vec3.dot(S, [.2126, .7152, .0722])
                          , D = (H, j, Y) => (1 - Y) * H + Y * j
                          , k = D(1 - .3 * Math.min(R, 1), 1, Math.min(I + 1, 1));
                        return D(.92, 1, Math.asin(s.aw(E[2], -1, 1)) / Math.PI + .5) * k
                    }(c, [0, 0, 1], t)
                      , d = [0, 0, 0];
                    s.ab.vec3.scale(d, i.slice(0, 3), h);
                    const m = [0, 0, 0];
                    s.ab.vec3.scale(m, t.slice(0, 3), c[2]);
                    const y = [0, 0, 0];
                    return s.ab.vec3.add(y, d, m),
                    s.cf(y)
                }
                const Da = ["fill", "fillOutline", "fillPattern", "line", "linePattern", "background", "backgroundPattern", "hillshade", "raster"]
                  , _u = ["stars", "rainParticle", "snowParticle", "fillExtrusion", "fillExtrusionGroundEffect", "model", "symbol"];
                class gh {
                    static cacheKey(t, i, h, d) {
                        let m = "".concat(i).concat(d ? d.cacheKey : "");
                        for (const y of h)
                            t.usedDefines.includes(y) && (m += "/".concat(y));
                        return m
                    }
                    constructor(t, i, h, d, m, y) {
                        const M = t.gl;
                        this.program = M.createProgram(),
                        this.configuration = d,
                        this.name = i,
                        this.fixedDefines = [...y];
                        const E = d ? d.getBinderAttributes() : []
                          , S = (h.staticAttributes || []).concat(E);
                        let I = d ? d.defines() : [];
                        I = I.concat(y.map(Y => "#define ".concat(Y)));
                        const R = "#version 300 es\n";
                        let D = R + I.concat("precision mediump float;", ds, As.fragmentSource).join("\n");
                        for (const Y of h.fragmentIncludes)
                            D += "\n".concat(rr[Y]);
                        D += "\n".concat(h.fragmentSource);
                        let k = R + I.concat("precision highp float;", ds, As.vertexSource).join("\n");
                        for (const Y of h.vertexIncludes)
                            k += "\n".concat(rr[Y]);
                        this.forceManualRenderingForInstanceIDShaders = t.forceManualRenderingForInstanceIDShaders && -1 !== h.vertexSource.indexOf("gl_InstanceID"),
                        this.forceManualRenderingForInstanceIDShaders && (k += "\nuniform int u_instanceID;\n"),
                        k += "\n".concat(h.vertexSource),
                        this.forceManualRenderingForInstanceIDShaders && (k = k.replaceAll("gl_InstanceID", "u_instanceID"));
                        const H = M.createShader(M.FRAGMENT_SHADER);
                        if (M.isContextLost())
                            return void (this.failedToCreate = !0);
                        M.shaderSource(H, D),
                        M.compileShader(H),
                        M.attachShader(this.program, H);
                        const j = M.createShader(M.VERTEX_SHADER);
                        if (M.isContextLost())
                            this.failedToCreate = !0;
                        else {
                            M.shaderSource(j, k),
                            M.compileShader(j),
                            M.attachShader(this.program, j),
                            this.attributes = {},
                            this.numAttributes = S.length;
                            for (let Y = 0; Y < this.numAttributes; Y++)
                                if (S[Y]) {
                                    const K = S[Y].startsWith("a_") ? S[Y] : "a_".concat(S[Y]);
                                    M.bindAttribLocation(this.program, Y, K),
                                    this.attributes[K] = Y
                                }
                            M.linkProgram(this.program),
                            M.deleteShader(j),
                            M.deleteShader(H),
                            this.fixedUniforms = m(t),
                            this.binderUniforms = d ? d.getUniforms(t) : [],
                            this.forceManualRenderingForInstanceIDShaders && (this.instancingUniforms = {
                                u_instanceID: new s.bN(t)
                            }),
                            (y.includes("TERRAIN") || -1 !== i.indexOf("symbol") || -1 !== i.indexOf("circle")) && (this.terrainUniforms = {
                                u_dem: new s.bN(Y = t),
                                u_dem_prev: new s.bN(Y),
                                u_dem_tl: new s.bK(Y),
                                u_dem_scale: new s.bM(Y),
                                u_dem_tl_prev: new s.bK(Y),
                                u_dem_scale_prev: new s.bM(Y),
                                u_dem_size: new s.bM(Y),
                                u_dem_lerp: new s.bM(Y),
                                u_exaggeration: new s.bM(Y),
                                u_depth: new s.bN(Y),
                                u_depth_size_inv: new s.bK(Y),
                                u_depth_range_unpack: new s.bK(Y),
                                u_occluder_half_size: new s.bM(Y),
                                u_occlusion_depth_offset: new s.bM(Y),
                                u_meter_to_dem: new s.bM(Y),
                                u_label_plane_matrix_inv: new s.bJ(Y)
                            }),
                            y.includes("GLOBE") && (this.globeUniforms = (Y => ({
                                u_tile_tl_up: new s.bL(Y),
                                u_tile_tr_up: new s.bL(Y),
                                u_tile_br_up: new s.bL(Y),
                                u_tile_bl_up: new s.bL(Y),
                                u_tile_up_scale: new s.bM(Y)
                            }))(t)),
                            y.includes("FOG") && (this.fogUniforms = (Y => ({
                                u_fog_matrix: new s.bJ(Y),
                                u_fog_range: new s.bK(Y),
                                u_fog_color: new s.ca(Y),
                                u_fog_horizon_blend: new s.bM(Y),
                                u_fog_vertical_limit: new s.bK(Y),
                                u_fog_temporal_offset: new s.bM(Y),
                                u_frustum_tl: new s.bL(Y),
                                u_frustum_tr: new s.bL(Y),
                                u_frustum_br: new s.bL(Y),
                                u_frustum_bl: new s.bL(Y),
                                u_globe_pos: new s.bL(Y),
                                u_globe_radius: new s.bM(Y),
                                u_globe_transition: new s.bM(Y),
                                u_is_globe: new s.bN(Y),
                                u_viewport: new s.bK(Y)
                            }))(t)),
                            y.includes("RENDER_CUTOFF") && (this.cutoffUniforms = (Y => ({
                                u_cutoff_params: new s.ca(Y)
                            }))(t)),
                            y.includes("LIGHTING_3D_MODE") && (this.lightsUniforms = (Y => ({
                                u_lighting_ambient_color: new s.bL(Y),
                                u_lighting_directional_dir: new s.bL(Y),
                                u_lighting_directional_color: new s.bL(Y),
                                u_ground_radiance: new s.bL(Y)
                            }))(t)),
                            y.includes("RENDER_SHADOWS") && (this.shadowUniforms = (Y => ({
                                u_light_matrix_0: new s.bJ(Y),
                                u_light_matrix_1: new s.bJ(Y),
                                u_fade_range: new s.bK(Y),
                                u_shadow_normal_offset: new s.bL(Y),
                                u_shadow_intensity: new s.bM(Y),
                                u_shadow_texel_size: new s.bM(Y),
                                u_shadow_map_resolution: new s.bM(Y),
                                u_shadow_direction: new s.bL(Y),
                                u_shadow_bias: new s.bL(Y),
                                u_shadowmap_0: new s.bN(Y),
                                u_shadowmap_1: new s.bN(Y)
                            }))(t))
                        }
                        var Y
                    }
                    setTerrainUniformValues(t, i) {
                        if (!this.terrainUniforms)
                            return;
                        const h = this.terrainUniforms;
                        if (!this.failedToCreate) {
                            t.program.set(this.program);
                            for (const d in i)
                                h[d] && h[d].set(this.program, d, i[d])
                        }
                    }
                    setGlobeUniformValues(t, i) {
                        if (!this.globeUniforms)
                            return;
                        const h = this.globeUniforms;
                        if (!this.failedToCreate) {
                            t.program.set(this.program);
                            for (const d in i)
                                h[d] && h[d].set(this.program, d, i[d])
                        }
                    }
                    setFogUniformValues(t, i) {
                        if (!this.fogUniforms)
                            return;
                        const h = this.fogUniforms;
                        if (!this.failedToCreate) {
                            t.program.set(this.program);
                            for (const d in i)
                                h[d].set(this.program, d, i[d])
                        }
                    }
                    setCutoffUniformValues(t, i) {
                        if (!this.cutoffUniforms)
                            return;
                        const h = this.cutoffUniforms;
                        if (!this.failedToCreate) {
                            t.program.set(this.program);
                            for (const d in i)
                                h[d].set(this.program, d, i[d])
                        }
                    }
                    setLightsUniformValues(t, i) {
                        if (!this.lightsUniforms)
                            return;
                        const h = this.lightsUniforms;
                        if (!this.failedToCreate) {
                            t.program.set(this.program);
                            for (const d in i)
                                h[d].set(this.program, d, i[d])
                        }
                    }
                    setShadowUniformValues(t, i) {
                        if (this.failedToCreate || !this.shadowUniforms)
                            return;
                        const h = this.shadowUniforms;
                        t.program.set(this.program);
                        for (const d in i)
                            h[d].set(this.program, d, i[d])
                    }
                    _drawDebugWireframe(t, i, h, d, m, y, M, E, S, I) {
                        const R = t.options.wireframe;
                        if (!1 === R.terrain && !1 === R.layers2D && !1 === R.layers3D)
                            return;
                        const D = t.context;
                        if (!(R.terrain && ("terrainRaster" === this.name || "globeRaster" === this.name) || !(!R.layers2D || t._terrain && t._terrain.renderingToTexture) && Da.includes(this.name) || R.layers3D && _u.includes(this.name)))
                            return;
                        const k = D.gl
                          , H = t.wireframeDebugCache.getLinesFromTrianglesBuffer(t.frameCounter, m, D);
                        if (!H)
                            return;
                        const j = [...this.fixedDefines];
                        j.push("DEBUG_WIREFRAME");
                        const Y = t.getOrCreateProgram(this.name, {
                            config: this.configuration,
                            defines: j
                        });
                        D.program.set(Y.program);
                        const K = (be, Ue, De) => {
                            if (Ue[be] && De[be])
                                for (const ke in Ue[be])
                                    De[be][ke] && De[be][ke].set(De.program, ke, Ue[be][ke].current)
                        }
                        ;
                        S && S.setUniforms(Y.program, D, Y.binderUniforms, M, {
                            zoom: E
                        }),
                        K("fixedUniforms", this, Y),
                        K("terrainUniforms", this, Y),
                        K("globeUniforms", this, Y),
                        K("fogUniforms", this, Y),
                        K("lightsUniforms", this, Y),
                        K("shadowUniforms", this, Y),
                        H.bind(),
                        D.setColorMode(new si([k.ONE, k.ONE_MINUS_SRC_ALPHA, k.ZERO, k.ONE],s.aj.transparent,[!0, !0, !0, !1])),
                        D.setDepthMode(new Fo(i.func === k.LESS ? k.LEQUAL : i.func,Fo.ReadOnly,i.range)),
                        D.setStencilMode(Xo.disabled);
                        const he = 3 * y.primitiveLength * 2
                          , Te = 3 * y.primitiveOffset * 2 * 2;
                        if (this.forceManualRenderingForInstanceIDShaders) {
                            const be = I || 1;
                            for (let Ue = 0; Ue < be; ++Ue)
                                Y.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", Ue),
                                k.drawElements(k.LINES, he, k.UNSIGNED_SHORT, Te)
                        } else
                            I && I > 1 ? k.drawElementsInstanced(k.LINES, he, k.UNSIGNED_SHORT, Te, I) : k.drawElements(k.LINES, he, k.UNSIGNED_SHORT, Te);
                        m.bind(),
                        D.program.set(this.program),
                        D.setDepthMode(i),
                        D.setStencilMode(h),
                        D.setColorMode(d)
                    }
                    checkUniforms(t, i, h) {
                        if (this.fixedDefines.includes(i))
                            for (const d of Object.keys(h))
                                if (!h[d].initialized)
                                    throw new Error("Program '".concat(this.name, "', from draw '").concat(t, "': uniform ").concat(d, " not set but required by ").concat(i, " being defined"))
                    }
                    draw(t, i, h, d, m, y, M, E, S, I, R, D, k, H, j, Y) {
                        const K = t.context
                          , he = K.gl;
                        if (this.failedToCreate)
                            return;
                        K.program.set(this.program),
                        K.setDepthMode(h),
                        K.setStencilMode(d),
                        K.setColorMode(m),
                        K.setCullFace(y);
                        for (const Ue of Object.keys(this.fixedUniforms))
                            this.fixedUniforms[Ue].set(this.program, Ue, M[Ue]);
                        H && H.setUniforms(this.program, K, this.binderUniforms, D, {
                            zoom: k
                        });
                        const Te = {
                            [he.POINTS]: 1,
                            [he.LINES]: 2,
                            [he.TRIANGLES]: 3,
                            [he.LINE_STRIP]: 1
                        }[i];
                        this.checkUniforms(E, "RENDER_SHADOWS", this.shadowUniforms);
                        const be = Y && Y > 0 ? 1 : void 0;
                        for (const Ue of R.get()) {
                            const De = Ue.vaos || (Ue.vaos = {});
                            if ((De[E] || (De[E] = new Ql)).bind(K, this, S, H ? H.getPaintVertexBuffers() : [], I, Ue.vertexOffset, j || [], be),
                            this.forceManualRenderingForInstanceIDShaders) {
                                const ke = Y || 1;
                                for (let Le = 0; Le < ke; ++Le)
                                    this.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", Le),
                                    I ? he.drawElements(i, Ue.primitiveLength * Te, he.UNSIGNED_SHORT, Ue.primitiveOffset * Te * 2) : he.drawArrays(i, Ue.vertexOffset, Ue.vertexLength)
                            } else
                                Y && Y > 1 ? he.drawElementsInstanced(i, Ue.primitiveLength * Te, he.UNSIGNED_SHORT, Ue.primitiveOffset * Te * 2, Y) : I ? he.drawElements(i, Ue.primitiveLength * Te, he.UNSIGNED_SHORT, Ue.primitiveOffset * Te * 2) : he.drawArrays(i, Ue.vertexOffset, Ue.vertexLength);
                            i === he.TRIANGLES && I && this._drawDebugWireframe(t, h, d, m, I, Ue, D, k, H, Y)
                        }
                    }
                }
                function fc(c, t) {
                    const i = Math.pow(2, t.tileID.overscaledZ)
                      , h = t.tileSize * Math.pow(2, c.transform.tileZoom) / i
                      , d = h * (t.tileID.canonical.x + t.tileID.wrap * i)
                      , m = h * t.tileID.canonical.y;
                    return {
                        u_image: 0,
                        u_texsize: t.imageAtlasTexture ? t.imageAtlasTexture.size : [0, 0],
                        u_tile_units_to_pixels: 1 / s.ar(t, 1, c.transform.tileZoom),
                        u_pixel_coord_upper: [d >> 16, m >> 16],
                        u_pixel_coord_lower: [65535 & d, 65535 & m]
                    }
                }
                const gl = {
                    terrain: 0,
                    flat: 1
                }
                  , _c = s.ab.mat4.create()
                  , yl = (c, t, i, h, d, m, y, M, E, S, I, R, D, k, H, j, Y, K) => {
                    const he = t.style.light
                      , Te = he.properties.get("position")
                      , be = [Te.x, Te.y, Te.z]
                      , Ue = s.ab.mat3.create();
                    "viewport" === he.properties.get("anchor") && (s.ab.mat3.fromRotation(Ue, -t.transform.angle),
                    s.ab.vec3.transformMat3(be, be, Ue));
                    const De = he.properties.get("color")
                      , ke = t.transform
                      , Le = {
                        u_matrix: c,
                        u_lightpos: be,
                        u_lightintensity: he.properties.get("intensity"),
                        u_lightcolor: [De.r, De.g, De.b],
                        u_vertical_gradient: +i,
                        u_opacity: h,
                        u_tile_id: [0, 0, 0],
                        u_zoom_transition: 0,
                        u_inv_rot_matrix: _c,
                        u_merc_center: [0, 0],
                        u_up_dir: [0, 0, 0],
                        u_height_lift: 0,
                        u_height_type: gl[S],
                        u_base_type: gl[I],
                        u_ao: d,
                        u_edge_radius: m,
                        u_width_scale: y,
                        u_flood_light_color: H,
                        u_vertical_scale: j,
                        u_flood_light_intensity: Y,
                        u_ground_shadow_factor: K
                    };
                    return "globe" === ke.projection.name && (Le.u_tile_id = [M.canonical.x, M.canonical.y, 1 << M.canonical.z],
                    Le.u_zoom_transition = R,
                    Le.u_inv_rot_matrix = k,
                    Le.u_merc_center = D,
                    Le.u_up_dir = ke.projection.upVector(new s.bT(0,0,0), D[0] * s.ag, D[1] * s.ag),
                    Le.u_height_lift = E),
                    Le
                }
                  , La = (c, t, i, h, d, m) => ({
                    u_matrix: c,
                    u_edge_radius: t,
                    u_width_scale: i,
                    u_vertical_scale: h,
                    u_height_type: gl[d],
                    u_base_type: gl[m]
                })
                  , gc = (c, t, i, h, d, m, y, M, E, S, I, R, D, k, H, j, Y) => {
                    const K = yl(c, t, i, h, d, m, y, M, S, I, R, D, k, H, j, Y, 1, [0, 0, 0])
                      , he = {
                        u_height_factor: -Math.pow(2, M.overscaledZ) / E.tileSize / 8
                    };
                    return s.l(K, fc(t, E), he)
                }
                  , aa = (c, t) => ({
                    u_matrix: c,
                    u_emissive_strength: t
                })
                  , yc = (c, t, i, h) => s.l(aa(c, t), fc(i, h))
                  , U = (c, t, i) => ({
                    u_matrix: c,
                    u_world: i,
                    u_emissive_strength: t
                })
                  , V = (c, t, i, h, d) => s.l(yc(c, t, i, h), {
                    u_world: d
                })
                  , te = (c, t, i, h) => {
                    const d = s.ag / i.tileSize;
                    return {
                        u_matrix: c,
                        u_camera_to_center_distance: t.getCameraToCenterDistance(h),
                        u_extrude_scale: [t.pixelsToGLUnits[0] / d, t.pixelsToGLUnits[1] / d]
                    }
                }
                  , Q = (c, t, i=1) => ({
                    u_matrix: c,
                    u_color: t.toRenderColor(null),
                    u_overlay: 0,
                    u_overlay_scale: i
                })
                  , ce = s.ab.mat4.create()
                  , xe = (c, t, i, h, d, m, y) => {
                    const M = c.transform
                      , E = "globe" === M.projection.name
                      , S = E ? s.cN(M.zoom, t.canonical) * M._pixelsPerMercatorPixel : s.ar(i, 1, m)
                      , I = {
                        u_matrix: t.projMatrix,
                        u_extrude_scale: S,
                        u_intensity: y,
                        u_inv_rot_matrix: ce,
                        u_merc_center: [0, 0],
                        u_tile_id: [0, 0, 0],
                        u_zoom_transition: 0,
                        u_up_dir: [0, 0, 0]
                    };
                    if (E) {
                        I.u_inv_rot_matrix = h,
                        I.u_merc_center = d,
                        I.u_tile_id = [t.canonical.x, t.canonical.y, 1 << t.canonical.z],
                        I.u_zoom_transition = s.ae(M.zoom);
                        const R = d[0] * s.ag
                          , D = d[1] * s.ag;
                        I.u_up_dir = M.projection.upVector(new s.bT(0,0,0), R, D)
                    }
                    return I
                }
                ;
                function Je(c, [t,i,h,d], [m,y]) {
                    if (m === y)
                        return [0, 0, 0, 0];
                    const M = 255 * (c - 1) / (c * (y - m));
                    return [t * M, i * M, h * M, d * M]
                }
                function Fe(c, t, [i,h]) {
                    return i === h ? 0 : .5 / c + (t - i) * (c - 1) / (c * (h - i))
                }
                const It = (c, t, i, h, d, m, y, M, E, S, I, R, D, k, H, j, Y, K, he, Te, be) => ({
                    u_matrix: c,
                    u_normalize_matrix: t,
                    u_globe_matrix: i,
                    u_merc_matrix: h,
                    u_grid_matrix: d,
                    u_tl_parent: m,
                    u_scale_parent: S,
                    u_fade_t: I.mix,
                    u_opacity: I.opacity * R.paint.get("raster-opacity"),
                    u_image0: 0,
                    u_image1: 1,
                    u_brightness_low: R.paint.get("raster-brightness-min"),
                    u_brightness_high: R.paint.get("raster-brightness-max"),
                    u_saturation_factor: s.cO(R.paint.get("raster-saturation")),
                    u_contrast_factor: s.cP(R.paint.get("raster-contrast")),
                    u_spin_weights: go(R.paint.get("raster-hue-rotate")),
                    u_perspective_transform: D,
                    u_raster_elevation: k,
                    u_zoom_transition: y,
                    u_merc_center: M,
                    u_cutoff_params: E,
                    u_colorization_mix: Je(s.cQ, j, K),
                    u_colorization_offset: Fe(s.cQ, Y, K),
                    u_color_ramp: H,
                    u_texture_offset: [Te / (he + 2 * Te), he / (he + 2 * Te)],
                    u_texture_res: [he + 2 * Te, he + 2 * Te],
                    u_emissive_strength: be
                });
                function go(c) {
                    c *= Math.PI / 180;
                    const t = Math.sin(c)
                      , i = Math.cos(c);
                    return [(2 * i + 1) / 3, (-Math.sqrt(3) * t - i + 1) / 3, (Math.sqrt(3) * t - i + 1) / 3]
                }
                const yo = .05
                  , Io = (c, t, i, h, d, m, y, M, E, S, I, R) => ({
                    u_matrix: c,
                    u_normalize_matrix: t,
                    u_globe_matrix: i,
                    u_merc_matrix: h,
                    u_grid_matrix: d,
                    u_tl_parent: m,
                    u_scale_parent: S,
                    u_fade_t: I.mix,
                    u_opacity: I.opacity,
                    u_image0: 0,
                    u_image1: 1,
                    u_raster_elevation: R,
                    u_zoom_transition: y,
                    u_merc_center: M,
                    u_cutoff_params: E
                })
                  , kt = (c, t, i, h, d, m, y, M, E, S) => ({
                    u_particle_texture: c,
                    u_particle_texture_side_len: t,
                    u_tile_offset: i,
                    u_velocity: h,
                    u_color_ramp: m,
                    u_velocity_res: d,
                    u_max_speed: y,
                    u_uv_offset: M,
                    u_data_scale: [255 * E[0], 255 * E[1]],
                    u_data_offset: S,
                    u_particle_pos_scale: 1.1,
                    u_particle_pos_offset: [yo, yo]
                })
                  , Wo = (c, t, i, h, d, m, y, M, E, S) => ({
                    u_particle_texture: c,
                    u_particle_texture_side_len: t,
                    u_velocity: i,
                    u_velocity_res: h,
                    u_max_speed: d,
                    u_speed_factor: m,
                    u_reset_rate: y,
                    u_rand_seed: Math.random(),
                    u_uv_offset: M,
                    u_data_scale: [255 * E[0], 255 * E[1]],
                    u_data_offset: S,
                    u_particle_pos_scale: 1.1,
                    u_particle_pos_offset: [yo, yo]
                })
                  , ti = s.ab.mat4.create()
                  , Bi = (c, t, i, h, d, m, y, M, E, S, I, R, D, k, H, j, Y, K, he, Te, be, Ue) => {
                    const De = d.transform
                      , ke = {
                        u_is_size_zoom_constant: +("constant" === c || "source" === c),
                        u_is_size_feature_constant: +("constant" === c || "camera" === c),
                        u_size_t: t ? t.uSizeT : 0,
                        u_size: t ? t.uSize : 0,
                        u_camera_to_center_distance: De.getCameraToCenterDistance(he),
                        u_rotate_symbol: +i,
                        u_aspect_ratio: De.width / De.height,
                        u_fade_change: d.options.fadeDuration ? d.symbolFadeChange : 1,
                        u_matrix: m,
                        u_label_plane_matrix: y,
                        u_coord_matrix: M,
                        u_is_text: +S,
                        u_elevation_from_sea: E ? 1 : 0,
                        u_pitch_with_map: +h,
                        u_texsize: I,
                        u_texsize_icon: R,
                        u_texture: 0,
                        u_texture_icon: 1,
                        u_tile_id: [0, 0, 0],
                        u_zoom_transition: 0,
                        u_inv_rot_matrix: ti,
                        u_merc_center: [0, 0],
                        u_camera_forward: [0, 0, 0],
                        u_ecef_origin: [0, 0, 0],
                        u_tile_matrix: ti,
                        u_up_vector: [0, -1, 0],
                        u_color_adj_mat: Te,
                        u_icon_transition: be || 0,
                        u_gamma_scale: h ? d.transform.getCameraToCenterDistance(he) * Math.cos(d.terrain ? 0 : d.transform._pitch) : 1,
                        u_device_pixel_ratio: s.q.devicePixelRatio,
                        u_is_halo: +D,
                        u_scale_factor: Ue || 1
                    };
                    return "globe" === he.name && (ke.u_tile_id = [k.canonical.x, k.canonical.y, 1 << k.canonical.z],
                    ke.u_zoom_transition = H,
                    ke.u_inv_rot_matrix = Y,
                    ke.u_merc_center = j,
                    ke.u_camera_forward = De._camera.forward(),
                    ke.u_ecef_origin = s.cR(De.globeMatrix, k.toUnwrapped()),
                    ke.u_tile_matrix = Float32Array.from(De.globeMatrix),
                    ke.u_up_vector = K),
                    ke
                }
                  , ai = (c, t, i, h) => ({
                    u_matrix: c,
                    u_emissive_strength: t,
                    u_opacity: i,
                    u_color: h
                })
                  , oi = (c, t, i, h, d, m, y, M, E) => s.l(function(S, I, R, D, k, H) {
                    const {width: j, height: Y} = D.imageManager.getPixelSize(I)
                      , K = Math.pow(2, H.tileID.overscaledZ)
                      , he = H.tileSize * Math.pow(2, D.transform.tileZoom) / K
                      , Te = he * (H.tileID.canonical.x + H.tileID.wrap * K)
                      , be = he * H.tileID.canonical.y;
                    return {
                        u_image: 0,
                        u_pattern_tl: R.tl,
                        u_pattern_br: R.br,
                        u_texsize: [j, Y],
                        u_pattern_size: R.displaySize,
                        u_pattern_units_to_pixels: k ? [D.transform.width, -1 * D.transform.height] : [1 / s.ar(H, 1, D.transform.tileZoom), 1 / s.ar(H, 1, D.transform.tileZoom)],
                        u_pixel_coord_upper: [Te >> 16, be >> 16],
                        u_pixel_coord_lower: [65535 & Te, 65535 & be]
                    }
                }(0, m, y, h, M, E), {
                    u_matrix: c,
                    u_emissive_strength: t,
                    u_opacity: i
                })
                  , rn = new Float32Array(s.ab.mat4.identity([]))
                  , Pn = (c, t, i, h, d, m, y, M, E, S, I, R, D, k=[0, 0, 0], H) => {
                    const j = d.style.light
                      , Y = j.properties.get("position")
                      , K = [-Y.x, -Y.y, Y.z]
                      , he = s.ab.mat3.create();
                    "viewport" === j.properties.get("anchor") && (s.ab.mat3.fromRotation(he, -d.transform.angle),
                    s.ab.vec3.transformMat3(K, K, he));
                    const Te = "MASK" === I.alphaMode
                      , be = j.properties.get("color").toRenderColor(null)
                      , Ue = D.paint.get("model-ambient-occlusion-intensity")
                      , De = D.paint.get("model-color").constantOr(s.aj.white).toRenderColor(null)
                      , ke = D.paint.get("model-color-mix-intensity").constantOr(0);
                    return {
                        u_matrix: c,
                        u_lighting_matrix: t,
                        u_normal_matrix: i,
                        u_node_matrix: h || rn,
                        u_lightpos: K,
                        u_lightintensity: j.properties.get("intensity"),
                        u_lightcolor: [be.r, be.g, be.b],
                        u_camera_pos: k,
                        u_opacity: m,
                        u_baseTextureIsAlpha: 0,
                        u_alphaMask: +Te,
                        u_alphaCutoff: I.alphaCutoff,
                        u_baseColorFactor: [y.r, y.g, y.b, y.a],
                        u_emissiveFactor: [M[0], M[1], M[2], 1],
                        u_metallicFactor: E,
                        u_roughnessFactor: S,
                        u_baseColorTexture: wn_BaseColor,
                        u_metallicRoughnessTexture: wn_MetallicRoughness,
                        u_normalTexture: wn_Normal,
                        u_occlusionTexture: wn_Occlusion,
                        u_emissionTexture: wn_Emission,
                        u_lutTexture: wn_LUT,
                        u_color_mix: [De.r, De.g, De.b, ke],
                        u_aoIntensity: Ue,
                        u_emissive_strength: R,
                        u_occlusionTextureTransform: H || [0, 0, 0, 0]
                    }
                }
                  , _n = (c, t=rn, i=rn) => ({
                    u_matrix: c,
                    u_instance: t,
                    u_node_matrix: i
                })
                  , Bn = {
                    fillExtrusion: c => ({
                        u_matrix: new s.bJ(c),
                        u_lightpos: new s.bL(c),
                        u_lightintensity: new s.bM(c),
                        u_lightcolor: new s.bL(c),
                        u_vertical_gradient: new s.bM(c),
                        u_opacity: new s.bM(c),
                        u_edge_radius: new s.bM(c),
                        u_width_scale: new s.bM(c),
                        u_ao: new s.bK(c),
                        u_height_type: new s.bN(c),
                        u_base_type: new s.bN(c),
                        u_tile_id: new s.bL(c),
                        u_zoom_transition: new s.bM(c),
                        u_inv_rot_matrix: new s.bJ(c),
                        u_merc_center: new s.bK(c),
                        u_up_dir: new s.bL(c),
                        u_height_lift: new s.bM(c),
                        u_flood_light_color: new s.bL(c),
                        u_vertical_scale: new s.bM(c),
                        u_flood_light_intensity: new s.bM(c),
                        u_ground_shadow_factor: new s.bL(c)
                    }),
                    fillExtrusionDepth: c => ({
                        u_matrix: new s.bJ(c),
                        u_edge_radius: new s.bM(c),
                        u_width_scale: new s.bM(c),
                        u_vertical_scale: new s.bM(c),
                        u_height_type: new s.bN(c),
                        u_base_type: new s.bN(c)
                    }),
                    fillExtrusionPattern: c => ({
                        u_matrix: new s.bJ(c),
                        u_lightpos: new s.bL(c),
                        u_lightintensity: new s.bM(c),
                        u_lightcolor: new s.bL(c),
                        u_vertical_gradient: new s.bM(c),
                        u_height_factor: new s.bM(c),
                        u_edge_radius: new s.bM(c),
                        u_width_scale: new s.bM(c),
                        u_ao: new s.bK(c),
                        u_height_type: new s.bN(c),
                        u_base_type: new s.bN(c),
                        u_tile_id: new s.bL(c),
                        u_zoom_transition: new s.bM(c),
                        u_inv_rot_matrix: new s.bJ(c),
                        u_merc_center: new s.bK(c),
                        u_up_dir: new s.bL(c),
                        u_height_lift: new s.bM(c),
                        u_image: new s.bN(c),
                        u_texsize: new s.bK(c),
                        u_pixel_coord_upper: new s.bK(c),
                        u_pixel_coord_lower: new s.bK(c),
                        u_tile_units_to_pixels: new s.bM(c),
                        u_opacity: new s.bM(c)
                    }),
                    fillExtrusionGroundEffect: c => ({
                        u_matrix: new s.bJ(c),
                        u_opacity: new s.bM(c),
                        u_ao_pass: new s.bM(c),
                        u_meter_to_tile: new s.bM(c),
                        u_ao: new s.bK(c),
                        u_flood_light_intensity: new s.bM(c),
                        u_flood_light_color: new s.bL(c),
                        u_attenuation: new s.bM(c),
                        u_edge_radius: new s.bM(c),
                        u_fb: new s.bN(c),
                        u_fb_size: new s.bM(c),
                        u_dynamic_offset: new s.bM(c)
                    }),
                    fill: c => ({
                        u_matrix: new s.bJ(c),
                        u_emissive_strength: new s.bM(c)
                    }),
                    fillPattern: c => ({
                        u_matrix: new s.bJ(c),
                        u_emissive_strength: new s.bM(c),
                        u_image: new s.bN(c),
                        u_texsize: new s.bK(c),
                        u_pixel_coord_upper: new s.bK(c),
                        u_pixel_coord_lower: new s.bK(c),
                        u_tile_units_to_pixels: new s.bM(c)
                    }),
                    fillOutline: c => ({
                        u_matrix: new s.bJ(c),
                        u_emissive_strength: new s.bM(c),
                        u_world: new s.bK(c)
                    }),
                    fillOutlinePattern: c => ({
                        u_matrix: new s.bJ(c),
                        u_emissive_strength: new s.bM(c),
                        u_world: new s.bK(c),
                        u_image: new s.bN(c),
                        u_texsize: new s.bK(c),
                        u_pixel_coord_upper: new s.bK(c),
                        u_pixel_coord_lower: new s.bK(c),
                        u_tile_units_to_pixels: new s.bM(c)
                    }),
                    circle: s.cS,
                    collisionBox: c => ({
                        u_matrix: new s.bJ(c),
                        u_camera_to_center_distance: new s.bM(c),
                        u_extrude_scale: new s.bK(c)
                    }),
                    collisionCircle: c => ({
                        u_matrix: new s.bJ(c),
                        u_inv_matrix: new s.bJ(c),
                        u_camera_to_center_distance: new s.bM(c),
                        u_viewport_size: new s.bK(c)
                    }),
                    debug: c => ({
                        u_color: new s.cz(c),
                        u_matrix: new s.bJ(c),
                        u_overlay: new s.bN(c),
                        u_overlay_scale: new s.bM(c)
                    }),
                    clippingMask: c => ({
                        u_matrix: new s.bJ(c)
                    }),
                    heatmap: c => ({
                        u_extrude_scale: new s.bM(c),
                        u_intensity: new s.bM(c),
                        u_matrix: new s.bJ(c),
                        u_inv_rot_matrix: new s.bJ(c),
                        u_merc_center: new s.bK(c),
                        u_tile_id: new s.bL(c),
                        u_zoom_transition: new s.bM(c),
                        u_up_dir: new s.bL(c)
                    }),
                    heatmapTexture: c => ({
                        u_image: new s.bN(c),
                        u_color_ramp: new s.bN(c),
                        u_opacity: new s.bM(c)
                    }),
                    hillshade: c => ({
                        u_matrix: new s.bJ(c),
                        u_image: new s.bN(c),
                        u_latrange: new s.bK(c),
                        u_light: new s.bK(c),
                        u_shadow: new s.cz(c),
                        u_highlight: new s.cz(c),
                        u_emissive_strength: new s.bM(c),
                        u_accent: new s.cz(c)
                    }),
                    hillshadePrepare: c => ({
                        u_matrix: new s.bJ(c),
                        u_image: new s.bN(c),
                        u_dimension: new s.bK(c),
                        u_zoom: new s.bM(c)
                    }),
                    line: s.cT,
                    linePattern: s.cU,
                    raster: c => ({
                        u_matrix: new s.bJ(c),
                        u_normalize_matrix: new s.bJ(c),
                        u_globe_matrix: new s.bJ(c),
                        u_merc_matrix: new s.bJ(c),
                        u_grid_matrix: new s.cA(c),
                        u_tl_parent: new s.bK(c),
                        u_scale_parent: new s.bM(c),
                        u_fade_t: new s.bM(c),
                        u_opacity: new s.bM(c),
                        u_image0: new s.bN(c),
                        u_image1: new s.bN(c),
                        u_brightness_low: new s.bM(c),
                        u_brightness_high: new s.bM(c),
                        u_saturation_factor: new s.bM(c),
                        u_contrast_factor: new s.bM(c),
                        u_spin_weights: new s.bL(c),
                        u_perspective_transform: new s.bK(c),
                        u_raster_elevation: new s.bM(c),
                        u_zoom_transition: new s.bM(c),
                        u_merc_center: new s.bK(c),
                        u_cutoff_params: new s.ca(c),
                        u_colorization_mix: new s.ca(c),
                        u_colorization_offset: new s.bM(c),
                        u_color_ramp: new s.bN(c),
                        u_texture_offset: new s.bK(c),
                        u_texture_res: new s.bK(c),
                        u_emissive_strength: new s.bM(c)
                    }),
                    rasterParticle: c => ({
                        u_matrix: new s.bJ(c),
                        u_normalize_matrix: new s.bJ(c),
                        u_globe_matrix: new s.bJ(c),
                        u_merc_matrix: new s.bJ(c),
                        u_grid_matrix: new s.cA(c),
                        u_tl_parent: new s.bK(c),
                        u_scale_parent: new s.bM(c),
                        u_fade_t: new s.bM(c),
                        u_opacity: new s.bM(c),
                        u_image0: new s.bN(c),
                        u_image1: new s.bN(c),
                        u_raster_elevation: new s.bM(c),
                        u_zoom_transition: new s.bM(c),
                        u_merc_center: new s.bK(c),
                        u_cutoff_params: new s.ca(c)
                    }),
                    rasterParticleTexture: c => ({
                        u_texture: new s.bN(c),
                        u_opacity: new s.bM(c)
                    }),
                    rasterParticleDraw: c => ({
                        u_particle_texture: new s.bN(c),
                        u_particle_texture_side_len: new s.bM(c),
                        u_tile_offset: new s.bK(c),
                        u_velocity: new s.bN(c),
                        u_color_ramp: new s.bN(c),
                        u_velocity_res: new s.bK(c),
                        u_max_speed: new s.bM(c),
                        u_uv_offset: new s.bK(c),
                        u_data_scale: new s.bK(c),
                        u_data_offset: new s.bM(c),
                        u_particle_pos_scale: new s.bM(c),
                        u_particle_pos_offset: new s.bK(c)
                    }),
                    rasterParticleUpdate: c => ({
                        u_particle_texture: new s.bN(c),
                        u_particle_texture_side_len: new s.bM(c),
                        u_velocity: new s.bN(c),
                        u_velocity_res: new s.bK(c),
                        u_max_speed: new s.bM(c),
                        u_speed_factor: new s.bM(c),
                        u_reset_rate: new s.bM(c),
                        u_rand_seed: new s.bM(c),
                        u_uv_offset: new s.bK(c),
                        u_data_scale: new s.bK(c),
                        u_data_offset: new s.bM(c),
                        u_particle_pos_scale: new s.bM(c),
                        u_particle_pos_offset: new s.bK(c)
                    }),
                    symbol: c => ({
                        u_is_size_zoom_constant: new s.bN(c),
                        u_is_size_feature_constant: new s.bN(c),
                        u_size_t: new s.bM(c),
                        u_size: new s.bM(c),
                        u_camera_to_center_distance: new s.bM(c),
                        u_rotate_symbol: new s.bN(c),
                        u_aspect_ratio: new s.bM(c),
                        u_fade_change: new s.bM(c),
                        u_matrix: new s.bJ(c),
                        u_label_plane_matrix: new s.bJ(c),
                        u_coord_matrix: new s.bJ(c),
                        u_is_text: new s.bN(c),
                        u_elevation_from_sea: new s.bN(c),
                        u_pitch_with_map: new s.bN(c),
                        u_texsize: new s.bK(c),
                        u_texsize_icon: new s.bK(c),
                        u_texture: new s.bN(c),
                        u_texture_icon: new s.bN(c),
                        u_gamma_scale: new s.bM(c),
                        u_device_pixel_ratio: new s.bM(c),
                        u_tile_id: new s.bL(c),
                        u_zoom_transition: new s.bM(c),
                        u_inv_rot_matrix: new s.bJ(c),
                        u_merc_center: new s.bK(c),
                        u_camera_forward: new s.bL(c),
                        u_tile_matrix: new s.bJ(c),
                        u_up_vector: new s.bL(c),
                        u_ecef_origin: new s.bL(c),
                        u_is_halo: new s.bN(c),
                        u_icon_transition: new s.bM(c),
                        u_color_adj_mat: new s.bJ(c),
                        u_scale_factor: new s.bM(c)
                    }),
                    background: c => ({
                        u_matrix: new s.bJ(c),
                        u_emissive_strength: new s.bM(c),
                        u_opacity: new s.bM(c),
                        u_color: new s.cz(c)
                    }),
                    backgroundPattern: c => ({
                        u_matrix: new s.bJ(c),
                        u_emissive_strength: new s.bM(c),
                        u_opacity: new s.bM(c),
                        u_image: new s.bN(c),
                        u_pattern_tl: new s.bK(c),
                        u_pattern_br: new s.bK(c),
                        u_texsize: new s.bK(c),
                        u_pattern_size: new s.bK(c),
                        u_pixel_coord_upper: new s.bK(c),
                        u_pixel_coord_lower: new s.bK(c),
                        u_pattern_units_to_pixels: new s.bK(c)
                    }),
                    terrainRaster: c => ({
                        u_matrix: new s.bJ(c),
                        u_image0: new s.bN(c),
                        u_skirt_height: new s.bM(c),
                        u_ground_shadow_factor: new s.bL(c)
                    }),
                    skybox: c => ({
                        u_matrix: new s.bJ(c),
                        u_sun_direction: new s.bL(c),
                        u_cubemap: new s.bN(c),
                        u_opacity: new s.bM(c),
                        u_temporal_offset: new s.bM(c)
                    }),
                    skyboxGradient: c => ({
                        u_matrix: new s.bJ(c),
                        u_color_ramp: new s.bN(c),
                        u_center_direction: new s.bL(c),
                        u_radius: new s.bM(c),
                        u_opacity: new s.bM(c),
                        u_temporal_offset: new s.bM(c)
                    }),
                    skyboxCapture: c => ({
                        u_matrix_3f: new s.cA(c),
                        u_sun_direction: new s.bL(c),
                        u_sun_intensity: new s.bM(c),
                        u_color_tint_r: new s.ca(c),
                        u_color_tint_m: new s.ca(c),
                        u_luminance: new s.bM(c)
                    }),
                    globeRaster: c => ({
                        u_proj_matrix: new s.bJ(c),
                        u_globe_matrix: new s.bJ(c),
                        u_normalize_matrix: new s.bJ(c),
                        u_merc_matrix: new s.bJ(c),
                        u_zoom_transition: new s.bM(c),
                        u_merc_center: new s.bK(c),
                        u_image0: new s.bN(c),
                        u_grid_matrix: new s.cA(c),
                        u_skirt_height: new s.bM(c),
                        u_far_z_cutoff: new s.bM(c),
                        u_frustum_tl: new s.bL(c),
                        u_frustum_tr: new s.bL(c),
                        u_frustum_br: new s.bL(c),
                        u_frustum_bl: new s.bL(c),
                        u_globe_pos: new s.bL(c),
                        u_globe_radius: new s.bM(c),
                        u_viewport: new s.bK(c)
                    }),
                    globeAtmosphere: c => ({
                        u_frustum_tl: new s.bL(c),
                        u_frustum_tr: new s.bL(c),
                        u_frustum_br: new s.bL(c),
                        u_frustum_bl: new s.bL(c),
                        u_horizon: new s.bM(c),
                        u_transition: new s.bM(c),
                        u_fadeout_range: new s.bM(c),
                        u_color: new s.ca(c),
                        u_high_color: new s.ca(c),
                        u_space_color: new s.ca(c),
                        u_temporal_offset: new s.bM(c),
                        u_horizon_angle: new s.bM(c)
                    }),
                    model: c => ({
                        u_matrix: new s.bJ(c),
                        u_lighting_matrix: new s.bJ(c),
                        u_normal_matrix: new s.bJ(c),
                        u_node_matrix: new s.bJ(c),
                        u_lightpos: new s.bL(c),
                        u_lightintensity: new s.bM(c),
                        u_lightcolor: new s.bL(c),
                        u_camera_pos: new s.bL(c),
                        u_opacity: new s.bM(c),
                        u_baseColorFactor: new s.ca(c),
                        u_emissiveFactor: new s.ca(c),
                        u_metallicFactor: new s.bM(c),
                        u_roughnessFactor: new s.bM(c),
                        u_baseTextureIsAlpha: new s.bN(c),
                        u_alphaMask: new s.bN(c),
                        u_alphaCutoff: new s.bM(c),
                        u_baseColorTexture: new s.bN(c),
                        u_metallicRoughnessTexture: new s.bN(c),
                        u_normalTexture: new s.bN(c),
                        u_occlusionTexture: new s.bN(c),
                        u_emissionTexture: new s.bN(c),
                        u_lutTexture: new s.bN(c),
                        u_color_mix: new s.ca(c),
                        u_aoIntensity: new s.bM(c),
                        u_emissive_strength: new s.bM(c),
                        u_occlusionTextureTransform: new s.ca(c)
                    }),
                    modelDepth: c => ({
                        u_matrix: new s.bJ(c),
                        u_instance: new s.bJ(c),
                        u_node_matrix: new s.bJ(c)
                    }),
                    groundShadow: c => ({
                        u_matrix: new s.bJ(c),
                        u_ground_shadow_factor: new s.bL(c)
                    }),
                    stars: c => ({
                        u_matrix: new s.bJ(c),
                        u_up: new s.bL(c),
                        u_right: new s.bL(c),
                        u_intensity_multiplier: new s.bM(c)
                    }),
                    snowParticle: c => ({
                        u_modelview: new s.bJ(c),
                        u_projection: new s.bJ(c),
                        u_time: new s.bM(c),
                        u_cam_pos: new s.bL(c),
                        u_velocityConeAperture: new s.bM(c),
                        u_velocity: new s.bM(c),
                        u_horizontalOscillationRadius: new s.bM(c),
                        u_horizontalOscillationRate: new s.bM(c),
                        u_boxSize: new s.bM(c),
                        u_billboardSize: new s.bM(c),
                        u_simpleShapeParameters: new s.bK(c),
                        u_screenSize: new s.bK(c),
                        u_thinningCenterPos: new s.bK(c),
                        u_thinningShape: new s.bL(c),
                        u_thinningAffectedRatio: new s.bM(c),
                        u_thinningParticleOffset: new s.bM(c),
                        u_particleColor: new s.ca(c),
                        u_direction: new s.bL(c)
                    }),
                    rainParticle: c => ({
                        u_modelview: new s.bJ(c),
                        u_projection: new s.bJ(c),
                        u_time: new s.bM(c),
                        u_cam_pos: new s.bL(c),
                        u_texScreen: new s.bN(c),
                        u_velocityConeAperture: new s.bM(c),
                        u_velocity: new s.bM(c),
                        u_boxSize: new s.bM(c),
                        u_rainDropletSize: new s.bK(c),
                        u_distortionStrength: new s.bM(c),
                        u_rainDirection: new s.bL(c),
                        u_color: new s.ca(c),
                        u_screenSize: new s.bK(c),
                        u_thinningCenterPos: new s.bK(c),
                        u_thinningShape: new s.bL(c),
                        u_thinningAffectedRatio: new s.bM(c),
                        u_thinningParticleOffset: new s.bM(c),
                        u_shapeDirectionalPower: new s.bM(c),
                        u_shapeNormalPower: new s.bM(c),
                        u_mode: new s.bM(c)
                    }),
                    vignette: c => ({
                        u_vignetteShape: new s.bL(c),
                        u_vignetteColor: new s.ca(c)
                    }),
                    occlusion: c => ({
                        u_matrix: new s.bJ(c),
                        u_anchorPos: new s.bL(c),
                        u_screenSizePx: new s.bK(c),
                        u_occluderSizePx: new s.bK(c),
                        u_color: new s.ca(c)
                    })
                };
                let Oi = ( () => {
                    class c {
                        constructor(i, h, d, m) {
                            this.id = c.uniqueIdxCounter,
                            c.uniqueIdxCounter++,
                            this.context = i;
                            const y = i.gl;
                            this.buffer = y.createBuffer(),
                            this.dynamicDraw = !!d,
                            this.context.unbindVAO(),
                            i.bindElementBuffer.set(this.buffer),
                            y.bufferData(y.ELEMENT_ARRAY_BUFFER, h.arrayBuffer, this.dynamicDraw ? y.DYNAMIC_DRAW : y.STATIC_DRAW),
                            this.dynamicDraw || m || h.destroy()
                        }
                        bind() {
                            this.context.bindElementBuffer.set(this.buffer)
                        }
                        updateData(i) {
                            this.id = c.uniqueIdxCounter,
                            c.uniqueIdxCounter++;
                            const h = this.context.gl;
                            this.context.unbindVAO(),
                            this.bind(),
                            h.bufferSubData(h.ELEMENT_ARRAY_BUFFER, 0, i.arrayBuffer)
                        }
                        destroy() {
                            this.buffer && (this.context.gl.deleteBuffer(this.buffer),
                            delete this.buffer)
                        }
                    }
                    return c.uniqueIdxCounter = 0,
                    c
                }
                )();
                const Oo = {
                    Int8: "BYTE",
                    Uint8: "UNSIGNED_BYTE",
                    Int16: "SHORT",
                    Uint16: "UNSIGNED_SHORT",
                    Int32: "INT",
                    Uint32: "UNSIGNED_INT",
                    Float32: "FLOAT"
                };
                class ui {
                    constructor(t, i, h, d, m, y) {
                        this.length = i.length,
                        this.attributes = h,
                        this.itemSize = i.bytesPerElement,
                        this.dynamicDraw = d,
                        this.instanceCount = y,
                        this.context = t;
                        const M = t.gl;
                        this.buffer = M.createBuffer(),
                        t.bindVertexBuffer.set(this.buffer),
                        M.bufferData(M.ARRAY_BUFFER, i.arrayBuffer, this.dynamicDraw ? M.DYNAMIC_DRAW : M.STATIC_DRAW),
                        this.dynamicDraw || m || i.destroy()
                    }
                    bind() {
                        this.context.bindVertexBuffer.set(this.buffer)
                    }
                    updateData(t) {
                        const i = this.context.gl;
                        this.bind(),
                        i.bufferSubData(i.ARRAY_BUFFER, 0, t.arrayBuffer)
                    }
                    enableAttributes(t, i) {
                        for (let h = 0; h < this.attributes.length; h++) {
                            const d = i.attributes[this.attributes[h].name];
                            void 0 !== d && t.enableVertexAttribArray(d)
                        }
                    }
                    setVertexAttribPointers(t, i, h) {
                        for (let d = 0; d < this.attributes.length; d++) {
                            const m = this.attributes[d]
                              , y = i.attributes[m.name];
                            void 0 !== y && t.vertexAttribPointer(y, m.components, t[Oo[m.type]], !1, this.itemSize, m.offset + this.itemSize * (h || 0))
                        }
                    }
                    setVertexAttribDivisor(t, i, h) {
                        for (let d = 0; d < this.attributes.length; d++) {
                            const m = i.attributes[this.attributes[d].name];
                            void 0 !== m && this.instanceCount && this.instanceCount > 0 && t.vertexAttribDivisor(m, h)
                        }
                    }
                    destroy() {
                        this.buffer && (this.context.gl.deleteBuffer(this.buffer),
                        delete this.buffer)
                    }
                }
                class hi {
                    constructor(t, i, h, d, m) {
                        this.context = t,
                        this.width = i,
                        this.height = h;
                        const y = this.framebuffer = t.gl.createFramebuffer();
                        d && (this.colorAttachment = new hc(t,y)),
                        m && (this.depthAttachmentType = m,
                        this.depthAttachment = "renderbuffer" === m ? new uc(t,y) : new ra(t,y))
                    }
                    destroy() {
                        const t = this.context.gl;
                        if (this.colorAttachment) {
                            const i = this.colorAttachment.get();
                            i && t.deleteTexture(i)
                        }
                        if (this.depthAttachment && this.depthAttachmentType)
                            if ("renderbuffer" === this.depthAttachmentType) {
                                const i = this.depthAttachment.get();
                                i && t.deleteRenderbuffer(i)
                            } else {
                                const i = this.depthAttachment.get();
                                i && t.deleteTexture(i)
                            }
                        t.deleteFramebuffer(this.framebuffer)
                    }
                }
                class pi {
                    constructor(t, i) {
                        this.gl = t,
                        this.clearColor = new sh(this),
                        this.clearDepth = new ah(this),
                        this.clearStencil = new fs(this),
                        this.colorMask = new xn(this),
                        this.depthMask = new $n(this),
                        this.stencilMask = new hl(this),
                        this.stencilFunc = new ic(this),
                        this.stencilOp = new lh(this),
                        this.stencilTest = new hu(this),
                        this.depthRange = new Aa(this),
                        this.depthTest = new _s(this),
                        this.depthFunc = new uu(this),
                        this.blend = new Jn(this),
                        this.blendFunc = new nc(this),
                        this.blendColor = new rc(this),
                        this.blendEquation = new ul(this),
                        this.cullFace = new Oa(this),
                        this.cullFaceSide = new ch(this),
                        this.frontFace = new sc(this),
                        this.program = new ac(this),
                        this.activeTexture = new lc(this),
                        this.viewport = new pl(this),
                        this.bindFramebuffer = new dl(this),
                        this.bindRenderbuffer = new hh(this),
                        this.bindTexture = new na(this),
                        this.bindVertexBuffer = new cc(this),
                        this.bindElementBuffer = new pu(this),
                        this.bindVertexArrayOES = new du(this),
                        this.pixelStoreUnpack = new mu(this),
                        this.pixelStoreUnpackPremultiplyAlpha = new uh(this),
                        this.pixelStoreUnpackFlipY = new fu(this),
                        this.options = i ? {
                            ...i
                        } : {},
                        this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),
                        this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))),
                        this.extDebugRendererInfo = t.getExtension("WEBGL_debug_renderer_info"),
                        this.extDebugRendererInfo && (this.renderer = t.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL),
                        this.vendor = t.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)),
                        this.forceManualRenderingForInstanceIDShaders = i && !!i.forceManualRenderingForInstanceIDShaders || this.renderer && -1 !== this.renderer.indexOf("PowerVR"),
                        this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = t.getExtension("OES_texture_float_linear")),
                        this.extRenderToTextureHalfFloat = t.getExtension("EXT_color_buffer_half_float"),
                        this.extTimerQuery = t.getExtension("EXT_disjoint_timer_query_webgl2"),
                        this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE),
                        this.maxPointSize = t.getParameter(t.ALIASED_POINT_SIZE_RANGE)[1]
                    }
                    setDefault() {
                        this.unbindVAO(),
                        this.clearColor.setDefault(),
                        this.clearDepth.setDefault(),
                        this.clearStencil.setDefault(),
                        this.colorMask.setDefault(),
                        this.depthMask.setDefault(),
                        this.stencilMask.setDefault(),
                        this.stencilFunc.setDefault(),
                        this.stencilOp.setDefault(),
                        this.stencilTest.setDefault(),
                        this.depthRange.setDefault(),
                        this.depthTest.setDefault(),
                        this.depthFunc.setDefault(),
                        this.blend.setDefault(),
                        this.blendFunc.setDefault(),
                        this.blendColor.setDefault(),
                        this.blendEquation.setDefault(),
                        this.cullFace.setDefault(),
                        this.cullFaceSide.setDefault(),
                        this.frontFace.setDefault(),
                        this.program.setDefault(),
                        this.activeTexture.setDefault(),
                        this.bindFramebuffer.setDefault(),
                        this.pixelStoreUnpack.setDefault(),
                        this.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                        this.pixelStoreUnpackFlipY.setDefault()
                    }
                    setDirty() {
                        this.clearColor.dirty = !0,
                        this.clearDepth.dirty = !0,
                        this.clearStencil.dirty = !0,
                        this.colorMask.dirty = !0,
                        this.depthMask.dirty = !0,
                        this.stencilMask.dirty = !0,
                        this.stencilFunc.dirty = !0,
                        this.stencilOp.dirty = !0,
                        this.stencilTest.dirty = !0,
                        this.depthRange.dirty = !0,
                        this.depthTest.dirty = !0,
                        this.depthFunc.dirty = !0,
                        this.blend.dirty = !0,
                        this.blendFunc.dirty = !0,
                        this.blendColor.dirty = !0,
                        this.blendEquation.dirty = !0,
                        this.cullFace.dirty = !0,
                        this.cullFaceSide.dirty = !0,
                        this.frontFace.dirty = !0,
                        this.program.dirty = !0,
                        this.activeTexture.dirty = !0,
                        this.viewport.dirty = !0,
                        this.bindFramebuffer.dirty = !0,
                        this.bindRenderbuffer.dirty = !0,
                        this.bindTexture.dirty = !0,
                        this.bindVertexBuffer.dirty = !0,
                        this.bindElementBuffer.dirty = !0,
                        this.bindVertexArrayOES.dirty = !0,
                        this.pixelStoreUnpack.dirty = !0,
                        this.pixelStoreUnpackPremultiplyAlpha.dirty = !0,
                        this.pixelStoreUnpackFlipY.dirty = !0
                    }
                    createIndexBuffer(t, i, h) {
                        return new Oi(this,t,i,h)
                    }
                    createVertexBuffer(t, i, h, d, m) {
                        return new ui(this,t,i,h,d,m)
                    }
                    createRenderbuffer(t, i, h) {
                        const d = this.gl
                          , m = d.createRenderbuffer();
                        return this.bindRenderbuffer.set(m),
                        d.renderbufferStorage(d.RENDERBUFFER, t, i, h),
                        this.bindRenderbuffer.set(null),
                        m
                    }
                    createFramebuffer(t, i, h, d) {
                        return new hi(this,t,i,h,d)
                    }
                    clear({color: t, depth: i, stencil: h, colorMask: d}) {
                        const m = this.gl;
                        let y = 0;
                        t && (y |= m.COLOR_BUFFER_BIT,
                        this.clearColor.set(t),
                        this.colorMask.set(d || [!0, !0, !0, !0])),
                        void 0 !== i && (y |= m.DEPTH_BUFFER_BIT,
                        this.depthRange.set([0, 1]),
                        this.clearDepth.set(i),
                        this.depthMask.set(!0)),
                        void 0 !== h && (y |= m.STENCIL_BUFFER_BIT,
                        this.clearStencil.set(h),
                        this.stencilMask.set(255)),
                        m.clear(y)
                    }
                    setCullFace(t) {
                        !1 === t.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0),
                        this.cullFaceSide.set(t.mode),
                        this.frontFace.set(t.frontFace))
                    }
                    setDepthMode(t) {
                        t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0),
                        this.depthFunc.set(t.func),
                        this.depthMask.set(t.mask),
                        this.depthRange.set(t.range)) : this.depthTest.set(!1)
                    }
                    setStencilMode(t) {
                        t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0),
                        this.stencilMask.set(t.mask),
                        this.stencilOp.set([t.fail, t.depthFail, t.pass]),
                        this.stencilFunc.set({
                            func: t.test.func,
                            ref: t.ref,
                            mask: t.test.mask
                        })) : this.stencilTest.set(!1)
                    }
                    setColorMode(t) {
                        s.bn(t.blendFunction, si.Replace) ? this.blend.set(!1) : (this.blend.set(!0),
                        this.blendFunc.set(t.blendFunction),
                        this.blendColor.set(t.blendColor),
                        t.blendEquation ? this.blendEquation.set(t.blendEquation) : this.blendEquation.setDefault()),
                        this.colorMask.set(t.mask)
                    }
                    unbindVAO() {
                        this.bindVertexArrayOES.set(null)
                    }
                }
                let Ui;
                function Li(c, t, i, h, d, m, y) {
                    const M = c.context
                      , E = M.gl
                      , S = c.transform
                      , I = c.getOrCreateProgram("collisionBox")
                      , R = [];
                    let D = 0
                      , k = 0;
                    for (let be = 0; be < h.length; be++) {
                        const Ue = h[be]
                          , De = t.getTile(Ue)
                          , ke = De.getBucket(i);
                        if (!ke)
                            continue;
                        const Le = Xi(Ue, ke, S);
                        let Ge = Le;
                        0 === d[0] && 0 === d[1] || (Ge = c.translatePosMatrix(Le, De, d, m));
                        const qe = y ? ke.textCollisionBox : ke.iconCollisionBox
                          , vt = ke.collisionCircleArray;
                        if (vt.length > 0) {
                            const dt = s.ab.mat4.create()
                              , Ze = Ge;
                            s.ab.mat4.mul(dt, ke.placementInvProjMatrix, S.glCoordMatrix),
                            s.ab.mat4.mul(dt, dt, ke.placementViewportMatrix),
                            R.push({
                                circleArray: vt,
                                circleOffset: k,
                                transform: Ze,
                                invTransform: dt,
                                projection: ke.getProjection()
                            }),
                            D += vt.length / 4,
                            k = D
                        }
                        qe && (c.terrain && c.terrain.setupElevationDraw(De, I),
                        I.draw(c, E.LINES, Fo.disabled, Xo.disabled, c.colorModeForRenderPass(), zo.disabled, te(Ge, S, De, ke.getProjection()), i.id, qe.layoutVertexBuffer, qe.indexBuffer, qe.segments, null, S.zoom, null, [qe.collisionVertexBuffer, qe.collisionVertexBufferExt]))
                    }
                    if (!y || !R.length)
                        return;
                    const H = c.getOrCreateProgram("collisionCircle")
                      , j = new s.cV;
                    j.resize(4 * D),
                    j._trim();
                    let Y = 0;
                    for (const be of R)
                        for (let Ue = 0; Ue < be.circleArray.length / 4; Ue++) {
                            const De = 4 * Ue
                              , ke = be.circleArray[De + 0]
                              , Le = be.circleArray[De + 1]
                              , Ge = be.circleArray[De + 2]
                              , qe = be.circleArray[De + 3];
                            j.emplace(Y++, ke, Le, Ge, qe, 0),
                            j.emplace(Y++, ke, Le, Ge, qe, 1),
                            j.emplace(Y++, ke, Le, Ge, qe, 2),
                            j.emplace(Y++, ke, Le, Ge, qe, 3)
                        }
                    (!Ui || Ui.length < 2 * D) && (Ui = function(be) {
                        const Ue = 2 * be
                          , De = new s.aU;
                        De.resize(Ue),
                        De._trim();
                        for (let ke = 0; ke < Ue; ke++) {
                            const Le = 6 * ke;
                            De.uint16[Le + 0] = 4 * ke + 0,
                            De.uint16[Le + 1] = 4 * ke + 1,
                            De.uint16[Le + 2] = 4 * ke + 2,
                            De.uint16[Le + 3] = 4 * ke + 2,
                            De.uint16[Le + 4] = 4 * ke + 3,
                            De.uint16[Le + 5] = 4 * ke + 0
                        }
                        return De
                    }(D));
                    const K = M.createIndexBuffer(Ui, !0)
                      , he = M.createVertexBuffer(j, s.cW.members, !0);
                    for (const be of R) {
                        const Ue = {
                            u_matrix: be.transform,
                            u_inv_matrix: be.invTransform,
                            u_camera_to_center_distance: (Te = S).getCameraToCenterDistance(be.projection),
                            u_viewport_size: [Te.width, Te.height]
                        };
                        H.draw(c, E.TRIANGLES, Fo.disabled, Xo.disabled, c.colorModeForRenderPass(), zo.disabled, Ue, i.id, he, K, s.b7.simpleSegment(0, 2 * be.circleOffset, be.circleArray.length, be.circleArray.length / 2), null, S.zoom)
                    }
                    var Te;
                    he.destroy(),
                    K.destroy()
                }
                const sn = s.ab.mat4.create();
                function Nr(c) {
                    const t = c._camera.getWorldToCamera(c.worldSize, 1)
                      , i = s.ab.mat4.multiply([], t, c.globeMatrix);
                    s.ab.mat4.invert(i, i);
                    const h = [0, 0, 0]
                      , d = [0, 1, 0, 0];
                    return s.ab.vec4.transformMat4(d, d, i),
                    h[0] = d[0],
                    h[1] = d[1],
                    h[2] = d[2],
                    s.ab.vec3.normalize(h, h),
                    h
                }
                function la({width: c, height: t, anchor: i, textOffset: h, textScale: d}, m) {
                    const {horizontalAlign: y, verticalAlign: M} = s.bD(i)
                      , E = -(y - .5) * c
                      , S = -(M - .5) * t
                      , I = s.bC(i, h);
                    return new s.P((E / d + I[0]) * m,(S / d + I[1]) * m)
                }
                function Qn(c, t, i, h, d, m, y, M, E, S, I) {
                    const R = c.text.placedSymbolArray
                      , D = c.text.dynamicLayoutVertexArray
                      , k = c.icon.dynamicLayoutVertexArray
                      , H = {}
                      , j = c.getProjection()
                      , Y = yr(M, j, m)
                      , K = m.elevation
                      , he = j.upVectorScale(M.canonical, m.center.lat, m.worldSize).metersToTile;
                    D.clear();
                    for (let Te = 0; Te < R.length; Te++) {
                        const be = R.get(Te)
                          , {tileAnchorX: Ue, tileAnchorY: De, numGlyphs: ke} = be
                          , Le = be.hidden || !be.crossTileID || c.allowVerticalPlacement && !be.placedOrientation ? null : h[be.crossTileID];
                        if (Le) {
                            let Ge = 0
                              , qe = 0
                              , vt = 0;
                            if (K) {
                                const wt = K ? K.getAtTileOffset(M, Ue, De) : 0
                                  , [qt,Ht,Dt] = j.upVector(M.canonical, Ue, De);
                                Ge = wt * qt * he,
                                qe = wt * Ht * he,
                                vt = wt * Dt * he
                            }
                            let[dt,Ze,nt,zt] = Vi(be.projectedAnchorX + Ge, be.projectedAnchorY + qe, be.projectedAnchorZ + vt, i ? Y : y);
                            const Yt = qa(m.getCameraToCenterDistance(j), zt);
                            let to = d.evaluateSizeForFeature(c.textSizeData, S, be) * Yt / s.bw;
                            i && (to *= c.tilePixelRatio / E);
                            const ut = la(Le, to);
                            i ? (({x: dt, y: Ze, z: nt} = j.projectTilePoint(Ue + ut.x, De + ut.y, M.canonical)),
                            [dt,Ze,nt] = Vi(dt + Ge, Ze + qe, nt + vt, y)) : (t && ut._rotate(-m.angle),
                            dt += ut.x,
                            Ze += ut.y,
                            nt = 0);
                            const Gt = c.allowVerticalPlacement && be.placedOrientation === s.bq.vertical ? Math.PI / 2 : 0;
                            for (let wt = 0; wt < ke; wt++)
                                s.bt(D, dt, Ze, nt, Gt);
                            I && be.associatedIconIndex >= 0 && (H[be.associatedIconIndex] = {
                                x: dt,
                                y: Ze,
                                z: nt,
                                angle: Gt
                            })
                        } else
                            ws(ke, D)
                    }
                    if (I) {
                        k.clear();
                        const Te = c.icon.placedSymbolArray;
                        for (let be = 0; be < Te.length; be++) {
                            const Ue = Te.get(be)
                              , {numGlyphs: De} = Ue
                              , ke = H[be];
                            if (Ue.hidden || !ke)
                                ws(De, k);
                            else {
                                const {x: Le, y: Ge, z: qe, angle: vt} = ke;
                                for (let dt = 0; dt < De; dt++)
                                    s.bt(k, Le, Ge, qe, vt)
                            }
                        }
                        c.icon.dynamicLayoutVertexBuffer.updateData(k)
                    }
                    c.text.dynamicLayoutVertexBuffer.updateData(D)
                }
                function Hi(c, t, i, h, d, m, y={}) {
                    const M = i.paint.get("icon-translate")
                      , E = i.paint.get("text-translate")
                      , S = i.paint.get("icon-translate-anchor")
                      , I = i.paint.get("text-translate-anchor")
                      , R = i.layout.get("icon-rotation-alignment")
                      , D = i.layout.get("text-rotation-alignment")
                      , k = i.layout.get("icon-pitch-alignment")
                      , H = i.layout.get("text-pitch-alignment")
                      , j = i.layout.get("icon-keep-upright")
                      , Y = i.layout.get("text-keep-upright")
                      , K = i.paint.get("icon-color-saturation")
                      , he = i.paint.get("icon-color-contrast")
                      , Te = i.paint.get("icon-color-brightness-min")
                      , be = i.paint.get("icon-color-brightness-max")
                      , Ue = "sea" === i.layout.get("symbol-elevation-reference")
                      , De = c.context
                      , ke = De.gl
                      , Le = c.transform
                      , Ge = "map" === R
                      , qe = "map" === D
                      , vt = "map" === k
                      , dt = "map" === H
                      , Ze = void 0 !== i.layout.get("symbol-sort-key").constantOr(1);
                    let nt = !1;
                    const zt = c.depthModeForSublayer(0, Fo.ReadOnly)
                      , Yt = [s.at(Le.center.lng), s.aA(Le.center.lat)]
                      , to = i.layout.get("text-variable-anchor")
                      , ut = "globe" === Le.projection.name
                      , Gt = []
                      , wt = [0, -1, 0];
                    for (const qt of h) {
                        const Ht = t.getTile(qt)
                          , Dt = Ht.getBucket(i);
                        if (!Dt || "mercator" === Dt.projection.name && ut || Dt.fullyClipped)
                            continue;
                        const bo = "globe" === Dt.projection.name
                          , oo = bo ? s.ae(Le.zoom) : 0
                          , Po = yr(qt, Dt.getProjection(), Le)
                          , Eo = Le.calculatePixelsToTileUnitsMatrix(Ht)
                          , Yo = to && Dt.hasTextData()
                          , ko = Dt.hasIconTextFit() && Yo && Dt.hasIconData()
                          , Uo = Dt.getProjection().createInversionMatrix(Le, qt.canonical)
                          , Zo = Ei => {
                            Le.depthOcclusionForSymbolsAndCircles && (i.hasInitialOcclusionOpacityProperties || c.terrain) && (Ei.push("DEPTH_D24"),
                            Ei.push("DEPTH_OCCLUSION"))
                        }
                          , yi = () => {
                            const Ei = Ge && "point" !== i.layout.get("symbol-placement")
                              , Di = [];
                            Zo(Di);
                            const an = Ei || ko
                              , jn = i.paint.get("icon-image-cross-fade").constantOr(0);
                            c.terrainRenderModeElevated() && vt && Di.push("PITCH_WITH_MAP_TERRAIN"),
                            bo && (Di.push("PROJECTION_GLOBE_VIEW"),
                            an && Di.push("PROJECTED_POS_ON_VIEWPORT")),
                            jn > 0 && Di.push("ICON_TRANSITION"),
                            Dt.icon.zOffsetVertexBuffer && Di.push("Z_OFFSET"),
                            0 === K && 0 === he && 0 === Te && 1 === be || Di.push("COLOR_ADJUSTMENT"),
                            Dt.sdfIcons && Di.push("RENDER_SDF");
                            const lr = Dt.icon.programConfigurations.get(i.id)
                              , bn = c.getOrCreateProgram("symbol", {
                                config: lr,
                                defines: Di
                            })
                              , Un = Ht.imageAtlasTexture ? Ht.imageAtlasTexture.size : [0, 0]
                              , er = Dt.iconSizeData
                              , pn = s.bp(er, Le.zoom)
                              , Yi = vt || 0 !== Le.pitch
                              , Qi = Xr(Po, Ht.tileID.canonical, vt, Ge, Le, Dt.getProjection(), Eo)
                              , vi = An(Po, Ht.tileID.canonical, vt, Ge, Le, Dt.getProjection(), Eo)
                              , dn = c.translatePosMatrix(vi, Ht, M, S, !0)
                              , Vn = c.translatePosMatrix(Po, Ht, M, S)
                              , Wi = an ? sn : Qi
                              , tr = Ge && !vt && !Ei;
                            let Or = wt;
                            !ut && !Le.mercatorFromTransition || Ge || (Or = Nr(Le));
                            const Tr = bo ? Or : wt
                              , zs = i.getColorAdjustmentMatrix(K, he, Te, be)
                              , cr = Bi(er.kind, pn, tr, vt, c, Vn, Wi, dn, Ue, !1, Un, [0, 0], !0, qt, oo, Yt, Uo, Tr, Dt.getProjection(), zs, jn)
                              , ns = Ht.imageAtlasTexture ? Ht.imageAtlasTexture : null
                              , Cr = 1 !== i.layout.get("icon-size").constantOr(0) || Dt.iconsNeedLinear
                              , ya = Dt.sdfIcons || c.options.rotating || c.options.zooming || Cr || Yi ? ke.LINEAR : ke.NEAREST
                              , ys = Dt.sdfIcons && 0 !== i.paint.get("icon-halo-width").constantOr(1)
                              , $a = c.terrain && vt && Ei ? s.ab.mat4.invert(s.ab.mat4.create(), Qi) : sn;
                            if (Ei && Dt.icon) {
                                const Fc = Le.elevation
                                  , zh = Fc ? Fc.getAtTileOffsetFunc(qt, Le.center.lat, Le.worldSize, Dt.getProjection()) : null
                                  , Bh = Ys(Po, Ht.tileID.canonical, vt, Ge, Le, Dt.getProjection(), Eo);
                                Pa(Dt, Po, c, !1, Bh, vi, vt, j, zh, qt)
                            }
                            return {
                                program: bn,
                                buffers: Dt.icon,
                                uniformValues: cr,
                                atlasTexture: ns,
                                atlasTextureIcon: null,
                                atlasInterpolation: ya,
                                atlasInterpolationIcon: null,
                                isSDF: Dt.sdfIcons,
                                hasHalo: ys,
                                tile: Ht,
                                labelPlaneMatrixInv: $a
                            }
                        }
                          , li = () => {
                            const Ei = qe && "point" !== i.layout.get("symbol-placement")
                              , Di = []
                              , an = Ei || to || ko;
                            c.terrainRenderModeElevated() && dt && Di.push("PITCH_WITH_MAP_TERRAIN"),
                            bo && (Di.push("PROJECTION_GLOBE_VIEW"),
                            an && Di.push("PROJECTED_POS_ON_VIEWPORT")),
                            Dt.text.zOffsetVertexBuffer && Di.push("Z_OFFSET"),
                            Dt.iconsInText && Di.push("RENDER_TEXT_AND_SYMBOL"),
                            Di.push("RENDER_SDF"),
                            Zo(Di);
                            const jn = Dt.text.programConfigurations.get(i.id)
                              , lr = c.getOrCreateProgram("symbol", {
                                config: jn,
                                defines: Di
                            });
                            let bn, Un = [0, 0], er = null;
                            const pn = Dt.textSizeData;
                            Dt.iconsInText && (Un = Ht.imageAtlasTexture ? Ht.imageAtlasTexture.size : [0, 0],
                            er = Ht.imageAtlasTexture ? Ht.imageAtlasTexture : null,
                            bn = dt || 0 !== Le.pitch || c.options.rotating || c.options.zooming || "composite" === pn.kind || "camera" === pn.kind ? ke.LINEAR : ke.NEAREST);
                            const Yi = Ht.glyphAtlasTexture ? Ht.glyphAtlasTexture.size : [0, 0]
                              , Qi = i.layout.get("text-size-scale-range")
                              , vi = s.aw(c.scaleFactor, Qi[0], Qi[1])
                              , dn = s.bp(pn, Le.zoom, vi)
                              , Vn = Xr(Po, Ht.tileID.canonical, dt, qe, Le, Dt.getProjection(), Eo)
                              , Wi = An(Po, Ht.tileID.canonical, dt, qe, Le, Dt.getProjection(), Eo)
                              , tr = c.translatePosMatrix(Wi, Ht, E, I, !0)
                              , Or = c.translatePosMatrix(Po, Ht, E, I)
                              , Tr = an ? sn : Vn
                              , zs = qe && !dt && !Ei;
                            let cr = wt;
                            !ut && !Le.mercatorFromTransition || qe || (cr = Nr(Le));
                            const ns = Bi(pn.kind, dn, zs, dt, c, Or, Tr, tr, Ue, !0, Yi, Un, !0, qt, oo, Yt, Uo, bo ? cr : wt, Dt.getProjection(), null, null, vi)
                              , Cr = Ht.glyphAtlasTexture ? Ht.glyphAtlasTexture : null
                              , ya = ke.LINEAR
                              , ys = 0 !== i.paint.get("text-halo-width").constantOr(1)
                              , $a = c.terrain && dt && Ei ? s.ab.mat4.invert(s.ab.mat4.create(), Vn) : sn;
                            if (Ei && Dt.text) {
                                const Fc = Le.elevation
                                  , zh = Fc ? Fc.getAtTileOffsetFunc(qt, Le.center.lat, Le.worldSize, Dt.getProjection()) : null
                                  , Bh = Ys(Po, Ht.tileID.canonical, dt, qe, Le, Dt.getProjection(), Eo);
                                Pa(Dt, Po, c, !0, Bh, Wi, dt, Y, zh, qt)
                            }
                            return {
                                program: lr,
                                buffers: Dt.text,
                                uniformValues: ns,
                                atlasTexture: Cr,
                                atlasTextureIcon: er,
                                atlasInterpolation: ya,
                                atlasInterpolationIcon: bn,
                                isSDF: !0,
                                hasHalo: ys,
                                tile: Ht,
                                labelPlaneMatrixInv: $a
                            }
                        }
                          , Ji = Dt.icon.segments.get().length
                          , on = Dt.text.segments.get().length
                          , Ri = Ji && !y.onlyText ? yi() : null
                          , Ni = on && !y.onlyIcons ? li() : null
                          , ii = i.paint.get("icon-opacity").constantOr(1)
                          , No = i.paint.get("text-opacity").constantOr(1);
                        if (Ze && Dt.canOverlap) {
                            nt = !0;
                            const Ei = ii && !y.onlyText ? Dt.icon.segments.get() : []
                              , Di = No && !y.onlyIcons ? Dt.text.segments.get() : [];
                            for (const an of Ei)
                                Gt.push({
                                    segments: new s.b7([an]),
                                    sortKey: an.sortKey,
                                    state: Ri
                                });
                            for (const an of Di)
                                Gt.push({
                                    segments: new s.b7([an]),
                                    sortKey: an.sortKey,
                                    state: Ni
                                })
                        } else
                            y.onlyText || Gt.push({
                                segments: ii ? Dt.icon.segments : new s.b7([]),
                                sortKey: 0,
                                state: Ri
                            }),
                            y.onlyIcons || Gt.push({
                                segments: No ? Dt.text.segments : new s.b7([]),
                                sortKey: 0,
                                state: Ni
                            })
                    }
                    nt && Gt.sort( (qt, Ht) => qt.sortKey - Ht.sortKey);
                    for (const qt of Gt) {
                        const Ht = qt.state;
                        if (Ht)
                            if (c.terrain ? c.terrain.setupElevationDraw(Ht.tile, Ht.program, {
                                useDepthForOcclusion: Le.depthOcclusionForSymbolsAndCircles,
                                labelPlaneMatrixInv: Ht.labelPlaneMatrixInv
                            }) : c.setupDepthForOcclusion(Le.depthOcclusionForSymbolsAndCircles, Ht.program),
                            De.activeTexture.set(ke.TEXTURE0),
                            Ht.atlasTexture && Ht.atlasTexture.bind(Ht.atlasInterpolation, ke.CLAMP_TO_EDGE, !0),
                            Ht.atlasTextureIcon && (De.activeTexture.set(ke.TEXTURE1),
                            Ht.atlasTextureIcon && Ht.atlasTextureIcon.bind(Ht.atlasInterpolationIcon, ke.CLAMP_TO_EDGE, !0)),
                            c.uploadCommonLightUniforms(c.context, Ht.program),
                            Ht.hasHalo) {
                                const Dt = Ht.uniformValues;
                                Dt.u_is_halo = 1,
                                Os(Ht.buffers, qt.segments, i, c, Ht.program, zt, d, m, Dt, 2),
                                Dt.u_is_halo = 0
                            } else {
                                if (Ht.isSDF) {
                                    const Dt = Ht.uniformValues;
                                    Ht.hasHalo && (Dt.u_is_halo = 1,
                                    Os(Ht.buffers, qt.segments, i, c, Ht.program, zt, d, m, Dt, 1)),
                                    Dt.u_is_halo = 0
                                }
                                Os(Ht.buffers, qt.segments, i, c, Ht.program, zt, d, m, Ht.uniformValues, 1)
                            }
                    }
                }
                function Os(c, t, i, h, d, m, y, M, E, S) {
                    const I = [c.dynamicLayoutVertexBuffer, c.opacityVertexBuffer, c.iconTransitioningVertexBuffer, c.globeExtVertexBuffer, c.zOffsetVertexBuffer];
                    d.draw(h, h.context.gl.TRIANGLES, m, y, M, zo.disabled, E, i.id, c.layoutVertexBuffer, c.indexBuffer, t, i.paint, h.transform.zoom, c.programConfigurations.get(i.id), I, S)
                }
                function vl(c, t, i, h, d, m, y) {
                    const M = c.context.gl
                      , E = i.paint.get("fill-pattern")
                      , S = i.is3D()
                      , I = S ? c.stencilModeFor3D() : Xo.disabled
                      , R = E && E.constantOr(1);
                    let D, k, H, j, Y;
                    y ? (k = R && !i.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline",
                    D = M.LINES) : (k = R ? "fillPattern" : "fill",
                    D = M.TRIANGLES);
                    for (const K of h) {
                        const he = t.getTile(K);
                        if (R && !he.patternsLoaded())
                            continue;
                        const Te = he.getBucket(i);
                        if (!Te)
                            continue;
                        c.prepareDrawTile();
                        const be = Te.programConfigurations.get(i.id)
                          , Ue = c.isTileAffectedByFog(K)
                          , De = c.getOrCreateProgram(k, {
                            config: be,
                            overrideFog: Ue
                        });
                        R && (c.context.activeTexture.set(M.TEXTURE0),
                        he.imageAtlasTexture && he.imageAtlasTexture.bind(M.LINEAR, M.CLAMP_TO_EDGE),
                        be.updatePaintBuffers());
                        const ke = E.constantOr(null);
                        if (ke && he.imageAtlas) {
                            const qe = he.imageAtlas
                              , vt = s.A.from(ke)
                              , dt = qe.patternPositions[vt.getSerializedPrimary()];
                            dt && be.setConstantPatternPositions(dt)
                        }
                        const Le = c.translatePosMatrix(K.projMatrix, he, i.paint.get("fill-translate"), i.paint.get("fill-translate-anchor"))
                          , Ge = i.paint.get("fill-emissive-strength");
                        if (y) {
                            j = Te.indexBuffer2,
                            Y = Te.segments2;
                            const qe = c.terrain && c.terrain.renderingToTexture ? c.terrain.drapeBufferSize : [M.drawingBufferWidth, M.drawingBufferHeight];
                            H = "fillOutlinePattern" === k && R ? V(Le, Ge, c, he, qe) : U(Le, Ge, qe)
                        } else
                            j = Te.indexBuffer,
                            Y = Te.segments,
                            H = R ? yc(Le, Ge, c, he) : aa(Le, Ge);
                        c.uploadCommonUniforms(c.context, De, K.toUnwrapped()),
                        De.draw(c, D, d, S ? I : c.stencilModeForClipping(K), m, zo.disabled, H, i.id, Te.layoutVertexBuffer, j, Y, i.paint, c.transform.zoom, be, void 0)
                    }
                }
                function xl(c, t, i, h, d, m, y, M) {
                    i.resetLayerRenderingStats(c);
                    const E = c.context
                      , S = E.gl
                      , I = c.transform
                      , R = i.paint.get("fill-extrusion-pattern")
                      , D = R.constantOr(1)
                      , k = i.paint.get("fill-extrusion-opacity")
                      , H = c.style.enable3dLights()
                      , j = i.paint.get(H && !D ? "fill-extrusion-ambient-occlusion-wall-radius" : "fill-extrusion-ambient-occlusion-radius")
                      , Y = [i.paint.get("fill-extrusion-ambient-occlusion-intensity"), j]
                      , K = i.layout.get("fill-extrusion-edge-radius")
                      , he = K > 0 && !i.paint.get("fill-extrusion-rounded-roof")
                      , Te = he ? 0 : K
                      , be = "globe" === I.projection.name ? s.d3() : 0
                      , Ue = "globe" === I.projection.name
                      , De = Ue ? s.ae(I.zoom) : 0
                      , ke = [s.at(I.center.lng), s.aA(I.center.lat)]
                      , Le = "none" === i.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default")
                      , Ge = i.paint.get("fill-extrusion-flood-light-color").toRenderColor(Le ? null : i.lut).toArray01().slice(0, 3)
                      , qe = i.paint.get("fill-extrusion-flood-light-intensity")
                      , vt = i.paint.get("fill-extrusion-vertical-scale")
                      , dt = 0 !== i.paint.get("fill-extrusion-line-width").constantOr(1)
                      , Ze = i.paint.get("fill-extrusion-height-alignment")
                      , nt = i.paint.get("fill-extrusion-base-alignment")
                      , zt = Kr(c, i.paint.get("fill-extrusion-cutoff-fade-range"))
                      , Yt = [];
                    let to;
                    Ue && Yt.push("PROJECTION_GLOBE_VIEW"),
                    Y[0] > 0 && Yt.push("FAUX_AO"),
                    he && Yt.push("ZERO_ROOF_RADIUS"),
                    M && Yt.push("HAS_CENTROID"),
                    qe > 0 && Yt.push("FLOOD_LIGHT"),
                    zt.shouldRenderCutoff && Yt.push("RENDER_CUTOFF"),
                    dt && Yt.push("RENDER_WALL_MODE");
                    const ut = "shadow" === c.renderPass
                      , Gt = c.shadowRenderer
                      , wt = ut && !!Gt;
                    c.shadowRenderer && (c.shadowRenderer.useNormalOffset = !0);
                    let qt = [0, 0, 0];
                    if (Gt) {
                        const bo = c.style.directionalLight
                          , oo = c.style.ambientLight;
                        bo && oo && (qt = oa(c.style, bo, oo)),
                        ut || (Yt.push("RENDER_SHADOWS", "DEPTH_TEXTURE"),
                        Gt.useNormalOffset && Yt.push("NORMAL_OFFSET")),
                        to = Yt.concat(["SHADOWS_SINGLE_CASCADE"])
                    }
                    const Ht = wt ? "fillExtrusionDepth" : D ? "fillExtrusionPattern" : "fillExtrusion"
                      , Dt = i.getLayerRenderingStats();
                    for (const bo of h) {
                        const oo = t.getTile(bo)
                          , Po = oo.getBucket(i);
                        if (!Po || Po.projection.name !== I.projection.name)
                            continue;
                        let Eo = !1;
                        Gt && (Eo = 0 === Gt.getMaxCascadeForTile(bo.toUnwrapped()));
                        const Yo = c.isTileAffectedByFog(bo)
                          , ko = Po.programConfigurations.get(i.id)
                          , Uo = c.getOrCreateProgram(Ht, {
                            config: ko,
                            defines: Eo ? to : Yt,
                            overrideFog: Yo
                        });
                        if (c.terrain && c.terrain.setupElevationDraw(oo, Uo, {
                            useMeterToDem: !0
                        }),
                        !Po.centroidVertexBuffer) {
                            const Ni = Uo.attributes.a_centroid_pos;
                            void 0 !== Ni && S.vertexAttrib2f(Ni, 0, 0)
                        }
                        !ut && Gt && Gt.setupShadows(oo.tileID.toUnwrapped(), Uo, "vector-tile", oo.tileID.overscaledZ),
                        D && (c.context.activeTexture.set(S.TEXTURE0),
                        oo.imageAtlasTexture && oo.imageAtlasTexture.bind(S.LINEAR, S.CLAMP_TO_EDGE),
                        ko.updatePaintBuffers());
                        const Zo = R.constantOr(null);
                        if (Zo && oo.imageAtlas) {
                            const Ni = oo.imageAtlas
                              , ii = s.A.from(Zo)
                              , No = Ni.patternPositions[ii.getSerializedPrimary()];
                            No && ko.setConstantPatternPositions(No)
                        }
                        const yi = i.paint.get("fill-extrusion-vertical-gradient")
                          , li = 1 / Po.tileToMeter;
                        let Ji;
                        if (ut && Gt) {
                            if (eo(oo.tileID, Po, c))
                                continue;
                            const Ni = Gt.calculateShadowPassMatrixFromTile(oo.tileID.toUnwrapped());
                            Ji = La(Ni, Te, li, vt, Ze, nt)
                        } else {
                            const Ni = c.translatePosMatrix(bo.expandedProjMatrix, oo, i.paint.get("fill-extrusion-translate"), i.paint.get("fill-extrusion-translate-anchor"))
                              , ii = I.projection.createInversionMatrix(I, bo.canonical);
                            Ji = D ? gc(Ni, c, yi, k, Y, Te, li, bo, oo, be, Ze, nt, De, ke, ii, Ge, vt) : yl(Ni, c, yi, k, Y, Te, li, bo, be, Ze, nt, De, ke, ii, Ge, vt, qe, qt)
                        }
                        c.uploadCommonUniforms(E, Uo, bo.toUnwrapped(), null, zt);
                        let on = Po.segments;
                        if ("mercator" === I.projection.name && !ut && (on = Po.getVisibleSegments(oo.tileID, c.terrain, c.transform.getFrustum(0)),
                        !on.get().length))
                            continue;
                        if (Dt)
                            if (ut)
                                for (const Ni of on.get())
                                    Dt.numRenderedVerticesInShadowPass += Ni.primitiveLength;
                            else
                                for (const Ni of on.get())
                                    Dt.numRenderedVerticesInTransparentPass += Ni.primitiveLength;
                        const Ri = [];
                        (c.terrain || M) && Ri.push(Po.centroidVertexBuffer),
                        Ue && Ri.push(Po.layoutVertexExtBuffer),
                        dt && Ri.push(Po.wallVertexBuffer),
                        Uo.draw(c, E.gl.TRIANGLES, d, m, y, zo.backCCW, Ji, i.id, Po.layoutVertexBuffer, Po.indexBuffer, on, i.paint, c.transform.zoom, ko, Ri)
                    }
                    c.shadowRenderer && (c.shadowRenderer.useNormalOffset = !1)
                }
                function Rs(c, t, i, h, d, m, y, M, E, S, I, R, D, k, H, j, Y, K, he) {
                    const Te = c.context
                      , be = Te.gl
                      , Ue = c.transform
                      , De = c.transform.zoom
                      , ke = []
                      , Le = Kr(c, i.paint.get("fill-extrusion-cutoff-fade-range"));
                    "clear" === S ? (ke.push("CLEAR_SUBPASS"),
                    he && (ke.push("CLEAR_FROM_TEXTURE"),
                    Te.activeTexture.set(be.TEXTURE0),
                    he.bind(be.LINEAR, be.CLAMP_TO_EDGE))) : "sdf" === S && ke.push("SDF_SUBPASS"),
                    Y && ke.push("HAS_CENTROID"),
                    Le.shouldRenderCutoff && ke.push("RENDER_CUTOFF");
                    const Ge = i.layout.get("fill-extrusion-edge-radius")
                      , qe = (vt, dt, Ze, nt, zt) => {
                        const Yt = dt.programConfigurations.get(i.id)
                          , to = c.isTileAffectedByFog(vt)
                          , ut = c.getOrCreateProgram("fillExtrusionGroundEffect", {
                            config: Yt,
                            defines: ke,
                            overrideFog: to
                        })
                          , Gt = ( (qt, Ht, Dt, bo, oo, Po, Eo, Yo, ko, Uo, Zo) => ({
                            u_matrix: Ht,
                            u_opacity: Dt,
                            u_ao_pass: bo ? 1 : 0,
                            u_meter_to_tile: oo,
                            u_ao: Po,
                            u_flood_light_intensity: Eo,
                            u_flood_light_color: Yo,
                            u_attenuation: ko,
                            u_edge_radius: Uo,
                            u_fb: 0,
                            u_fb_size: Zo,
                            u_dynamic_offset: 1
                        }))(0, nt, I, E, zt, [R, D * zt], k, H, j, De >= 17 ? 0 : Ge * zt, he ? he.size[0] : 0)
                          , wt = [];
                        Y && wt.push(dt.hiddenByLandmarkVertexBuffer),
                        c.uploadCommonUniforms(Te, ut, vt.toUnwrapped(), null, Le),
                        ut.draw(c, Te.gl.TRIANGLES, d, m, y, M, Gt, i.id, dt.vertexBuffer, dt.indexBuffer, Ze, i.paint, De, Yt, wt)
                    }
                    ;
                    for (const vt of h) {
                        const dt = t.getTile(vt)
                          , Ze = dt.getBucket(i);
                        if (!Ze || Ze.projection.name !== Ue.projection.name || !Ze.groundEffect || Ze.groundEffect && !Ze.groundEffect.hasData())
                            continue;
                        const nt = Ze.groundEffect
                          , zt = 1 / Ze.tileToMeter;
                        {
                            const Yt = c.translatePosMatrix(vt.projMatrix, dt, i.paint.get("fill-extrusion-translate"), i.paint.get("fill-extrusion-translate-anchor"))
                              , to = nt.getDefaultSegment();
                            qe(vt, nt, to, Yt, zt)
                        }
                        if (K)
                            for (let Yt = 0; Yt < 4; Yt++) {
                                const to = s.d4[Yt](vt)
                                  , ut = t.getTile(to);
                                if (!ut)
                                    continue;
                                const Gt = ut.getBucket(i);
                                if (!Gt || Gt.projection.name !== Ue.projection.name || !Gt.groundEffect || Gt.groundEffect && !Gt.groundEffect.hasData())
                                    continue;
                                const wt = Gt.groundEffect;
                                let qt, Ht;
                                0 === Yt ? (qt = [-s.ag, 0, 0],
                                Ht = 1) : 1 === Yt ? (qt = [s.ag, 0, 0],
                                Ht = 0) : 2 === Yt ? (qt = [0, -s.ag, 0],
                                Ht = 3) : (qt = [0, s.ag, 0],
                                Ht = 2);
                                const Dt = wt.regionSegments[Ht];
                                if (!Dt)
                                    continue;
                                const bo = new Float32Array(16);
                                s.ab.mat4.translate(bo, vt.projMatrix, qt),
                                qe(vt, wt, Dt, c.translatePosMatrix(bo, dt, i.paint.get("fill-extrusion-translate"), i.paint.get("fill-extrusion-translate-anchor")), zt)
                            }
                    }
                }
                function yh(c, t, i, h, d, m, y) {
                    0 === h.centroidVertexArray.length && h.createCentroidsBuffer();
                    const M = m ? m.findDEMTileFor(i) : null;
                    if (!(M && M.dem || y))
                        return;
                    m && M && M.dem && h.selfDEMTileTimestamp !== M.dem._timestamp && (h.borderDoneWithNeighborZ = [-1, -1, -1, -1],
                    h.selfDEMTileTimestamp = M.dem._timestamp);
                    const E = K => new s.P(Math.ceil((K + s.d7) * s.d8),0)
                      , S = K => {
                        const he = t.getSource().minzoom
                          , Te = Ue => {
                            const De = t.getTileByID(Ue);
                            if (De && De.hasData())
                                return De.getBucket(d)
                        }
                          , be = [0, -1, 1];
                        for (const Ue of be) {
                            if (K.overscaledZ + Ue < he)
                                continue;
                            const De = Te(K.calculateScaledKey(K.overscaledZ + Ue));
                            if (De)
                                return De
                        }
                    }
                      , I = [0, 0, 0]
                      , R = (K, he) => (I[0] = Math.min(K.min.y, he.min.y),
                    I[1] = Math.max(K.max.y, he.max.y),
                    I[2] = s.ag - he.min.x > K.max.x ? he.min.x - s.ag : K.max.x,
                    I)
                      , D = (K, he) => (I[0] = Math.min(K.min.x, he.min.x),
                    I[1] = Math.max(K.max.x, he.max.x),
                    I[2] = s.ag - he.min.y > K.max.y ? he.min.y - s.ag : K.max.y,
                    I)
                      , k = [ (K, he) => R(K, he), (K, he) => R(he, K), (K, he) => D(K, he), (K, he) => D(he, K)]
                      , H = (K, he, Te, be, Ue, De, ke) => {
                        if (!m)
                            return 0;
                        const Le = [[De ? Te : K, De ? K : Te, 0], [De ? Te : he, De ? he : Te, 0]]
                          , Ge = ke < 0 ? s.ag + ke : ke
                          , qe = [De ? Ge : (K + he) / 2, De ? (K + he) / 2 : Ge, 0];
                        return 0 === Te && ke < 0 || 0 !== Te && ke > 0 ? m.getForTilePoints(Ue, [qe], !0, be) : Le.push(qe),
                        m.getForTilePoints(i, Le, !0, M),
                        Math.max(Le[0][2], Le[1][2], qe[2]) / m.exaggeration()
                    }
                    ;
                    for (let K = 0; K < 4; K++) {
                        const he = h.borderFeatureIndices[K];
                        if (0 === he.length)
                            continue;
                        const Te = s.d4[K](i)
                          , be = S(Te);
                        if (!(be && be instanceof s.d5))
                            continue;
                        const Ue = m ? m.findDEMTileFor(Te) : null;
                        if (!(Ue && Ue.dem || y) || (m && Ue && Ue.dem && h.borderDEMTileTimestamp[K] !== Ue.dem._timestamp && (h.borderDoneWithNeighborZ[K] = -1,
                        h.borderDEMTileTimestamp[K] = Ue.dem._timestamp),
                        h.borderDoneWithNeighborZ[K] === be.canonical.z))
                            continue;
                        0 === be.centroidVertexArray.length && be.createCentroidsBuffer();
                        const De = (K < 2 ? 1 : 5) - K
                          , ke = be.borderDoneWithNeighborZ[De] !== h.canonical.z
                          , Le = be.borderFeatureIndices[De];
                        let Ge = 0;
                        if (h.canonical.z !== be.canonical.z) {
                            for (const qe of he)
                                h.showCentroid(h.featuresOnBorder[qe]);
                            if (ke)
                                for (const qe of Le)
                                    be.showCentroid(be.featuresOnBorder[qe]);
                            h.borderDoneWithNeighborZ[K] = be.canonical.z,
                            be.borderDoneWithNeighborZ[De] = h.canonical.z
                        }
                        for (const qe of he) {
                            const vt = h.featuresOnBorder[qe]
                              , dt = h.centroidData[vt.centroidDataIndex]
                              , Ze = vt.borders[K];
                            let nt;
                            for (; Ge < Le.length; ) {
                                nt = be.featuresOnBorder[Le[Ge]];
                                const zt = nt.borders[De];
                                if (zt[1] > Ze[0] + 3 || zt[0] > Ze[0] - 3)
                                    break;
                                be.showCentroid(nt),
                                Ge++
                            }
                            if (nt && Ge < Le.length) {
                                const zt = Ge;
                                let Yt = 0;
                                for (; !(nt.borders[De][0] > Ze[1] - 3) && (Yt++,
                                ++Ge !== Le.length); )
                                    nt = be.featuresOnBorder[Le[Ge]];
                                nt = be.featuresOnBorder[Le[zt]];
                                let to = !1;
                                if (Yt >= 1) {
                                    const wt = nt.borders[De];
                                    Math.abs(Ze[0] - wt[0]) < 3 && Math.abs(Ze[1] - wt[1]) < 3 && (Yt = 1,
                                    to = !0,
                                    Ge = zt + 1)
                                } else if (0 === Yt) {
                                    h.showCentroid(vt);
                                    continue
                                }
                                const ut = be.centroidData[nt.centroidDataIndex];
                                y && to && (((j = dt).flags | (Y = ut).flags) & s.d6 ? (j.flags |= s.d6,
                                Y.flags |= s.d6) : (j.flags &= ~s.d6,
                                Y.flags &= ~s.d6));
                                const Gt = vt.intersectsCount() > 1 || nt.intersectsCount() > 1;
                                if (Yt > 1)
                                    Ge = zt,
                                    dt.centroidXY = ut.centroidXY = new s.P(0,0);
                                else if (Ue && Ue.dem && !Gt) {
                                    const wt = k[K](dt, ut)
                                      , qt = K % 2 ? s.ag - 1 : 0
                                      , Ht = H(wt[0], Math.min(s.ag - 1, wt[1]), qt, Ue, Te, K < 2, wt[2]);
                                    dt.centroidXY = ut.centroidXY = E(Ht)
                                } else
                                    Gt ? dt.centroidXY = ut.centroidXY = new s.P(0,0) : (dt.centroidXY = h.encodeBorderCentroid(vt),
                                    ut.centroidXY = be.encodeBorderCentroid(nt));
                                h.writeCentroidToBuffer(dt),
                                be.writeCentroidToBuffer(ut)
                            } else
                                h.showCentroid(vt)
                        }
                        h.borderDoneWithNeighborZ[K] = be.canonical.z,
                        be.borderDoneWithNeighborZ[De] = h.canonical.z
                    }
                    var j, Y;
                    (h.needsCentroidUpdate || !h.centroidVertexBuffer && 0 !== h.centroidVertexArray.length) && h.uploadCentroid(c)
                }
                const vc = [1, 0, 0]
                  , bl = [0, 1, 0]
                  , wl = [0, 0, 1];
                function eo(c, t, i) {
                    const h = i.transform
                      , d = i.shadowRenderer;
                    if (!d)
                        return !0;
                    const m = c.toUnwrapped()
                      , y = h.tileSize * d._cascades[i.currentShadowCascade].scale;
                    let M = t.maxHeight;
                    if (h.elevation) {
                        const j = h.elevation.getMinMaxForTile(c);
                        j && (M += j.max)
                    }
                    const E = [...d.shadowDirection];
                    E[2] = -E[2];
                    const S = d.computeSimplifiedTileShadowVolume(m, M, y, E);
                    if (!S)
                        return !1;
                    const I = [vc, bl, wl, E, [E[0], 0, E[2]], [0, E[1], E[2]]]
                      , R = "globe" === h.projection.name
                      , D = h.scaleZoom(y)
                      , k = s.bR.fromInvProjectionMatrix(h.invProjMatrix, h.worldSize, D, !R)
                      , H = d.getCurrentCascadeFrustum();
                    return 0 === k.intersectsPrecise(S.vertices, S.planes, I) || 0 === H.intersectsPrecise(S.vertices, S.planes, I)
                }
                function Mo(c) {
                    return [c[0] * s.d9, c[1] * s.d9, c[2] * s.d9, 0]
                }
                function ca(c, t, i, h, d, m, y, M, E) {
                    const S = h.getSource()
                      , I = i.globeSharedBuffers;
                    if (!I)
                        return;
                    let R, D, k;
                    if (t && (R = h.getTile(t)),
                    S instanceof s.aJ ? (D = S.texture,
                    k = s.cI(0, 0, i.transform)) : R && t && (D = R.texture,
                    k = s.cI(t.canonical.z, t.canonical.x, i.transform)),
                    !D || !k)
                        return;
                    c || (k = s.ab.mat4.scale(s.ab.mat4.create(), k, [1, -1, 1]));
                    const H = i.context
                      , j = H.gl
                      , Y = "nearest" === d.paint.get("raster-resampling") ? j.NEAREST : j.LINEAR
                      , K = i.colorModeForDrapableLayerRenderPass(m)
                      , he = y.defines;
                    he.push("GLOBE_POLES");
                    const Te = new Fo(j.LEQUAL,Fo.ReadWrite,i.depthRangeFor3D)
                      , be = Float32Array.from(i.transform.expandedFarZProjMatrix)
                      , Ue = Float32Array.from(s.bb(s.cH(new s.bT(0,0,0))));
                    i.terrain && i.terrain.prepareDrawTile(),
                    H.activeTexture.set(j.TEXTURE0),
                    D.bind(Y, j.CLAMP_TO_EDGE),
                    H.activeTexture.set(j.TEXTURE1),
                    D.bind(Y, j.CLAMP_TO_EDGE),
                    D.useMipmap && H.extTextureFilterAnisotropic && i.transform.pitch > 20 && j.texParameterf(j.TEXTURE_2D, H.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, H.extTextureFilterAnisotropicMax);
                    const [De,ke,Le,Ge] = t ? I.getPoleBuffers(t.canonical.z, !1) : I.getPoleBuffers(0, !0)
                      , qe = d.paint.get("raster-elevation");
                    let vt;
                    c ? (vt = De,
                    i.renderDefaultNorthPole = 0 !== qe) : (vt = ke,
                    i.renderDefaultSouthPole = 0 !== qe);
                    const dt = Mo(y.mix)
                      , Ze = (zt = be,
                    Yt = Ue,
                    to = k,
                    ut = s.ae(i.transform.zoom),
                    wt = d,
                    Ht = qe,
                    bo = dt,
                    oo = y.offset,
                    Po = y.range,
                    Eo = m,
                    It(zt, Yt, to, new Float32Array(16), new Float32Array(9), [0, 0], ut, [0, 0], [0, 0, 0, 0], 1, {
                        opacity: 1,
                        mix: 0
                    }, wt, [0, 0], Ht, 2, bo, oo, Po, 1, 0, Eo))
                      , nt = i.getOrCreateProgram("raster", {
                        defines: he
                    });
                    var zt, Yt, to, ut, wt, Ht, bo, oo, Po, Eo;
                    i.uploadCommonUniforms(H, nt, null),
                    nt.draw(i, j.TRIANGLES, Te, E, K, M, Ze, d.id, vt, Le, Ge)
                }
                function cn(c) {
                    const t = c._nearZ
                      , i = c.projection.farthestPixelDistance(c)
                      , h = i - t
                      , d = .2 * c.height
                      , m = t + d;
                    return [t, i, (m - d - t) / h, (m - t) / h]
                }
                function ft(c, t, i, h) {
                    if (c)
                        return t instanceof ls && c instanceof Ya ? t.getTextureDescriptor(c, i, !0) : {
                            texture: c.texture,
                            mix: Mo(h.mix),
                            offset: h.offset,
                            buffer: 0,
                            tileSize: 1
                        }
                }
                var mp = s.da([{
                    name: "a_index",
                    type: "Int16",
                    components: 1
                }]);
                class vh {
                    constructor(t, i, h, d) {
                        const m = {
                            width: h[0],
                            height: h[1],
                            data: null
                        }
                          , y = t.gl;
                        this.targetColorTexture = new s.T(t,m,y.RGBA8,{
                            useMipmap: !1
                        }),
                        this.backgroundColorTexture = new s.T(t,m,y.RGBA8,{
                            useMipmap: !1
                        }),
                        this.context = t,
                        this.updateParticleTexture(i, d),
                        this.lastInvalidatedAt = 0
                    }
                    updateParticleTexture(t, i) {
                        if (this.particleTextureDimension === i.width)
                            return;
                        (this.particleTexture0 || this.particleTexture1 || this.particleIndexBuffer || this.particleSegment) && (this.particleTexture0.destroy(),
                        this.particleTexture1.destroy(),
                        this.particleIndexBuffer.destroy(),
                        this.particleSegment.destroy());
                        const h = this.context.gl
                          , d = i.width * i.height;
                        this.particleTexture0 = new s.T(this.context,i,h.RGBA8,{
                            premultiply: !1,
                            useMipmap: !1
                        }),
                        this.particleTexture1 = new s.T(this.context,i,h.RGBA8,{
                            premultiply: !1,
                            useMipmap: !1
                        });
                        const m = new s.db;
                        m.reserve(d);
                        for (let y = 0; y < d; y++)
                            m.emplaceBack(y);
                        this.particleIndexBuffer = this.context.createVertexBuffer(m, mp.members, !0),
                        this.particleSegment = s.b7.simpleSegment(0, 0, this.particleIndexBuffer.length, 0),
                        this.particleTextureDimension = i.width
                    }
                    update(t) {
                        return !(this.lastInvalidatedAt < t && (this.lastInvalidatedAt = s.q.now(),
                        1))
                    }
                    destroy() {
                        this.targetColorTexture.destroy(),
                        this.backgroundColorTexture.destroy(),
                        this.particleIndexBuffer.destroy(),
                        this.particleTexture0.destroy(),
                        this.particleTexture1.destroy(),
                        this.particleSegment.destroy()
                    }
                }
                function gu(c, t, i) {
                    if (!c)
                        return null;
                    const h = t.getTextureDescriptor(c, i, !0);
                    if (!h)
                        return null;
                    let {texture: d, mix: m, offset: y, tileSize: M, buffer: E, format: S} = h;
                    if (!d || !S)
                        return null;
                    let I = !1;
                    return "uint32" === S && (I = !0,
                    m[3] = 0,
                    m = Je(s.dc, m, [0, i.paint.get("raster-particle-max-speed")]),
                    y = Fe(s.dc, y, [0, i.paint.get("raster-particle-max-speed")])),
                    {
                        texture: d,
                        textureOffset: [E / (M + 2 * E), M / (M + 2 * E)],
                        tileSize: M,
                        scalarData: I,
                        scale: m,
                        offset: y,
                        defines: ["RASTER_ARRAY", {
                            uint8: "DATA_FORMAT_UINT8",
                            uint16: "DATA_FORMAT_UINT16",
                            uint32: "DATA_FORMAT_UINT32"
                        }[S]]
                    }
                }
                function fp(c) {
                    const t = c._nearZ
                      , i = c.projection.farthestPixelDistance(c)
                      , h = i - t
                      , d = .2 * c.height
                      , m = t + d;
                    return [t, i, (m - d - t) / h, (m - t) / h]
                }
                const _p = new s.aj(1,0,0,1)
                  , gp = new s.aj(0,1,0,1)
                  , Pl = new s.aj(0,0,1,1)
                  , Md = new s.aj(1,0,1,1)
                  , Td = new s.aj(0,1,1,1);
                function Fa(c, t, i, h, d, m, y) {
                    const M = c.context
                      , E = c.transform
                      , S = M.gl
                      , I = "globe" === E.projection.name
                      , R = I ? ["PROJECTION_GLOBE_VIEW"] : [];
                    let D = s.ab.mat4.clone(i.projMatrix);
                    if (I && s.ae(E.zoom) > 0) {
                        const dt = s.ba(i.canonical, E)
                          , Ze = s.dd(dt);
                        D = s.ab.mat4.multiply(new Float32Array(16), E.globeMatrix, Ze),
                        s.ab.mat4.multiply(D, E.projMatrix, D)
                    }
                    const k = s.ab.mat4.create();
                    k[12] += 2 * d / (s.q.devicePixelRatio * E.width),
                    k[13] += 2 * m / (s.q.devicePixelRatio * E.height),
                    s.ab.mat4.multiply(D, k, D);
                    const H = c.getOrCreateProgram("debug", {
                        defines: R
                    })
                      , j = t.getTileByID(i.key);
                    c.terrain && c.terrain.setupElevationDraw(j, H);
                    const Y = Fo.disabled
                      , K = Xo.disabled
                      , he = c.colorModeForRenderPass();
                    M.activeTexture.set(S.TEXTURE0),
                    c.emptyTexture.bind(S.LINEAR, S.CLAMP_TO_EDGE),
                    I ? j._makeGlobeTileDebugBuffers(c.context, E) : j._makeDebugTileBoundsBuffers(c.context, E.projection);
                    const be = j._tileDebugBuffer || c.debugBuffer
                      , Ue = j._tileDebugIndexBuffer || c.debugIndexBuffer
                      , De = j._tileDebugSegments || c.debugSegments;
                    if (H.draw(c, S.LINE_STRIP, Y, K, he, zo.disabled, Q(D, h), "$debug", be, Ue, De, null, null, null, [j._globeTileDebugBorderBuffer]),
                    y) {
                        const dt = j.latestRawTileData
                          , Ze = Math.floor((dt && dt.byteLength || 0) / 1024);
                        let nt = i.canonical.toString();
                        i.overscaledZ !== i.canonical.z && (nt += " => ".concat(i.overscaledZ)),
                        nt += " ".concat(j.state),
                        nt += " ".concat(Ze, "kb"),
                        function(zt, Yt) {
                            zt.initDebugOverlayCanvas();
                            const to = zt.debugOverlayCanvas
                              , ut = zt.context.gl
                              , Gt = zt.debugOverlayCanvas.getContext("2d");
                            Gt.clearRect(0, 0, to.width, to.height),
                            Gt.shadowColor = "white",
                            Gt.shadowBlur = 2,
                            Gt.lineWidth = 1.5,
                            Gt.strokeStyle = "white",
                            Gt.textBaseline = "top",
                            Gt.font = "bold 36px Open Sans, sans-serif",
                            Gt.fillText(Yt, 5, 5),
                            Gt.strokeText(Yt, 5, 5),
                            zt.debugOverlayTexture.update(to),
                            zt.debugOverlayTexture.bind(ut.LINEAR, ut.CLAMP_TO_EDGE)
                        }(c, nt)
                    }
                    const ke = t.getTile(i).tileSize
                      , Le = 512 / Math.min(ke, 512) * (i.overscaledZ / E.zoom) * .5
                      , Ge = j._tileDebugTextBuffer || c.debugBuffer
                      , qe = j._tileDebugTextIndexBuffer || c.quadTriangleIndexBuffer
                      , vt = j._tileDebugTextSegments || c.debugSegments;
                    H.draw(c, S.TRIANGLES, Y, K, si.alphaBlended, zo.disabled, Q(D, s.aj.transparent, Le), "$debug", Ge, qe, vt, null, null, null, [j._globeTileDebugTextBuffer])
                }
                function xc(c, t, i, h) {
                    bc(c, 0, t + i / 2, c.transform.width, i, h)
                }
                function xh(c, t, i, h) {
                    bc(c, t - i / 2, 0, i, c.transform.height, h)
                }
                function bc(c, t, i, h, d, m) {
                    const y = c.context
                      , M = y.gl;
                    M.enable(M.SCISSOR_TEST),
                    M.scissor(t * s.q.devicePixelRatio, i * s.q.devicePixelRatio, h * s.q.devicePixelRatio, d * s.q.devicePixelRatio),
                    y.clear({
                        color: m
                    }),
                    M.disable(M.SCISSOR_TEST)
                }
                const yp = s.da([{
                    name: "a_pos_3f",
                    components: 3,
                    type: "Float32"
                }])
                  , {members: bh} = yp;
                function Qr(c, t, i, h) {
                    c.emplaceBack(t, i, h)
                }
                class es {
                    constructor(t) {
                        this.vertexArray = new s.de,
                        this.indices = new s.aU,
                        Qr(this.vertexArray, -1, -1, 1),
                        Qr(this.vertexArray, 1, -1, 1),
                        Qr(this.vertexArray, -1, 1, 1),
                        Qr(this.vertexArray, 1, 1, 1),
                        Qr(this.vertexArray, -1, -1, -1),
                        Qr(this.vertexArray, 1, -1, -1),
                        Qr(this.vertexArray, -1, 1, -1),
                        Qr(this.vertexArray, 1, 1, -1),
                        this.indices.emplaceBack(5, 1, 3),
                        this.indices.emplaceBack(3, 7, 5),
                        this.indices.emplaceBack(6, 2, 0),
                        this.indices.emplaceBack(0, 4, 6),
                        this.indices.emplaceBack(2, 6, 7),
                        this.indices.emplaceBack(7, 3, 2),
                        this.indices.emplaceBack(5, 4, 0),
                        this.indices.emplaceBack(0, 1, 5),
                        this.indices.emplaceBack(0, 2, 3),
                        this.indices.emplaceBack(3, 1, 0),
                        this.indices.emplaceBack(7, 6, 4),
                        this.indices.emplaceBack(4, 5, 7),
                        this.vertexBuffer = t.createVertexBuffer(this.vertexArray, bh),
                        this.indexBuffer = t.createIndexBuffer(this.indices),
                        this.segment = s.b7.simpleSegment(0, 0, 36, 12)
                    }
                }
                function ka(c, t, i, h, d, m) {
                    const y = c.context.gl
                      , M = t.paint.get("sky-atmosphere-color")
                      , E = t.paint.get("sky-atmosphere-halo-color")
                      , S = t.paint.get("sky-atmosphere-sun-intensity")
                      , I = {
                        u_matrix_3f: s.ab.mat3.fromMat4(s.ab.mat3.create(), h),
                        u_sun_direction: d,
                        u_sun_intensity: S,
                        u_color_tint_r: [(H = M).r, H.g, H.b, H.a],
                        u_color_tint_m: [(j = E).r, j.g, j.b, j.a],
                        u_luminance: 5e-5
                    };
                    var H, j;
                    y.framebufferTexture2D(y.FRAMEBUFFER, y.COLOR_ATTACHMENT0, y.TEXTURE_CUBE_MAP_POSITIVE_X + m, t.skyboxTexture, 0),
                    i.draw(c, y.TRIANGLES, Fo.disabled, Xo.disabled, si.unblended, zo.frontCW, I, "skyboxCapture", t.skyboxGeometry.vertexBuffer, t.skyboxGeometry.indexBuffer, t.skyboxGeometry.segment)
                }
                const Cd = s.da([{
                    type: "Float32",
                    name: "a_pos",
                    components: 3
                }, {
                    type: "Float32",
                    name: "a_uv",
                    components: 2
                }]);
                class dr {
                    constructor(t) {
                        const i = new s.df;
                        i.emplaceBack(-1, 1, 1, 0, 0),
                        i.emplaceBack(1, 1, 1, 1, 0),
                        i.emplaceBack(1, -1, 1, 1, 1),
                        i.emplaceBack(-1, -1, 1, 0, 1);
                        const h = new s.aU;
                        h.emplaceBack(0, 1, 2),
                        h.emplaceBack(2, 3, 0),
                        this.vertexBuffer = t.createVertexBuffer(i, Cd.members),
                        this.indexBuffer = t.createIndexBuffer(h),
                        this.segments = s.b7.simpleSegment(0, 0, 4, 2)
                    }
                    destroy() {
                        this.vertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.segments.destroy()
                    }
                }
                const Ed = s.da([{
                    type: "Float32",
                    name: "a_pos_3f",
                    components: 3
                }, {
                    type: "Float32",
                    name: "a_uv",
                    components: 2
                }, {
                    type: "Float32",
                    name: "a_size_scale",
                    components: 1
                }, {
                    type: "Float32",
                    name: "a_fade_opacity",
                    components: 1
                }]);
                class wc {
                    constructor() {
                        this.starsCount = 16e3,
                        this.sizeMultiplier = .15,
                        this.sizeRange = 100,
                        this.intensityRange = 200
                    }
                }
                class tn {
                    constructor(t) {
                        this.colorModeAlphaBlendedWriteRGB = new si([1, 771, 1, 771],s.aj.transparent,[!0, !0, !0, !1]),
                        this.colorModeWriteAlpha = new si([1, 0, 1, 0],s.aj.transparent,[!1, !1, !1, !0]),
                        this.params = new wc,
                        this.updateNeeded = !0,
                        t.tp.registerParameter(this.params, ["Stars"], "starsCount", {
                            min: 100,
                            max: 16e3,
                            step: 1
                        }, () => {
                            this.updateNeeded = !0
                        }
                        ),
                        t.tp.registerParameter(this.params, ["Stars"], "sizeMultiplier", {
                            min: .01,
                            max: 2,
                            step: .01
                        }),
                        t.tp.registerParameter(this.params, ["Stars"], "sizeRange", {
                            min: 0,
                            max: 200,
                            step: 1
                        }, () => {
                            this.updateNeeded = !0
                        }
                        ),
                        t.tp.registerParameter(this.params, ["Stars"], "intensityRange", {
                            min: 0,
                            max: 200,
                            step: 1
                        }, () => {
                            this.updateNeeded = !0
                        }
                        )
                    }
                    update(t) {
                        const i = t.context;
                        if (!this.atmosphereBuffer || this.updateNeeded) {
                            this.updateNeeded = !1,
                            this.atmosphereBuffer = new dr(i);
                            const h = this.params.sizeRange
                              , d = this.params.intensityRange
                              , m = function(I) {
                                const R = s.di(30)
                                  , D = [];
                                for (let k = 0; k < I; ++k) {
                                    const H = 2 * Math.PI * R()
                                      , j = Math.acos(1 - 2 * R()) - .5 * Math.PI;
                                    D.push(s.ab.vec3.fromValues(Math.cos(j) * Math.cos(H), Math.cos(j) * Math.sin(H), Math.sin(j)))
                                }
                                return D
                            }(this.params.starsCount)
                              , y = s.di(300)
                              , M = new s.dg
                              , E = new s.aU;
                            let S = 0;
                            for (let I = 0; I < m.length; ++I) {
                                const R = s.ab.vec3.scale([], m[I], 200)
                                  , D = Math.max(0, 1 + .01 * h * (1 * y() - .5))
                                  , k = Math.max(0, 1 + .01 * d * (1 * y() - .5));
                                M.emplaceBack(R[0], R[1], R[2], -1, -1, D, k),
                                M.emplaceBack(R[0], R[1], R[2], 1, -1, D, k),
                                M.emplaceBack(R[0], R[1], R[2], 1, 1, D, k),
                                M.emplaceBack(R[0], R[1], R[2], -1, 1, D, k),
                                E.emplaceBack(S + 0, S + 1, S + 2),
                                E.emplaceBack(S + 0, S + 2, S + 3),
                                S += 4
                            }
                            this.starsVx = i.createVertexBuffer(M, Ed.members),
                            this.starsIdx = i.createIndexBuffer(E),
                            this.starsSegments = s.b7.simpleSegment(0, 0, M.length, E.length)
                        }
                    }
                    destroy() {
                        this.atmosphereBuffer && this.atmosphereBuffer.destroy(),
                        this.starsVx && this.starsVx.destroy(),
                        this.starsIdx && this.starsIdx.destroy()
                    }
                    drawAtmosphereGlow(t, i) {
                        const h = t.context
                          , d = h.gl
                          , m = t.transform
                          , y = new Fo(d.LEQUAL,Fo.ReadOnly,[0, 1])
                          , M = s.ae(m.zoom)
                          , E = t.style.getLut(i.scope)
                          , S = "none" === i.properties.get("color-use-theme")
                          , I = i.properties.get("color").toRenderColor(S ? null : E).toArray01()
                          , R = "none" === i.properties.get("high-color-use-theme")
                          , D = i.properties.get("high-color").toRenderColor(R ? null : E).toArray01()
                          , k = "none" === i.properties.get("space-color-use-theme")
                          , H = i.properties.get("space-color").toRenderColor(k ? null : E).toArray01PremultipliedAlpha()
                          , j = 5e-4
                          , Y = s.dh(i.properties.get("horizon-blend"), 0, 1, j, .25)
                          , K = s.cC(t, h, m) && Y === j ? m.worldSize / (2 * Math.PI * 1.025) - 1 : m.globeRadius
                          , he = t.frameCounter / 1e3 % 1
                          , Te = s.ab.vec3.length(m.globeCenterInViewSpace)
                          , be = Math.sqrt(Math.pow(Te, 2) - Math.pow(K, 2))
                          , Ue = Math.acos(be / Te)
                          , De = ke => {
                            const Le = "globe" === m.projection.name ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"];
                            ke && Le.push("ALPHA_PASS");
                            const Ge = t.getOrCreateProgram("globeAtmosphere", {
                                defines: Le
                            })
                              , qe = ( (dt, Ze, nt, zt, Yt, to, ut, Gt, wt, qt, Ht, Dt) => ({
                                u_frustum_tl: dt,
                                u_frustum_tr: Ze,
                                u_frustum_br: nt,
                                u_frustum_bl: zt,
                                u_horizon: Yt,
                                u_transition: to,
                                u_fadeout_range: ut,
                                u_color: Gt,
                                u_high_color: wt,
                                u_space_color: qt,
                                u_temporal_offset: Ht,
                                u_horizon_angle: Dt
                            }))(m.frustumCorners.TL, m.frustumCorners.TR, m.frustumCorners.BR, m.frustumCorners.BL, m.frustumCorners.horizon, M, Y, I, D, H, he, Ue);
                            t.uploadCommonUniforms(h, Ge);
                            const vt = this.atmosphereBuffer;
                            vt && Ge.draw(t, d.TRIANGLES, y, Xo.disabled, ke ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, zo.backCW, qe, ke ? "atmosphere_glow_alpha" : "atmosphere_glow", vt.vertexBuffer, vt.indexBuffer, vt.segments)
                        }
                        ;
                        De(!1),
                        De(!0)
                    }
                    drawStars(t, i) {
                        const h = s.aw(i.properties.get("star-intensity"), 0, 1);
                        if (0 === h)
                            return;
                        const d = t.context
                          , m = d.gl
                          , y = t.transform
                          , M = t.getOrCreateProgram("stars")
                          , E = s.ab.quat.identity([]);
                        s.ab.quat.rotateX(E, E, -y._pitch),
                        s.ab.quat.rotateZ(E, E, -y.angle),
                        s.ab.quat.rotateX(E, E, s.ai(y._center.lat)),
                        s.ab.quat.rotateY(E, E, -s.ai(y._center.lng));
                        const S = s.ab.mat4.fromQuat(new Float32Array(16), E)
                          , I = s.ab.mat4.multiply([], y.starsProjMatrix, S)
                          , R = s.ab.mat3.fromMat4([], S)
                          , D = s.ab.mat3.invert([], R)
                          , k = [0, 1, 0];
                        s.ab.vec3.transformMat3(k, k, D),
                        s.ab.vec3.scale(k, k, this.params.sizeMultiplier);
                        const H = [1, 0, 0];
                        s.ab.vec3.transformMat3(H, H, D),
                        s.ab.vec3.scale(H, H, this.params.sizeMultiplier);
                        const j = (Y = k,
                        K = H,
                        he = h,
                        {
                            u_matrix: Float32Array.from(I),
                            u_up: Y,
                            u_right: K,
                            u_intensity_multiplier: he
                        });
                        var Y, K, he;
                        t.uploadCommonUniforms(d, M),
                        this.starsVx && this.starsIdx && M.draw(t, m.TRIANGLES, Fo.disabled, Xo.disabled, this.colorModeAlphaBlendedWriteRGB, zo.disabled, j, "atmosphere_stars", this.starsVx, this.starsIdx, this.starsSegments)
                    }
                }
                function Si(c, t) {
                    const i = [...c]
                      , h = t.cameraWorldSizeForFog / t.worldSize
                      , d = s.ab.mat4.identity([]);
                    return s.ab.mat4.scale(d, d, [h, h, 1]),
                    s.ab.mat4.multiply(i, d, i),
                    s.ab.mat4.multiply(i, t.worldToFogMatrix, i),
                    i
                }
                function wh(c, t, i, h, d) {
                    const m = i.material
                      , y = h.context
                      , {baseColorTexture: M, metallicRoughnessTexture: E} = m.pbrMetallicRoughness
                      , {normalTexture: S, occlusionTexture: I, emissionTexture: R} = m;
                    function D(H, j, Y) {
                        if (H && (c.push(j),
                        y.activeTexture.set(y.gl.TEXTURE0 + Y),
                        H.gfxTexture)) {
                            const {minFilter: K, magFilter: he, wrapS: Te, wrapT: be} = H.sampler;
                            H.gfxTexture.bindExtraParam(K, he, Te, be)
                        }
                    }
                    D(M, "HAS_TEXTURE_u_baseColorTexture", wn_BaseColor),
                    D(E, "HAS_TEXTURE_u_metallicRoughnessTexture", wn_MetallicRoughness),
                    D(S, "HAS_TEXTURE_u_normalTexture", wn_Normal),
                    D(I, "HAS_TEXTURE_u_occlusionTexture", wn_Occlusion),
                    D(R, "HAS_TEXTURE_u_emissionTexture", wn_Emission),
                    d && (d.texture || (d.texture = new s.dk(h.context,d.image,[d.image.height, d.image.height, d.image.height],y.gl.RGBA8)),
                    y.activeTexture.set(y.gl.TEXTURE0 + wn_LUT),
                    d.texture && d.texture.bind(y.gl.LINEAR, y.gl.CLAMP_TO_EDGE),
                    c.push("APPLY_LUT_ON_GPU")),
                    i.texcoordBuffer && (c.push("HAS_ATTRIBUTE_a_uv_2f"),
                    t.push(i.texcoordBuffer)),
                    i.colorBuffer && (c.push(12 === i.colorBuffer.itemSize ? "HAS_ATTRIBUTE_a_color_3f" : "HAS_ATTRIBUTE_a_color_4f"),
                    t.push(i.colorBuffer)),
                    i.normalBuffer && (c.push("HAS_ATTRIBUTE_a_normal_3f"),
                    t.push(i.normalBuffer)),
                    i.pbrBuffer && (c.push("HAS_ATTRIBUTE_a_pbr"),
                    c.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"),
                    t.push(i.pbrBuffer)),
                    "OPAQUE" !== m.alphaMode && "MASK" !== m.alphaMode || c.push("UNPREMULT_TEXTURE_IN_SHADER"),
                    m.defined || c.push("DIFFUSE_SHADED"),
                    c.push("USE_STANDARD_DERIVATIVES");
                    const k = h.shadowRenderer;
                    k && (c.push("RENDER_SHADOWS", "DEPTH_TEXTURE"),
                    k.useNormalOffset && c.push("NORMAL_OFFSET"))
                }
                function ts(c, t, i, h, d, m) {
                    const y = i.paint.get("model-opacity").constantOr(1)
                      , M = t.context
                      , E = new Fo(t.context.gl.LEQUAL,Fo.ReadWrite,t.depthRangeFor3D)
                      , S = t.transform
                      , I = c.mesh
                      , R = I.material
                      , D = R.pbrMetallicRoughness
                      , k = t.style.fog;
                    let H;
                    H = "pixels" === t.transform.projection.zAxisUnit ? [...c.nodeModelMatrix] : s.ab.mat4.multiply([], h.zScaleMatrix, c.nodeModelMatrix),
                    s.ab.mat4.multiply(H, h.negCameraPosMatrix, H);
                    const j = s.ab.mat4.invert([], H);
                    s.ab.mat4.transpose(j, j);
                    const Y = "none" === i.paint.get("model-color-use-theme").constantOr("default")
                      , K = i.paint.get("model-emissive-strength").constantOr(0)
                      , he = Pn(new Float32Array(c.worldViewProjection), new Float32Array(H), new Float32Array(j), null, t, y, D.baseColorFactor.toRenderColor(null), R.emissiveFactor, D.metallicFactor, D.roughnessFactor, R, K, i)
                      , Te = {
                        defines: []
                    }
                      , be = []
                      , Ue = t.shadowRenderer;
                    Ue && (Ue.useNormalOffset = !1),
                    wh(Te.defines, be, I, t, Y ? null : i.lut);
                    let De = null;
                    if (k) {
                        const Ge = Si(c.nodeModelMatrix, t.transform);
                        if (De = new Float32Array(Ge),
                        "globe" !== S.projection.name) {
                            const qe = I.aabb.min
                              , vt = I.aabb.max
                              , [dt,Ze] = k.getOpacityForBounds(Ge, qe[0], qe[1], vt[0], vt[1]);
                            Te.overrideFog = dt >= wo || Ze >= wo
                        }
                    }
                    const ke = Kr(t, i.paint.get("model-cutoff-fade-range"));
                    ke.shouldRenderCutoff && Te.defines.push("RENDER_CUTOFF");
                    const Le = t.getOrCreateProgram("model", Te);
                    t.uploadCommonUniforms(M, Le, null, De, ke),
                    "shadow" !== t.renderPass && Ue && Ue.setupShadowsFromMatrix(c.nodeModelMatrix, Le),
                    Le.draw(t, M.gl.TRIANGLES, E, d, m, I.material.doubleSided ? zo.disabled : zo.backCCW, he, i.id, I.vertexBuffer, I.indexBuffer, I.segments, i.paint, t.transform.zoom, void 0, be)
                }
                function Pc(c, t, i, h, d, m, y) {
                    let M;
                    M = "globe" === c.projection.name ? s.dl(i, c) : [...i],
                    s.ab.mat4.multiply(M, M, t.matrix);
                    const E = s.ab.mat4.multiply([], h, M);
                    if (t.meshes)
                        for (const S of t.meshes) {
                            if ("BLEND" !== S.material.alphaMode) {
                                y.push({
                                    mesh: S,
                                    depth: 0,
                                    modelIndex: d,
                                    worldViewProjection: E,
                                    nodeModelMatrix: M
                                });
                                continue
                            }
                            const I = s.ab.vec3.transformMat4([], S.centroid, E);
                            I[2] > 0 && m.push({
                                mesh: S,
                                depth: I[2],
                                modelIndex: d,
                                worldViewProjection: E,
                                nodeModelMatrix: M
                            })
                        }
                    if (t.children)
                        for (const S of t.children)
                            Pc(c, S, i, h, d, m, y)
                }
                function ha(c, t, i, h) {
                    const d = i.shadowRenderer;
                    if (!d)
                        return;
                    const m = d.getShadowPassDepthMode()
                      , y = d.getShadowPassColorMode()
                      , M = d.calculateShadowPassMatrixFromMatrix(t)
                      , E = _n(M);
                    i.getOrCreateProgram("modelDepth", {
                        defines: i._shadowMapDebug ? [] : ["DEPTH_TEXTURE"]
                    }).draw(i, i.context.gl.TRIANGLES, m, Xo.disabled, y, zo.backCCW, E, h.id, c.vertexBuffer, c.indexBuffer, c.segments, h.paint, i.transform.zoom, void 0, void 0)
                }
                function yu(c, t, i) {
                    const h = t.updateZoomBasedPaintProperties()
                      , d = function(m, y, M) {
                        let E, S, I, R = m.terrain ? m.terrain.exaggeration() : 0;
                        if (m.terrain && R > 0) {
                            const D = m.terrain
                              , k = D.findDEMTileFor(M);
                            k && k.dem ? E = s.dn.create(D, M, k) : R = 0
                        }
                        if (0 === R && (y.terrainElevationMin = 0,
                        y.terrainElevationMax = 0),
                        R === y.validForExaggeration && (0 === R || E && E._demTile && E._demTile.tileID === y.validForDEMTile.id && E._dem._timestamp === y.validForDEMTile.timestamp))
                            return !1;
                        for (const D in y.instancesPerModel) {
                            const k = y.instancesPerModel[D];
                            for (let H = 0; H < k.instancedDataArray.length; ++H) {
                                const j = (E ? R * E.getElevationAt(0 | k.instancedDataArray.float32[16 * H], 0 | k.instancedDataArray.float32[16 * H + 1], !0, !0) : 0) + k.instancesEvaluatedElevation[H];
                                k.instancedDataArray.float32[16 * H + 6] = j,
                                S = S ? Math.min(y.terrainElevationMin, j) : j,
                                I = I ? Math.max(y.terrainElevationMax, j) : j
                            }
                        }
                        return y.terrainElevationMin = S || 0,
                        y.terrainElevationMax = I || 0,
                        y.validForExaggeration = R,
                        y.validForDEMTile = E && E._demTile ? {
                            id: E._demTile.tileID,
                            timestamp: E._dem._timestamp
                        } : {
                            id: void 0,
                            timestamp: 0
                        },
                        !0
                    }(c, t, i);
                    (h || d) && (t.uploaded = !1,
                    t.upload(c.context))
                }
                const $r = {
                    shadowUniformsInitialized: !1,
                    useSingleShadowCascade: !1,
                    tileMatrix: new Float64Array(16),
                    shadowTileMatrix: new Float32Array(16),
                    aabb: new s.cd([0, 0, 0],[s.ag, s.ag, 0])
                };
                function ua(c, t) {
                    const i = 1 << c.canonical.z
                      , h = t.getFreeCameraOptions().position
                      , d = t.elevation
                      , m = c.canonical.x / i
                      , y = (c.canonical.x + 1) / i
                      , M = c.canonical.y / i
                      , E = (c.canonical.y + 1) / i;
                    let S = t._centerAltitude;
                    if (d) {
                        const k = d.getMinMaxForTile(c);
                        k && k.max > S && (S = k.max)
                    }
                    const I = s.aw(h.x, m, y) - h.x
                      , R = s.aw(h.y, M, E) - h.y
                      , D = s.bH(S, t.center.lat) - h.z;
                    return t._zoomFromMercatorZ(Math.sqrt(I * I + R * R + D * D))
                }
                function Ds(c, t, i, h, d, m, y) {
                    const M = c.context
                      , E = "shadow" === c.renderPass
                      , S = c.shadowRenderer
                      , I = E && S ? S.getShadowPassDepthMode() : new Fo(M.gl.LEQUAL,Fo.ReadWrite,c.depthRangeFor3D)
                      , R = c.isTileAffectedByFog(m);
                    if (i.meshes)
                        for (const D of i.meshes) {
                            const k = ["MODEL_POSITION_ON_GPU"]
                              , H = [];
                            let j, Y, K;
                            h.instancedDataArray.length > 20 && k.push("INSTANCED_ARRAYS");
                            const he = Kr(c, t.paint.get("model-cutoff-fade-range"));
                            if (he.shouldRenderCutoff && k.push("RENDER_CUTOFF"),
                            E && S)
                                j = c.getOrCreateProgram("modelDepth", {
                                    defines: k
                                }),
                                Y = _n(y.shadowTileMatrix, y.shadowTileMatrix, Float32Array.from(i.matrix)),
                                K = S.getShadowPassColorMode();
                            else {
                                wh(k, H, D, c, "none" === t.paint.get("model-color-use-theme").constantOr("default") ? null : t.lut),
                                j = c.getOrCreateProgram("model", {
                                    defines: k,
                                    overrideFog: R
                                });
                                const be = D.material
                                  , Ue = be.pbrMetallicRoughness
                                  , De = t.paint.get("model-opacity").constantOr(1)
                                  , ke = t.paint.get("model-emissive-strength").constantOr(0);
                                Y = Pn(m.expandedProjMatrix, Float32Array.from(i.matrix), new Float32Array(16), null, c, De, Ue.baseColorFactor.toRenderColor(null), be.emissiveFactor, Ue.metallicFactor, Ue.roughnessFactor, be, ke, t, d),
                                S && (y.shadowUniformsInitialized ? j.setShadowUniformValues(M, S.getShadowUniformValues()) : (S.setupShadows(m.toUnwrapped(), j, "model-tile", m.overscaledZ),
                                y.shadowUniformsInitialized = !0)),
                                K = he.shouldRenderCutoff || De < 1 || "OPAQUE" !== be.alphaMode ? si.alphaBlended : si.unblended
                            }
                            c.uploadCommonUniforms(M, j, m.toUnwrapped(), null, he);
                            const Te = D.material.doubleSided ? zo.disabled : zo.backCCW;
                            if (h.instancedDataArray.length > 20)
                                H.push(h.instancedDataBuffer),
                                j.draw(c, M.gl.TRIANGLES, I, Xo.disabled, K, Te, Y, t.id, D.vertexBuffer, D.indexBuffer, D.segments, t.paint, c.transform.zoom, void 0, H, h.instancedDataArray.length);
                            else {
                                const be = E ? "u_instance" : "u_normal_matrix";
                                for (let Ue = 0; Ue < h.instancedDataArray.length; ++Ue)
                                    Y[be] = new Float32Array(h.instancedDataArray.arrayBuffer,64 * Ue,16),
                                    j.draw(c, M.gl.TRIANGLES, I, Xo.disabled, K, Te, Y, t.id, D.vertexBuffer, D.indexBuffer, D.segments, t.paint, c.transform.zoom, void 0, H)
                            }
                        }
                    if (i.children)
                        for (const D of i.children)
                            Ds(c, t, D, h, d, m, y)
                }
                const pa = [1, -1, 1];
                function Ph(c, t, i, h) {
                    if (!i.modelManager)
                        return !0;
                    const d = i.modelManager;
                    if (!i.shadowRenderer)
                        return !0;
                    const m = i.shadowRenderer
                      , y = t.aabb;
                    let M = !0
                      , E = c.maxHeight;
                    if (0 === E) {
                        let I = 0;
                        for (const R in c.instancesPerModel) {
                            const D = d.getModel(R, h);
                            D ? I = Math.max(I, Math.max(Math.max(D.aabb.max[0], D.aabb.max[1]), D.aabb.max[2])) : M = !1
                        }
                        E = c.maxScale * I * 1.41 + c.maxVerticalOffset,
                        M && (c.maxHeight = E)
                    }
                    y.max[2] = E,
                    y.min[2] += c.terrainElevationMin,
                    y.max[2] += c.terrainElevationMax,
                    s.ab.vec3.transformMat4(y.min, y.min, t.tileMatrix),
                    s.ab.vec3.transformMat4(y.max, y.max, t.tileMatrix);
                    const S = y.intersects(m.getCurrentCascadeFrustum());
                    return 0 === i.currentShadowCascade && (c.isInsideFirstShadowMapFrustum = 2 === S),
                    0 === S
                }
                function Mh(c, t) {
                    const i = c.uniformValues.u_cutoff_params[0]
                      , h = c.uniformValues.u_cutoff_params[1]
                      , d = c.uniformValues.u_cutoff_params[2]
                      , m = c.uniformValues.u_cutoff_params[3];
                    return h === i || m === d ? 1 : s.aw(((t - i) / (h - i) - d) / (m - d), 0, 1)
                }
                function vu(c, t, i, h) {
                    if (t.pitch < 20)
                        return 1;
                    const d = t.getWorldToCameraMatrix();
                    s.ab.mat4.multiply(d, d, c);
                    const m = s.ab.vec4.fromValues(i.min[0], i.min[1], i.min[2], 1);
                    let y = s.ab.vec4.transformMat4(s.ab.vec4.create(), m, d)
                      , M = y
                      , E = y;
                    m[1] = i.max[1],
                    y = s.ab.vec4.transformMat4(s.ab.vec4.create(), m, d),
                    M = y[1] < M[1] ? y : M,
                    E = y[1] > E[1] ? y : E,
                    m[0] = i.max[0],
                    y = s.ab.vec4.transformMat4(s.ab.vec4.create(), m, d),
                    M = y[1] < M[1] ? y : M,
                    E = y[1] > E[1] ? y : E,
                    m[1] = i.min[1],
                    y = s.ab.vec4.transformMat4(s.ab.vec4.create(), m, d),
                    M = y[1] < M[1] ? y : M,
                    E = y[1] > E[1] ? y : E;
                    const S = s.aw(h[0], 0, 1)
                      , I = 100 * t.pixelsPerMeter * s.aw(h[1], 0, 1)
                      , R = s.aw(h[2], 0, 1)
                      , D = s.ab.vec4.lerp(s.ab.vec4.create(), M, E, S)
                      , k = Math.tan(.5 * t.fovX)
                      , H = -D[2] * k;
                    if (0 === I)
                        return D[1] < -Math.abs(H) ? R : 1;
                    const j = (-Math.abs(H) - D[1]) / I
                      , Y = (he, Te, be) => (1 - be) * he + be * Te
                      , K = s.aw(Y(1, R, j), R, 1);
                    return Y(1, K, s.aw((t.pitch - 20) / 20, 0, 1))
                }
                class xu {
                }
                class bu {
                    constructor() {
                        this._storage = new Map
                    }
                    getLinesFromTrianglesBuffer(t, i, h) {
                        {
                            const R = this._storage.get(i.id);
                            if (R)
                                return R.lastUsedFrameIdx = t,
                                R.buf
                        }
                        const d = h.gl
                          , m = d.getBufferParameter(d.ELEMENT_ARRAY_BUFFER, d.BUFFER_SIZE)
                          , y = new ArrayBuffer(m)
                          , M = new Int16Array(y);
                        d.getBufferSubData(d.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(y));
                        const E = new s.dq;
                        for (let R = 0; R < m / 2; R += 3) {
                            const D = M[R]
                              , k = M[R + 1]
                              , H = M[R + 2];
                            E.emplaceBack(D, k),
                            E.emplaceBack(k, H),
                            E.emplaceBack(H, D)
                        }
                        const S = h.bindVertexArrayOES.current
                          , I = new xu;
                        return I.buf = new Oi(h,E),
                        I.lastUsedFrameIdx = t,
                        this._storage.set(i.id, I),
                        h.bindVertexArrayOES.set(S),
                        I.buf
                    }
                    update(t) {
                        for (const [i,h] of this._storage)
                            t - h.lastUsedFrameIdx > 30 && (h.buf.destroy(),
                            this._storage.delete(i))
                    }
                    destroy() {
                        for (const [t,i] of this._storage)
                            i.buf.destroy(),
                            this._storage.delete(t)
                    }
                }
                class da {
                    constructor(t) {
                        this.occluderSize = 30,
                        this.depthOffset = -1e-4,
                        t.registerParameter(this, ["Occlusion"], "occluderSize", {
                            min: 1,
                            max: 100,
                            step: 1
                        }),
                        t.registerParameter(this, ["Occlusion"], "depthOffset", {
                            min: -.05,
                            max: 0,
                            step: 1e-5
                        })
                    }
                }
                const wu = s.da([{
                    type: "Float32",
                    name: "a_pos_3f",
                    components: 3
                }, {
                    type: "Float32",
                    name: "a_uv",
                    components: 2
                }, {
                    type: "Float32",
                    name: "a_rainParticleData",
                    components: 4
                }]);
                class Th {
                    registerParameter() {}
                    registerButton() {}
                    registerBinding() {}
                    refreshUI() {}
                }
                class Ch {
                    constructor(t, i) {
                        this.revealStart = 11,
                        this.revealRange = 2,
                        t.registerParameter(this, [...i, "Reveal"], "revealStart", {
                            min: 0,
                            max: 17,
                            step: .05
                        }),
                        t.registerParameter(this, [...i, "Reveal"], "revealRange", {
                            min: .1,
                            max: 5.1,
                            step: .05
                        })
                    }
                }
                const Pu = s.da([{
                    type: "Float32",
                    name: "a_pos_2f",
                    components: 2
                }]);
                class Xn {
                    destroy() {
                        this.vignetteVx && this.vignetteVx.destroy(),
                        this.vignetteIdx && this.vignetteIdx.destroy()
                    }
                    draw(t, i) {
                        const h = t.getOrCreateProgram("vignette");
                        if (!this.vignetteVx || !this.vignetteIdx) {
                            const y = new s.dr
                              , M = new s.aU;
                            y.emplaceBack(-1, -1),
                            y.emplaceBack(1, -1),
                            y.emplaceBack(1, 1),
                            y.emplaceBack(-1, 1),
                            M.emplaceBack(0, 1, 2),
                            M.emplaceBack(0, 2, 3),
                            this.vignetteVx = t.context.createVertexBuffer(y, Pu.members),
                            this.vignetteIdx = t.context.createIndexBuffer(M)
                        }
                        const d = s.b7.simpleSegment(0, 0, 4, 6);
                        if (this.vignetteVx && this.vignetteIdx) {
                            t.uploadCommonUniforms(t.context, h);
                            const y = {
                                u_vignetteShape: (m = {
                                    vignetteShape: [i.start, i.range, Math.pow(10, i.fadePower)],
                                    vignetteColor: [i.color.r, i.color.g, i.color.b, i.color.a * i.strength]
                                }).vignetteShape,
                                u_vignetteColor: m.vignetteColor
                            };
                            h.draw(t, t.context.gl.TRIANGLES, Fo.disabled, Xo.disabled, si.alphaBlended, zo.disabled, y, "vignette", this.vignetteVx, this.vignetteIdx, d, {})
                        }
                        var m
                    }
                }
                class Mu {
                    constructor() {
                        this._accumulatedOffsetX = 0,
                        this._accumulatedOffsetY = 0,
                        this._accumulatedElevation = 0
                    }
                    update(t, i) {
                        const h = t.getFreeCameraOptions().position
                          , d = h.toAltitude()
                          , m = h.toLngLat()
                          , y = s.ai(m.lng)
                          , M = s.ai(m.lat)
                          , E = t.pixelsPerMeter / i
                          , S = y * s.ds
                          , I = s.ds * Math.log(Math.tan(Math.PI / 4 + M / 2));
                        if (void 0 === this._offsetXPrev)
                            this._offsetXPrev = 0,
                            this._offsetYPrev = 0,
                            this._elevationPrev = 0,
                            this._accumulatedOffsetX = 0,
                            this._accumulatedOffsetY = 0,
                            this._accumulatedElevation = 0;
                        else {
                            const R = -this._offsetYPrev + I
                              , D = -this._elevationPrev + d;
                            this._accumulatedOffsetX += (-this._offsetXPrev + S) * E,
                            this._accumulatedOffsetY += R * E,
                            this._accumulatedElevation += D * E,
                            this._offsetXPrev = S,
                            this._offsetYPrev = I,
                            this._elevationPrev = d
                        }
                    }
                    getPosition() {
                        return [this._accumulatedOffsetX, this._accumulatedOffsetY, this._accumulatedElevation]
                    }
                }
                function Eh(c, t) {
                    return [-(c[0] - Math.floor(c[0] / t) * t), -(c[1] - Math.floor(c[1] / t) * t), -(c[2] - Math.floor(c[2] / t) * t)]
                }
                function Ml(c) {
                    const t = s.di(1323123451230)
                      , i = [];
                    for (let h = 0; h < c; ++h) {
                        const d = 2 * t() - 1
                          , m = 2 * t() - 1
                          , y = 2 * t() - 1;
                        i.push(s.ab.vec3.fromValues(d, m, y))
                    }
                    return i
                }
                function wr(c, t, i, h, d) {
                    const m = s.aw((d - i) / (h - i), 0, 1);
                    return (1 - m) * c + m * t
                }
                class Sh {
                    constructor(t) {
                        this._movement = new Mu,
                        this._accumulatedTimeFromStart = 0,
                        this._prevTime = Date.now() / 1e3,
                        this._vignette = new Xn,
                        this._ppmScaleFactor = t
                    }
                    destroy() {
                        this.particlesVx && this.particlesVx.destroy(),
                        this.particlesIdx && this.particlesIdx.destroy(),
                        this._vignette && this._vignette.destroy()
                    }
                    updateOnRender(t, i) {
                        const h = t.transform;
                        this._movement.update(h, this._ppmScaleFactor);
                        const d = h.starsProjMatrix
                          , m = s.ab.quat.identity([]);
                        s.ab.quat.rotateX(m, m, s.ai(90) - h._pitch),
                        s.ab.quat.rotateZ(m, m, -h.angle);
                        const y = s.ab.mat4.fromQuat(new Float32Array(16), m)
                          , M = s.ab.mat4.fromValues(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1)
                          , E = s.ab.mat4.transpose([], M)
                          , S = s.ab.mat4.multiply([], E, y)
                          , I = Date.now() / 1e3;
                        return this._accumulatedTimeFromStart += (I - this._prevTime) * i,
                        this._prevTime = I,
                        {
                            projectionMatrix: d,
                            modelviewMatrix: S
                        }
                    }
                }
                class Tu extends Sh {
                    constructor(t) {
                        super(4.25),
                        this._params = {
                            overrideStyleParameters: !1,
                            intensity: .5,
                            timeFactor: 1,
                            velocityConeAperture: 0,
                            velocity: 300,
                            boxSize: 2500,
                            dropletSizeX: 1,
                            dropletSizeYScale: 10,
                            distortionStrength: 70,
                            screenThinning: {
                                intensity: .57,
                                start: .46,
                                range: 1.17,
                                fadePower: .17,
                                affectedRatio: 1,
                                particleOffset: -.2
                            },
                            color: {
                                r: .66,
                                g: .68,
                                b: .74,
                                a: .7
                            },
                            direction: {
                                x: -50,
                                y: -35
                            },
                            shapeDirPower: 2,
                            shapeNormalPower: 1
                        },
                        this._revealParams = new Ch(t.tp,["Precipitation", "Rain"]),
                        this._vignetteParams = {
                            strength: 1,
                            start: .7,
                            range: 1,
                            fadePower: .4,
                            color: {
                                r: .27,
                                g: .27,
                                b: .27,
                                a: 1
                            }
                        },
                        this.particlesCount = 16e3
                    }
                    update(t) {
                        const i = t.context;
                        if (!this.particlesVx) {
                            const h = Ml(this.particlesCount)
                              , d = new s.dt
                              , m = new s.aU;
                            let y = 0;
                            const M = s.di(1323123451230);
                            for (let E = 0; E < h.length; ++E) {
                                const S = h[E]
                                  , I = [2 * M() - 1, M(), M(), M()];
                                d.emplaceBack(S[0], S[1], S[2], -1, -1, ...I),
                                d.emplaceBack(S[0], S[1], S[2], 1, -1, ...I),
                                d.emplaceBack(S[0], S[1], S[2], 1, 1, ...I),
                                d.emplaceBack(S[0], S[1], S[2], -1, 1, ...I),
                                m.emplaceBack(y + 0, y + 1, y + 2),
                                m.emplaceBack(y + 0, y + 2, y + 3),
                                y += 4
                            }
                            this.particlesVx = i.createVertexBuffer(d, wu.members),
                            this.particlesIdx = i.createIndexBuffer(m)
                        }
                    }
                    draw(t) {
                        if (!this._params.overrideStyleParameters && !t.style.rain)
                            return;
                        const i = this._params.overrideStyleParameters ? this._revealParams : {
                            revealStart: 0,
                            revealRange: .01
                        }
                          , h = t.transform.zoom;
                        if (i.revealStart > h)
                            return;
                        const d = wr(0, 1, i.revealStart, i.revealStart + i.revealRange, h);
                        if (!this.particlesVx || !this.particlesIdx)
                            return;
                        const m = structuredClone(this._params);
                        let y = [-m.direction.x, m.direction.y, -100];
                        s.ab.vec3.normalize(y, y);
                        const M = structuredClone(this._vignetteParams);
                        M.strength *= d,
                        m.overrideStyleParameters || (m.intensity = t.style.rain.state.density,
                        m.timeFactor = t.style.rain.state.intensity,
                        m.color = structuredClone(t.style.rain.state.color),
                        y = structuredClone(t.style.rain.state.direction),
                        m.screenThinning.intensity = t.style.rain.state.centerThinning,
                        m.dropletSizeX = t.style.rain.state.dropletSize[0],
                        m.dropletSizeYScale = t.style.rain.state.dropletSize[1] / t.style.rain.state.dropletSize[0],
                        m.distortionStrength = 100 * t.style.rain.state.distortionStrength,
                        M.strength = 1,
                        M.color = structuredClone(t.style.rain.state.vignetteColor));
                        const E = this.updateOnRender(t, m.timeFactor)
                          , S = t.context
                          , I = S.gl
                          , R = t.transform;
                        this.screenTexture && this.screenTexture.size[0] === t.width && this.screenTexture.size[1] === t.height || (this.screenTexture = new s.T(S,{
                            width: t.width,
                            height: t.height,
                            data: null
                        },I.RGBA8)),
                        m.distortionStrength > 0 && (S.activeTexture.set(I.TEXTURE0),
                        this.screenTexture.bind(I.LINEAR, I.CLAMP_TO_EDGE),
                        I.copyTexSubImage2D(I.TEXTURE_2D, 0, 0, 0, 0, 0, t.width, t.height));
                        const D = t.getOrCreateProgram("rainParticle");
                        t.uploadCommonUniforms(S, D),
                        S.activeTexture.set(I.TEXTURE0),
                        this.screenTexture.bind(I.LINEAR, I.CLAMP_TO_EDGE);
                        const k = [m.color.r, m.color.g, m.color.b, m.color.a]
                          , H = (j, Y) => {
                            const K = Eh(this._movement.getPosition(), j)
                              , he = m.dropletSizeX
                              , Te = m.dropletSizeX * m.dropletSizeYScale
                              , be = t.width / 2
                              , Ue = t.height / 2
                              , De = wr(0, m.screenThinning.start, 0, 1, m.screenThinning.intensity)
                              , ke = wr(.001, m.screenThinning.range, 0, 1, m.screenThinning.intensity)
                              , Le = wr(0, m.screenThinning.particleOffset, 0, 1, m.screenThinning.intensity)
                              , Ge = (qe = {
                                modelview: E.modelviewMatrix,
                                projection: E.projectionMatrix,
                                time: this._accumulatedTimeFromStart,
                                camPos: K,
                                velocityConeAperture: m.velocityConeAperture,
                                velocity: m.velocity,
                                boxSize: j,
                                rainDropletSize: [he, Te],
                                distortionStrength: m.distortionStrength,
                                rainDirection: y,
                                color: k,
                                screenSize: [R.width, R.height],
                                thinningCenterPos: [be, Ue],
                                thinningShape: [De, ke, Math.pow(10, m.screenThinning.fadePower)],
                                thinningAffectedRatio: m.screenThinning.affectedRatio,
                                thinningParticleOffset: Le,
                                shapeDirectionalPower: m.shapeDirPower,
                                shapeNormalPower: m.shapeNormalPower,
                                mode: Y ? 0 : 1
                            },
                            {
                                u_modelview: Float32Array.from(qe.modelview),
                                u_projection: Float32Array.from(qe.projection),
                                u_time: qe.time,
                                u_cam_pos: qe.camPos,
                                u_texScreen: 0,
                                u_velocityConeAperture: qe.velocityConeAperture,
                                u_velocity: qe.velocity,
                                u_boxSize: qe.boxSize,
                                u_rainDropletSize: qe.rainDropletSize,
                                u_distortionStrength: qe.distortionStrength,
                                u_rainDirection: qe.rainDirection,
                                u_color: qe.color,
                                u_screenSize: qe.screenSize,
                                u_thinningCenterPos: qe.thinningCenterPos,
                                u_thinningShape: qe.thinningShape,
                                u_thinningAffectedRatio: qe.thinningAffectedRatio,
                                u_thinningParticleOffset: qe.thinningParticleOffset,
                                u_shapeDirectionalPower: qe.shapeDirectionalPower,
                                u_shapeNormalPower: qe.shapeNormalPower,
                                u_mode: qe.mode
                            });
                            var qe;
                            const vt = Math.round(d * m.intensity * this.particlesCount)
                              , dt = s.b7.simpleSegment(0, 0, 4 * vt, 2 * vt);
                            D.draw(t, I.TRIANGLES, Fo.disabled, Xo.disabled, si.alphaBlended, zo.disabled, Ge, "rain_particles", this.particlesVx, this.particlesIdx, dt, {})
                        }
                        ;
                        m.distortionStrength > 0 && H(m.boxSize, !0),
                        H(m.boxSize, !1),
                        this._vignette.draw(t, M)
                    }
                }
                const Cu = s.da([{
                    type: "Float32",
                    name: "a_pos_3f",
                    components: 3
                }, {
                    type: "Float32",
                    name: "a_uv",
                    components: 2
                }, {
                    type: "Float32",
                    name: "a_snowParticleData",
                    components: 4
                }, {
                    type: "Float32",
                    name: "a_snowParticleDataHorizontalOscillation",
                    components: 2
                }]);
                class za extends Sh {
                    constructor(t) {
                        super(2.25),
                        this._params = {
                            overrideStyleParameters: !1,
                            intensity: .85,
                            timeFactor: .75,
                            velocityConeAperture: 70,
                            velocity: 40,
                            horizontalOscillationRadius: 4,
                            horizontalOscillationRate: 1.5,
                            boxSize: 2e3,
                            billboardSize: 2,
                            shapeFadeStart: .27,
                            shapeFadePower: .21,
                            screenThinning: {
                                intensity: .4,
                                start: .15,
                                range: 1.4,
                                fadePower: .24,
                                affectedRatio: 1,
                                particleOffset: -.2
                            },
                            color: {
                                r: 1,
                                g: 1,
                                b: 1,
                                a: 1
                            },
                            direction: {
                                x: -50,
                                y: -35
                            }
                        },
                        this._revealParams = new Ch(t.tp,["Precipitation", "Snow"]),
                        this._vignetteParams = {
                            strength: .3,
                            start: .78,
                            range: .46,
                            fadePower: .2,
                            color: {
                                r: 1,
                                g: 1,
                                b: 1,
                                a: 1
                            }
                        },
                        this.particlesCount = 16e3
                    }
                    update(t) {
                        const i = t.context;
                        if (!this.particlesVx) {
                            const h = Ml(this.particlesCount)
                              , d = new s.du
                              , m = new s.aU;
                            let y = 0;
                            const M = s.di(1323123451230);
                            for (let E = 0; E < h.length; ++E) {
                                const S = h[E]
                                  , I = M()
                                  , R = M()
                                  , D = M()
                                  , k = [E / h.length, I, R, D]
                                  , H = [M(), M()];
                                d.emplaceBack(S[0], S[1], S[2], -1, -1, ...k, ...H),
                                d.emplaceBack(S[0], S[1], S[2], 1, -1, ...k, ...H),
                                d.emplaceBack(S[0], S[1], S[2], 1, 1, ...k, ...H),
                                d.emplaceBack(S[0], S[1], S[2], -1, 1, ...k, ...H),
                                m.emplaceBack(y + 0, y + 1, y + 2),
                                m.emplaceBack(y + 0, y + 2, y + 3),
                                y += 4
                            }
                            this.particlesVx = i.createVertexBuffer(d, Cu.members),
                            this.particlesIdx = i.createIndexBuffer(m)
                        }
                    }
                    draw(t) {
                        if (!this._params.overrideStyleParameters && !t.style.snow)
                            return;
                        const i = structuredClone(this._params);
                        let h = [-i.direction.x, i.direction.y, -100];
                        s.ab.vec3.normalize(h, h);
                        const d = structuredClone(this._vignetteParams)
                          , m = i.overrideStyleParameters ? this._revealParams : {
                            revealStart: 0,
                            revealRange: .01
                        }
                          , y = t.transform.zoom;
                        if (m.revealStart > y)
                            return;
                        const M = wr(0, 1, m.revealStart, m.revealStart + m.revealRange, y);
                        d.strength *= M,
                        i.overrideStyleParameters || (i.intensity = t.style.snow.state.density,
                        i.timeFactor = t.style.snow.state.intensity,
                        i.color = structuredClone(t.style.snow.state.color),
                        h = structuredClone(t.style.snow.state.direction),
                        i.screenThinning.intensity = t.style.snow.state.centerThinning,
                        i.billboardSize = 2.79 * t.style.snow.state.flakeSize,
                        d.strength = 1,
                        d.color = structuredClone(t.style.snow.state.vignetteColor));
                        const E = this.updateOnRender(t, i.timeFactor);
                        if (!this.particlesVx || !this.particlesIdx)
                            return;
                        const S = t.context
                          , I = S.gl
                          , R = t.transform
                          , D = t.getOrCreateProgram("snowParticle");
                        t.uploadCommonUniforms(S, D),
                        ( (k, H, j) => {
                            const Y = Eh(this._movement.getPosition(), k)
                              , K = R.width / 2
                              , he = R.height / 2
                              , Te = wr(0, j.screenThinning.start, 0, 1, j.screenThinning.intensity)
                              , be = wr(.001, j.screenThinning.range, 0, 1, j.screenThinning.intensity)
                              , Ue = wr(0, j.screenThinning.particleOffset, 0, 1, j.screenThinning.intensity)
                              , De = (ke = {
                                modelview: E.modelviewMatrix,
                                projection: E.projectionMatrix,
                                time: this._accumulatedTimeFromStart,
                                camPos: Y,
                                velocityConeAperture: j.velocityConeAperture,
                                velocity: j.velocity,
                                horizontalOscillationRadius: j.horizontalOscillationRadius,
                                horizontalOscillationRate: j.horizontalOscillationRate,
                                boxSize: k,
                                billboardSize: 1 * j.billboardSize,
                                simpleShapeParameters: [j.shapeFadeStart, j.shapeFadePower],
                                screenSize: [R.width, R.height],
                                thinningCenterPos: [K, he],
                                thinningShape: [Te, be, Math.pow(10, j.screenThinning.fadePower)],
                                thinningAffectedRatio: j.screenThinning.affectedRatio,
                                thinningParticleOffset: Ue,
                                color: [j.color.r, j.color.g, j.color.b, j.color.a],
                                direction: h
                            },
                            {
                                u_modelview: Float32Array.from(ke.modelview),
                                u_projection: Float32Array.from(ke.projection),
                                u_time: ke.time,
                                u_cam_pos: ke.camPos,
                                u_velocityConeAperture: ke.velocityConeAperture,
                                u_velocity: ke.velocity,
                                u_horizontalOscillationRadius: ke.horizontalOscillationRadius,
                                u_horizontalOscillationRate: ke.horizontalOscillationRate,
                                u_boxSize: ke.boxSize,
                                u_billboardSize: ke.billboardSize,
                                u_simpleShapeParameters: ke.simpleShapeParameters,
                                u_screenSize: ke.screenSize,
                                u_thinningCenterPos: ke.thinningCenterPos,
                                u_thinningShape: ke.thinningShape,
                                u_thinningAffectedRatio: ke.thinningAffectedRatio,
                                u_thinningParticleOffset: ke.thinningParticleOffset,
                                u_particleColor: ke.color,
                                u_direction: ke.direction
                            });
                            var ke;
                            const Le = Math.round(M * j.intensity * this.particlesCount)
                              , Ge = s.b7.simpleSegment(0, 0, 4 * Le, 2 * Le);
                            this.particlesVx && this.particlesIdx && D.draw(t, I.TRIANGLES, Fo.disabled, Xo.disabled, si.alphaBlended, zo.disabled, De, "snow_particles", this.particlesVx, this.particlesIdx, Ge, {})
                        }
                        )(i.boxSize, 0, i),
                        this._vignette.draw(t, d)
                    }
                }
                const Mc = {
                    symbol: function(c, t, i, h, d) {
                        if ("translucent" !== c.renderPass)
                            return;
                        const m = Xo.disabled
                          , y = c.colorModeForRenderPass()
                          , M = i.layout.get("text-variable-anchor")
                          , E = i.layout.get("text-size-scale-range")
                          , S = s.aw(c.scaleFactor, E[0], E[1]);
                        M && function(D, k, H, j, Y, K, he, Te) {
                            const be = k.transform
                              , Ue = "map" === Y
                              , De = "map" === K;
                            for (const ke of D) {
                                const Le = j.getTile(ke)
                                  , Ge = Le.getBucket(H);
                                if (!Ge || !Ge.text || !Ge.text.segments.get().length)
                                    continue;
                                const qe = s.bp(Ge.textSizeData, be.zoom, Te)
                                  , vt = yr(ke, Ge.getProjection(), be)
                                  , dt = be.calculatePixelsToTileUnitsMatrix(Le)
                                  , Ze = Xr(vt, Le.tileID.canonical, De, Ue, be, Ge.getProjection(), dt)
                                  , nt = Ge.hasIconTextFit() && Ge.hasIconData();
                                if (qe) {
                                    const zt = Math.pow(2, be.zoom - Le.tileID.overscaledZ);
                                    Qn(Ge, Ue, De, he, s.cX, be, Ze, ke, zt, qe, nt)
                                }
                            }
                        }(h, c, i, t, i.layout.get("text-rotation-alignment"), i.layout.get("text-pitch-alignment"), d, S);
                        const I = 0 !== i.paint.get("icon-opacity").constantOr(1)
                          , R = 0 !== i.paint.get("text-opacity").constantOr(1);
                        void 0 !== i.layout.get("symbol-sort-key").constantOr(1) && (I || R) ? Hi(c, t, i, h, m, y) : (I && Hi(c, t, i, h, m, y, {
                            onlyIcons: !0
                        }),
                        R && Hi(c, t, i, h, m, y, {
                            onlyText: !0
                        })),
                        t.map.showCollisionBoxes && (Li(c, t, i, h, i.paint.get("text-translate"), i.paint.get("text-translate-anchor"), !0),
                        Li(c, t, i, h, i.paint.get("icon-translate"), i.paint.get("icon-translate-anchor"), !1))
                    },
                    circle: function(c, t, i, h) {
                        if ("translucent" !== c.renderPass)
                            return;
                        const d = i.paint.get("circle-opacity")
                          , m = i.paint.get("circle-stroke-width")
                          , y = i.paint.get("circle-stroke-opacity")
                          , M = void 0 !== i.layout.get("circle-sort-key").constantOr(1)
                          , E = i.paint.get("circle-emissive-strength");
                        if (0 === d.constantOr(1) && (0 === m.constantOr(1) || 0 === y.constantOr(1)))
                            return;
                        const S = c.context
                          , I = S.gl
                          , R = c.transform
                          , D = c.depthModeForSublayer(0, Fo.ReadOnly)
                          , k = Xo.disabled
                          , H = c.colorModeForDrapableLayerRenderPass(E)
                          , j = "globe" === R.projection.name
                          , Y = [s.at(R.center.lng), s.aA(R.center.lat)]
                          , K = [];
                        for (let Te = 0; Te < h.length; Te++) {
                            const be = h[Te]
                              , Ue = t.getTile(be)
                              , De = Ue.getBucket(i);
                            if (!De || De.projection.name !== R.projection.name)
                                continue;
                            const ke = De.programConfigurations.get(i.id)
                              , Le = s.cY(i)
                              , Ge = c.isTileAffectedByFog(be);
                            j && Le.push("PROJECTION_GLOBE_VIEW"),
                            Le.push("DEPTH_D24"),
                            c.terrain && R.depthOcclusionForSymbolsAndCircles && Le.push("DEPTH_OCCLUSION");
                            const qe = c.getOrCreateProgram("circle", {
                                config: ke,
                                defines: Le,
                                overrideFog: Ge
                            })
                              , vt = De.layoutVertexBuffer
                              , dt = De.globeExtVertexBuffer
                              , Ze = De.indexBuffer
                              , nt = R.projection.createInversionMatrix(R, be.canonical)
                              , zt = {
                                programConfiguration: ke,
                                program: qe,
                                layoutVertexBuffer: vt,
                                globeExtVertexBuffer: dt,
                                indexBuffer: Ze,
                                uniformValues: s.cZ(c, be, Ue, nt, Y, i),
                                tile: Ue
                            };
                            if (M) {
                                const Yt = De.segments.get();
                                for (const to of Yt)
                                    K.push({
                                        segments: new s.b7([to]),
                                        sortKey: to.sortKey,
                                        state: zt
                                    })
                            } else
                                K.push({
                                    segments: De.segments,
                                    sortKey: 0,
                                    state: zt
                                })
                        }
                        M && K.sort( (Te, be) => Te.sortKey - be.sortKey);
                        const he = {
                            useDepthForOcclusion: R.depthOcclusionForSymbolsAndCircles
                        };
                        for (const Te of K) {
                            const {programConfiguration: be, program: Ue, layoutVertexBuffer: De, globeExtVertexBuffer: ke, indexBuffer: Le, uniformValues: Ge, tile: qe} = Te.state
                              , vt = Te.segments;
                            c.terrain && c.terrain.setupElevationDraw(qe, Ue, he),
                            c.uploadCommonUniforms(S, Ue, qe.tileID.toUnwrapped()),
                            Ue.draw(c, I.TRIANGLES, D, k, H, zo.disabled, Ge, i.id, De, Le, vt, i.paint, R.zoom, be, [ke])
                        }
                    },
                    heatmap: function(c, t, i, h) {
                        if (0 !== i.paint.get("heatmap-opacity"))
                            if ("offscreen" === c.renderPass) {
                                const d = c.context
                                  , m = d.gl
                                  , y = Xo.disabled
                                  , M = new si([m.ONE, m.ONE, m.ONE, m.ONE],s.aj.transparent,[!0, !0, !0, !0]);
                                (function(k, H, j, Y) {
                                    const K = k.gl
                                      , he = H.width * Y
                                      , Te = H.height * Y;
                                    k.activeTexture.set(K.TEXTURE1),
                                    k.viewport.set([0, 0, he, Te]);
                                    let be = j.heatmapFbo;
                                    if (!be || be && (be.width !== he || be.height !== Te)) {
                                        be && be.destroy();
                                        const Ue = K.createTexture();
                                        K.bindTexture(K.TEXTURE_2D, Ue),
                                        K.texParameteri(K.TEXTURE_2D, K.TEXTURE_WRAP_S, K.CLAMP_TO_EDGE),
                                        K.texParameteri(K.TEXTURE_2D, K.TEXTURE_WRAP_T, K.CLAMP_TO_EDGE),
                                        K.texParameteri(K.TEXTURE_2D, K.TEXTURE_MIN_FILTER, K.LINEAR),
                                        K.texParameteri(K.TEXTURE_2D, K.TEXTURE_MAG_FILTER, K.LINEAR),
                                        be = j.heatmapFbo = k.createFramebuffer(he, Te, !0, null),
                                        function(De, ke, Le, Ge, qe, vt) {
                                            const dt = De.gl;
                                            dt.texImage2D(dt.TEXTURE_2D, 0, De.extRenderToTextureHalfFloat ? dt.RGBA16F : dt.RGBA, qe, vt, 0, dt.RGBA, De.extRenderToTextureHalfFloat ? dt.HALF_FLOAT : dt.UNSIGNED_BYTE, null),
                                            Ge.colorAttachment.set(Le)
                                        }(k, 0, Ue, be, he, Te)
                                    } else
                                        K.bindTexture(K.TEXTURE_2D, be.colorAttachment.get()),
                                        k.bindFramebuffer.set(be.framebuffer)
                                }
                                )(d, c, i, "globe" === c.transform.projection.name ? .5 : .25),
                                d.clear({
                                    color: s.aj.transparent
                                });
                                const E = c.transform
                                  , S = "globe" === E.projection.name
                                  , I = S ? ["PROJECTION_GLOBE_VIEW"] : []
                                  , R = S ? zo.frontCCW : zo.disabled
                                  , D = [s.at(E.center.lng), s.aA(E.center.lat)];
                                for (let k = 0; k < h.length; k++) {
                                    const H = h[k];
                                    if (t.hasRenderableParent(H))
                                        continue;
                                    const j = t.getTile(H)
                                      , Y = j.getBucket(i);
                                    if (!Y || Y.projection.name !== E.projection.name)
                                        continue;
                                    const K = c.isTileAffectedByFog(H)
                                      , he = Y.programConfigurations.get(i.id)
                                      , Te = c.getOrCreateProgram("heatmap", {
                                        config: he,
                                        defines: I,
                                        overrideFog: K
                                    })
                                      , {zoom: be} = c.transform;
                                    c.terrain && c.terrain.setupElevationDraw(j, Te),
                                    c.uploadCommonUniforms(d, Te, H.toUnwrapped());
                                    const Ue = E.projection.createInversionMatrix(E, H.canonical);
                                    Te.draw(c, m.TRIANGLES, Fo.disabled, y, M, R, xe(c, H, j, Ue, D, be, i.paint.get("heatmap-intensity")), i.id, Y.layoutVertexBuffer, Y.indexBuffer, Y.segments, i.paint, c.transform.zoom, he, S ? [Y.globeExtVertexBuffer] : null)
                                }
                                d.viewport.set([0, 0, c.width, c.height])
                            } else
                                "translucent" === c.renderPass && (c.context.setColorMode(c.colorModeForRenderPass()),
                                function(d, m) {
                                    const y = d.context
                                      , M = y.gl
                                      , E = m.heatmapFbo;
                                    if (!E)
                                        return;
                                    y.activeTexture.set(M.TEXTURE0),
                                    M.bindTexture(M.TEXTURE_2D, E.colorAttachment.get()),
                                    y.activeTexture.set(M.TEXTURE1);
                                    let S = m.colorRampTexture;
                                    S || (S = m.colorRampTexture = new s.T(y,m.colorRamp,M.RGBA8)),
                                    S.bind(M.LINEAR, M.CLAMP_TO_EDGE),
                                    d.getOrCreateProgram("heatmapTexture").draw(d, M.TRIANGLES, Fo.disabled, Xo.disabled, d.colorModeForRenderPass(), zo.disabled, {
                                        u_image: 0,
                                        u_color_ramp: 1,
                                        u_opacity: m.paint.get("heatmap-opacity")
                                    }, m.id, d.viewportBuffer, d.quadTriangleIndexBuffer, d.viewportSegments, m.paint, d.transform.zoom)
                                }(c, i))
                    },
                    line: function(c, t, i, h) {
                        if ("translucent" !== c.renderPass)
                            return;
                        const d = i.paint.get("line-opacity")
                          , m = i.paint.get("line-width");
                        if (0 === d.constantOr(1) || 0 === m.constantOr(1))
                            return;
                        const y = i.paint.get("line-emissive-strength")
                          , M = i.paint.get("line-occlusion-opacity")
                          , E = i.layout.get("line-elevation-reference")
                          , S = "meters" === i.layout.get("line-width-unit")
                          , I = "sea" === E
                          , R = c.context
                          , D = R.gl
                          , k = !i.isDraped();
                        if (k && "globe" === c.transform.projection.name)
                            return;
                        const H = i.layout.get("line-cross-slope")
                          , j = void 0 !== H
                          , Y = H < 1
                          , K = k ? new Fo(c.depthOcclusion ? D.GREATER : D.LEQUAL,Fo.ReadOnly,c.depthRangeFor3D) : c.depthModeForSublayer(0, Fo.ReadOnly)
                          , he = c.colorModeForDrapableLayerRenderPass(y)
                          , Te = c.terrain && c.terrain.renderingToTexture
                          , be = Te ? 1 : s.q.devicePixelRatio
                          , Ue = i.paint.get("line-dasharray")
                          , De = Ue.constantOr(1)
                          , ke = i.layout.get("line-cap")
                          , Le = Ue.constantOr(null)
                          , Ge = ke.constantOr(null)
                          , qe = i.paint.get("line-pattern")
                          , vt = qe.constantOr(1)
                          , dt = qe.constantOr(null)
                          , Ze = i.paint.get("line-opacity").constantOr(1);
                        let nt = !vt && 1 !== Ze || c.depthOcclusion && M > 0 && M < 1;
                        const zt = i.paint.get("line-gradient")
                          , Yt = vt ? "linePattern" : "line"
                          , to = s.c_(i);
                        let ut;
                        if (Te && c.terrain && c.terrain.clipOrMaskOverlapStencilType() && (nt = !1),
                        0 !== M && c.depthOcclusion) {
                            const wt = i.paint._values["line-opacity"];
                            wt && wt.value && "constant" === wt.value.kind ? ut = wt.value : s.w("Occlusion opacity for layer ".concat(i.id, " is supported only when line-opacity isn't data-driven."))
                        }
                        if (k && (c.forceTerrainMode = !0),
                        !k && 0 !== M && c.terrain && !Te)
                            return void s.w("Occlusion opacity for layer ".concat(i.id, " is supported on terrain only if the layer has line-z-offset enabled."));
                        const Gt = nt && k ? c.stencilModeFor3D() : Xo.disabled;
                        k && (to.push("ELEVATED"),
                        j && to.push(Y ? "CROSS_SLOPE_HORIZONTAL" : "CROSS_SLOPE_VERTICAL"),
                        I && to.push("ELEVATION_REFERENCE_SEA")),
                        "constant" !== m.value.kind && !1 === m.value.isLineProgressConstant && to.push("VARIABLE_LINE_WIDTH");
                        for (const wt of h) {
                            const qt = t.getTile(wt);
                            if (vt && !qt.patternsLoaded())
                                continue;
                            const Ht = qt.getBucket(i);
                            if (!Ht)
                                continue;
                            c.prepareDrawTile();
                            const Dt = Ht.programConfigurations.get(i.id)
                              , bo = c.isTileAffectedByFog(wt)
                              , oo = c.getOrCreateProgram(Yt, {
                                config: Dt,
                                defines: to,
                                overrideFog: bo,
                                overrideRtt: !k && void 0
                            });
                            if (dt && qt.imageAtlas) {
                                const li = s.A.from(dt)
                                  , Ji = qt.imageAtlas.patternPositions[li.getSerializedPrimary()];
                                Ji && Dt.setConstantPatternPositions(Ji)
                            }
                            if (!vt && Le && Ge && qt.lineAtlas) {
                                const li = qt.lineAtlas.getDash(Le, Ge);
                                li && Dt.setConstantPatternPositions(li)
                            }
                            let[Po,Eo] = i.paint.get("line-trim-offset");
                            ("round" === Ge || "square" === Ge) && Po !== Eo && (0 === Po && (Po -= 1),
                            1 === Eo && (Eo += 1));
                            const Yo = Te ? wt.projMatrix : null
                              , ko = S ? 1 / Ht.tileToMeter / s.ar(qt, 1, c.transform.zoom) : 1
                              , Uo = S ? 1 / Ht.tileToMeter / s.ar(qt, 1, Math.floor(c.transform.zoom)) : 1
                              , Zo = vt ? s.c$(c, qt, i, Yo, be, ko, Uo, [Po, Eo]) : s.d0(c, qt, i, Yo, Ht.lineClipsArray.length, be, ko, Uo, [Po, Eo]);
                            if (zt) {
                                const li = Ht.gradients[i.id];
                                let Ji = li.texture;
                                if (i.gradientVersion !== li.version) {
                                    let on = 256;
                                    if (i.stepInterpolant) {
                                        const Ri = t.getSource().maxzoom
                                          , Ni = wt.canonical.z === Ri ? Math.ceil(1 << c.transform.maxZoom - wt.canonical.z) : 1;
                                        on = s.aw(s.d1(Ht.maxLineLength / s.ag * 1024 * Ni), 256, R.maxTextureSize)
                                    }
                                    li.gradient = s.d2({
                                        expression: i.gradientExpression(),
                                        evaluationKey: "lineProgress",
                                        resolution: on,
                                        image: li.gradient || void 0,
                                        clips: Ht.lineClipsArray
                                    }),
                                    li.texture ? li.texture.update(li.gradient) : li.texture = new s.T(R,li.gradient,D.RGBA8),
                                    li.version = i.gradientVersion,
                                    Ji = li.texture
                                }
                                R.activeTexture.set(D.TEXTURE1),
                                Ji.bind(i.stepInterpolant ? D.NEAREST : D.LINEAR, D.CLAMP_TO_EDGE)
                            }
                            De && (R.activeTexture.set(D.TEXTURE0),
                            qt.lineAtlasTexture && qt.lineAtlasTexture.bind(D.LINEAR, D.REPEAT),
                            Dt.updatePaintBuffers()),
                            vt && (R.activeTexture.set(D.TEXTURE0),
                            qt.imageAtlasTexture && qt.imageAtlasTexture.bind(D.LINEAR, D.CLAMP_TO_EDGE),
                            Dt.updatePaintBuffers()),
                            k && !I && c.terrain.setupElevationDraw(qt, oo),
                            c.uploadCommonUniforms(R, oo, wt.toUnwrapped());
                            const yi = li => {
                                null != ut && (ut.value = Ze * M),
                                oo.draw(c, D.TRIANGLES, K, li, he, zo.disabled, Zo, i.id, Ht.layoutVertexBuffer, Ht.indexBuffer, Ht.segments, i.paint, c.transform.zoom, Dt, [Ht.layoutVertexBuffer2, Ht.patternVertexBuffer, Ht.zOffsetVertexBuffer]),
                                null != ut && (ut.value = Ze)
                            }
                            ;
                            if (nt && !k) {
                                const li = c.stencilModeForClipping(wt).ref;
                                0 === li && Te && R.clear({
                                    stencil: 0
                                });
                                const Ji = {
                                    func: D.EQUAL,
                                    mask: 255
                                };
                                Zo.u_alpha_discard_threshold = .8,
                                yi(new Xo(Ji,li,255,D.KEEP,D.KEEP,D.INVERT)),
                                Zo.u_alpha_discard_threshold = 0,
                                yi(new Xo(Ji,li,255,D.KEEP,D.KEEP,D.KEEP))
                            } else
                                nt && k && (Zo.u_alpha_discard_threshold = .001),
                                yi(k ? Gt : c.stencilModeForClipping(wt))
                        }
                        k && (c.forceTerrainMode = !1),
                        nt && (c.resetStencilClippingMasks(),
                        Te && R.clear({
                            stencil: 0
                        })),
                        0 === M || c.depthOcclusion || Te || c.layersWithOcclusionOpacity.push(c.currentLayer)
                    },
                    fill: function(c, t, i, h) {
                        const d = i.paint.get("fill-color")
                          , m = i.paint.get("fill-opacity")
                          , y = i.is3D()
                          , M = new Fo(c.context.gl.LEQUAL,Fo.ReadWrite,c.depthRangeFor3D);
                        if (0 === m.constantOr(1))
                            return;
                        const E = i.paint.get("fill-emissive-strength")
                          , S = c.colorModeForDrapableLayerRenderPass(E)
                          , I = i.paint.get("fill-pattern")
                          , R = c.opaquePassEnabledForLayer() && !I.constantOr(1) && 1 === d.constantOr(s.aj.transparent).a && 1 === m.constantOr(0) ? "opaque" : "translucent";
                        if (c.renderPass === R) {
                            const D = y ? M : c.depthModeForSublayer(1, "opaque" === c.renderPass ? Fo.ReadWrite : Fo.ReadOnly);
                            vl(c, t, i, h, D, S, !1)
                        }
                        if (!y && "translucent" === c.renderPass && i.paint.get("fill-antialias")) {
                            const D = y ? M : c.depthModeForSublayer(i.getPaintProperty("fill-outline-color") ? 2 : 0, Fo.ReadOnly);
                            vl(c, t, i, h, D, S, !0)
                        }
                    },
                    "fill-extrusion": function(c, t, i, h) {
                        const d = i.paint.get("fill-extrusion-opacity")
                          , m = c.context
                          , y = m.gl
                          , M = c.terrain
                          , E = M && M.renderingToTexture;
                        if (0 === d)
                            return;
                        const S = c.conflationActive && c.style.isLayerClipped(i, t.getSource())
                          , I = c.style.order.indexOf(i.fqid);
                        if (S && function(R, D, k, H, j) {
                            for (const Y of H) {
                                const K = D.getTile(Y).getBucket(k);
                                K && (K.updateReplacement(Y, R.replacementSource, j),
                                K.uploadCentroid(R.context))
                            }
                        }(c, t, i, h, I),
                        M || S)
                            for (const R of h) {
                                const D = t.getTile(R).getBucket(i);
                                D && yh(c.context, t, R, D, i, M, S)
                            }
                        if ("shadow" === c.renderPass && c.shadowRenderer) {
                            const R = c.shadowRenderer;
                            if (M && d < .65 && i._transitionablePaint._values["fill-extrusion-opacity"].value.expression instanceof s.a9)
                                return;
                            const D = R.getShadowPassDepthMode()
                              , k = R.getShadowPassColorMode();
                            xl(c, t, i, h, D, Xo.disabled, k, S)
                        } else if ("translucent" === c.renderPass) {
                            const R = !i.paint.get("fill-extrusion-pattern").constantOr(1)
                              , D = i.paint.get("fill-extrusion-color").constantOr(s.aj.white);
                            if (!E && 0 !== D.a) {
                                const k = new Fo(c.context.gl.LEQUAL,Fo.ReadWrite,c.depthRangeFor3D);
                                1 === d && R ? xl(c, t, i, h, k, Xo.disabled, si.unblended, S) : (xl(c, t, i, h, k, Xo.disabled, si.disabled, S),
                                xl(c, t, i, h, k, c.stencilModeFor3D(), c.colorModeForRenderPass(), S),
                                c.resetStencilClippingMasks())
                            }
                            if (c.style.enable3dLights() && R && (!M && "globe" !== c.transform.projection.name || E)) {
                                const k = i.paint.get("fill-extrusion-opacity")
                                  , H = i.paint.get("fill-extrusion-ambient-occlusion-intensity")
                                  , j = i.paint.get("fill-extrusion-ambient-occlusion-ground-radius")
                                  , Y = i.paint.get("fill-extrusion-flood-light-intensity")
                                  , K = "none" === i.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default")
                                  , he = i.paint.get("fill-extrusion-flood-light-color").toRenderColor(K ? null : i.lut).toArray01().slice(0, 3)
                                  , Te = H > 0 && j > 0
                                  , be = Y > 0
                                  , Ue = (ke, Le, Ge) => (1 - Ge) * ke + Ge * Le
                                  , De = ke => {
                                    const Le = c.depthModeForSublayer(1, Fo.ReadOnly, y.LEQUAL, !0)
                                      , Ge = i.paint.get(ke ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation")
                                      , qe = Ue(.1, 3, Ge)
                                      , vt = c._showOverdrawInspector;
                                    if (!vt) {
                                        const dt = new Xo({
                                            func: y.ALWAYS,
                                            mask: 255
                                        },255,255,y.KEEP,y.KEEP,y.REPLACE)
                                          , Ze = new si([y.ONE, y.ONE, y.ONE, y.ONE],s.aj.transparent,[!1, !1, !1, !0],y.MIN);
                                        Rs(c, t, i, h, Le, dt, Ze, zo.disabled, ke, "sdf", k, H, j, Y, he, qe, S, !1)
                                    }
                                    {
                                        const dt = vt ? Xo.disabled : new Xo({
                                            func: y.EQUAL,
                                            mask: 255
                                        },255,255,y.KEEP,y.DECR,y.DECR)
                                          , Ze = vt ? c.colorModeForRenderPass() : new si([y.ONE_MINUS_DST_ALPHA, y.DST_ALPHA, y.ONE, y.ONE],s.aj.transparent,[!0, !0, !0, !0]);
                                        Rs(c, t, i, h, Le, dt, Ze, zo.disabled, ke, "color", k, H, j, Y, he, qe, S, !1)
                                    }
                                }
                                ;
                                if (E) {
                                    const ke = (Le, Ge, qe) => {
                                        const vt = c.depthModeForSublayer(1, Fo.ReadOnly, y.LEQUAL, !1)
                                          , dt = i.paint.get(Le ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation")
                                          , Ze = Ue(.1, 3, dt);
                                        {
                                            const nt = new si([y.ONE, y.ONE, y.ONE, y.ONE],s.aj.transparent,[!1, !1, !1, !0]);
                                            Rs(c, t, i, h, vt, Xo.disabled, nt, zo.disabled, Le, "clear", k, H, j, Y, he, Ze, S, Ge)
                                        }
                                        {
                                            const nt = new Xo({
                                                func: y.ALWAYS,
                                                mask: 255
                                            },255,255,y.KEEP,y.KEEP,y.REPLACE)
                                              , zt = new si([y.ONE, y.ONE, y.ONE, y.ONE],s.aj.transparent,[!1, !1, !1, !0],y.MIN);
                                            Rs(c, t, i, h, vt, nt, zt, zo.disabled, Le, "sdf", k, H, j, Y, he, Ze, S, Ge)
                                        }
                                        {
                                            const nt = Le ? y.ZERO : y.ONE_MINUS_DST_ALPHA
                                              , zt = new Xo({
                                                func: y.EQUAL,
                                                mask: 255
                                            },255,255,y.KEEP,y.DECR,y.DECR)
                                              , Yt = new si([nt, y.DST_ALPHA, y.ONE_MINUS_DST_ALPHA, y.ZERO],s.aj.transparent,[!0, !0, !0, !0]);
                                            Rs(c, t, i, h, vt, zt, Yt, zo.disabled, Le, "color", k, H, j, Y, he, Ze, S, Ge)
                                        }
                                        {
                                            const nt = new si([y.ONE, y.ONE, y.ONE, Le ? y.ZERO : y.ONE],s.aj.transparent,[!1, !1, !1, !0],Le ? y.FUNC_ADD : y.MAX);
                                            Rs(c, t, i, h, vt, Xo.disabled, nt, zo.disabled, Le, "clear", k, H, j, Y, he, Ze, S, Ge, qe)
                                        }
                                    }
                                    ;
                                    if (Te || be) {
                                        let Le;
                                        if (c.prepareDrawTile(),
                                        M) {
                                            const Ge = M.drapeBufferSize[0]
                                              , qe = M.drapeBufferSize[1];
                                            Le = M.framebufferCopyTexture,
                                            Le && (!Le || Le.size[0] === Ge && Le.size[1] === qe) || (Le && Le.destroy(),
                                            Le = M.framebufferCopyTexture = new s.T(m,new s.r({
                                                width: Ge,
                                                height: qe
                                            }),y.RGBA8)),
                                            Le.bind(y.LINEAR, y.CLAMP_TO_EDGE),
                                            y.copyTexSubImage2D(y.TEXTURE_2D, 0, 0, 0, 0, 0, Ge, qe)
                                        }
                                        Te && ke(!0, !1, Le),
                                        be && ke(!1, !0, Le)
                                    }
                                } else
                                    Te && De(!0),
                                    be && De(!1),
                                    (Te || be) && c.resetStencilClippingMasks()
                            }
                        }
                    },
                    hillshade: function(c, t, i, h) {
                        if ("offscreen" !== c.renderPass && "translucent" !== c.renderPass || c.style.disableElevatedTerrain)
                            return;
                        const d = c.context
                          , m = c.terrain && c.terrain.renderingToTexture
                          , [y,M] = "translucent" !== c.renderPass || m ? [{}, h] : c.stencilConfigForOverlap(h);
                        for (const E of M) {
                            const S = t.getTile(E);
                            if (S.needsHillshadePrepare && "offscreen" === c.renderPass)
                                oc(c, S, i);
                            else if ("translucent" === c.renderPass) {
                                const I = c.depthModeForSublayer(0, Fo.ReadOnly)
                                  , R = i.paint.get("hillshade-emissive-strength")
                                  , D = c.colorModeForDrapableLayerRenderPass(R)
                                  , k = m && c.terrain ? c.terrain.stencilModeForRTTOverlap(E) : y[E.overscaledZ];
                                tc(c, E, S, i, I, k, D)
                            }
                        }
                        d.viewport.set([0, 0, c.width, c.height]),
                        c.resetStencilClippingMasks()
                    },
                    raster: function(c, t, i, h, d, m) {
                        if ("translucent" !== c.renderPass || 0 === i.paint.get("raster-opacity"))
                            return;
                        const y = "globe" === c.transform.projection.name
                          , M = 0 !== i.paint.get("raster-elevation")
                          , E = M && y;
                        if (c.renderElevatedRasterBackface && !E)
                            return;
                        const S = c.context
                          , I = S.gl
                          , R = t.getSource()
                          , D = function(De, ke, Le, Ge) {
                            const qe = ke.paint.get("raster-color")
                              , vt = "raster-array" === De.type
                              , dt = []
                              , Ze = ke.paint.get("raster-resampling")
                              , nt = ke.paint.get("raster-color-mix");
                            let zt = ke.paint.get("raster-color-range");
                            const Yt = [nt[0], nt[1], nt[2], 0]
                              , to = nt[3];
                            let ut = "nearest" === Ze ? Ge.NEAREST : Ge.LINEAR;
                            if (vt && (dt.push("RASTER_ARRAY"),
                            qe || dt.push("RASTER_COLOR"),
                            "linear" === Ze && dt.push("RASTER_ARRAY_LINEAR"),
                            ut = Ge.NEAREST,
                            !zt && De.rasterLayers)) {
                                const Gt = De.rasterLayers.find( ({id: wt}) => wt === ke.sourceLayer);
                                Gt && Gt.fields && Gt.fields.range && (zt = Gt.fields.range)
                            }
                            if (zt = zt || [0, 1],
                            qe) {
                                dt.push("RASTER_COLOR"),
                                Le.activeTexture.set(Ge.TEXTURE2),
                                ke.updateColorRamp(zt);
                                let Gt = ke.colorRampTexture;
                                Gt || (Gt = ke.colorRampTexture = new s.T(Le,ke.colorRamp,Ge.RGBA8)),
                                Gt.bind(Ge.LINEAR, Ge.CLAMP_TO_EDGE)
                            }
                            return {
                                mix: Yt,
                                range: zt,
                                offset: to,
                                defines: dt,
                                resampling: ut
                            }
                        }(R, i, S, I);
                        if (R instanceof s.aJ && !h.length && !y)
                            return;
                        const k = i.paint.get("raster-emissive-strength")
                          , H = c.colorModeForDrapableLayerRenderPass(k)
                          , j = c.terrain && c.terrain.renderingToTexture
                          , Y = !c.options.moving
                          , K = "nearest" === i.paint.get("raster-resampling") ? I.NEAREST : I.LINEAR;
                        if (R instanceof s.aJ && !h.length && (R.onNorthPole || R.onSouthPole)) {
                            const De = M ? c.stencilModeFor3D() : Xo.disabled;
                            return void ca(!!R.onNorthPole, null, c, t, i, k, D, zo.disabled, De)
                        }
                        if (!h.length)
                            return;
                        const [he,Te] = R instanceof s.aJ || j ? [{}, h] : c.stencilConfigForOverlap(h)
                          , be = Te[Te.length - 1].overscaledZ;
                        E && D.defines.push("PROJECTION_GLOBE_VIEW"),
                        M && D.defines.push("RENDER_CUTOFF");
                        const Ue = (De, ke, Le) => {
                            for (const Ge of De) {
                                const qe = Ge.toUnwrapped()
                                  , vt = t.getTile(Ge);
                                if (j && (!vt || !vt.hasData()))
                                    continue;
                                S.activeTexture.set(I.TEXTURE0);
                                const dt = ft(vt, R, i, D);
                                if (!dt || !dt.texture)
                                    continue;
                                const {texture: Ze, mix: nt, offset: zt, tileSize: Yt, buffer: to} = dt;
                                let ut, Gt;
                                j ? (ut = Fo.disabled,
                                Gt = Ge.projMatrix) : M ? (ut = new Fo(I.LEQUAL,Fo.ReadWrite,c.depthRangeFor3D),
                                Gt = y ? Float32Array.from(c.transform.expandedFarZProjMatrix) : c.transform.calculateProjMatrix(qe, Y)) : (ut = c.depthModeForSublayer(Ge.overscaledZ - be, 1 === i.paint.get("raster-opacity") ? Fo.ReadWrite : Fo.ReadOnly, I.LESS),
                                Gt = c.transform.calculateProjMatrix(qe, Y));
                                const wt = c.terrain && j ? c.terrain.stencilModeForRTTOverlap(Ge) : he[Ge.overscaledZ]
                                  , qt = m ? 0 : i.paint.get("raster-fade-duration");
                                vt.registerFadeDuration(qt);
                                const Ht = t.findLoadedParent(Ge, 0)
                                  , Dt = fl(vt, Ht, t, c.transform, qt);
                                let bo, oo;
                                c.terrain && c.terrain.prepareDrawTile(),
                                S.activeTexture.set(I.TEXTURE0),
                                Ze.bind(K, I.CLAMP_TO_EDGE),
                                S.activeTexture.set(I.TEXTURE1),
                                Ht ? (Ht.texture && Ht.texture.bind(K, I.CLAMP_TO_EDGE),
                                bo = Math.pow(2, Ht.tileID.overscaledZ - vt.tileID.overscaledZ),
                                oo = [vt.tileID.canonical.x * bo % 1, vt.tileID.canonical.y * bo % 1]) : Ze.bind(K, I.CLAMP_TO_EDGE),
                                Ze.useMipmap && S.extTextureFilterAnisotropic && c.transform.pitch > 20 && I.texParameterf(I.TEXTURE_2D, S.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, S.extTextureFilterAnisotropicMax);
                                const Po = c.transform;
                                let Eo;
                                const Yo = M ? cn(Po) : [0, 0, 0, 0];
                                let ko, Uo, Zo, yi, li, Ji = 0;
                                if (E && R instanceof s.aJ && R.coordinates.length > 3)
                                    ko = Float32Array.from(s.bb(s.cH(new s.bT(0,0,0)))),
                                    Uo = Float32Array.from(Po.globeMatrix),
                                    Zo = Float32Array.from(s.cD(Po)),
                                    yi = [s.at(Po.center.lng), s.aA(Po.center.lat)],
                                    Eo = R.elevatedGlobePerspectiveTransform,
                                    li = R.elevatedGlobeGridMatrix || new Float32Array(9);
                                else if (E) {
                                    const ii = s.cE(Ge.canonical);
                                    Ji = s.cF(ii.getCenter().lat),
                                    ko = Float32Array.from(s.bb(s.cH(Ge.canonical))),
                                    Uo = Float32Array.from(Po.globeMatrix),
                                    Zo = Float32Array.from(s.cD(Po)),
                                    yi = [s.at(Po.center.lng), s.aA(Po.center.lat)],
                                    Eo = [0, 0],
                                    li = Float32Array.from(s.cG(Ge.canonical, ii, Ji, Po.worldSize / Po._pixelsPerMercatorPixel))
                                } else
                                    Eo = R instanceof s.aJ ? R.perspectiveTransform : [0, 0],
                                    ko = new Float32Array(16),
                                    Uo = new Float32Array(9),
                                    Zo = new Float32Array(16),
                                    yi = [0, 0],
                                    li = new Float32Array(9);
                                const on = It(Gt, ko, Uo, Zo, li, oo || [0, 0], s.ae(c.transform.zoom), yi, Yo, bo || 1, Dt, i, Eo, M ? i.paint.get("raster-elevation") : 0, 2, nt, zt, D.range, Yt, to, k)
                                  , Ri = c.isTileAffectedByFog(Ge)
                                  , Ni = c.getOrCreateProgram("raster", {
                                    defines: D.defines,
                                    overrideFog: Ri
                                });
                                if (c.uploadCommonUniforms(S, Ni, qe),
                                R instanceof s.aJ) {
                                    const ii = R.elevatedGlobeVertexBuffer
                                      , No = R.elevatedGlobeIndexBuffer;
                                    if (j || !y)
                                        R.boundsBuffer && R.boundsSegments && Ni.draw(c, I.TRIANGLES, ut, Xo.disabled, H, zo.disabled, on, i.id, R.boundsBuffer, c.quadTriangleIndexBuffer, R.boundsSegments);
                                    else if (ii && No) {
                                        const Ei = Po.zoom <= s.c6 ? R.elevatedGlobeSegments : R.getSegmentsForLongitude(Po.center.lng);
                                        Ei && Ni.draw(c, I.TRIANGLES, ut, Xo.disabled, H, ke, on, i.id, ii, No, Ei)
                                    }
                                } else if (E) {
                                    ut = new Fo(I.LEQUAL,Fo.ReadOnly,c.depthRangeFor3D);
                                    const ii = c.globeSharedBuffers;
                                    if (ii) {
                                        const [No,Ei,Di] = ii.getGridBuffers(Ji, !1);
                                        Ni.draw(c, I.TRIANGLES, ut, Le || wt, c.colorModeForRenderPass(), ke, on, i.id, No, Ei, Di)
                                    }
                                } else {
                                    const {tileBoundsBuffer: ii, tileBoundsIndexBuffer: No, tileBoundsSegments: Ei} = c.getTileBoundsBuffers(vt);
                                    Ni.draw(c, I.TRIANGLES, ut, wt, H, zo.disabled, on, i.id, ii, No, Ei)
                                }
                            }
                            if (!(R instanceof s.aJ) && E)
                                for (const Ge of De) {
                                    const qe = Ge.canonical.y === (1 << Ge.canonical.z) - 1;
                                    0 === Ge.canonical.y && ca(!0, Ge, c, t, i, k, D, ke, Le || Xo.disabled),
                                    qe && ca(!1, Ge, c, t, i, k, D, ke === zo.frontCW ? zo.backCW : zo.frontCW, Le || Xo.disabled)
                                }
                        }
                        ;
                        E ? Ue(Te, c.renderElevatedRasterBackface ? zo.backCW : zo.frontCW, c.stencilModeFor3D()) : Ue(Te, zo.disabled, void 0),
                        c.resetStencilClippingMasks()
                    },
                    "raster-particle": function(c, t, i, h, d, m) {
                        "offscreen" === c.renderPass && function(y, M, E, S) {
                            if (!S.length)
                                return;
                            const I = y.context
                              , R = I.gl
                              , D = M.getSource();
                            if (!(D instanceof ls))
                                return;
                            const k = Math.ceil(Math.sqrt(E.paint.get("raster-particle-count")));
                            let H = E.particlePositionRGBAImage;
                            if (!H || H.width !== k) {
                                const Te = function(be) {
                                    const Ue = be * be
                                      , De = new Uint8Array(4 * Ue)
                                      , ke = function(Ge) {
                                        return Ge |= 0,
                                        Ge = Math.imul(2747636419 ^ Ge, 2654435769),
                                        Ge = Math.imul(Ge ^ Ge >>> 16, 2654435769),
                                        ((Ge = Math.imul(Ge ^ Ge >>> 16, 2654435769)) >>> 0) / 4294967296
                                    }
                                      , Le = 1 / 1.1;
                                    for (let Ge = 0; Ge < Ue; Ge++) {
                                        const qe = Le * (ke(2 * Ge + 0) + yo)
                                          , vt = Le * (ke(2 * Ge + 1) + yo)
                                          , dt = 255 * qe % 1
                                          , Ze = 255 * vt % 1
                                          , nt = dt
                                          , zt = vt - Ze / 255
                                          , Yt = Ze;
                                        De[4 * Ge + 0] = 255 * (qe - dt / 255),
                                        De[4 * Ge + 1] = 255 * nt,
                                        De[4 * Ge + 2] = 255 * zt,
                                        De[4 * Ge + 3] = 255 * Yt
                                    }
                                    return De
                                }(k);
                                H = E.particlePositionRGBAImage = new s.r({
                                    width: k,
                                    height: k
                                },Te)
                            }
                            let j = E.particleFramebuffer;
                            j ? j.width !== k && (j.destroy(),
                            j = E.particleFramebuffer = I.createFramebuffer(k, k, !0, null)) : j = E.particleFramebuffer = I.createFramebuffer(k, k, !0, null);
                            const Y = [];
                            for (const Te of S) {
                                const be = M.getTile(Te);
                                if (!(be instanceof Ya))
                                    continue;
                                const Ue = gu(be, D, E);
                                if (!Ue)
                                    continue;
                                const De = [be.tileSize, be.tileSize];
                                let ke = E.tileFramebuffer;
                                ke || (ke = E.tileFramebuffer = I.createFramebuffer(De[0], De[1], !0, null));
                                let Le = be.rasterParticleState;
                                Le || (Le = be.rasterParticleState = new vh(I,Te,De,H));
                                const Ge = Le.update(E.lastInvalidatedAt);
                                Le.particleTextureDimension !== k && Le.updateParticleTexture(Te, H);
                                const qe = Le.targetColorTexture;
                                Le.targetColorTexture = Le.backgroundColorTexture,
                                Le.backgroundColorTexture = qe;
                                const vt = Le.particleTexture0;
                                Le.particleTexture0 = Le.particleTexture1,
                                Le.particleTexture1 = vt,
                                Y.push([Te, Ue, Le, Ge])
                            }
                            if (0 === Y.length)
                                return;
                            const K = s.q.now()
                              , he = E.previousDrawTimestamp ? .001 * (K - E.previousDrawTimestamp) : .0167;
                            if (E.previousDrawTimestamp = K,
                            E.hasColorMap()) {
                                I.activeTexture.set(R.TEXTURE0 + 2);
                                let Te = E.colorRampTexture;
                                Te || (Te = E.colorRampTexture = new s.T(I,E.colorRamp,R.RGBA8)),
                                Te.bind(R.LINEAR, R.CLAMP_TO_EDGE)
                            }
                            I.bindFramebuffer.set(E.tileFramebuffer.framebuffer),
                            function(Te, be, Ue) {
                                const De = Te.context
                                  , ke = De.gl
                                  , Le = be.tileFramebuffer;
                                De.activeTexture.set(ke.TEXTURE0);
                                const Ge = {
                                    u_texture: 0,
                                    u_opacity: 1.05 * (vt = be.paint.get("raster-particle-fade-opacity-factor")) / (vt + .05)
                                }
                                  , qe = Te.getOrCreateProgram("rasterParticleTexture", {
                                    defines: [],
                                    overrideFog: !1
                                });
                                var vt;
                                for (const dt of Ue) {
                                    const [,,Ze,nt] = dt;
                                    Le.colorAttachment.set(Ze.targetColorTexture.texture),
                                    De.viewport.set([0, 0, Le.width, Le.height]),
                                    De.clear({
                                        color: s.aj.transparent
                                    }),
                                    nt && (Ze.backgroundColorTexture.bind(ke.NEAREST, ke.CLAMP_TO_EDGE),
                                    qe.draw(Te, ke.TRIANGLES, Fo.disabled, Xo.disabled, si.alphaBlended, zo.disabled, Ge, be.id, Te.viewportBuffer, Te.quadTriangleIndexBuffer, Te.viewportSegments))
                                }
                            }(y, E, Y),
                            function(Te, be, Ue, De) {
                                const ke = Te.context
                                  , Le = ke.gl
                                  , Ge = Ue.tileFramebuffer
                                  , qe = "globe" === Te.transform.projection.name
                                  , vt = Ue.paint.get("raster-particle-max-speed");
                                for (const dt of De) {
                                    const [Ze,nt,zt] = dt;
                                    ke.activeTexture.set(Le.TEXTURE0 + 0),
                                    nt.texture.bind(Le.LINEAR, Le.CLAMP_TO_EDGE),
                                    Ge.colorAttachment.set(zt.targetColorTexture.texture);
                                    const Yt = Te.getOrCreateProgram("rasterParticleDraw", {
                                        defines: nt.defines,
                                        overrideFog: !1
                                    });
                                    ke.activeTexture.set(Le.TEXTURE0 + 1);
                                    const to = nt.scalarData ? [] : [0, 1, 2, 3].map(wt => s.d4[wt](Ze));
                                    to.push(Ze);
                                    const ut = Ze.canonical.x
                                      , Gt = Ze.canonical.y;
                                    for (const wt of to) {
                                        const qt = be.getTile(qe ? wt.wrapped() : wt);
                                        if (!qt)
                                            continue;
                                        const Ht = qt.rasterParticleState;
                                        if (!Ht)
                                            continue;
                                        const Dt = wt.canonical.x + (1 << wt.canonical.z) * (wt.wrap - Ze.wrap)
                                          , bo = wt.canonical.y;
                                        Ht.particleTexture0.bind(Le.NEAREST, Le.CLAMP_TO_EDGE);
                                        const oo = kt(1, Ht.particleTexture0.size[0], [Dt - ut, bo - Gt], 0, nt.texture.size, 2, vt, nt.textureOffset, nt.scale, nt.offset);
                                        Yt.draw(Te, Le.POINTS, Fo.disabled, Xo.disabled, si.alphaBlended, zo.disabled, oo, Ue.id, Ht.particleIndexBuffer, void 0, Ht.particleSegment)
                                    }
                                }
                            }(y, M, E, Y),
                            I.bindFramebuffer.set(E.particleFramebuffer.framebuffer),
                            function(Te, be, Ue, De) {
                                const ke = Te.context
                                  , Le = ke.gl
                                  , Ge = be.paint.get("raster-particle-max-speed")
                                  , qe = De * be.paint.get("raster-particle-speed-factor") * .15
                                  , vt = (Ze = .01 + 1 * be.paint.get("raster-particle-reset-rate-factor"),
                                Math.pow(Ze, 6))
                                  , dt = be.particleFramebuffer;
                                var Ze;
                                ke.viewport.set([0, 0, dt.width, dt.height]);
                                for (const Ze of Ue) {
                                    const [,nt,zt] = Ze;
                                    ke.activeTexture.set(Le.TEXTURE0 + 0),
                                    nt.texture.bind(Le.LINEAR, Le.CLAMP_TO_EDGE),
                                    ke.activeTexture.set(Le.TEXTURE0 + 1);
                                    const Yt = zt.particleTexture0;
                                    Yt.bind(Le.NEAREST, Le.CLAMP_TO_EDGE);
                                    const to = Wo(1, Yt.size[0], 0, nt.texture.size, Ge, qe, vt, nt.textureOffset, nt.scale, nt.offset);
                                    dt.colorAttachment.set(zt.particleTexture1.texture),
                                    ke.clear({
                                        color: s.aj.transparent
                                    }),
                                    Te.getOrCreateProgram("rasterParticleUpdate", {
                                        defines: nt.defines
                                    }).draw(Te, Le.TRIANGLES, Fo.disabled, Xo.disabled, si.unblended, zo.disabled, to, be.id, Te.viewportBuffer, Te.quadTriangleIndexBuffer, Te.viewportSegments)
                                }
                            }(y, E, Y, he)
                        }(c, t, i, h),
                        "translucent" === c.renderPass && (function(y, M, E, S) {
                            const R = y.context
                              , D = R.gl
                              , k = M.getSource().tileSize
                              , H = 5 * (1 - s.ac(s.bY, s.bY + 1, y.transform.zoom)) * k + E.paint.get("raster-particle-elevation")
                              , j = !y.options.moving
                              , Y = "globe" === y.transform.projection.name;
                            if (!S.length)
                                return;
                            const [K,he] = y.stencilConfigForOverlap(S)
                              , Te = [];
                            Y && Te.push("PROJECTION_GLOBE_VIEW");
                            const be = y.stencilModeFor3D();
                            for (const Ue of he) {
                                const De = Ue.toUnwrapped()
                                  , ke = M.getTile(Ue);
                                if (!ke.rasterParticleState)
                                    continue;
                                const Le = ke.rasterParticleState
                                  , Ge = 100;
                                ke.registerFadeDuration(Ge);
                                const qe = M.findLoadedParent(Ue, 0)
                                  , vt = fl(ke, qe, M, y.transform, Ge);
                                let dt, Ze;
                                y.terrain && y.terrain.prepareDrawTile(),
                                R.activeTexture.set(D.TEXTURE0),
                                Le.targetColorTexture.bind(D.LINEAR, D.CLAMP_TO_EDGE),
                                R.activeTexture.set(D.TEXTURE1),
                                qe && qe.rasterParticleState ? (qe.rasterParticleState.targetColorTexture.bind(D.LINEAR, D.CLAMP_TO_EDGE),
                                dt = Math.pow(2, qe.tileID.overscaledZ - ke.tileID.overscaledZ),
                                Ze = [ke.tileID.canonical.x * dt % 1, ke.tileID.canonical.y * dt % 1]) : Le.targetColorTexture.bind(D.LINEAR, D.CLAMP_TO_EDGE);
                                const nt = Y ? Float32Array.from(y.transform.expandedFarZProjMatrix) : y.transform.calculateProjMatrix(De, j)
                                  , zt = y.transform
                                  , Yt = fp(zt)
                                  , to = s.cE(Ue.canonical)
                                  , ut = s.cF(to.getCenter().lat);
                                let Gt, wt, qt, Ht, Dt;
                                Y ? (Gt = Float32Array.from(s.bb(s.cH(Ue.canonical))),
                                wt = Float32Array.from(zt.globeMatrix),
                                qt = Float32Array.from(s.cD(zt)),
                                Ht = [s.at(zt.center.lng), s.aA(zt.center.lat)],
                                Dt = Float32Array.from(s.cG(Ue.canonical, to, ut, zt.worldSize / zt._pixelsPerMercatorPixel))) : (Gt = new Float32Array(16),
                                wt = new Float32Array(9),
                                qt = new Float32Array(16),
                                Ht = [0, 0],
                                Dt = new Float32Array(9));
                                const bo = Io(nt, Gt, wt, qt, Dt, Ze || [0, 0], s.ae(y.transform.zoom), Ht, Yt, dt || 1, vt, H)
                                  , oo = y.isTileAffectedByFog(Ue)
                                  , Po = y.getOrCreateProgram("rasterParticle", {
                                    defines: Te,
                                    overrideFog: oo
                                });
                                if (y.uploadCommonUniforms(R, Po, De),
                                Y) {
                                    const Eo = new Fo(D.LEQUAL,Fo.ReadOnly,y.depthRangeFor3D)
                                      , Yo = 0
                                      , ko = y.globeSharedBuffers;
                                    if (ko) {
                                        const [Uo,Zo,yi] = ko.getGridBuffers(ut, 0 !== Yo);
                                        Po.draw(y, D.TRIANGLES, Eo, be, si.alphaBlended, y.renderElevatedRasterBackface ? zo.frontCCW : zo.backCCW, bo, E.id, Uo, Zo, yi)
                                    }
                                } else {
                                    const Eo = y.depthModeForSublayer(0, Fo.ReadOnly)
                                      , Yo = K[Ue.overscaledZ]
                                      , {tileBoundsBuffer: ko, tileBoundsIndexBuffer: Uo, tileBoundsSegments: Zo} = y.getTileBoundsBuffers(ke);
                                    Po.draw(y, D.TRIANGLES, Eo, Yo, si.alphaBlended, zo.disabled, bo, E.id, ko, Uo, Zo)
                                }
                            }
                            y.resetStencilClippingMasks()
                        }(c, t, i, h),
                        c.style.map.triggerRepaint())
                    },
                    background: function(c, t, i, h) {
                        const d = i.paint.get("background-color")
                          , m = "none" === i.paint.get("background-color-use-theme").constantOr("default")
                          , y = i.paint.get("background-opacity")
                          , M = i.paint.get("background-emissive-strength")
                          , E = "viewport" === i.paint.get("background-pitch-alignment");
                        if (0 === y)
                            return;
                        const S = c.context
                          , I = S.gl
                          , R = c.transform
                          , D = R.tileSize
                          , k = i.paint.get("background-pattern");
                        let H;
                        if (void 0 !== k && (null === k || (H = c.imageManager.getPattern(k.toString(), i.scope, c.style.getLut(i.scope)),
                        !H)))
                            return;
                        const j = !k && 1 === d.a && 1 === y && c.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                        if (c.renderPass !== j)
                            return;
                        const Y = Xo.disabled
                          , K = c.depthModeForSublayer(0, "opaque" === j ? Fo.ReadWrite : Fo.ReadOnly)
                          , he = c.colorModeForDrapableLayerRenderPass(M)
                          , Te = k ? "backgroundPattern" : "background";
                        let be, Ue = h;
                        if (Ue || (be = c.getBackgroundTiles(),
                        Ue = Object.values(be).map(De => De.tileID)),
                        k && (S.activeTexture.set(I.TEXTURE0),
                        c.imageManager.bind(c.context, i.scope)),
                        E) {
                            const De = c.getOrCreateProgram(Te, {
                                overrideFog: !1,
                                overrideRtt: !0
                            })
                              , ke = new Float32Array(s.ab.mat4.identity([]))
                              , Le = new s.aG(0,0,0,0,0)
                              , Ge = k ? oi(ke, M, y, c, 0, i.scope, H, E, {
                                tileID: Le,
                                tileSize: D
                            }) : ai(ke, M, y, d.toRenderColor(m ? null : i.lut));
                            De.draw(c, I.TRIANGLES, K, Y, he, zo.disabled, Ge, i.id, c.viewportBuffer, c.quadTriangleIndexBuffer, c.viewportSegments)
                        } else
                            for (const De of Ue) {
                                const ke = c.isTileAffectedByFog(De)
                                  , Le = c.getOrCreateProgram(Te, {
                                    overrideFog: ke
                                })
                                  , Ge = De.toUnwrapped()
                                  , qe = h ? De.projMatrix : c.transform.calculateProjMatrix(Ge);
                                c.prepareDrawTile();
                                const vt = t ? t.getTile(De) : be ? be[De.key] : new hs(De,D,R.zoom,c)
                                  , dt = k ? oi(qe, M, y, c, 0, i.scope, H, E, {
                                    tileID: De,
                                    tileSize: D
                                }) : ai(qe, M, y, d.toRenderColor(m ? null : i.lut));
                                c.uploadCommonUniforms(S, Le, Ge);
                                const {tileBoundsBuffer: Ze, tileBoundsIndexBuffer: nt, tileBoundsSegments: zt} = c.getTileBoundsBuffers(vt);
                                Le.draw(c, I.TRIANGLES, K, Y, he, zo.disabled, dt, i.id, Ze, nt, zt)
                            }
                    },
                    sky: function(c, t, i) {
                        const h = c._atmosphere ? s.ae(c.transform.zoom) : 1
                          , d = i.paint.get("sky-opacity") * h;
                        if (0 === d)
                            return;
                        const m = c.context
                          , y = i.paint.get("sky-type")
                          , M = new Fo(m.gl.LEQUAL,Fo.ReadOnly,[0, 1])
                          , E = c.frameCounter / 1e3 % 1;
                        "atmosphere" === y ? "offscreen" === c.renderPass ? i.needsSkyboxCapture(c) && (function(S, I) {
                            const k = S.context
                              , H = k.gl;
                            let j = I.skyboxFbo;
                            if (!j) {
                                j = I.skyboxFbo = k.createFramebuffer(32, 32, !0, null),
                                I.skyboxGeometry = new es(k),
                                I.skyboxTexture = k.gl.createTexture(),
                                H.bindTexture(H.TEXTURE_CUBE_MAP, I.skyboxTexture),
                                H.texParameteri(H.TEXTURE_CUBE_MAP, H.TEXTURE_WRAP_S, H.CLAMP_TO_EDGE),
                                H.texParameteri(H.TEXTURE_CUBE_MAP, H.TEXTURE_WRAP_T, H.CLAMP_TO_EDGE),
                                H.texParameteri(H.TEXTURE_CUBE_MAP, H.TEXTURE_MIN_FILTER, H.LINEAR),
                                H.texParameteri(H.TEXTURE_CUBE_MAP, H.TEXTURE_MAG_FILTER, H.LINEAR);
                                for (let Te = 0; Te < 6; ++Te)
                                    H.texImage2D(H.TEXTURE_CUBE_MAP_POSITIVE_X + Te, 0, H.RGBA, 32, 32, 0, H.RGBA, H.UNSIGNED_BYTE, null)
                            }
                            k.bindFramebuffer.set(j.framebuffer),
                            k.viewport.set([0, 0, 32, 32]);
                            const Y = I.getCenter(S, !0)
                              , K = S.getOrCreateProgram("skyboxCapture")
                              , he = new Float64Array(16);
                            s.ab.mat4.identity(he),
                            s.ab.mat4.rotateY(he, he, .5 * -Math.PI),
                            ka(S, I, K, he, Y, 0),
                            s.ab.mat4.identity(he),
                            s.ab.mat4.rotateY(he, he, .5 * Math.PI),
                            ka(S, I, K, he, Y, 1),
                            s.ab.mat4.identity(he),
                            s.ab.mat4.rotateX(he, he, .5 * -Math.PI),
                            ka(S, I, K, he, Y, 2),
                            s.ab.mat4.identity(he),
                            s.ab.mat4.rotateX(he, he, .5 * Math.PI),
                            ka(S, I, K, he, Y, 3),
                            s.ab.mat4.identity(he),
                            ka(S, I, K, he, Y, 4),
                            s.ab.mat4.identity(he),
                            s.ab.mat4.rotateY(he, he, Math.PI),
                            ka(S, I, K, he, Y, 5),
                            k.viewport.set([0, 0, S.width, S.height])
                        }(c, i),
                        i.markSkyboxValid(c)) : "sky" === c.renderPass && function(S, I, R, D, k) {
                            const H = S.context
                              , j = H.gl
                              , Y = S.transform
                              , K = S.getOrCreateProgram("skybox");
                            H.activeTexture.set(j.TEXTURE0),
                            j.bindTexture(j.TEXTURE_CUBE_MAP, I.skyboxTexture);
                            const he = ( (Te, be, Ue, De, ke) => ({
                                u_matrix: Te,
                                u_sun_direction: be,
                                u_cubemap: 0,
                                u_opacity: De,
                                u_temporal_offset: ke
                            }))(Y.skyboxMatrix, I.getCenter(S, !1), 0, D, k);
                            S.uploadCommonUniforms(H, K),
                            K.draw(S, j.TRIANGLES, R, Xo.disabled, S.colorModeForRenderPass(), zo.backCW, he, "skybox", I.skyboxGeometry.vertexBuffer, I.skyboxGeometry.indexBuffer, I.skyboxGeometry.segment)
                        }(c, i, M, d, E) : "gradient" === y && "sky" === c.renderPass && function(S, I, R, D, k) {
                            const H = S.context
                              , j = H.gl
                              , Y = S.transform
                              , K = S.getOrCreateProgram("skyboxGradient");
                            I.skyboxGeometry || (I.skyboxGeometry = new es(H)),
                            H.activeTexture.set(j.TEXTURE0);
                            let he = I.colorRampTexture;
                            he || (he = I.colorRampTexture = new s.T(H,I.colorRamp,j.RGBA8)),
                            he.bind(j.LINEAR, j.CLAMP_TO_EDGE);
                            const Te = (be = Y.skyboxMatrix,
                            Ue = I.getCenter(S, !1),
                            De = I.paint.get("sky-gradient-radius"),
                            ke = D,
                            Le = k,
                            {
                                u_matrix: be,
                                u_color_ramp: 0,
                                u_center_direction: Ue,
                                u_radius: s.ai(De),
                                u_opacity: ke,
                                u_temporal_offset: Le
                            });
                            var be, Ue, De, ke, Le;
                            S.uploadCommonUniforms(H, K),
                            K.draw(S, j.TRIANGLES, R, Xo.disabled, S.colorModeForRenderPass(), zo.backCW, Te, "skyboxGradient", I.skyboxGeometry.vertexBuffer, I.skyboxGeometry.indexBuffer, I.skyboxGeometry.segment)
                        }(c, i, M, d, E)
                    },
                    debug: function(c, t, i, h, d, m) {
                        for (let y = 0; y < i.length; y++)
                            if (d) {
                                const S = new s.aj(.8 * h.r,.8 * h.g,.8 * h.b,1);
                                Fa(c, t, i[y], h, -1, -1, m),
                                Fa(c, t, i[y], h, -1, 1, m),
                                Fa(c, t, i[y], h, 1, 1, m),
                                Fa(c, t, i[y], h, 1, -1, m),
                                Fa(c, t, i[y], S, 0, 0, m)
                            } else
                                Fa(c, t, i[y], h, 0, 0, m)
                    },
                    custom: function(c, t, i, h) {
                        const d = c.context
                          , m = i.implementation;
                        if (!c.transform.projection.unsupportedLayers || !c.transform.projection.unsupportedLayers.includes("custom") || c.terrain && (c.terrain.renderingToTexture || "offscreen" === c.renderPass) && i.isDraped(t)) {
                            if ("offscreen" === c.renderPass) {
                                const y = m.prerender;
                                if (y) {
                                    if (c.setCustomLayerDefaults(),
                                    d.setColorMode(c.colorModeForRenderPass()),
                                    "globe" === c.transform.projection.name) {
                                        const M = c.transform.pointMerc;
                                        y.call(m, d.gl, c.transform.customLayerMatrix(), c.transform.getProjection(), c.transform.globeToMercatorMatrix(), s.ae(c.transform.zoom), [M.x, M.y], c.transform.pixelsPerMeterRatio)
                                    } else
                                        y.call(m, d.gl, c.transform.customLayerMatrix());
                                    d.setDirty(),
                                    c.setBaseState()
                                }
                            } else if ("translucent" === c.renderPass) {
                                if (c.terrain && c.terrain.renderingToTexture) {
                                    const M = m.renderToTile;
                                    if (M) {
                                        const E = h[0].canonical
                                          , S = new s.aa(E.x + h[0].wrap * (1 << E.z),E.y,E.z);
                                        d.setDepthMode(Fo.disabled),
                                        d.setStencilMode(Xo.disabled),
                                        d.setColorMode(c.colorModeForRenderPass()),
                                        c.setCustomLayerDefaults(),
                                        M.call(m, d.gl, S),
                                        d.setDirty(),
                                        c.setBaseState()
                                    }
                                    return
                                }
                                c.setCustomLayerDefaults(),
                                d.setColorMode(c.colorModeForRenderPass()),
                                d.setStencilMode(Xo.disabled);
                                const y = "3d" === m.renderingMode ? new Fo(c.context.gl.LEQUAL,Fo.ReadWrite,c.depthRangeFor3D) : c.depthModeForSublayer(0, Fo.ReadOnly);
                                if (d.setDepthMode(y),
                                "globe" === c.transform.projection.name) {
                                    const M = c.transform.pointMerc;
                                    m.render(d.gl, c.transform.customLayerMatrix(), c.transform.getProjection(), c.transform.globeToMercatorMatrix(), s.ae(c.transform.zoom), [M.x, M.y], c.transform.pixelsPerMeterRatio)
                                } else
                                    m.render(d.gl, c.transform.customLayerMatrix());
                                d.setDirty(),
                                c.setBaseState(),
                                d.bindFramebuffer.set(null)
                            }
                        } else
                            s.w("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.")
                    },
                    model: function(c, t, i, h) {
                        if ("opaque" === c.renderPass)
                            return;
                        const d = i.paint.get("model-opacity").constantOr(1);
                        if (0 === d)
                            return;
                        const m = i.paint.get("model-cast-shadows");
                        if ("shadow" === c.renderPass && (!m || c.terrain && d < .65 && i._transitionablePaint._values["model-opacity"].value.expression instanceof s.a9))
                            return;
                        const y = c.shadowRenderer
                          , M = i.paint.get("model-receive-shadows");
                        y && (y.useNormalOffset = !0,
                        M || (y.enabled = !1));
                        const E = () => {
                            y && (y.useNormalOffset = !0,
                            M || (y.enabled = !0))
                        }
                          , S = t.getSource();
                        if ("light-beam" === c.renderPass && "batched-model" !== S.type)
                            return;
                        if ("vector" === S.type || "geojson" === S.type)
                            return function(K, he, Te, be, Ue) {
                                const De = K.transform;
                                if ("mercator" !== De.projection.name)
                                    return void s.w("Drawing 3D models for ".concat(De.projection.name, " projection is not yet implemented"));
                                const ke = De.getFreeCameraOptions().position;
                                if (!K.modelManager)
                                    return;
                                const Le = K.modelManager;
                                Te.modelManager = Le;
                                const Ge = K.shadowRenderer;
                                if (!Te._unevaluatedLayout._values.hasOwnProperty("model-id"))
                                    return;
                                const qe = Te._unevaluatedLayout._values["model-id"]
                                  , vt = {
                                    ...Te.layout.get("model-id").parameters
                                }
                                  , dt = K.style.order.indexOf(Te.fqid);
                                for (const Ze of be) {
                                    const nt = he.getTile(Ze).getBucket(Te);
                                    if (!nt || nt.projection.name !== De.projection.name)
                                        continue;
                                    const zt = nt.getModelUris();
                                    zt && !nt.modelsRequested && (Le.addModelsFromBucket(zt, Ue),
                                    nt.modelsRequested = !0);
                                    const Yt = ua(Ze, De);
                                    vt.zoom = Yt;
                                    const to = qe.possiblyEvaluate(vt);
                                    if (yu(K, nt, Ze),
                                    $r.shadowUniformsInitialized = !1,
                                    $r.useSingleShadowCascade = !!Ge && 0 === Ge.getMaxCascadeForTile(Ze.toUnwrapped()),
                                    "shadow" === K.renderPass && Ge) {
                                        if (1 === K.currentShadowCascade && nt.isInsideFirstShadowMapFrustum)
                                            continue;
                                        const wt = De.calculatePosMatrix(Ze.toUnwrapped(), De.worldSize);
                                        if ($r.tileMatrix.set(wt),
                                        $r.shadowTileMatrix = Float32Array.from(Ge.calculateShadowPassMatrixFromMatrix(wt)),
                                        $r.aabb.min.fill(0),
                                        $r.aabb.max[0] = $r.aabb.max[1] = s.ag,
                                        $r.aabb.max[2] = 0,
                                        Ph(nt, $r, K, Te.scope))
                                            continue
                                    }
                                    const ut = 1 << Ze.canonical.z
                                      , Gt = [((ke.x - Ze.wrap) * ut - Ze.canonical.x) * s.ag, (ke.y * ut - Ze.canonical.y) * s.ag, ke.z * ut * s.ag];
                                    K.conflationActive && Object.keys(nt.instancesPerModel).length > 0 && K.style.isLayerClipped(Te, he.getSource()) && nt.updateReplacement(Ze, K.replacementSource, dt, Ue) && (nt.uploaded = !1,
                                    nt.upload(K.context));
                                    for (let wt in nt.instancesPerModel) {
                                        const qt = nt.instancesPerModel[wt];
                                        qt.features.length > 0 && (wt = to.evaluate(qt.features[0].feature, {}));
                                        const Ht = Le.getModel(wt, Ue);
                                        if (Ht && Ht.uploaded)
                                            for (const Dt of Ht.nodes)
                                                Ds(K, Te, Dt, qt, Gt, Ze, $r)
                                    }
                                }
                            }(c, t, i, h, "vector" === S.type ? i.scope : ""),
                            void E();
                        if (!S.loaded())
                            return;
                        if ("batched-model" === S.type)
                            return function(K, he, Te, be) {
                                Te.resetLayerRenderingStats(K);
                                const Ue = K.context
                                  , De = K.transform
                                  , ke = K.style.fog
                                  , Le = K.shadowRenderer;
                                if ("mercator" !== De.projection.name)
                                    return void s.w("Drawing 3D landmark models for ".concat(De.projection.name, " projection is not yet implemented"));
                                const Ge = K.transform.getFreeCameraOptions().position
                                  , qe = s.ab.vec3.scale([], [Ge.x, Ge.y, Ge.z], K.transform.worldSize)
                                  , vt = s.ab.vec3.negate([], qe)
                                  , dt = s.ab.mat4.identity([])
                                  , Ze = s.dj(De.center.lat, De.zoom)
                                  , nt = s.ab.mat4.fromScaling([], [1, 1, 1 / Ze]);
                                s.ab.mat4.translate(dt, dt, vt);
                                const zt = Te.paint.get("model-opacity").constantOr(1)
                                  , Yt = new Fo(Ue.gl.LEQUAL,Fo.ReadWrite,K.depthRangeFor3D)
                                  , to = new Fo(Ue.gl.LEQUAL,Fo.ReadOnly,K.depthRangeFor3D)
                                  , ut = new s.cd([1 / 0, 1 / 0, 1 / 0],[-1 / 0, -1 / 0, -1 / 0])
                                  , Gt = "shadow" === K.renderPass
                                  , wt = Gt && Le ? Le.getCurrentCascadeFrustum() : De.getFrustum(De.scaleZoom(De.worldSize))
                                  , qt = Te.paint.get("model-front-cutoff")
                                  , Ht = qt[2] < 1
                                  , Dt = Kr(K, Te.paint.get("model-cutoff-fade-range"))
                                  , bo = Te.getLayerRenderingStats();
                                (function(oo, Po, Eo, Yo) {
                                    const ko = oo.terrain ? oo.terrain.exaggeration() : 0
                                      , Uo = oo.transform.zoom;
                                    for (const Zo of Yo) {
                                        const yi = Po.getTile(Zo).getBucket(Eo);
                                        yi && (oo.conflationActive && yi.updateReplacement(Zo, oo.replacementSource),
                                        yi.evaluateScale(oo, Eo),
                                        oo.terrain && ko > 0 && yi.elevationUpdate(oo.terrain, ko, Zo, Eo.source),
                                        yi.needsReEvaluation(oo, Uo, Eo) && yi.evaluate(Eo))
                                    }
                                }
                                )(K, he, Te, be),
                                function() {
                                    let oo, Po, Eo;
                                    Ht ? (oo = be.length - 1,
                                    Po = -1,
                                    Eo = -1) : (oo = 0,
                                    Po = be.length,
                                    Eo = 1);
                                    const Yo = new Float64Array(16)
                                      , ko = s.ab.vec3.create()
                                      , Uo = new s.P(0,0);
                                    for (let Zo = oo; Zo !== Po; Zo += Eo) {
                                        const yi = be[Zo]
                                          , li = he.getTile(yi).getBucket(Te);
                                        if (!li || !li.uploaded)
                                            continue;
                                        let Ji = !1;
                                        Le && (Ji = 0 === Le.getMaxCascadeForTile(yi.toUnwrapped()));
                                        const on = De.calculatePosMatrix(yi.toUnwrapped(), De.worldSize)
                                          , Ri = li.modelTraits;
                                        !Gt && Ht && (s.ab.mat4.invert(Yo, on),
                                        s.ab.vec3.transformMat4(ko, qe, Yo),
                                        Uo.x = ko[0],
                                        Uo.y = ko[1]);
                                        const Ni = [];
                                        for (const ii of li.getNodesInfo()) {
                                            if (ii.hiddenByReplacement || !ii.node.meshes)
                                                continue;
                                            const No = ii.node;
                                            let Ei = 0;
                                            K.terrain && No.elevation && (Ei = No.elevation * K.terrain.exaggeration());
                                            const Di = ( () => {
                                                const vi = ii.aabb;
                                                return ut.min = [...vi.min],
                                                ut.max = [...vi.max],
                                                ut.min[2] += Ei,
                                                ut.max[2] += Ei,
                                                s.ab.vec3.transformMat4(ut.min, ut.min, on),
                                                s.ab.vec3.transformMat4(ut.max, ut.max, on),
                                                ut
                                            }
                                            )()
                                              , an = ii.evaluatedScale;
                                            if (an[0] <= 1 && an[1] <= 1 && an[2] <= 1 && 0 === Di.intersects(wt))
                                                continue;
                                            if (!Gt && Ht) {
                                                const vi = .16666666666666666;
                                                ii.cameraCollisionOpacity = qe[0] > Di.min[0] && qe[0] < Di.max[0] && qe[1] > Di.min[1] && qe[1] < Di.max[1] && qe[2] * Ze < Di.max[2] && No.footprint && s.bA(Uo, No.footprint) ? Math.max(ii.cameraCollisionOpacity - vi, 0) : Math.min(1, ii.cameraCollisionOpacity + vi)
                                            }
                                            const jn = [...on]
                                              , lr = No.anchor ? No.anchor[0] : 0
                                              , bn = No.anchor ? No.anchor[1] : 0;
                                            s.ab.mat4.translate(jn, jn, [lr * (an[0] - 1), bn * (an[1] - 1), Ei]),
                                            s.ab.vec3.exactEquals(an, s.dm) || s.ab.mat4.scale(jn, jn, an);
                                            const Un = s.ab.mat4.multiply([], jn, No.matrix)
                                              , er = s.ab.mat4.multiply([], De.expandedFarZProjMatrix, Un)
                                              , pn = s.ab.mat4.multiply([], De.expandedFarZProjMatrix, jn)
                                              , Yi = s.ab.vec4.transformMat4([], [lr, bn, Ei, 1], er)[2];
                                            No.hidden = !1;
                                            let Qi = zt;
                                            Gt || (Ht && (Qi *= ii.cameraCollisionOpacity,
                                            Qi *= vu(jn, De, ii.aabb, qt)),
                                            Qi *= Mh(Dt, Yi)),
                                            0 !== Qi ? Ni.push({
                                                nodeInfo: ii,
                                                depth: Yi,
                                                opacity: Qi,
                                                wvpForNode: er,
                                                wvpForTile: pn,
                                                nodeModelMatrix: Un,
                                                tileModelMatrix: jn
                                            }) : No.hidden = !0
                                        }
                                        Gt || Ni.sort( (ii, No) => !Ht || 1 === ii.opacity && 1 === No.opacity ? ii.depth < No.depth ? -1 : 1 : 1 === ii.opacity ? -1 : 1 === No.opacity ? 1 : ii.depth > No.depth ? -1 : 1);
                                        for (const ii of Ni) {
                                            const No = ii.nodeInfo
                                              , Ei = No.node;
                                            let Di = s.ab.mat4.multiply([], nt, ii.tileModelMatrix);
                                            s.ab.mat4.multiply(Di, dt, Di);
                                            const an = s.ab.mat4.invert([], Di);
                                            s.ab.mat4.transpose(an, an),
                                            s.ab.mat4.scale(an, an, pa),
                                            Di = s.ab.mat4.multiply(Di, Di, Ei.matrix);
                                            const jn = "light-beam" === K.renderPass
                                              , lr = "none" === Te.paint.get("model-color-use-theme").constantOr("default")
                                              , bn = Ri & s.dp.HasMapboxMeshFeatures
                                              , Un = bn ? 0 : No.evaluatedRMEA[0][2];
                                            for (let er = 0; er < Ei.meshes.length; ++er) {
                                                const pn = Ei.meshes[er]
                                                  , Yi = er === Ei.lightMeshIndex;
                                                let Qi = ii.wvpForNode;
                                                if (Yi) {
                                                    if (!jn && !K.terrain && K.shadowRenderer) {
                                                        K.currentLayer < K.firstLightBeamLayer && (K.firstLightBeamLayer = K.currentLayer);
                                                        continue
                                                    }
                                                    Qi = ii.wvpForTile
                                                } else if (jn)
                                                    continue;
                                                const vi = {
                                                    defines: []
                                                }
                                                  , dn = [];
                                                if (!Gt && Le && (Le.useNormalOffset = !!pn.normalBuffer),
                                                wh(vi.defines, dn, pn, K, lr ? null : Te.lut),
                                                bn || vi.defines.push("DIFFUSE_SHADED"),
                                                Ji && vi.defines.push("SHADOWS_SINGLE_CASCADE"),
                                                bo && (Gt ? bo.numRenderedVerticesInShadowPass += pn.vertexArray.length : bo.numRenderedVerticesInTransparentPass += pn.vertexArray.length),
                                                Gt) {
                                                    ha(pn, ii.nodeModelMatrix, K, Te);
                                                    continue
                                                }
                                                let Vn = null;
                                                if (ke) {
                                                    const cr = Si(ii.nodeModelMatrix, K.transform);
                                                    if (Vn = new Float32Array(cr),
                                                    "globe" !== De.projection.name) {
                                                        const ns = pn.aabb.min
                                                          , Cr = pn.aabb.max
                                                          , [ya,ys] = ke.getOpacityForBounds(cr, ns[0], ns[1], Cr[0], Cr[1]);
                                                        vi.overrideFog = ya >= wo || ys >= wo
                                                    }
                                                }
                                                const Wi = pn.material;
                                                let tr;
                                                Wi.occlusionTexture && Wi.occlusionTexture.offsetScale && (tr = Wi.occlusionTexture.offsetScale,
                                                vi.defines.push("OCCLUSION_TEXTURE_TRANSFORM"));
                                                const Or = K.getOrCreateProgram("model", vi);
                                                !Gt && Le && Le.setupShadowsFromMatrix(ii.tileModelMatrix, Or, Le.useNormalOffset),
                                                K.uploadCommonUniforms(Ue, Or, null, Vn);
                                                const Tr = Wi.pbrMetallicRoughness;
                                                Tr.metallicFactor = .9,
                                                Tr.roughnessFactor = .5;
                                                const zs = Pn(new Float32Array(Qi), new Float32Array(Di), new Float32Array(an), new Float32Array(Ei.matrix), K, ii.opacity, Tr.baseColorFactor.toRenderColor(null), Wi.emissiveFactor, Tr.metallicFactor, Tr.roughnessFactor, Wi, Un, Te, [0, 0, 0], tr);
                                                !Yi && (No.hasTranslucentParts || ii.opacity < 1) && Or.draw(K, Ue.gl.TRIANGLES, Yt, Xo.disabled, si.disabled, zo.backCCW, zs, Te.id, pn.vertexBuffer, pn.indexBuffer, pn.segments, Te.paint, K.transform.zoom, void 0, dn),
                                                Or.draw(K, Ue.gl.TRIANGLES, Yi ? to : Yt, Xo.disabled, Yi || ii.opacity < 1 || No.hasTranslucentParts ? si.alphaBlended : si.unblended, zo.backCCW, zs, Te.id, pn.vertexBuffer, pn.indexBuffer, pn.segments, Te.paint, K.transform.zoom, void 0, dn)
                                            }
                                        }
                                    }
                                }()
                            }(c, t, i, h),
                            void E();
                        if ("model" !== S.type)
                            return;
                        const I = S.getModels()
                          , R = []
                          , D = c.transform.getFreeCameraOptions().position
                          , k = s.ab.vec3.scale([], [D.x, D.y, D.z], c.transform.worldSize);
                        s.ab.vec3.negate(k, k);
                        const H = []
                          , j = [];
                        let Y = 0;
                        for (const K of I) {
                            const he = i.paint.get("model-rotation").constantOr(null)
                              , Te = i.paint.get("model-scale").constantOr(null)
                              , be = i.paint.get("model-translation").constantOr(null);
                            K.computeModelMatrix(c, he, Te, be, !0, !0, !1);
                            const Ue = s.ab.mat4.identity([])
                              , De = s.dj(K.position.lat, c.transform.zoom)
                              , ke = s.ab.mat4.fromScaling([], [1, 1, 1 / De]);
                            s.ab.mat4.translate(Ue, Ue, k),
                            R.push({
                                zScaleMatrix: ke,
                                negCameraPosMatrix: Ue
                            });
                            for (const Le of K.nodes)
                                Pc(c.transform, Le, K.matrix, c.transform.expandedFarZProjMatrix, Y, H, j);
                            Y++
                        }
                        if (H.sort( (K, he) => he.depth - K.depth),
                        "shadow" !== c.renderPass) {
                            if (1 === d)
                                for (const K of j)
                                    ts(K, c, i, R[K.modelIndex], Xo.disabled, c.colorModeForRenderPass());
                            else {
                                for (const K of j)
                                    ts(K, c, i, R[K.modelIndex], Xo.disabled, si.disabled);
                                for (const K of j)
                                    ts(K, c, i, R[K.modelIndex], c.stencilModeFor3D(), c.colorModeForRenderPass());
                                c.resetStencilClippingMasks()
                            }
                            for (const K of H)
                                ts(K, c, i, R[K.modelIndex], Xo.disabled, c.colorModeForRenderPass());
                            E()
                        } else {
                            for (const K of j)
                                ha(K.mesh, K.nodeModelMatrix, c, i);
                            for (const K of H)
                                ha(K.mesh, K.nodeModelMatrix, c, i);
                            E()
                        }
                    }
                }
                  , Ih = {
                    model: function(c, t, i) {
                        const h = t.getSource();
                        if (!h.loaded())
                            return;
                        if ("vector" === h.type || "geojson" === h.type)
                            return void (i.modelManager && i.modelManager.upload(i, "vector" === h.type ? c.scope : ""));
                        if ("batched-model" === h.type || "model" !== h.type)
                            return;
                        const d = h.getModels();
                        for (const m of d)
                            m.upload(i.context)
                    },
                    raster: function(c, t, i) {
                        const h = t.getSource();
                        if (!(h instanceof ls && h.loaded()))
                            return;
                        const d = c.sourceLayer || h.rasterLayerIds && h.rasterLayerIds[0];
                        if (!d)
                            return;
                        const m = c.paint.get("raster-array-band") || h.getInitialBand(d);
                        if (null == m)
                            return;
                        const y = t.getIds().map(M => t.getTileByID(M));
                        for (const M of y)
                            M.updateNeeded(d, m) && h.prepareTile(M, d, m)
                    },
                    "raster-particle": function(c, t, i) {
                        const h = t.getSource();
                        if (!(h instanceof ls && h.loaded()))
                            return;
                        const d = c.sourceLayer || h.rasterLayerIds && h.rasterLayerIds[0];
                        if (!d)
                            return;
                        const m = c.paint.get("raster-particle-array-band") || h.getInitialBand(d);
                        if (null == m)
                            return;
                        const y = t.getIds().map(M => t.getTileByID(M));
                        for (const M of y)
                            M.updateNeeded(d, m) && h.prepareTile(M, d, m)
                    }
                };
                class Eu {
                    constructor(t, i, h, d, m) {
                        this.context = new pi(t,i),
                        this.transform = h,
                        this._tileTextures = {},
                        this.frameCopies = [],
                        this.loadTimeStamps = [],
                        this.tp = m,
                        this._timeStamp = s.q.now(),
                        this._averageFPS = 0,
                        this._fpsHistory = [],
                        this._dt = 0,
                        this._debugParams = {
                            forceEnablePrecipitation: !1,
                            showTerrainProxyTiles: !1,
                            fpsWindow: 30,
                            continousRedraw: !1,
                            enabledLayers: {}
                        };
                        const y = ["fill", "line", "symbol", "circle", "heatmap", "fill-extrusion", "raster", "raster-particle", "hillshade", "model", "background", "sky"];
                        for (const E of y)
                            this._debugParams.enabledLayers[E] = !0;
                        m.registerParameter(this._debugParams, ["Terrain"], "showTerrainProxyTiles", {}, () => {
                            this.style.map.triggerRepaint()
                        }
                        ),
                        m.registerParameter(this._debugParams, ["Precipitation"], "forceEnablePrecipitation"),
                        m.registerParameter(this._debugParams, ["FPS"], "fpsWindow", {
                            min: 1,
                            max: 100,
                            step: 1
                        }),
                        m.registerBinding(this._debugParams, ["FPS"], "continousRedraw", {
                            readonly: !0,
                            label: "continuous redraw"
                        }),
                        m.registerBinding(this, ["FPS"], "_averageFPS", {
                            readonly: !0,
                            label: "value"
                        }),
                        m.registerBinding(this, ["FPS"], "_averageFPS", {
                            readonly: !0,
                            label: "graph",
                            view: "graph",
                            min: 0,
                            max: 200
                        });
                        for (const E of y)
                            m.registerParameter(this._debugParams.enabledLayers, ["Debug", "Layers"], E);
                        this.occlusionParams = new da(m),
                        this.setup(),
                        this.numSublayers = Ir.maxUnderzooming + Ir.maxOverzooming + 1,
                        this.depthEpsilon = 1 / Math.pow(2, 16),
                        this.deferredRenderGpuTimeQueries = [],
                        this.gpuTimers = {},
                        this.frameCounter = 0,
                        this._backgroundTiles = {},
                        this.conflationActive = !1,
                        this.replacementSource = new s.dv,
                        this.longestCutoffRange = 0,
                        this.minCutoffZoom = 0,
                        this._fogVisible = !1,
                        this._cachedTileFogOpacities = {},
                        this._shadowRenderer = new Br(this),
                        this._wireframeDebugCache = new bu,
                        this.renderDefaultNorthPole = !0,
                        this.renderDefaultSouthPole = !0,
                        this.layersWithOcclusionOpacity = [];
                        const M = new s.r({
                            width: 1,
                            height: 1
                        },Uint8Array.of(0, 0, 0, 0));
                        this.emptyDepthTexture = new s.T(this.context,M,t.RGBA8),
                        this._clippingActiveLastFrame = !1,
                        this.scaleFactor = d
                    }
                    updateTerrain(t, i) {
                        const h = !!t && !!t.terrain && this.transform.projection.supportsTerrain;
                        if (!(h || this._terrain && this._terrain.enabled))
                            return;
                        this._terrain || (this._terrain = new fh(this,t));
                        const d = this._terrain;
                        this.transform.elevation = h ? d : null,
                        d.update(t, this.transform, i),
                        this.transform.elevation && !d.enabled && (this.transform.elevation = null)
                    }
                    _updateFog(t) {
                        const i = t.fog;
                        if (!i || "globe" === this.transform.projection.name || i.getOpacity(this.transform.pitch) < 1 || i.properties.get("horizon-blend") < .03)
                            return void (this.transform.fogCullDistSq = null);
                        const [h,d] = i.getFovAdjustedRange(this.transform._fov);
                        if (h > d)
                            return void (this.transform.fogCullDistSq = null);
                        const m = h + .78 * (d - h);
                        this.transform.fogCullDistSq = m * m
                    }
                    get terrain() {
                        return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled || this._forceTerrainMode ? this._terrain : null
                    }
                    get forceTerrainMode() {
                        return this._forceTerrainMode
                    }
                    set forceTerrainMode(t) {
                        t && !this._terrain && (this._terrain = new fh(this,this.style)),
                        this._forceTerrainMode = t
                    }
                    get shadowRenderer() {
                        return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null
                    }
                    get wireframeDebugCache() {
                        return this._wireframeDebugCache
                    }
                    resize(t, i) {
                        if (this.width = t * s.q.devicePixelRatio,
                        this.height = i * s.q.devicePixelRatio,
                        this.context.viewport.set([0, 0, this.width, this.height]),
                        this.style)
                            for (const h of this.style.order)
                                this.style._mergedLayers[h].resize()
                    }
                    setup() {
                        const t = this.context
                          , i = new s.b4;
                        i.emplaceBack(0, 0),
                        i.emplaceBack(s.ag, 0),
                        i.emplaceBack(0, s.ag),
                        i.emplaceBack(s.ag, s.ag),
                        this.tileExtentBuffer = t.createVertexBuffer(i, s.b6.members),
                        this.tileExtentSegments = s.b7.simpleSegment(0, 0, 4, 2);
                        const h = new s.b4;
                        h.emplaceBack(0, 0),
                        h.emplaceBack(s.ag, 0),
                        h.emplaceBack(0, s.ag),
                        h.emplaceBack(s.ag, s.ag),
                        this.debugBuffer = t.createVertexBuffer(h, s.b6.members),
                        this.debugSegments = s.b7.simpleSegment(0, 0, 4, 5);
                        const d = new s.b4;
                        d.emplaceBack(-1, -1),
                        d.emplaceBack(1, -1),
                        d.emplaceBack(-1, 1),
                        d.emplaceBack(1, 1),
                        this.viewportBuffer = t.createVertexBuffer(d, s.b6.members),
                        this.viewportSegments = s.b7.simpleSegment(0, 0, 4, 2);
                        const m = new s.aT;
                        m.emplaceBack(0, 0, 0, 0),
                        m.emplaceBack(s.ag, 0, s.ag, 0),
                        m.emplaceBack(0, s.ag, 0, s.ag),
                        m.emplaceBack(s.ag, s.ag, s.ag, s.ag),
                        this.mercatorBoundsBuffer = t.createVertexBuffer(m, s.b9.members),
                        this.mercatorBoundsSegments = s.b7.simpleSegment(0, 0, 4, 2);
                        const y = new s.aU;
                        y.emplaceBack(0, 1, 2),
                        y.emplaceBack(2, 1, 3),
                        this.quadTriangleIndexBuffer = t.createIndexBuffer(y);
                        const M = new s.b5;
                        for (const S of [0, 1, 3, 2, 0])
                            M.emplaceBack(S);
                        this.debugIndexBuffer = t.createIndexBuffer(M),
                        this.emptyTexture = new s.T(t,new s.r({
                            width: 1,
                            height: 1
                        },Uint8Array.of(0, 0, 0, 0)),t.gl.RGBA8),
                        this.identityMat = s.ab.mat4.create();
                        const E = this.context.gl;
                        this.stencilClearMode = new Xo({
                            func: E.ALWAYS,
                            mask: 0
                        },0,255,E.ZERO,E.ZERO,E.ZERO),
                        this.loadTimeStamps.push(performance.now())
                    }
                    getMercatorTileBoundsBuffers() {
                        return {
                            tileBoundsBuffer: this.mercatorBoundsBuffer,
                            tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,
                            tileBoundsSegments: this.mercatorBoundsSegments
                        }
                    }
                    getTileBoundsBuffers(t) {
                        return t._makeTileBoundsBuffers(this.context, this.transform.projection),
                        t._tileBoundsBuffer ? {
                            tileBoundsBuffer: t._tileBoundsBuffer,
                            tileBoundsIndexBuffer: t._tileBoundsIndexBuffer,
                            tileBoundsSegments: t._tileBoundsSegments
                        } : this.getMercatorTileBoundsBuffers()
                    }
                    clearStencil() {
                        const t = this.context.gl;
                        this.nextStencilID = 1,
                        this.currentStencilSource = void 0,
                        this._tileClippingMaskIDs = {},
                        this.getOrCreateProgram("clippingMask").draw(this, t.TRIANGLES, Fo.disabled, this.stencilClearMode, si.disabled, zo.disabled, sa(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments)
                    }
                    resetStencilClippingMasks() {
                        this.terrain || (this.currentStencilSource = void 0,
                        this._tileClippingMaskIDs = {})
                    }
                    _renderTileClippingMasks(t, i, h) {
                        if (!i || this.currentStencilSource === i.id || !t.isTileClipped() || !h || 0 === h.length)
                            return;
                        if (this._tileClippingMaskIDs && !this.terrain) {
                            let M = !1;
                            for (const E of h)
                                if (void 0 === this._tileClippingMaskIDs[E.key]) {
                                    M = !0;
                                    break
                                }
                            if (!M)
                                return
                        }
                        this.currentStencilSource = i.id;
                        const d = this.context
                          , m = d.gl;
                        this.nextStencilID + h.length > 256 && this.clearStencil(),
                        d.setColorMode(si.disabled),
                        d.setDepthMode(Fo.disabled);
                        const y = this.getOrCreateProgram("clippingMask");
                        this._tileClippingMaskIDs = {};
                        for (const M of h) {
                            const E = i.getTile(M)
                              , S = this._tileClippingMaskIDs[M.key] = this.nextStencilID++
                              , {tileBoundsBuffer: I, tileBoundsIndexBuffer: R, tileBoundsSegments: D} = this.getTileBoundsBuffers(E);
                            y.draw(this, m.TRIANGLES, Fo.disabled, new Xo({
                                func: m.ALWAYS,
                                mask: 0
                            },S,255,m.KEEP,m.KEEP,m.REPLACE), si.disabled, zo.disabled, sa(M.projMatrix), "$clipping", I, R, D)
                        }
                    }
                    stencilModeFor3D() {
                        this.currentStencilSource = void 0,
                        this.nextStencilID + 1 > 256 && this.clearStencil();
                        const t = this.nextStencilID++
                          , i = this.context.gl;
                        return new Xo({
                            func: i.NOTEQUAL,
                            mask: 255
                        },t,255,i.KEEP,i.KEEP,i.REPLACE)
                    }
                    stencilModeForClipping(t) {
                        if (this.terrain)
                            return this.terrain.stencilModeForRTTOverlap(t);
                        const i = this.context.gl;
                        return new Xo({
                            func: i.EQUAL,
                            mask: 255
                        },this._tileClippingMaskIDs[t.key],0,i.KEEP,i.KEEP,i.REPLACE)
                    }
                    stencilConfigForOverlap(t) {
                        const i = this.context.gl
                          , h = t.sort( (y, M) => M.overscaledZ - y.overscaledZ)
                          , d = h[h.length - 1].overscaledZ
                          , m = h[0].overscaledZ - d + 1;
                        if (m > 1) {
                            this.currentStencilSource = void 0,
                            this.nextStencilID + m > 256 && this.clearStencil();
                            const y = {};
                            for (let M = 0; M < m; M++)
                                y[M + d] = new Xo({
                                    func: i.GEQUAL,
                                    mask: 255
                                },M + this.nextStencilID,255,i.KEEP,i.KEEP,i.REPLACE);
                            return this.nextStencilID += m,
                            [y, h]
                        }
                        return [{
                            [d]: Xo.disabled
                        }, h]
                    }
                    colorModeForRenderPass() {
                        const t = this.context.gl;
                        return this._showOverdrawInspector ? new si([t.CONSTANT_COLOR, t.ONE, t.CONSTANT_COLOR, t.ONE],new s.aj(.125,.125,.125,0),[!0, !0, !0, !0]) : "opaque" === this.renderPass ? si.unblended : si.alphaBlended
                    }
                    colorModeForDrapableLayerRenderPass(t) {
                        const i = this.context.gl;
                        return this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture && "translucent" === this.renderPass ? new si([i.ONE, i.ONE_MINUS_SRC_ALPHA, i.CONSTANT_ALPHA, i.ONE_MINUS_SRC_ALPHA],new s.aj(0,0,0,void 0 === t ? 0 : t),[!0, !0, !0, !0]) : this.colorModeForRenderPass()
                    }
                    depthModeForSublayer(t, i, h, d=!1) {
                        if (this.depthOcclusion)
                            return new Fo(this.context.gl.GREATER,Fo.ReadOnly,this.depthRangeFor3D);
                        if (!this.opaquePassEnabledForLayer() && !d)
                            return Fo.disabled;
                        const m = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;
                        return new Fo(h || this.context.gl.LEQUAL,i,[m, m])
                    }
                    opaquePassEnabledForLayer() {
                        return this.currentLayer < this.opaquePassCutoff
                    }
                    blitDepth() {
                        const t = this.context.gl
                          , i = Math.ceil(this.width)
                          , h = Math.ceil(this.height)
                          , d = this.context.bindFramebuffer.get()
                          , m = t.getParameter(t.TEXTURE_BINDING_2D);
                        this.depthFBO && this.depthFBO.width === i && this.depthFBO.height === h || (this.depthFBO && (this.depthFBO.destroy(),
                        this.depthFBO = void 0,
                        this.depthTexture = void 0),
                        0 !== i && 0 !== h && (this.depthFBO = new hi(this.context,i,h,!1,"texture"),
                        this.depthTexture = new s.T(this.context,{
                            width: i,
                            height: h,
                            data: null
                        },t.DEPTH24_STENCIL8),
                        this.depthFBO.depthAttachment.set(this.depthTexture.texture))),
                        this.context.bindFramebuffer.set(d),
                        t.bindTexture(t.TEXTURE_2D, m),
                        this.depthFBO && (t.bindFramebuffer(t.READ_FRAMEBUFFER, null),
                        t.bindFramebuffer(t.DRAW_FRAMEBUFFER, this.depthFBO.framebuffer),
                        t.blitFramebuffer(0, 0, i, h, 0, 0, i, h, t.DEPTH_BUFFER_BIT, t.NEAREST),
                        t.bindFramebuffer(t.FRAMEBUFFER, this.context.bindFramebuffer.current))
                    }
                    updateAverageFPS() {
                        this._fpsHistory.push(0 === this._dt ? 0 : 1e3 / this._dt),
                        this._fpsHistory.length > this._debugParams.fpsWindow && this._fpsHistory.splice(0, this._fpsHistory.length - this._debugParams.fpsWindow),
                        this._averageFPS = Math.round(this._fpsHistory.reduce( (t, i) => t + i / this._fpsHistory.length, 0))
                    }
                    render(t, i) {
                        const h = s.q.now();
                        this._dt = h - this._timeStamp,
                        this._timeStamp = h,
                        this._wireframeDebugCache.update(this.frameCounter),
                        this._debugParams.continousRedraw = t.map.repaint,
                        this.style = t,
                        this.options = i;
                        const d = this.style._mergedLayers
                          , m = this.style._getOrder(!(!this.terrain || !this.terrain.enabled)).filter(Ze => {
                            const nt = d[Ze];
                            return !(nt.type in this._debugParams.enabledLayers) || this._debugParams.enabledLayers[nt.type]
                        }
                        );
                        let y = !1
                          , M = !1;
                        for (const Ze of m) {
                            const nt = d[Ze];
                            "circle" === nt.type && (y = !0),
                            "symbol" === nt.type && (nt.hasInitialOcclusionOpacityProperties ? M = !0 : y = !0)
                        }
                        const E = m.map(Ze => d[Ze])
                          , S = this.style._mergedSourceCaches;
                        this.imageManager = t.imageManager,
                        this.modelManager = t.modelManager,
                        this.symbolFadeChange = t.placement.symbolFadeChange(s.q.now()),
                        this.imageManager.beginFrame();
                        let I = 0
                          , R = !1;
                        for (const Ze in S) {
                            const nt = S[Ze];
                            nt.used && (nt.prepare(this.context),
                            nt.getSource().usedInConflation && ++I)
                        }
                        let D = !1;
                        for (const Ze of E)
                            Ze.isHidden(this.transform.zoom) || ("clip" === Ze.type && (D = !0),
                            this.prepareLayer(Ze));
                        const k = {}
                          , H = {}
                          , j = {}
                          , Y = {}
                          , K = {};
                        for (const Ze in S) {
                            const nt = S[Ze];
                            k[Ze] = nt.getVisibleCoordinates(),
                            H[Ze] = k[Ze].slice().reverse(),
                            j[Ze] = nt.getVisibleCoordinates(!0).reverse(),
                            Y[Ze] = nt.getShadowCasterCoordinates(),
                            K[Ze] = nt.sortCoordinatesByDistance(k[Ze])
                        }
                        const he = Ze => {
                            const nt = this.style.getLayerSourceCache(Ze);
                            return nt && nt.used ? nt.getSource() : null
                        }
                        ;
                        if (I || D || this._clippingActiveLastFrame) {
                            const Ze = []
                              , nt = [];
                            let zt = 0;
                            for (const Yt of E)
                                this.isSourceForClippingOrConflation(Yt, he(Yt)) && (Ze.push(Yt),
                                nt.push(zt)),
                                zt++;
                            if (Ze && (D || Ze.length > 1) || this._clippingActiveLastFrame) {
                                D = !1;
                                const Yt = [];
                                for (let to = 0; to < Ze.length; to++) {
                                    const ut = Ze[to]
                                      , Gt = nt[to]
                                      , wt = this.style.getLayerSourceCache(ut);
                                    if (!wt || !wt.used || !wt.getSource().usedInConflation && "clip" !== ut.type)
                                        continue;
                                    let qt = s.dx
                                      , Ht = s.by.None;
                                    const Dt = [];
                                    let bo = !0;
                                    if ("clip" === ut.type) {
                                        qt = Gt;
                                        for (const oo of ut.layout.get("clip-layer-types"))
                                            Ht |= "model" === oo ? s.by.Model : "symbol" === oo ? s.by.Symbol : s.by.FillExtrusion;
                                        for (const oo of ut.layout.get("clip-layer-scope"))
                                            Dt.push(oo);
                                        ut.isHidden(this.transform.zoom) ? bo = !1 : D = !0
                                    }
                                    bo && Yt.push({
                                        layer: ut.fqid,
                                        cache: wt,
                                        order: qt,
                                        clipMask: Ht,
                                        clipScope: Dt
                                    })
                                }
                                this.replacementSource.setSources(Yt),
                                R = !0
                            }
                        }
                        this._clippingActiveLastFrame = D,
                        R || this.replacementSource.clear(),
                        this.conflationActive = R,
                        this.minCutoffZoom = 0,
                        this.longestCutoffRange = 0,
                        this.opaquePassCutoff = 1 / 0,
                        this._lastOcclusionLayer = -1,
                        this.layersWithOcclusionOpacity = [];
                        for (let Ze = 0; Ze < E.length; Ze++) {
                            const nt = E[Ze]
                              , zt = nt.cutoffRange();
                            if (this.longestCutoffRange = Math.max(zt, this.longestCutoffRange),
                            zt > 0) {
                                const Yt = he(nt);
                                Yt && (this.minCutoffZoom = Math.max(Yt.minzoom, this.minCutoffZoom)),
                                nt.minzoom && (this.minCutoffZoom = Math.max(nt.minzoom, this.minCutoffZoom))
                            }
                            nt.is3D() && (this.opaquePassCutoff === 1 / 0 && (this.opaquePassCutoff = Ze),
                            this._lastOcclusionLayer = Ze)
                        }
                        const Te = this.style && this.style.fog;
                        Te ? (this._fogVisible = 0 !== Te.getOpacity(this.transform.pitch),
                        this._fogVisible && "globe" !== this.transform.projection.name && (this._fogVisible = Te.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = !1,
                        this._cachedTileFogOpacities = {},
                        this.terrain && (this.terrain.updateTileBinding(j),
                        this.opaquePassCutoff = 0);
                        const be = this._shadowRenderer;
                        if (be) {
                            be.updateShadowParameters(this.transform, this.style.directionalLight);
                            for (const Ze in S)
                                for (const nt of k[Ze]) {
                                    let zt = {
                                        min: 0,
                                        max: 0
                                    };
                                    this.terrain && (zt = this.terrain.getMinMaxForTile(nt) || zt),
                                    be.addShadowReceiver(nt.toUnwrapped(), zt.min, zt.max)
                                }
                        }
                        "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new s.dw(this.context)),
                        this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new tn(this)),
                        this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(),
                        this._atmosphere = void 0);
                        const Ue = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.snow)
                          , De = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.rain);
                        if (Ue && !this._snow && (this._snow = new za(this)),
                        !Ue && this._snow && (this._snow.destroy(),
                        delete this._snow),
                        De && !this._rain && (this._rain = new Tu(this)),
                        !De && this._rain && (this._rain.destroy(),
                        delete this._rain),
                        this._snow && this._snow.update(this),
                        this._rain && this._rain.update(this),
                        !de.has(this.context.gl))
                            return;
                        this.renderPass = "offscreen";
                        for (const Ze of E) {
                            const nt = t.getLayerSourceCache(Ze);
                            if (!Ze.hasOffscreenPass() || Ze.isHidden(this.transform.zoom))
                                continue;
                            const zt = nt ? H[nt.id] : void 0;
                            ("custom" === Ze.type || "raster" === Ze.type || "raster-particle" === Ze.type || Ze.isSky() || zt && zt.length) && this.renderLayer(this, nt, Ze, zt)
                        }
                        this.depthRangeFor3D = [0, 1 - (E.length + 2) * this.numSublayers * this.depthEpsilon],
                        this._shadowRenderer && (this.renderPass = "shadow",
                        this._shadowRenderer.drawShadowPass(this.style, Y)),
                        this.context.bindFramebuffer.set(null),
                        this.context.viewport.set([0, 0, this.width, this.height]);
                        const ke = "globe" === this.transform.projection.name || this.transform.isHorizonVisible()
                          , Le = ( () => {
                            if (i.showOverdrawInspector)
                                return s.aj.black;
                            const Ze = this.style.fog;
                            if (Ze && this.transform.projection.supportsFog) {
                                const nt = this.style.getLut(Ze.scope);
                                if (!ke) {
                                    const zt = "none" === Ze.properties.get("color-use-theme")
                                      , Yt = Ze.properties.get("color").toRenderColor(zt ? null : nt).toArray01();
                                    return new s.aj(...Yt)
                                }
                                if (ke) {
                                    const zt = "none" === Ze.properties.get("space-color-use-theme")
                                      , Yt = Ze.properties.get("space-color").toRenderColor(zt ? null : nt).toArray01();
                                    return new s.aj(...Yt)
                                }
                            }
                            return s.aj.transparent
                        }
                        )();
                        if (this.context.clear({
                            color: Le,
                            depth: 1
                        }),
                        this.clearStencil(),
                        this._showOverdrawInspector = i.showOverdrawInspector,
                        this.renderPass = "opaque",
                        this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && ke && this._atmosphere.drawStars(this, this.style.fog),
                        !this.terrain)
                            for (this.currentLayer = m.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                                const Ze = E[this.currentLayer]
                                  , nt = t.getLayerSourceCache(Ze);
                                if (Ze.isSky())
                                    continue;
                                const zt = nt ? (Ze.is3D() ? K : H)[nt.id] : void 0;
                                this._renderTileClippingMasks(Ze, nt, zt),
                                this.renderLayer(this, nt, Ze, zt)
                            }
                        if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && ke && this._atmosphere.drawAtmosphereGlow(this, this.style.fog),
                        this.renderPass = "sky",
                        (!this._atmosphere || s.ae(this.transform.zoom) > 0) && ("globe" === this.transform.projection.name || this.transform.isHorizonVisible()))
                            for (this.currentLayer = 0; this.currentLayer < m.length; this.currentLayer++) {
                                const Ze = E[this.currentLayer]
                                  , nt = t.getLayerSourceCache(Ze);
                                Ze.isSky() && this.renderLayer(this, nt, Ze, nt ? H[nt.id] : void 0)
                            }
                        function Ge(Ze, nt) {
                            let zt;
                            return nt && (zt = ("symbol" === Ze.type ? j : Ze.is3D() ? K : H)[nt.id]),
                            zt
                        }
                        if (this.renderPass = "translucent",
                        "globe" === this.transform.projection.name) {
                            for (this.renderElevatedRasterBackface = !0,
                            this.currentLayer = 0; this.currentLayer < m.length; ) {
                                const Ze = E[this.currentLayer];
                                if ("raster" === Ze.type || "raster-particle" === Ze.type) {
                                    const nt = t.getLayerSourceCache(Ze);
                                    this.renderLayer(this, nt, Ze, Ge(Ze, nt))
                                }
                                ++this.currentLayer
                            }
                            this.renderElevatedRasterBackface = !1
                        }
                        this.currentLayer = 0,
                        this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;
                        let qe = 0;
                        be && (qe = be.getShadowCastingLayerCount());
                        let vt = !1
                          , dt = -1;
                        for (let Ze = 0; Ze < m.length; ++Ze) {
                            const nt = E[Ze];
                            nt.isHidden(this.transform.zoom) || nt.is3D() && (dt = Ze)
                        }
                        for (M && -1 === dt && (y = !0); this.currentLayer < m.length; ) {
                            const Ze = E[this.currentLayer]
                              , nt = t.getLayerSourceCache(Ze);
                            if (Ze.isSky())
                                ++this.currentLayer;
                            else if (this.terrain && this.style.isLayerDraped(Ze)) {
                                if (Ze.isHidden(this.transform.zoom)) {
                                    ++this.currentLayer;
                                    continue
                                }
                                this.currentLayer = this.terrain.renderBatch(this.currentLayer),
                                this._lastOcclusionLayer = Math.max(this.currentLayer, this._lastOcclusionLayer)
                            } else {
                                if (y && !vt && this.terrain && !this.transform.isOrthographic && (vt = !0,
                                this.blitDepth()),
                                M && -1 !== dt && this.currentLayer === dt + 1 && !this.transform.isOrthographic && this.blitDepth(),
                                Ze.is3D() || this.terrain || this._renderTileClippingMasks(Ze, nt, nt ? k[nt.id] : void 0),
                                this.renderLayer(this, nt, Ze, Ge(Ze, nt)),
                                !this.terrain && be && qe > 0 && Ze.hasShadowPass() && 0 == --qe && (be.drawGroundShadows(),
                                this.firstLightBeamLayer <= this.currentLayer)) {
                                    const zt = this.currentLayer;
                                    for (this.renderPass = "light-beam",
                                    this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= zt; this.currentLayer++) {
                                        const Yt = E[this.currentLayer];
                                        if (!Yt.hasLightBeamPass())
                                            continue;
                                        const to = t.getLayerSourceCache(Yt);
                                        this.renderLayer(this, to, Yt, to ? H[to.id] : void 0)
                                    }
                                    this.currentLayer = zt,
                                    this.renderPass = "translucent"
                                }
                                if (this.currentLayer >= this._lastOcclusionLayer && this.layersWithOcclusionOpacity.length > 0) {
                                    const zt = this.currentLayer;
                                    this.depthOcclusion = !0;
                                    for (const Yt of this.layersWithOcclusionOpacity) {
                                        this.currentLayer = Yt;
                                        const to = E[this.currentLayer]
                                          , ut = t.getLayerSourceCache(to)
                                          , Gt = ut ? H[ut.id] : void 0;
                                        to.is3D() || this.terrain || this._renderTileClippingMasks(to, ut, ut ? k[ut.id] : void 0),
                                        this.renderLayer(this, ut, to, Gt)
                                    }
                                    this.depthOcclusion = !1,
                                    this.currentLayer = zt,
                                    this.renderPass = "translucent",
                                    this.layersWithOcclusionOpacity = []
                                }
                                ++this.currentLayer
                            }
                        }
                        if (this.terrain && this.terrain.postRender(),
                        this._snow && this._snow.draw(this),
                        this._rain && this._rain.draw(this),
                        this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
                            let Ze = null;
                            E.forEach(nt => {
                                const zt = t.getLayerSourceCache(nt);
                                zt && !nt.isHidden(this.transform.zoom) && zt.getVisibleCoordinates().length && (!Ze || Ze.getSource().maxzoom < zt.getSource().maxzoom) && (Ze = zt)
                            }
                            ),
                            Ze && this.options.showTileBoundaries && Mc.debug(this, Ze, Ze.getVisibleCoordinates(), s.aj.red, !1, this.options.showParseStatus)
                        }
                        this.terrain && this._debugParams.showTerrainProxyTiles && Mc.debug(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new s.aj(1,.8,.1,1), !0, this.options.showParseStatus),
                        this.options.showPadding && function(Ze) {
                            const nt = Ze.transform.padding;
                            xc(Ze, Ze.transform.height - (nt.top || 0), 3, _p),
                            xc(Ze, nt.bottom || 0, 3, gp),
                            xh(Ze, nt.left || 0, 3, Pl),
                            xh(Ze, Ze.transform.width - (nt.right || 0), 3, Md);
                            const zt = Ze.transform.centerPoint;
                            var Yt, to, ut, Gt;
                            bc(Yt = Ze, (to = zt.x) - 1, (ut = Ze.transform.height - zt.y) - 10, 2, 20, Gt = Td),
                            bc(Yt, to - 10, ut - 1, 20, 2, Gt)
                        }(this),
                        this.context.setDefault(),
                        this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER,
                        this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()),
                        this.saveCanvasCopy()),
                        R || (this.conflationActive = !1)
                    }
                    prepareLayer(t) {
                        this.gpuTimingStart(t);
                        const {unsupportedLayers: i} = this.transform.projection
                          , h = !i || !i.includes(t.type);
                        if (Ih[t.type] && (h || this.terrain && "custom" === t.type)) {
                            const d = this.style.getLayerSourceCache(t);
                            Ih[t.type](t, d, this)
                        }
                        this.gpuTimingEnd()
                    }
                    renderLayer(t, i, h, d) {
                        h.isHidden(this.transform.zoom) || ("background" === h.type || "sky" === h.type || "custom" === h.type || "model" === h.type || "raster" === h.type || "raster-particle" === h.type || d && d.length) && (this.id = h.id,
                        this.gpuTimingStart(h),
                        t.transform.projection.unsupportedLayers && t.transform.projection.unsupportedLayers.includes(h.type) && (!t.terrain || "custom" !== h.type) || "clip" === h.type || Mc[h.type](t, i, h, d, this.style.placement.variableOffsets, this.options.isInitialLoad),
                        this.gpuTimingEnd())
                    }
                    gpuTimingStart(t) {
                        if (!this.options.gpuTiming)
                            return;
                        const i = this.context.extTimerQuery
                          , h = this.context.gl;
                        let d = this.gpuTimers[t.id];
                        d || (d = this.gpuTimers[t.id] = {
                            calls: 0,
                            cpuTime: 0,
                            query: h.createQuery()
                        }),
                        d.calls++,
                        h.beginQuery(i.TIME_ELAPSED_EXT, d.query)
                    }
                    gpuTimingDeferredRenderStart() {
                        if (this.options.gpuTimingDeferredRender) {
                            const t = this.context.extTimerQuery
                              , i = this.context.gl
                              , h = i.createQuery();
                            this.deferredRenderGpuTimeQueries.push(h),
                            i.beginQuery(t.TIME_ELAPSED_EXT, h)
                        }
                    }
                    gpuTimingDeferredRenderEnd() {
                        this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT)
                    }
                    gpuTimingEnd() {
                        this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT)
                    }
                    collectGpuTimers() {
                        const t = this.gpuTimers;
                        return this.gpuTimers = {},
                        t
                    }
                    collectDeferredRenderGpuQueries() {
                        const t = this.deferredRenderGpuTimeQueries;
                        return this.deferredRenderGpuTimeQueries = [],
                        t
                    }
                    queryGpuTimers(t) {
                        const i = {};
                        for (const h in t) {
                            const d = t[h]
                              , m = this.context.extTimerQuery
                              , y = m.getQueryParameter(d.query, this.context.gl.QUERY_RESULT) / 1e6;
                            m.deleteQueryEXT(d.query),
                            i[h] = y
                        }
                        return i
                    }
                    queryGpuTimeDeferredRender(t) {
                        if (!this.options.gpuTimingDeferredRender)
                            return 0;
                        const i = this.context.gl;
                        let h = 0;
                        for (const d of t)
                            h += i.getQueryParameter(d, i.QUERY_RESULT) / 1e6,
                            i.deleteQuery(d);
                        return h
                    }
                    translatePosMatrix(t, i, h, d, m) {
                        if (!h[0] && !h[1])
                            return t;
                        const y = m ? "map" === d ? this.transform.angle : 0 : "viewport" === d ? -this.transform.angle : 0;
                        if (y) {
                            const S = Math.sin(y)
                              , I = Math.cos(y);
                            h = [h[0] * I - h[1] * S, h[0] * S + h[1] * I]
                        }
                        const M = [m ? h[0] : s.ar(i, h[0], this.transform.zoom), m ? h[1] : s.ar(i, h[1], this.transform.zoom), 0]
                          , E = new Float32Array(16);
                        return s.ab.mat4.translate(E, t, M),
                        E
                    }
                    saveTileTexture(t) {
                        const i = t.size[0]
                          , h = this._tileTextures[i];
                        h ? h.push(t) : this._tileTextures[i] = [t]
                    }
                    getTileTexture(t) {
                        const i = this._tileTextures[t];
                        return i && i.length > 0 ? i.pop() : null
                    }
                    terrainRenderModeElevated() {
                        return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture || this.forceTerrainMode
                    }
                    linearFloatFilteringSupported() {
                        return null != this.context.extTextureFloatLinear
                    }
                    currentGlobalDefines(t, i, h) {
                        const d = void 0 === h ? this.terrain && this.terrain.renderingToTexture : h
                          , m = [];
                        return this.style && this.style.enable3dLights() && ("globeRaster" === t || "terrainRaster" === t ? (m.push("LIGHTING_3D_MODE"),
                        m.push("LIGHTING_3D_ALPHA_EMISSIVENESS")) : d || m.push("LIGHTING_3D_MODE")),
                        "shadow" === this.renderPass && (this._shadowMapDebug || m.push("DEPTH_TEXTURE")),
                        this.terrainRenderModeElevated() && (m.push("TERRAIN"),
                        this.linearFloatFilteringSupported() && m.push("TERRAIN_DEM_FLOAT_FORMAT")),
                        "globe" === this.transform.projection.name && m.push("GLOBE"),
                        !this._fogVisible || d || void 0 !== i && !i || m.push("FOG", "FOG_DITHERING"),
                        d && m.push("RENDER_TO_TEXTURE"),
                        this._showOverdrawInspector && m.push("OVERDRAW_INSPECTOR"),
                        m
                    }
                    getOrCreateProgram(t, i) {
                        this.cache = this.cache || {};
                        const h = i && i.defines || []
                          , d = i && i.config
                          , m = this.currentGlobalDefines(t, i && i.overrideFog, i && i.overrideRtt).concat(h)
                          , y = gh.cacheKey(Ia[t], t, m, d);
                        return this.cache[y] || (this.cache[y] = new gh(this.context,t,Ia[t],d,Bn[t],m)),
                        this.cache[y]
                    }
                    setCustomLayerDefaults() {
                        this.context.unbindVAO(),
                        this.context.cullFace.setDefault(),
                        this.context.frontFace.setDefault(),
                        this.context.cullFaceSide.setDefault(),
                        this.context.activeTexture.setDefault(),
                        this.context.pixelStoreUnpack.setDefault(),
                        this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                        this.context.pixelStoreUnpackFlipY.setDefault()
                    }
                    setBaseState() {
                        const t = this.context.gl;
                        this.context.cullFace.set(!1),
                        this.context.viewport.set([0, 0, this.width, this.height]),
                        this.context.blendEquation.set(t.FUNC_ADD)
                    }
                    initDebugOverlayCanvas() {
                        null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"),
                        this.debugOverlayCanvas.width = 512,
                        this.debugOverlayCanvas.height = 512,
                        this.debugOverlayTexture = new s.T(this.context,this.debugOverlayCanvas,this.context.gl.RGBA8))
                    }
                    destroy() {
                        this._terrain && this._terrain.destroy(),
                        this._atmosphere && (this._atmosphere.destroy(),
                        this._atmosphere = void 0),
                        this.globeSharedBuffers && this.globeSharedBuffers.destroy(),
                        this.emptyTexture.destroy(),
                        this.debugOverlayTexture && this.debugOverlayTexture.destroy(),
                        this._wireframeDebugCache.destroy(),
                        this.depthFBO && (this.depthFBO.destroy(),
                        this.depthFBO = void 0,
                        this.depthTexture = void 0),
                        this.emptyDepthTexture && this.emptyDepthTexture.destroy()
                    }
                    prepareDrawTile() {
                        this.terrain && this.terrain.prepareDrawTile()
                    }
                    uploadCommonLightUniforms(t, i) {
                        if (this.style.enable3dLights()) {
                            const h = this.style.directionalLight
                              , d = this.style.ambientLight;
                            if (h && d) {
                                const m = ( (y, M, E) => {
                                    const S = y.properties.get("direction")
                                      , I = "none" === y.properties.get("color-use-theme")
                                      , R = y.properties.get("color").toRenderColor(I ? null : E.getLut(y.scope)).toArray01()
                                      , D = y.properties.get("intensity")
                                      , k = "none" === M.properties.get("color-use-theme")
                                      , H = M.properties.get("color").toRenderColor(k ? null : E.getLut(M.scope)).toArray01()
                                      , j = M.properties.get("intensity")
                                      , Y = [S.x, S.y, S.z]
                                      , K = s.cM(H, j)
                                      , he = s.cM(R, D);
                                    return {
                                        u_lighting_ambient_color: K,
                                        u_lighting_directional_dir: Y,
                                        u_lighting_directional_color: he,
                                        u_ground_radiance: _h(Y, he, K)
                                    }
                                }
                                )(h, d, this.style);
                                i.setLightsUniformValues(t, m)
                            }
                        }
                    }
                    uploadCommonUniforms(t, i, h, d, m) {
                        if (this.uploadCommonLightUniforms(t, i),
                        this.terrain && this.terrain.renderingToTexture)
                            return;
                        const y = this.style.fog;
                        if (y) {
                            const M = y.getOpacity(this.transform.pitch)
                              , E = ( (S, I, R, D, k, H, j, Y, K, he, Te, be) => {
                                const Ue = S.transform
                                  , De = "none" === I.properties.get("color-use-theme")
                                  , ke = I.properties.get("color").toRenderColor(De ? null : S.style.getLut(I.scope)).toArray01();
                                ke[3] = D;
                                const Le = S.frameCounter / 1e3 % 1
                                  , [Ge,qe] = I.properties.get("vertical-range");
                                return {
                                    u_fog_matrix: R ? Ue.calculateFogTileMatrix(R) : be || S.identityMat,
                                    u_fog_range: I.getFovAdjustedRange(Ue._fov),
                                    u_fog_color: ke,
                                    u_fog_horizon_blend: I.properties.get("horizon-blend"),
                                    u_fog_vertical_limit: [Math.min(Ge, qe), qe],
                                    u_fog_temporal_offset: Le,
                                    u_frustum_tl: k,
                                    u_frustum_tr: H,
                                    u_frustum_br: j,
                                    u_frustum_bl: Y,
                                    u_globe_pos: K,
                                    u_globe_radius: he,
                                    u_viewport: Te,
                                    u_globe_transition: s.ae(Ue.zoom),
                                    u_is_globe: +("globe" === Ue.projection.name)
                                }
                            }
                            )(this, y, h, M, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * s.q.devicePixelRatio, this.transform.height * s.q.devicePixelRatio], d);
                            i.setFogUniformValues(t, E)
                        }
                        m && i.setCutoffUniformValues(t, m.uniformValues)
                    }
                    setTileLoadedFlag(t) {
                        this.tileLoaded = t
                    }
                    saveCanvasCopy() {
                        const t = this.canvasCopy();
                        t && (this.frameCopies.push(t),
                        this.tileLoaded = !1)
                    }
                    canvasCopy() {
                        const t = this.context.gl
                          , i = t.createTexture();
                        return t.bindTexture(t.TEXTURE_2D, i),
                        t.copyTexImage2D(t.TEXTURE_2D, 0, t.RGBA, 0, 0, t.drawingBufferWidth, t.drawingBufferHeight, 0),
                        i
                    }
                    getCanvasCopiesAndTimestamps() {
                        return {
                            canvasCopies: this.frameCopies,
                            timeStamps: this.loadTimeStamps
                        }
                    }
                    averageElevationNeedsEasing() {
                        if (!this.transform._elevation)
                            return !1;
                        const t = this.style && this.style.fog;
                        return !!t && 0 !== t.getOpacity(this.transform.pitch)
                    }
                    getBackgroundTiles() {
                        const t = this._backgroundTiles
                          , i = this._backgroundTiles = {}
                          , h = this.transform.coveringTiles({
                            tileSize: 512
                        });
                        for (const d of h)
                            i[d.key] = t[d.key] || new hs(d,512,this.transform.tileZoom,this);
                        return i
                    }
                    clearBackgroundTiles() {
                        this._backgroundTiles = {}
                    }
                    isSourceForClippingOrConflation(t, i) {
                        return !(!t.is3D() || "clip" !== t.type && (t.minzoom && t.minzoom > this.transform.zoom || (this.style._clipLayerPresent || "building" !== t.sourceLayer) && (!i || "batched-model" !== i.type)))
                    }
                    isTileAffectedByFog(t) {
                        if (!this.style || !this.style.fog)
                            return !1;
                        if ("globe" === this.transform.projection.name)
                            return !0;
                        let i = this._cachedTileFogOpacities[t.key];
                        return i || (this._cachedTileFogOpacities[t.key] = i = this.style.fog.getOpacityForTile(t)),
                        i[0] >= wo || i[1] >= wo
                    }
                    setupDepthForOcclusion(t, i, h) {
                        const d = this.context
                          , m = d.gl
                          , y = !!h;
                        var M;
                        h || (h = {
                            u_dem: 2,
                            u_dem_prev: 4,
                            u_dem_tl: [0, 0],
                            u_dem_tl_prev: [0, 0],
                            u_dem_scale: 0,
                            u_dem_scale_prev: 0,
                            u_dem_size: 0,
                            u_dem_lerp: 1,
                            u_depth: 3,
                            u_depth_size_inv: [0, 0],
                            u_depth_range_unpack: [0, 1],
                            u_occluder_half_size: 16,
                            u_occlusion_depth_offset: -1e-4,
                            u_exaggeration: 0
                        }),
                        d.activeTexture.set(m.TEXTURE3),
                        t && this.depthFBO && this.depthTexture ? (this.depthTexture.bind(m.NEAREST, m.CLAMP_TO_EDGE),
                        h.u_depth_size_inv = [1 / this.depthFBO.width, 1 / this.depthFBO.height],
                        h.u_depth_range_unpack = [2 / ((M = this.depthRangeFor3D)[1] - M[0]), -1 - 2 * M[0] / (M[1] - M[0])],
                        h.u_occluder_half_size = .5 * this.occlusionParams.occluderSize,
                        h.u_occlusion_depth_offset = this.occlusionParams.depthOffset) : this.emptyDepthTexture.bind(m.NEAREST, m.CLAMP_TO_EDGE),
                        d.activeTexture.set(m.TEXTURE0),
                        y || i.setTerrainUniformValues(d, h)
                    }
                }
                function Tc(c, t) {
                    let i = !1
                      , h = null;
                    const d = () => {
                        h = null,
                        i && (c(),
                        h = setTimeout(d, t),
                        i = !1)
                    }
                    ;
                    return () => (i = !0,
                    h || d(),
                    h)
                }
                class Su {
                    constructor(t) {
                        this._hashName = t && encodeURIComponent(t),
                        s.aP(["_getCurrentHash", "_onHashChange", "_updateHash"], this),
                        this._updateHash = Tc(this._updateHashUnthrottled.bind(this), 300)
                    }
                    addTo(t) {
                        return this._map = t,
                        window.addEventListener("hashchange", this._onHashChange, !1),
                        t.on("moveend", this._updateHash),
                        this
                    }
                    remove() {
                        return this._map ? (this._map.off("moveend", this._updateHash),
                        window.removeEventListener("hashchange", this._onHashChange, !1),
                        clearTimeout(this._updateHash()),
                        this._map = void 0,
                        this) : this
                    }
                    getHashString() {
                        const t = this._map;
                        if (!t)
                            return "";
                        const i = Ah(t);
                        if (this._hashName) {
                            const h = this._hashName;
                            let d = !1;
                            const m = location.hash.slice(1).split("&").map(y => {
                                const M = y.split("=")[0];
                                return M === h ? (d = !0,
                                "".concat(M, "=").concat(i)) : y
                            }
                            ).filter(y => y);
                            return d || m.push("".concat(h, "=").concat(i)),
                            "#".concat(m.join("&"))
                        }
                        return "#".concat(i)
                    }
                    _getCurrentHash() {
                        const t = location.hash.replace("#", "");
                        if (this._hashName) {
                            let i;
                            return t.split("&").map(h => h.split("=")).forEach(h => {
                                h[0] === this._hashName && (i = h)
                            }
                            ),
                            (i && i[1] || "").split("/")
                        }
                        return t.split("/")
                    }
                    _onHashChange() {
                        const t = this._map;
                        if (!t)
                            return !1;
                        const i = this._getCurrentHash();
                        if (i.length >= 3 && !i.some(h => isNaN(h))) {
                            const h = t.dragRotate.isEnabled() && t.touchZoomRotate.isEnabled() ? +(i[3] || 0) : t.getBearing();
                            return t.jumpTo({
                                center: [+i[2], +i[1]],
                                zoom: +i[0],
                                bearing: h,
                                pitch: +(i[4] || 0)
                            }),
                            !0
                        }
                        return !1
                    }
                    _updateHashUnthrottled() {
                        history.replaceState(history.state, "", location.href.replace(/(#.+)?$/, this.getHashString()))
                    }
                }
                function Ah(c, t) {
                    const i = c.getCenter()
                      , h = Math.round(100 * c.getZoom()) / 100
                      , d = Math.ceil((h * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10)
                      , m = Math.pow(10, d)
                      , y = Math.round(i.lng * m) / m
                      , M = Math.round(i.lat * m) / m
                      , E = c.getBearing()
                      , S = c.getPitch();
                    let I = t ? "/".concat(y, "/").concat(M, "/").concat(h) : "".concat(h, "/").concat(M, "/").concat(y);
                    return (E || S) && (I += "/" + Math.round(10 * E) / 10),
                    S && (I += "/".concat(Math.round(S))),
                    I
                }
                const Cc = {
                    linearity: .3,
                    easing: s.dy(0, 0, .3, 1)
                }
                  , vp = s.l({
                    deceleration: 2500,
                    maxSpeed: 1400
                }, Cc)
                  , xp = s.l({
                    deceleration: 20,
                    maxSpeed: 1400
                }, Cc)
                  , bp = s.l({
                    deceleration: 1e3,
                    maxSpeed: 360
                }, Cc)
                  , wp = s.l({
                    deceleration: 1e3,
                    maxSpeed: 90
                }, Cc);
                class Pp {
                    constructor(t) {
                        this._map = t,
                        this.clear()
                    }
                    clear() {
                        this._inertiaBuffer = []
                    }
                    record(t) {
                        this._drainInertiaBuffer(),
                        this._inertiaBuffer.push({
                            time: s.q.now(),
                            settings: t
                        })
                    }
                    _drainInertiaBuffer() {
                        const t = this._inertiaBuffer
                          , i = s.q.now();
                        for (; t.length > 0 && i - t[0].time > 160; )
                            t.shift()
                    }
                    _onMoveEnd(t) {
                        if (this._map._prefersReducedMotion() || (this._drainInertiaBuffer(),
                        this._inertiaBuffer.length < 2))
                            return;
                        const i = {
                            zoom: 0,
                            bearing: 0,
                            pitch: 0,
                            pan: new s.P(0,0),
                            pinchAround: void 0,
                            around: void 0
                        };
                        for (const {settings: m} of this._inertiaBuffer)
                            i.zoom += m.zoomDelta || 0,
                            i.bearing += m.bearingDelta || 0,
                            i.pitch += m.pitchDelta || 0,
                            m.panDelta && i.pan._add(m.panDelta),
                            m.around && (i.around = m.around),
                            m.pinchAround && (i.pinchAround = m.pinchAround);
                        const h = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time
                          , d = {};
                        if (i.pan.mag()) {
                            const m = Sc(i.pan.mag(), h, s.l({}, vp, t || {}));
                            d.offset = i.pan.mult(m.amount / i.pan.mag()),
                            d.center = this._map.transform.center,
                            Ec(d, m)
                        }
                        if (i.zoom) {
                            const m = Sc(i.zoom, h, xp);
                            d.zoom = this._map.transform.zoom + m.amount,
                            Ec(d, m)
                        }
                        if (i.bearing) {
                            const m = Sc(i.bearing, h, bp);
                            d.bearing = this._map.transform.bearing + s.aw(m.amount, -179, 179),
                            Ec(d, m)
                        }
                        if (i.pitch) {
                            const m = Sc(i.pitch, h, wp);
                            d.pitch = this._map.transform.pitch + m.amount,
                            Ec(d, m)
                        }
                        if (d.zoom || d.bearing) {
                            const m = void 0 === i.pinchAround ? i.around : i.pinchAround;
                            d.around = m ? this._map.unproject(m) : this._map.getCenter()
                        }
                        return this.clear(),
                        d.noMoveStart = !0,
                        d
                    }
                }
                function Ec(c, t) {
                    (!c.duration || c.duration < t.duration) && (c.duration = t.duration,
                    c.easing = t.easing)
                }
                function Sc(c, t, i) {
                    const {maxSpeed: h, linearity: d, deceleration: m} = i
                      , y = s.aw(c * d / (t / 1e3), -h, h)
                      , M = Math.abs(y) / (m * d);
                    return {
                        easing: i.easing,
                        duration: 1e3 * M,
                        amount: y * (M / 2)
                    }
                }
                class Pr extends s.z {
                    preventDefault() {
                        this._defaultPrevented = !0
                    }
                    get defaultPrevented() {
                        return this._defaultPrevented
                    }
                    constructor(t, i, h, d={}) {
                        const m = ze(i.getCanvasContainer(), h)
                          , y = i.unproject(m);
                        super(t, s.l({
                            point: m,
                            lngLat: y,
                            originalEvent: h
                        }, d)),
                        this._defaultPrevented = !1,
                        this.target = i
                    }
                }
                class Ic extends s.z {
                    preventDefault() {
                        this._defaultPrevented = !0
                    }
                    get defaultPrevented() {
                        return this._defaultPrevented
                    }
                    constructor(t, i, h) {
                        const d = "touchend" === t ? h.changedTouches : h.touches
                          , m = ye(i.getCanvasContainer(), d)
                          , y = m.map(E => i.unproject(E))
                          , M = m.reduce( (E, S, I, R) => E.add(S.div(R.length)), new s.P(0,0));
                        super(t, {
                            points: m,
                            point: M,
                            lngLats: y,
                            lngLat: i.unproject(M),
                            originalEvent: h
                        }),
                        this._defaultPrevented = !1
                    }
                }
                class Mp extends s.z {
                    preventDefault() {
                        this._defaultPrevented = !0
                    }
                    get defaultPrevented() {
                        return this._defaultPrevented
                    }
                    constructor(t, i) {
                        super("wheel", {
                            originalEvent: i
                        }),
                        this._defaultPrevented = !1
                    }
                }
                class Tp {
                    constructor(t, i) {
                        this._map = t,
                        this._clickTolerance = i.clickTolerance
                    }
                    reset() {
                        this._mousedownPos = void 0
                    }
                    wheel(t) {
                        return this._firePreventable(new Mp(this._map,t))
                    }
                    mousedown(t, i) {
                        return this._mousedownPos = i,
                        this._firePreventable(new Pr(t.type,this._map,t))
                    }
                    mouseup(t) {
                        this._map.fire(new Pr(t.type,this._map,t))
                    }
                    preclick(t) {
                        const i = s.l({}, t);
                        i.type = "preclick",
                        this._map.fire(new Pr(i.type,this._map,i))
                    }
                    click(t, i) {
                        this._mousedownPos && this._mousedownPos.dist(i) >= this._clickTolerance || (this.preclick(t),
                        this._map.fire(new Pr(t.type,this._map,t)))
                    }
                    dblclick(t) {
                        return this._firePreventable(new Pr(t.type,this._map,t))
                    }
                    mouseover(t) {
                        this._map.fire(new Pr(t.type,this._map,t))
                    }
                    mouseout(t) {
                        this._map.fire(new Pr(t.type,this._map,t))
                    }
                    touchstart(t) {
                        return this._firePreventable(new Ic(t.type,this._map,t))
                    }
                    touchmove(t) {
                        this._map.fire(new Ic(t.type,this._map,t))
                    }
                    touchend(t) {
                        this._map.fire(new Ic(t.type,this._map,t))
                    }
                    touchcancel(t) {
                        this._map.fire(new Ic(t.type,this._map,t))
                    }
                    _firePreventable(t) {
                        if (this._map.fire(t),
                        t.defaultPrevented)
                            return {}
                    }
                    isEnabled() {
                        return !0
                    }
                    isActive() {
                        return !1
                    }
                    enable() {}
                    disable() {}
                }
                class Cp {
                    constructor(t) {
                        this._map = t
                    }
                    reset() {
                        this._delayContextMenu = !1,
                        this._contextMenuEvent = void 0
                    }
                    mousemove(t) {
                        this._map.fire(new Pr(t.type,this._map,t))
                    }
                    mousedown() {
                        this._delayContextMenu = !0
                    }
                    mouseup() {
                        this._delayContextMenu = !1,
                        this._contextMenuEvent && (this._map.fire(new Pr("contextmenu",this._map,this._contextMenuEvent)),
                        delete this._contextMenuEvent)
                    }
                    contextmenu(t) {
                        this._delayContextMenu ? this._contextMenuEvent = t : this._map.fire(new Pr(t.type,this._map,t)),
                        this._map.listens("contextmenu") && t.preventDefault()
                    }
                    isEnabled() {
                        return !0
                    }
                    isActive() {
                        return !1
                    }
                    enable() {}
                    disable() {}
                }
                class Sd {
                    constructor(t, i) {
                        this._map = t,
                        this._el = t.getCanvasContainer(),
                        this._container = t.getContainer(),
                        this._clickTolerance = i.clickTolerance || 1
                    }
                    isEnabled() {
                        return !!this._enabled
                    }
                    isActive() {
                        return !!this._active
                    }
                    enable() {
                        this.isEnabled() || (this._enabled = !0)
                    }
                    disable() {
                        this.isEnabled() && (this._enabled = !1)
                    }
                    mousedown(t, i) {
                        this.isEnabled() && t.shiftKey && 0 === t.button && (et(),
                        this._startPos = this._lastPos = i,
                        this._active = !0)
                    }
                    mousemoveWindow(t, i) {
                        if (!this._active)
                            return;
                        const h = i
                          , d = this._startPos
                          , m = this._lastPos;
                        if (!d || !m || m.equals(h) || !this._box && h.dist(d) < this._clickTolerance)
                            return;
                        this._lastPos = h,
                        this._box || (this._box = Qe("div", "mapboxgl-boxzoom", this._container),
                        this._container.classList.add("mapboxgl-crosshair"),
                        this._fireEvent("boxzoomstart", t));
                        const y = Math.min(d.x, h.x)
                          , M = Math.max(d.x, h.x)
                          , E = Math.min(d.y, h.y)
                          , S = Math.max(d.y, h.y);
                        this._map._requestDomTask( () => {
                            this._box && (this._box.style.transform = "translate(".concat(y, "px,").concat(E, "px)"),
                            this._box.style.width = M - y + "px",
                            this._box.style.height = S - E + "px")
                        }
                        )
                    }
                    mouseupWindow(t, i) {
                        if (!this._active)
                            return;
                        const h = this._startPos
                          , d = i;
                        if (h && 0 === t.button) {
                            if (this.reset(),
                            Be(),
                            h.x !== d.x || h.y !== d.y)
                                return this._map.fire(new s.z("boxzoomend",{
                                    originalEvent: t
                                })),
                                {
                                    cameraAnimation: m => m.fitScreenCoordinates(h, d, this._map.getBearing(), {
                                        linear: !1
                                    })
                                };
                            this._fireEvent("boxzoomcancel", t)
                        }
                    }
                    keydown(t) {
                        this._active && 27 === t.keyCode && (this.reset(),
                        this._fireEvent("boxzoomcancel", t))
                    }
                    blur() {
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        this._container.classList.remove("mapboxgl-crosshair"),
                        this._box && (this._box.remove(),
                        this._box = null),
                        re(),
                        delete this._startPos,
                        delete this._lastPos
                    }
                    _fireEvent(t, i) {
                        return this._map.fire(new s.z(t,{
                            originalEvent: i
                        }))
                    }
                }
                function Iu(c, t) {
                    const i = {};
                    for (let h = 0; h < c.length; h++)
                        i[c[h].identifier] = t[h];
                    return i
                }
                class mn {
                    constructor(t) {
                        this.reset(),
                        this.numTouches = t.numTouches
                    }
                    reset() {
                        this.centroid = void 0,
                        this.startTime = 0,
                        this.touches = {},
                        this.aborted = !1
                    }
                    touchstart(t, i, h) {
                        (this.centroid || h.length > this.numTouches) && (this.aborted = !0),
                        this.aborted || (0 === this.startTime && (this.startTime = t.timeStamp),
                        h.length === this.numTouches && (this.centroid = function(d) {
                            const m = new s.P(0,0);
                            for (const y of d)
                                m._add(y);
                            return m.div(d.length)
                        }(i),
                        this.touches = Iu(h, i)))
                    }
                    touchmove(t, i, h) {
                        if (this.aborted || !this.centroid)
                            return;
                        const d = Iu(h, i);
                        for (const m in this.touches) {
                            const y = d[m];
                            (!y || y.dist(this.touches[m]) > 30) && (this.aborted = !0)
                        }
                    }
                    touchend(t, i, h) {
                        if ((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = !0),
                        0 === h.length) {
                            const d = !this.aborted && this.centroid;
                            if (this.reset(),
                            d)
                                return d
                        }
                    }
                }
                class Oh {
                    constructor(t) {
                        this.singleTap = new mn(t),
                        this.numTaps = t.numTaps,
                        this.reset()
                    }
                    reset() {
                        this.lastTime = 1 / 0,
                        this.lastTap = void 0,
                        this.count = 0,
                        this.singleTap.reset()
                    }
                    touchstart(t, i, h) {
                        this.singleTap.touchstart(t, i, h)
                    }
                    touchmove(t, i, h) {
                        this.singleTap.touchmove(t, i, h)
                    }
                    touchend(t, i, h) {
                        const d = this.singleTap.touchend(t, i, h);
                        if (d) {
                            const m = t.timeStamp - this.lastTime < 500
                              , y = !this.lastTap || this.lastTap.dist(d) < 30;
                            if (m && y || this.reset(),
                            this.count++,
                            this.lastTime = t.timeStamp,
                            this.lastTap = d,
                            this.count === this.numTaps)
                                return this.reset(),
                                d
                        }
                    }
                }
                class Id {
                    constructor() {
                        this._zoomIn = new Oh({
                            numTouches: 1,
                            numTaps: 2
                        }),
                        this._zoomOut = new Oh({
                            numTouches: 2,
                            numTaps: 1
                        }),
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        this._zoomIn.reset(),
                        this._zoomOut.reset()
                    }
                    touchstart(t, i, h) {
                        this._zoomIn.touchstart(t, i, h),
                        this._zoomOut.touchstart(t, i, h)
                    }
                    touchmove(t, i, h) {
                        this._zoomIn.touchmove(t, i, h),
                        this._zoomOut.touchmove(t, i, h)
                    }
                    touchend(t, i, h) {
                        const d = this._zoomIn.touchend(t, i, h)
                          , m = this._zoomOut.touchend(t, i, h);
                        return d ? (this._active = !0,
                        t.preventDefault(),
                        setTimeout( () => this.reset(), 0),
                        {
                            cameraAnimation: y => y.easeTo({
                                duration: 300,
                                zoom: y.getZoom() + 1,
                                around: y.unproject(d)
                            }, {
                                originalEvent: t
                            })
                        }) : m ? (this._active = !0,
                        t.preventDefault(),
                        setTimeout( () => this.reset(), 0),
                        {
                            cameraAnimation: y => y.easeTo({
                                duration: 300,
                                zoom: y.getZoom() - 1,
                                around: y.unproject(m)
                            }, {
                                originalEvent: t
                            })
                        }) : void 0
                    }
                    touchcancel() {
                        this.reset()
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                const Ad = {
                    0: 1,
                    2: 2
                };
                class Ba {
                    constructor(t) {
                        this.reset(),
                        this._clickTolerance = t.clickTolerance || 1
                    }
                    blur() {
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        this._moved = !1,
                        this._lastPoint = void 0,
                        this._eventButton = void 0
                    }
                    _correctButton(t, i) {
                        return !1
                    }
                    _move(t, i) {
                        return {}
                    }
                    mousedown(t, i) {
                        if (this._lastPoint)
                            return;
                        const h = ge(t);
                        this._correctButton(t, h) && (this._lastPoint = i,
                        this._eventButton = h)
                    }
                    mousemoveWindow(t, i) {
                        const h = this._lastPoint;
                        if (h)
                            if (t.preventDefault(),
                            null != this._eventButton && function(d, m) {
                                const y = Ad[m];
                                return void 0 === d.buttons || (d.buttons & y) !== y
                            }(t, this._eventButton))
                                this.reset();
                            else if (this._moved || !(i.dist(h) < this._clickTolerance))
                                return this._moved = !0,
                                this._lastPoint = i,
                                this._move(h, i)
                    }
                    mouseupWindow(t) {
                        this._lastPoint && ge(t) === this._eventButton && (this._moved && Be(),
                        this.reset())
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                class Ep extends Ba {
                    mousedown(t, i) {
                        super.mousedown(t, i),
                        this._lastPoint && (this._active = !0)
                    }
                    _correctButton(t, i) {
                        return 0 === i && !t.ctrlKey
                    }
                    _move(t, i) {
                        return {
                            around: i,
                            panDelta: i.sub(t)
                        }
                    }
                }
                class Rh extends Ba {
                    _correctButton(t, i) {
                        return 0 === i && t.ctrlKey || 2 === i
                    }
                    _move(t, i) {
                        const h = .8 * (i.x - t.x);
                        if (h)
                            return this._active = !0,
                            {
                                bearingDelta: h
                            }
                    }
                    contextmenu(t) {
                        t.preventDefault()
                    }
                }
                class Ac extends Ba {
                    _correctButton(t, i) {
                        return 0 === i && t.ctrlKey || 2 === i
                    }
                    _move(t, i) {
                        const h = -.5 * (i.y - t.y);
                        if (h)
                            return this._active = !0,
                            {
                                pitchDelta: h
                            }
                    }
                    contextmenu(t) {
                        t.preventDefault()
                    }
                }
                class Ls {
                    constructor(t, i) {
                        this._map = t,
                        this._el = t.getCanvasContainer(),
                        this._minTouches = 1,
                        this._clickTolerance = i.clickTolerance || 1,
                        this.reset(),
                        s.aP(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this)
                    }
                    reset() {
                        this._active = !1,
                        this._touches = {},
                        this._sum = new s.P(0,0)
                    }
                    touchstart(t, i, h) {
                        return this._calculateTransform(t, i, h)
                    }
                    touchmove(t, i, h) {
                        if (this._active && !(h.length < this._minTouches)) {
                            if (this._map._cooperativeGestures && !this._map.isMoving()) {
                                if (1 === h.length && !s.dz())
                                    return void this._showTouchPanBlockerAlert();
                                "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden",
                                clearTimeout(this._alertTimer))
                            }
                            return t.cancelable && t.preventDefault(),
                            this._calculateTransform(t, i, h)
                        }
                    }
                    touchend(t, i, h) {
                        this._calculateTransform(t, i, h),
                        this._active && h.length < this._minTouches && this.reset()
                    }
                    touchcancel() {
                        this.reset()
                    }
                    _calculateTransform(t, i, h) {
                        h.length > 0 && (this._active = !0);
                        const d = Iu(h, i)
                          , m = new s.P(0,0)
                          , y = new s.P(0,0);
                        let M = 0;
                        for (const S in d) {
                            const I = d[S]
                              , R = this._touches[S];
                            R && (m._add(I),
                            y._add(I.sub(R)),
                            M++,
                            d[S] = I)
                        }
                        if (this._touches = d,
                        M < this._minTouches || !y.mag())
                            return;
                        const E = y.div(M);
                        return this._sum._add(E),
                        this._sum.mag() < this._clickTolerance ? void 0 : {
                            around: m.div(M),
                            panDelta: E
                        }
                    }
                    enable() {
                        this._enabled = !0,
                        this._map._cooperativeGestures && (this._addTouchPanBlocker(),
                        this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"))
                    }
                    disable() {
                        this._enabled = !1,
                        this._map._cooperativeGestures && (clearTimeout(this._alertTimer),
                        this._alertContainer.remove(),
                        this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")),
                        this.reset()
                    }
                    isEnabled() {
                        return !!this._enabled
                    }
                    isActive() {
                        return !!this._active
                    }
                    _addTouchPanBlocker() {
                        this._map && !this._alertContainer && (this._alertContainer = Qe("div", "mapboxgl-touch-pan-blocker", this._map._container),
                        this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"),
                        this._alertContainer.style.fontSize = "".concat(Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth))), "px"))
                    }
                    _showTouchPanBlockerAlert() {
                        this._alertContainer.style.visibility = "visible",
                        this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"),
                        this._alertContainer.setAttribute("role", "alert"),
                        clearTimeout(this._alertTimer),
                        this._alertTimer = window.setTimeout( () => {
                            this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"),
                            this._alertContainer.removeAttribute("role")
                        }
                        , 500)
                    }
                }
                class Tl {
                    constructor() {
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        this._firstTwoTouches = void 0
                    }
                    _start(t) {}
                    _move(t, i, h) {
                        return {}
                    }
                    touchstart(t, i, h) {
                        this._firstTwoTouches || h.length < 2 || (this._firstTwoTouches = [h[0].identifier, h[1].identifier],
                        this._start([i[0], i[1]]))
                    }
                    touchmove(t, i, h) {
                        const d = this._firstTwoTouches;
                        if (!d)
                            return;
                        t.preventDefault();
                        const [m,y] = d
                          , M = hn(h, i, m)
                          , E = hn(h, i, y);
                        if (!M || !E)
                            return;
                        const S = this._aroundCenter ? null : M.add(E).div(2);
                        return this._move([M, E], S, t)
                    }
                    touchend(t, i, h) {
                        if (!this._firstTwoTouches)
                            return;
                        const [d,m] = this._firstTwoTouches
                          , y = hn(h, i, d)
                          , M = hn(h, i, m);
                        y && M || (this._active && Be(),
                        this.reset())
                    }
                    touchcancel() {
                        this.reset()
                    }
                    enable(t) {
                        this._enabled = !0,
                        this._aroundCenter = !!t && "center" === t.around
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                function hn(c, t, i) {
                    for (let h = 0; h < c.length; h++)
                        if (c[h].identifier === i)
                            return t[h]
                }
                function os(c, t) {
                    return Math.log(c / t) / Math.LN2
                }
                class Au extends Tl {
                    reset() {
                        super.reset(),
                        this._distance = 0,
                        this._startDistance = 0
                    }
                    _start(t) {
                        this._startDistance = this._distance = t[0].dist(t[1])
                    }
                    _move(t, i) {
                        const h = this._distance;
                        if (this._distance = t[0].dist(t[1]),
                        this._active || !(Math.abs(os(this._distance, this._startDistance)) < .1))
                            return this._active = !0,
                            {
                                zoomDelta: os(this._distance, h),
                                pinchAround: i
                            }
                    }
                }
                function Oc(c, t) {
                    return 180 * c.angleWith(t) / Math.PI
                }
                class Sp extends Tl {
                    reset() {
                        super.reset(),
                        this._minDiameter = 0,
                        this._startVector = void 0,
                        this._vector = void 0
                    }
                    _start(t) {
                        this._startVector = this._vector = t[0].sub(t[1]),
                        this._minDiameter = t[0].dist(t[1])
                    }
                    _move(t, i) {
                        const h = this._vector;
                        if (this._vector = t[0].sub(t[1]),
                        h && (this._active || !this._isBelowThreshold(this._vector)))
                            return this._active = !0,
                            {
                                bearingDelta: Oc(this._vector, h),
                                pinchAround: i
                            }
                    }
                    _isBelowThreshold(t) {
                        this._minDiameter = Math.min(this._minDiameter, t.mag());
                        const i = 25 / (Math.PI * this._minDiameter) * 360
                          , h = this._startVector;
                        if (!h)
                            return !1;
                        const d = Oc(t, h);
                        return Math.abs(d) < i
                    }
                }
                function Ou(c) {
                    return Math.abs(c.y) > Math.abs(c.x)
                }
                class Rc extends Tl {
                    constructor(t) {
                        super(),
                        this._map = t
                    }
                    reset() {
                        super.reset(),
                        this._valid = void 0,
                        this._firstMove = void 0,
                        this._lastPoints = void 0
                    }
                    _start(t) {
                        this._lastPoints = t,
                        Ou(t[0].sub(t[1])) && (this._valid = !1)
                    }
                    _move(t, i, h) {
                        const d = this._lastPoints;
                        if (!d)
                            return;
                        const m = t[0].sub(d[0])
                          , y = t[1].sub(d[1]);
                        return this._map._cooperativeGestures && !s.dz() && h.touches.length < 3 || (this._valid = this.gestureBeginsVertically(m, y, h.timeStamp),
                        !this._valid) ? void 0 : (this._lastPoints = t,
                        this._active = !0,
                        {
                            pitchDelta: (m.y + y.y) / 2 * -.5
                        })
                    }
                    gestureBeginsVertically(t, i, h) {
                        if (void 0 !== this._valid)
                            return this._valid;
                        const d = t.mag() >= 2
                          , m = i.mag() >= 2;
                        if (!d && !m)
                            return;
                        if (!d || !m)
                            return null == this._firstMove && (this._firstMove = h),
                            h - this._firstMove < 100 && void 0;
                        const y = t.y > 0 == i.y > 0;
                        return Ou(t) && Ou(i) && y
                    }
                }
                const Od = {
                    panStep: 100,
                    bearingStep: 15,
                    pitchStep: 10
                };
                class Rd {
                    constructor() {
                        const t = Od;
                        this._panStep = t.panStep,
                        this._bearingStep = t.bearingStep,
                        this._pitchStep = t.pitchStep,
                        this._rotationDisabled = !1
                    }
                    blur() {
                        this.reset()
                    }
                    reset() {
                        this._active = !1
                    }
                    keydown(t) {
                        if (t.altKey || t.ctrlKey || t.metaKey)
                            return;
                        let i = 0
                          , h = 0
                          , d = 0
                          , m = 0
                          , y = 0;
                        switch (t.keyCode) {
                        case 61:
                        case 107:
                        case 171:
                        case 187:
                            i = 1;
                            break;
                        case 189:
                        case 109:
                        case 173:
                            i = -1;
                            break;
                        case 37:
                            t.shiftKey ? h = -1 : (t.preventDefault(),
                            m = -1);
                            break;
                        case 39:
                            t.shiftKey ? h = 1 : (t.preventDefault(),
                            m = 1);
                            break;
                        case 38:
                            t.shiftKey ? d = 1 : (t.preventDefault(),
                            y = -1);
                            break;
                        case 40:
                            t.shiftKey ? d = -1 : (t.preventDefault(),
                            y = 1);
                            break;
                        default:
                            return
                        }
                        return this._rotationDisabled && (h = 0,
                        d = 0),
                        {
                            cameraAnimation: M => {
                                const E = M.getZoom();
                                M.easeTo({
                                    duration: 300,
                                    easeId: "keyboardHandler",
                                    easing: Ru,
                                    zoom: i ? Math.round(E) + i * (t.shiftKey ? 2 : 1) : E,
                                    bearing: M.getBearing() + h * this._bearingStep,
                                    pitch: M.getPitch() + d * this._pitchStep,
                                    offset: [-m * this._panStep, -y * this._panStep],
                                    center: M.getCenter()
                                }, {
                                    originalEvent: t
                                })
                            }
                        }
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                    disableRotation() {
                        this._rotationDisabled = !0
                    }
                    enableRotation() {
                        this._rotationDisabled = !1
                    }
                }
                function Ru(c) {
                    return c * (2 - c)
                }
                const Dh = 4.000244140625
                  , Cl = 1 / 450;
                class El {
                    constructor(t, i) {
                        this._map = t,
                        this._el = t.getCanvasContainer(),
                        this._handler = i,
                        this._delta = 0,
                        this._lastDelta = 0,
                        this._defaultZoomRate = .01,
                        this._wheelZoomRate = Cl,
                        s.aP(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this)
                    }
                    setZoomRate(t) {
                        this._defaultZoomRate = t
                    }
                    setWheelZoomRate(t) {
                        this._wheelZoomRate = t
                    }
                    isEnabled() {
                        return !!this._enabled
                    }
                    isActive() {
                        return this._active || void 0 !== this._finishTimeout
                    }
                    isZooming() {
                        return !!this._zooming
                    }
                    enable(t) {
                        this.isEnabled() || (this._enabled = !0,
                        this._aroundCenter = !!t && "center" === t.around,
                        this._map._cooperativeGestures && this._addScrollZoomBlocker())
                    }
                    disable() {
                        this.isEnabled() && (this._enabled = !1,
                        this._map._cooperativeGestures && (clearTimeout(this._alertTimer),
                        this._alertContainer.remove()))
                    }
                    wheel(t) {
                        if (!this.isEnabled())
                            return;
                        if (this._map._cooperativeGestures) {
                            if (!(t.ctrlKey || t.metaKey || this.isZooming() || s.dz()))
                                return void this._showBlockerAlert();
                            "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden",
                            clearTimeout(this._alertTimer))
                        }
                        let i = t.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;
                        const h = s.q.now()
                          , d = h - (this._lastWheelEventTime || 0);
                        this._lastWheelEventTime = h,
                        0 !== i && i % Dh == 0 ? this._type = "wheel" : 0 !== i && Math.abs(i) < 4 ? this._type = "trackpad" : d > 400 ? (this._type = null,
                        this._lastValue = i,
                        this._timeout = window.setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(d * i) < 200 ? "trackpad" : "wheel",
                        this._timeout && (clearTimeout(this._timeout),
                        this._timeout = null,
                        i += this._lastValue)),
                        t.shiftKey && i && (i /= 4),
                        this._type && (this._lastWheelEvent = t,
                        this._delta -= i,
                        this._active || this._start(t)),
                        t.preventDefault()
                    }
                    _onTimeout(t) {
                        this._type = "wheel",
                        this._delta -= this._lastValue,
                        this._active || this._start(t)
                    }
                    _start(t) {
                        if (!this._delta)
                            return;
                        this._frameId && (this._frameId = null),
                        this._active = !0,
                        this.isZooming() || (this._zooming = !0),
                        this._finishTimeout && (clearTimeout(this._finishTimeout),
                        delete this._finishTimeout);
                        const i = ze(this._el, t);
                        this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : i,
                        this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint),
                        this._targetZoom = void 0,
                        this._frameId || (this._frameId = !0,
                        this._handler._triggerRenderFrame())
                    }
                    renderFrame() {
                        if (!this._frameId || (this._frameId = null,
                        !this.isActive()))
                            return;
                        const t = this._map.transform;
                        "wheel" === this._type && t.projection.wrap && (t._center.lng >= 180 || t._center.lng <= -180) && (this._prevEase = null,
                        this._easing = null,
                        this._lastWheelEvent = null,
                        this._lastWheelEventTime = 0);
                        const i = () => t._terrainEnabled() && this._aroundCoord ? t.computeZoomRelativeTo(this._aroundCoord) : t.zoom;
                        if (0 !== this._delta) {
                            const S = "wheel" === this._type && Math.abs(this._delta) > Dh ? this._wheelZoomRate : this._defaultZoomRate;
                            let I = 2 / (1 + Math.exp(-Math.abs(this._delta * S)));
                            this._delta < 0 && 0 !== I && (I = 1 / I);
                            const R = i()
                              , D = Math.pow(2, R)
                              , k = "number" == typeof this._targetZoom ? t.zoomScale(this._targetZoom) : D;
                            this._targetZoom = Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(k * I))),
                            "wheel" === this._type && (this._startZoom = R,
                            this._easing = this._smoothOutEasing(200)),
                            this._lastDelta = this._delta,
                            this._delta = 0
                        }
                        const h = "number" == typeof this._targetZoom ? this._targetZoom : i()
                          , d = this._startZoom
                          , m = this._easing;
                        let y, M = !1;
                        if ("wheel" === this._type && d && m) {
                            const S = Math.min((s.q.now() - this._lastWheelEventTime) / 200, 1)
                              , I = m(S);
                            y = s.af(d, h, I),
                            S < 1 ? this._frameId || (this._frameId = !0) : M = !0
                        } else
                            y = h,
                            M = !0;
                        this._active = !0,
                        M && (this._active = !1,
                        this._finishTimeout = window.setTimeout( () => {
                            this._zooming = !1,
                            this._handler._triggerRenderFrame(),
                            delete this._targetZoom,
                            delete this._finishTimeout
                        }
                        , 200));
                        let E = y - i();
                        return E * this._lastDelta < 0 && (E = 0),
                        {
                            noInertia: !0,
                            needsRenderFrame: !M,
                            zoomDelta: E,
                            around: this._aroundPoint,
                            aroundCoord: this._aroundCoord,
                            originalEvent: this._lastWheelEvent
                        }
                    }
                    _smoothOutEasing(t) {
                        let i = s.dA;
                        if (this._prevEase) {
                            const h = this._prevEase
                              , d = (s.q.now() - h.start) / h.duration
                              , m = h.easing(d + .01) - h.easing(d)
                              , y = .27 / Math.sqrt(m * m + 1e-4) * .01
                              , M = Math.sqrt(.0729 - y * y);
                            i = s.dy(y, M, .25, 1)
                        }
                        return this._prevEase = {
                            start: s.q.now(),
                            duration: t,
                            easing: i
                        },
                        i
                    }
                    blur() {
                        this.reset()
                    }
                    reset() {
                        this._active = !1
                    }
                    _addScrollZoomBlocker() {
                        this._map && !this._alertContainer && (this._alertContainer = Qe("div", "mapboxgl-scroll-zoom-blocker", this._map._container),
                        this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"),
                        this._alertContainer.style.fontSize = "".concat(Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth))), "px"))
                    }
                    _showBlockerAlert() {
                        this._alertContainer.style.visibility = "visible",
                        this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"),
                        this._alertContainer.setAttribute("role", "alert"),
                        clearTimeout(this._alertTimer),
                        this._alertTimer = window.setTimeout( () => {
                            this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"),
                            this._alertContainer.removeAttribute("role")
                        }
                        , 200)
                    }
                }
                class Fs {
                    constructor(t, i) {
                        this._clickZoom = t,
                        this._tapZoom = i
                    }
                    enable() {
                        this._clickZoom.enable(),
                        this._tapZoom.enable()
                    }
                    disable() {
                        this._clickZoom.disable(),
                        this._tapZoom.disable()
                    }
                    isEnabled() {
                        return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
                    }
                    isActive() {
                        return this._clickZoom.isActive() || this._tapZoom.isActive()
                    }
                }
                class is {
                    constructor() {
                        this.reset()
                    }
                    reset() {
                        this._active = !1
                    }
                    blur() {
                        this.reset()
                    }
                    dblclick(t, i) {
                        return t.preventDefault(),
                        {
                            cameraAnimation: h => {
                                h.easeTo({
                                    duration: 300,
                                    zoom: h.getZoom() + (t.shiftKey ? -1 : 1),
                                    around: h.unproject(i)
                                }, {
                                    originalEvent: t
                                })
                            }
                        }
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                class ma {
                    constructor() {
                        this._tap = new Oh({
                            numTouches: 1,
                            numTaps: 1
                        }),
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        this._swipePoint = void 0,
                        this._swipeTouch = 0,
                        this._tapTime = 0,
                        this._tap.reset()
                    }
                    touchstart(t, i, h) {
                        this._swipePoint || (this._tapTime && t.timeStamp - this._tapTime > 500 && this.reset(),
                        this._tapTime ? h.length > 0 && (this._swipePoint = i[0],
                        this._swipeTouch = h[0].identifier) : this._tap.touchstart(t, i, h))
                    }
                    touchmove(t, i, h) {
                        if (this._tapTime) {
                            if (this._swipePoint) {
                                if (h[0].identifier !== this._swipeTouch)
                                    return;
                                const d = i[0]
                                  , m = d.y - this._swipePoint.y;
                                return this._swipePoint = d,
                                t.preventDefault(),
                                this._active = !0,
                                {
                                    zoomDelta: m / 128
                                }
                            }
                        } else
                            this._tap.touchmove(t, i, h)
                    }
                    touchend(t, i, h) {
                        this._tapTime ? this._swipePoint && 0 === h.length && this.reset() : this._tap.touchend(t, i, h) && (this._tapTime = t.timeStamp)
                    }
                    touchcancel() {
                        this.reset()
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                class Ua {
                    constructor(t, i, h) {
                        this._el = t,
                        this._mousePan = i,
                        this._touchPan = h
                    }
                    enable(t) {
                        this._inertiaOptions = t || {},
                        this._mousePan.enable(),
                        this._touchPan.enable(),
                        this._el.classList.add("mapboxgl-touch-drag-pan")
                    }
                    disable() {
                        this._mousePan.disable(),
                        this._touchPan.disable(),
                        this._el.classList.remove("mapboxgl-touch-drag-pan")
                    }
                    isEnabled() {
                        return this._mousePan.isEnabled() && this._touchPan.isEnabled()
                    }
                    isActive() {
                        return this._mousePan.isActive() || this._touchPan.isActive()
                    }
                }
                class fa {
                    constructor(t, i, h) {
                        this._pitchWithRotate = t.pitchWithRotate,
                        this._mouseRotate = i,
                        this._mousePitch = h
                    }
                    enable() {
                        this._mouseRotate.enable(),
                        this._pitchWithRotate && this._mousePitch.enable()
                    }
                    disable() {
                        this._mouseRotate.disable(),
                        this._mousePitch.disable()
                    }
                    isEnabled() {
                        return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled())
                    }
                    isActive() {
                        return this._mouseRotate.isActive() || this._mousePitch.isActive()
                    }
                }
                class Dd {
                    constructor(t, i, h, d) {
                        this._el = t,
                        this._touchZoom = i,
                        this._touchRotate = h,
                        this._tapDragZoom = d,
                        this._rotationDisabled = !1,
                        this._enabled = !0
                    }
                    enable(t) {
                        this._touchZoom.enable(t),
                        this._rotationDisabled || this._touchRotate.enable(t),
                        this._tapDragZoom.enable(),
                        this._el.classList.add("mapboxgl-touch-zoom-rotate")
                    }
                    disable() {
                        this._touchZoom.disable(),
                        this._touchRotate.disable(),
                        this._tapDragZoom.disable(),
                        this._el.classList.remove("mapboxgl-touch-zoom-rotate")
                    }
                    isEnabled() {
                        return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
                    }
                    isActive() {
                        return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
                    }
                    disableRotation() {
                        this._rotationDisabled = !0,
                        this._touchRotate.disable()
                    }
                    enableRotation() {
                        this._rotationDisabled = !1,
                        this._touchZoom.isEnabled() && this._touchRotate.enable()
                    }
                }
                const Lh = c => c.zoom || c.drag || c.pitch || c.rotate;
                class Ld extends s.z {
                }
                class Fd {
                    constructor() {
                        this.constants = [1, 1, .01],
                        this.radius = 0
                    }
                    setup(t, i) {
                        const h = s.ab.vec3.sub([], i, t);
                        this.radius = s.ab.vec3.length(h[2] < 0 ? s.ab.vec3.div([], h, this.constants) : [h[0], h[1], 0])
                    }
                    projectRay(t) {
                        s.ab.vec3.div(t, t, this.constants),
                        s.ab.vec3.normalize(t, t),
                        s.ab.vec3.mul(t, t, this.constants);
                        const i = s.ab.vec3.scale([], t, this.radius);
                        if (i[2] > 0) {
                            const h = s.ab.vec3.scale([], [0, 0, 1], s.ab.vec3.dot(i, [0, 0, 1]))
                              , d = s.ab.vec3.scale([], s.ab.vec3.normalize([], [i[0], i[1], 0]), this.radius)
                              , m = s.ab.vec3.add([], i, s.ab.vec3.scale([], s.ab.vec3.sub([], s.ab.vec3.add([], d, h), i), 2));
                            i[0] = m[0],
                            i[1] = m[1]
                        }
                        return i
                    }
                }
                function Dc(c) {
                    return c.panDelta && c.panDelta.mag() || c.zoomDelta || c.bearingDelta || c.pitchDelta
                }
                class sr {
                    constructor(t, i) {
                        this._map = t,
                        this._el = this._map.getCanvasContainer(),
                        this._handlers = [],
                        this._handlersById = {},
                        this._changes = [],
                        this._inertia = new Pp(t),
                        this._bearingSnap = i.bearingSnap,
                        this._previousActiveHandlers = {},
                        this._trackingEllipsoid = new Fd,
                        this._dragOrigin = null,
                        this._eventsInProgress = {},
                        this._addDefaultHandlers(i),
                        s.aP(["handleEvent", "handleWindowEvent"], this);
                        const h = this._el;
                        this._listeners = [[h, "touchstart", {
                            passive: !0
                        }], [h, "touchmove", {
                            passive: !1
                        }], [h, "touchend", void 0], [h, "touchcancel", void 0], [h, "mousedown", void 0], [h, "mousemove", void 0], [h, "mouseup", void 0], [document, "mousemove", {
                            capture: !0
                        }], [document, "mouseup", void 0], [h, "mouseover", void 0], [h, "mouseout", void 0], [h, "dblclick", void 0], [h, "click", void 0], [h, "keydown", {
                            capture: !1
                        }], [h, "keyup", void 0], [h, "wheel", {
                            passive: !1
                        }], [h, "contextmenu", void 0], [window, "blur", void 0]];
                        for (const [d,m,y] of this._listeners) {
                            const M = d === document ? this.handleWindowEvent : this.handleEvent;
                            d.addEventListener(m, M, y)
                        }
                    }
                    destroy() {
                        for (const [t,i,h] of this._listeners) {
                            const d = t === document ? this.handleWindowEvent : this.handleEvent;
                            t.removeEventListener(i, d, h)
                        }
                    }
                    _addDefaultHandlers(t) {
                        const i = this._map
                          , h = i.getCanvasContainer();
                        this._add("mapEvent", new Tp(i,t));
                        const d = i.boxZoom = new Sd(i,t);
                        this._add("boxZoom", d);
                        const m = new Id
                          , y = new is;
                        i.doubleClickZoom = new Fs(y,m),
                        this._add("tapZoom", m),
                        this._add("clickZoom", y);
                        const M = new ma;
                        this._add("tapDragZoom", M);
                        const E = i.touchPitch = new Rc(i);
                        this._add("touchPitch", E);
                        const S = new Rh(t)
                          , I = new Ac(t);
                        i.dragRotate = new fa(t,S,I),
                        this._add("mouseRotate", S, ["mousePitch"]),
                        this._add("mousePitch", I, ["mouseRotate"]);
                        const R = new Ep(t)
                          , D = new Ls(i,t);
                        i.dragPan = new Ua(h,R,D),
                        this._add("mousePan", R),
                        this._add("touchPan", D, ["touchZoom", "touchRotate"]);
                        const k = new Sp
                          , H = new Au;
                        i.touchZoomRotate = new Dd(h,H,k,M),
                        this._add("touchRotate", k, ["touchPan", "touchZoom"]),
                        this._add("touchZoom", H, ["touchPan", "touchRotate"]),
                        this._add("blockableMapEvent", new Cp(i));
                        const j = i.scrollZoom = new El(i,this);
                        this._add("scrollZoom", j, ["mousePan"]);
                        const Y = i.keyboard = new Rd;
                        this._add("keyboard", Y);
                        for (const K of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
                            t.interactive && t[K] && i[K].enable(t[K])
                    }
                    _add(t, i, h) {
                        this._handlers.push({
                            handlerName: t,
                            handler: i,
                            allowed: h
                        }),
                        this._handlersById[t] = i
                    }
                    stop(t) {
                        if (!this._updatingCamera) {
                            for (const {handler: i} of this._handlers)
                                i.reset();
                            this._inertia.clear(),
                            this._fireEvents({}, {}, t),
                            this._changes = [],
                            this._originalZoom = void 0
                        }
                    }
                    isActive() {
                        for (const {handler: t} of this._handlers)
                            if (t.isActive())
                                return !0;
                        return !1
                    }
                    isZooming() {
                        return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
                    }
                    isRotating() {
                        return !!this._eventsInProgress.rotate
                    }
                    isMoving() {
                        return !!Lh(this._eventsInProgress) || this.isZooming()
                    }
                    _isDragging() {
                        return !!this._eventsInProgress.drag
                    }
                    _blockedByActive(t, i, h) {
                        for (const d in t)
                            if (d !== h && (!i || i.indexOf(d) < 0))
                                return !0;
                        return !1
                    }
                    handleWindowEvent(t) {
                        this.handleEvent(t, "".concat(t.type, "Window"))
                    }
                    _getMapTouches(t) {
                        const i = [];
                        for (const h of t)
                            this._el.contains(h.target) && i.push(h);
                        return i
                    }
                    handleEvent(t, i) {
                        this._updatingCamera = !0;
                        const h = "renderFrame" === t.type
                          , d = h ? void 0 : t
                          , m = {
                            needsRenderFrame: !1
                        }
                          , y = {}
                          , M = {}
                          , E = t.touches ? this._getMapTouches(t.touches) : void 0
                          , S = E ? ye(this._el, E) : h ? void 0 : ze(this._el, t);
                        for (const {handlerName: D, handler: k, allowed: H} of this._handlers) {
                            if (!k.isEnabled())
                                continue;
                            let j;
                            this._blockedByActive(M, H, D) ? k.reset() : k[i || t.type] && (j = k[i || t.type](t, S, E),
                            this.mergeHandlerResult(m, y, j, D, d),
                            j && j.needsRenderFrame && this._triggerRenderFrame()),
                            (j || k.isActive()) && (M[D] = k)
                        }
                        const I = {};
                        for (const D in this._previousActiveHandlers)
                            M[D] || (I[D] = d);
                        this._previousActiveHandlers = M,
                        (Object.keys(I).length || Dc(m)) && (this._changes.push([m, y, I]),
                        this._triggerRenderFrame()),
                        (Object.keys(M).length || Dc(m)) && this._map._stop(!0),
                        this._updatingCamera = !1;
                        const {cameraAnimation: R} = m;
                        R && (this._inertia.clear(),
                        this._fireEvents({}, {}, !0),
                        this._changes = [],
                        R(this._map))
                    }
                    mergeHandlerResult(t, i, h, d, m) {
                        if (!h)
                            return;
                        s.l(t, h);
                        const y = {
                            handlerName: d,
                            originalEvent: h.originalEvent || m
                        };
                        void 0 !== h.zoomDelta && (i.zoom = y),
                        void 0 !== h.panDelta && (i.drag = y),
                        void 0 !== h.pitchDelta && (i.pitch = y),
                        void 0 !== h.bearingDelta && (i.rotate = y)
                    }
                    _applyChanges() {
                        const t = {}
                          , i = {}
                          , h = {};
                        for (const [d,m,y] of this._changes)
                            d.panDelta && (t.panDelta = (t.panDelta || new s.P(0,0))._add(d.panDelta)),
                            d.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + d.zoomDelta),
                            d.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + d.bearingDelta),
                            d.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + d.pitchDelta),
                            void 0 !== d.around && (t.around = d.around),
                            void 0 !== d.aroundCoord && (t.aroundCoord = d.aroundCoord),
                            void 0 !== d.pinchAround && (t.pinchAround = d.pinchAround),
                            d.noInertia && (t.noInertia = d.noInertia),
                            s.l(i, m),
                            s.l(h, y);
                        this._updateMapTransform(t, i, h),
                        this._changes = []
                    }
                    _updateMapTransform(t, i, h) {
                        const d = this._map
                          , m = d.transform
                          , y = he => [he.x, he.y, he.z];
                        if (( () => {
                            const Te = this._eventsInProgress.drag;
                            return Te && !this._handlersById[Te.handlerName].isActive()
                        }
                        )() && !Dc(t)) {
                            const he = m.zoom;
                            m.cameraElevationReference = "sea",
                            null != this._originalZoom && m._orthographicProjectionAtLowPitch && "globe" !== m.projection.name && 0 === m.pitch ? (m.cameraElevationReference = "ground",
                            m.zoom = this._originalZoom) : (m.recenterOnTerrain(),
                            m.cameraElevationReference = "ground"),
                            he !== m.zoom && this._map._update(!0)
                        }
                        if (m._isCameraConstrained && d._stop(!0),
                        !Dc(t))
                            return void this._fireEvents(i, h, !0);
                        let {panDelta: M, zoomDelta: E, bearingDelta: S, pitchDelta: I, around: R, aroundCoord: D, pinchAround: k} = t;
                        m._isCameraConstrained && (E > 0 && (E = 0),
                        m._isCameraConstrained = !1),
                        void 0 !== k && (R = k),
                        (E || ( () => i.drag && !this._eventsInProgress.drag)()) && R && (this._dragOrigin = y(m.pointCoordinate3D(R)),
                        this._originalZoom = m.zoom,
                        this._trackingEllipsoid.setup(m._camera.position, this._dragOrigin)),
                        m.cameraElevationReference = "sea",
                        d._stop(!0),
                        R = R || d.transform.centerPoint,
                        S && (m.bearing += S),
                        I && (m.pitch += I),
                        m._updateCameraState();
                        const H = [0, 0, 0];
                        if (M)
                            if ("mercator" === m.projection.name) {
                                const he = this._trackingEllipsoid.projectRay(m.screenPointToMercatorRay(R).dir)
                                  , Te = this._trackingEllipsoid.projectRay(m.screenPointToMercatorRay(R.sub(M)).dir);
                                H[0] = Te[0] - he[0],
                                H[1] = Te[1] - he[1]
                            } else {
                                const he = m.pointCoordinate(R);
                                if ("globe" === m.projection.name) {
                                    M = M.rotate(-m.angle);
                                    const Te = m._pixelsPerMercatorPixel / m.worldSize;
                                    H[0] = -M.x * s.dB(s.aS(he.y)) * Te,
                                    H[1] = -M.y * s.dB(m.center.lat) * Te
                                } else {
                                    const Te = m.pointCoordinate(R.sub(M));
                                    he && Te && (H[0] = Te.x - he.x,
                                    H[1] = Te.y - he.y)
                                }
                            }
                        const j = m.zoom
                          , Y = [0, 0, 0];
                        if (E) {
                            const he = y(D || m.pointCoordinate3D(R))
                              , Te = {
                                dir: s.ab.vec3.normalize([], s.ab.vec3.sub([], he, m._camera.position))
                            };
                            if (Te.dir[2] < 0) {
                                const be = m.zoomDeltaToMovement(he, E);
                                s.ab.vec3.scale(Y, Te.dir, be)
                            }
                        }
                        const K = s.ab.vec3.add(H, H, Y);
                        m._translateCameraConstrained(K),
                        E && Math.abs(m.zoom - j) > 1e-4 && m.recenterOnTerrain(),
                        m.cameraElevationReference = "ground",
                        this._map._update(),
                        t.noInertia || this._inertia.record(t),
                        this._fireEvents(i, h, !0)
                    }
                    _fireEvents(t, i, h) {
                        const d = Lh(this._eventsInProgress)
                          , m = Lh(t)
                          , y = {};
                        for (const I in t) {
                            const {originalEvent: R} = t[I];
                            this._eventsInProgress[I] || (y["".concat(I, "start")] = R),
                            this._eventsInProgress[I] = t[I]
                        }
                        !d && m && this._fireEvent("movestart", m.originalEvent);
                        for (const I in y)
                            this._fireEvent(I, y[I]);
                        m && this._fireEvent("move", m.originalEvent);
                        for (const I in t) {
                            const {originalEvent: R} = t[I];
                            this._fireEvent(I, R)
                        }
                        const M = {};
                        let E;
                        for (const I in this._eventsInProgress) {
                            const {handlerName: R, originalEvent: D} = this._eventsInProgress[I];
                            this._handlersById[R].isActive() || (delete this._eventsInProgress[I],
                            E = i[R] || D,
                            M["".concat(I, "end")] = E)
                        }
                        for (const I in M)
                            this._fireEvent(I, M[I]);
                        const S = Lh(this._eventsInProgress);
                        if (h && (d || m) && !S) {
                            this._updatingCamera = !0;
                            const I = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions)
                              , R = D => 0 !== D && -this._bearingSnap < D && D < this._bearingSnap;
                            I ? (R(I.bearing || this._map.getBearing()) && (I.bearing = 0),
                            this._map.easeTo(I, {
                                originalEvent: E
                            })) : (this._map.fire(new s.z("moveend",{
                                originalEvent: E
                            })),
                            R(this._map.getBearing()) && this._map.resetNorth()),
                            this._updatingCamera = !1
                        }
                    }
                    _fireEvent(t, i) {
                        this._map.fire(new s.z(t,i ? {
                            originalEvent: i
                        } : {}))
                    }
                    _requestFrame() {
                        return this._map.triggerRepaint(),
                        this._map._renderTaskQueue.add(t => {
                            this._frameId = void 0,
                            this.handleEvent(new Ld("renderFrame",{
                                timeStamp: t
                            })),
                            this._applyChanges()
                        }
                        )
                    }
                    _triggerRenderFrame() {
                        void 0 === this._frameId && (this._frameId = this._requestFrame())
                    }
                }
                const Fh = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
                class Ip extends s.E {
                    constructor(t, i) {
                        super(),
                        this._moving = !1,
                        this._zooming = !1,
                        this.transform = t,
                        this._bearingSnap = i.bearingSnap,
                        this._respectPrefersReducedMotion = !1 !== i.respectPrefersReducedMotion,
                        s.aP(["_renderFrameCallback"], this)
                    }
                    getCenter() {
                        return new s.bO(this.transform.center.lng,this.transform.center.lat)
                    }
                    setCenter(t, i) {
                        return this.jumpTo({
                            center: t
                        }, i)
                    }
                    panBy(t, i, h) {
                        return t = s.P.convert(t).mult(-1),
                        this.panTo(this.transform.center, s.l({
                            offset: t
                        }, i), h)
                    }
                    panTo(t, i, h) {
                        return this.easeTo(s.l({
                            center: t
                        }, i), h)
                    }
                    getZoom() {
                        return this.transform.zoom
                    }
                    setZoom(t, i) {
                        return this.jumpTo({
                            zoom: t
                        }, i),
                        this
                    }
                    zoomTo(t, i, h) {
                        return this.easeTo(s.l({
                            zoom: t
                        }, i), h)
                    }
                    zoomIn(t, i) {
                        return this.zoomTo(this.getZoom() + 1, t, i),
                        this
                    }
                    zoomOut(t, i) {
                        return this.zoomTo(this.getZoom() - 1, t, i),
                        this
                    }
                    getBearing() {
                        return this.transform.bearing
                    }
                    setBearing(t, i) {
                        return this.jumpTo({
                            bearing: t
                        }, i),
                        this
                    }
                    getPadding() {
                        return this.transform.padding
                    }
                    setPadding(t, i) {
                        return this.jumpTo({
                            padding: t
                        }, i),
                        this
                    }
                    rotateTo(t, i, h) {
                        return this.easeTo(s.l({
                            bearing: t
                        }, i), h)
                    }
                    resetNorth(t, i) {
                        return this.rotateTo(0, s.l({
                            duration: 1e3
                        }, t), i),
                        this
                    }
                    resetNorthPitch(t, i) {
                        return this.easeTo(s.l({
                            bearing: 0,
                            pitch: 0,
                            duration: 1e3
                        }, t), i),
                        this
                    }
                    snapToNorth(t, i) {
                        return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, i) : this
                    }
                    getPitch() {
                        return this.transform.pitch
                    }
                    setPitch(t, i) {
                        return this.jumpTo({
                            pitch: t
                        }, i),
                        this
                    }
                    cameraForBounds(t, i) {
                        t = s.az.convert(t);
                        const h = i && i.bearing || 0
                          , d = i && i.pitch || 0
                          , m = t.getNorthWest()
                          , y = t.getSouthEast();
                        return this._cameraForBounds(this.transform, m, y, h, d, i)
                    }
                    _extendPadding(t) {
                        const i = {
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0
                        };
                        return null == t ? s.l({}, i, this.transform.padding) : "number" == typeof t ? {
                            top: t,
                            bottom: t,
                            right: t,
                            left: t
                        } : s.l({}, i, t)
                    }
                    _extendCameraOptions(t) {
                        return (t = s.l({
                            offset: [0, 0],
                            maxZoom: this.transform.maxZoom
                        }, t)).padding = this._extendPadding(t.padding),
                        t
                    }
                    _minimumAABBFrustumDistance(t, i) {
                        const h = i.max[0] - i.min[0]
                          , d = i.max[1] - i.min[1];
                        return h / d > t.aspect ? h / (2 * Math.tan(.5 * t.fovX) * t.aspect) : d / (2 * Math.tan(.5 * t.fovY) * t.aspect)
                    }
                    _cameraForBoundsOnGlobe(t, i, h, d, m, y) {
                        const M = t.clone()
                          , E = this._extendCameraOptions(y);
                        M.bearing = d,
                        M.pitch = m;
                        const S = s.bO.convert(i)
                          , I = s.bO.convert(h)
                          , R = .5 * (S.lat + I.lat)
                          , D = .5 * (S.lng + I.lng)
                          , k = s.dC(R, D)
                          , H = s.ab.vec3.normalize([], k)
                          , j = s.ab.vec3.normalize([], s.ab.vec3.cross([], H, [0, 1, 0]))
                          , Y = s.ab.vec3.cross([], j, H)
                          , K = [j[0], j[1], j[2], 0, Y[0], Y[1], Y[2], 0, H[0], H[1], H[2], 0, 0, 0, 0, 1]
                          , he = [k, s.dC(S.lat, S.lng), s.dC(I.lat, S.lng), s.dC(I.lat, I.lng), s.dC(S.lat, I.lng), s.dC(R, S.lng), s.dC(R, I.lng), s.dC(S.lat, D), s.dC(I.lat, D)];
                        let Te = s.cd.fromPoints(he.map(wt => [s.ab.vec3.dot(j, wt), s.ab.vec3.dot(Y, wt), s.ab.vec3.dot(H, wt)]));
                        const be = s.ab.vec3.transformMat4([], Te.center, K);
                        0 === s.ab.vec3.squaredLength(be) && s.ab.vec3.set(be, 0, 0, 1),
                        s.ab.vec3.normalize(be, be),
                        s.ab.vec3.scale(be, be, s.ax),
                        M.center = s.dD(be);
                        const Ue = M.getWorldToCameraMatrix()
                          , De = s.ab.mat4.invert(new Float64Array(16), Ue);
                        Te = s.cd.applyTransform(Te, s.ab.mat4.multiply([], Ue, K));
                        const ke = this._extendAABB(Te, M, E, d);
                        if (!ke)
                            return void s.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
                        Te = ke,
                        s.ab.vec3.transformMat4(be, be, Ue);
                        const Le = .5 * (Te.max[2] - Te.min[2])
                          , Ge = this._minimumAABBFrustumDistance(M, Te)
                          , qe = s.ab.vec3.scale([], [0, 0, 1], Le)
                          , vt = s.ab.vec3.add(qe, be, qe)
                          , dt = Ge + (0 === M.pitch ? 0 : s.ab.vec3.distance(be, vt))
                          , Ze = M.globeCenterInViewSpace
                          , nt = s.ab.vec3.sub([], be, [Ze[0], Ze[1], Ze[2]]);
                        s.ab.vec3.normalize(nt, nt),
                        s.ab.vec3.scale(nt, nt, dt);
                        const zt = s.ab.vec3.add([], be, nt);
                        s.ab.vec3.transformMat4(zt, zt, De);
                        const Yt = s.ds / s.ax
                          , to = s.ab.vec3.length(zt)
                          , ut = s.bH(Math.max(to * Yt - s.ds, Number.EPSILON), 0)
                          , Gt = Math.min(M.zoomFromMercatorZAdjusted(ut), E.maxZoom);
                        return Gt > .5 * (s.c6 + s.bY) ? (M.setProjection({
                            name: "mercator"
                        }),
                        M.zoom = Gt,
                        this._cameraForBounds(M, i, h, d, m, y)) : {
                            center: M.center,
                            zoom: Gt,
                            bearing: d,
                            pitch: m
                        }
                    }
                    _extendAABB(t, i, h, d) {
                        const m = .5 * ((h.padding.left || 0) + (h.padding.right || 0))
                          , y = .5 * ((h.padding.top || 0) + (h.padding.bottom || 0))
                          , M = y
                          , E = m
                          , S = m
                          , I = y
                          , R = i.width - (E + S)
                          , D = i.height - (M + I)
                          , k = s.ab.vec3.sub([], t.max, t.min)
                          , H = Math.min(R / k[0], D / k[1])
                          , j = Math.min(i.scaleZoom(i.scale * H), h.maxZoom);
                        if (isNaN(j))
                            return null;
                        const Y = i.scale / i.zoomScale(j)
                          , K = new s.cd([t.min[0] - E * Y, t.min[1] - I * Y, t.min[2]],[t.max[0] + S * Y, t.max[1] + M * Y, t.max[2]])
                          , he = ("number" == typeof h.offset.x && "number" == typeof h.offset.y ? new s.P(h.offset.x,h.offset.y) : s.P.convert(h.offset)).rotate(-s.ai(d));
                        return K.center[0] -= he.x * Y,
                        K.center[1] += he.y * Y,
                        K
                    }
                    queryTerrainElevation(t, i) {
                        const h = this.transform.elevation;
                        return h ? (i = s.l({}, {
                            exaggerated: !0
                        }, i),
                        h.getAtPoint(s.aa.fromLngLat(t), null, i.exaggerated)) : null
                    }
                    _cameraForBounds(t, i, h, d, m, y) {
                        if ("globe" === t.projection.name)
                            return this._cameraForBoundsOnGlobe(t, i, h, d, m, y);
                        const M = t.clone()
                          , E = this._extendCameraOptions(y);
                        M.bearing = d,
                        M.pitch = m;
                        const S = s.bO.convert(i)
                          , I = s.bO.convert(h)
                          , R = new s.bO(S.lng,I.lat)
                          , D = new s.bO(I.lng,S.lat)
                          , k = M.project(S)
                          , H = M.project(I)
                          , j = this.queryTerrainElevation(S)
                          , Y = this.queryTerrainElevation(I)
                          , K = this.queryTerrainElevation(R)
                          , he = this.queryTerrainElevation(D)
                          , Te = [[k.x, k.y, Math.min(j || 0, Y || 0, K || 0, he || 0)], [H.x, H.y, Math.max(j || 0, Y || 0, K || 0, he || 0)]];
                        let be = s.cd.fromPoints(Te);
                        const Ue = M.getWorldToCameraMatrix()
                          , De = s.ab.mat4.invert(new Float64Array(16), Ue);
                        be = s.cd.applyTransform(be, Ue);
                        const ke = this._extendAABB(be, M, E, d);
                        if (!ke)
                            return void s.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
                        be = ke;
                        const Le = .5 * s.ab.vec3.sub([], be.max, be.min)[2]
                          , Ge = this._minimumAABBFrustumDistance(M, be)
                          , qe = [0, 0, 1, 0];
                        s.ab.vec4.transformMat4(qe, qe, Ue),
                        s.ab.vec4.normalize(qe, qe);
                        const vt = s.ab.vec3.scale([], qe, Ge + Le)
                          , dt = s.ab.vec3.add([], be.center, vt);
                        s.ab.vec3.transformMat4(be.center, be.center, De),
                        s.ab.vec3.transformMat4(dt, dt, De);
                        const Ze = M.unproject(new s.P(be.center[0],be.center[1]))
                          , nt = s.dE(M.projection, Ze)
                          , zt = Math.pow(2, nt)
                          , Yt = Math.min(M._zoomFromMercatorZ(dt[2] * M.pixelsPerMeter * zt / M.worldSize), E.maxZoom);
                        return M.mercatorFromTransition && Yt < .5 * (s.c6 + s.bY) ? (M.setProjection({
                            name: "globe"
                        }),
                        M.zoom = Yt,
                        this._cameraForBounds(M, i, h, d, m, y)) : {
                            center: Ze,
                            zoom: Yt,
                            bearing: d,
                            pitch: m
                        }
                    }
                    fitBounds(t, i, h) {
                        const d = this.cameraForBounds(t, i);
                        return this._fitInternal(d, i, h)
                    }
                    fitScreenCoordinates(t, i, h, d, m) {
                        const y = s.P.convert(t)
                          , M = s.P.convert(i)
                          , E = new s.P(Math.min(y.x, M.x),Math.min(y.y, M.y))
                          , S = new s.P(Math.max(y.x, M.x),Math.max(y.y, M.y));
                        if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(y, M))
                            return this;
                        const I = this.transform.pointLocation3D(E)
                          , R = this.transform.pointLocation3D(S)
                          , D = this.transform.pointLocation3D(new s.P(E.x,S.y))
                          , k = this.transform.pointLocation3D(new s.P(S.x,E.y))
                          , H = [Math.min(I.lng, R.lng, D.lng, k.lng), Math.min(I.lat, R.lat, D.lat, k.lat)]
                          , j = [Math.max(I.lng, R.lng, D.lng, k.lng), Math.max(I.lat, R.lat, D.lat, k.lat)]
                          , Y = d && d.pitch ? d.pitch : this.getPitch()
                          , K = this._cameraForBounds(this.transform, H, j, h, Y, d);
                        return this._fitInternal(K, d, m)
                    }
                    _fitInternal(t, i, h) {
                        return t ? (i = s.l(t, i)).linear ? this.easeTo(i, h) : this.flyTo(i, h) : this
                    }
                    jumpTo(t, i) {
                        this.stop();
                        const h = t.preloadOnly ? this.transform.clone() : this.transform;
                        let d = !1
                          , m = !1
                          , y = !1;
                        "zoom"in t && h.zoom !== +t.zoom && (d = !0,
                        h.zoom = +t.zoom),
                        void 0 !== t.center && (h.center = s.bO.convert(t.center)),
                        "bearing"in t && h.bearing !== +t.bearing && (m = !0,
                        h.bearing = +t.bearing),
                        "pitch"in t && h.pitch !== +t.pitch && (y = !0,
                        h.pitch = +t.pitch);
                        const M = "number" == typeof t.padding ? this._extendPadding(t.padding) : t.padding;
                        if (null != t.padding && !h.isPaddingEqual(M))
                            if (!1 === t.retainPadding) {
                                const E = h.clone();
                                E.padding = M,
                                h.setLocationAtPoint(h.center, E.centerPoint)
                            } else
                                h.padding = M;
                        return t.preloadOnly ? (this._preloadTiles(h),
                        this) : (this.fire(new s.z("movestart",i)).fire(new s.z("move",i)),
                        d && this.fire(new s.z("zoomstart",i)).fire(new s.z("zoom",i)).fire(new s.z("zoomend",i)),
                        m && this.fire(new s.z("rotatestart",i)).fire(new s.z("rotate",i)).fire(new s.z("rotateend",i)),
                        y && this.fire(new s.z("pitchstart",i)).fire(new s.z("pitch",i)).fire(new s.z("pitchend",i)),
                        this.fire(new s.z("moveend",i)))
                    }
                    getFreeCameraOptions() {
                        return this.transform.projection.supportsFreeCamera || s.w(Fh),
                        this.transform.getFreeCameraOptions()
                    }
                    setFreeCameraOptions(t, i) {
                        const h = this.transform;
                        if (!h.projection.supportsFreeCamera)
                            return s.w(Fh),
                            this;
                        this.stop();
                        const d = h.zoom
                          , m = h.pitch
                          , y = h.bearing;
                        h.setFreeCameraOptions(t);
                        const M = d !== h.zoom
                          , E = m !== h.pitch
                          , S = y !== h.bearing;
                        return this.fire(new s.z("movestart",i)).fire(new s.z("move",i)),
                        M && this.fire(new s.z("zoomstart",i)).fire(new s.z("zoom",i)).fire(new s.z("zoomend",i)),
                        S && this.fire(new s.z("rotatestart",i)).fire(new s.z("rotate",i)).fire(new s.z("rotateend",i)),
                        E && this.fire(new s.z("pitchstart",i)).fire(new s.z("pitch",i)).fire(new s.z("pitchend",i)),
                        this.fire(new s.z("moveend",i)),
                        this
                    }
                    easeTo(t, i) {
                        this._stop(!1, t.easeId),
                        (!1 === (t = s.l({
                            offset: [0, 0],
                            duration: 500,
                            easing: s.dA
                        }, t)).animate || this._prefersReducedMotion(t)) && (t.duration = 0);
                        const h = this.transform
                          , d = this.getZoom()
                          , m = this.getBearing()
                          , y = this.getPitch()
                          , M = this.getPadding()
                          , E = "zoom"in t ? +t.zoom : d
                          , S = "bearing"in t ? this._normalizeBearing(t.bearing, m) : m
                          , I = "pitch"in t ? +t.pitch : y
                          , R = this._extendPadding(t.padding)
                          , D = s.P.convert(t.offset);
                        let k, H, j;
                        if ("globe" === h.projection.name) {
                            const qe = s.aa.fromLngLat(h.center)
                              , vt = D.rotate(-h.angle);
                            qe.x += vt.x / h.worldSize,
                            qe.y += vt.y / h.worldSize;
                            const dt = qe.toLngLat()
                              , Ze = s.bO.convert(t.center || dt);
                            this._normalizeCenter(Ze),
                            k = h.centerPoint.add(vt),
                            H = new s.P(qe.x,qe.y).mult(h.worldSize),
                            j = new s.P(s.at(Ze.lng),s.aA(Ze.lat)).mult(h.worldSize).sub(H)
                        } else {
                            k = h.centerPoint.add(D);
                            const qe = h.pointLocation(k)
                              , vt = s.bO.convert(t.center || qe);
                            this._normalizeCenter(vt),
                            H = h.project(qe),
                            j = h.project(vt).sub(H)
                        }
                        const Y = h.zoomScale(E - d);
                        let K, he;
                        t.around && (K = s.bO.convert(t.around),
                        he = h.locationPoint(K));
                        const Te = this._zooming || E !== d
                          , be = this._rotating || m !== S
                          , Ue = this._pitching || I !== y
                          , De = !h.isPaddingEqual(R)
                          , ke = !1 === t.retainPadding ? h.clone() : h
                          , Le = qe => vt => {
                            if (Te && (qe.zoom = s.af(d, E, vt)),
                            be && (qe.bearing = s.af(m, S, vt)),
                            Ue && (qe.pitch = s.af(y, I, vt)),
                            De && (ke.interpolatePadding(M, R, vt),
                            k = ke.centerPoint.add(D)),
                            K)
                                qe.setLocationAtPoint(K, he);
                            else {
                                const dt = qe.zoomScale(qe.zoom - d)
                                  , Ze = E > d ? Math.min(2, Y) : Math.max(.5, Y)
                                  , nt = Math.pow(Ze, 1 - vt)
                                  , zt = qe.unproject(H.add(j.mult(vt * nt)).mult(dt));
                                qe.setLocationAtPoint(qe.renderWorldCopies ? zt.wrap() : zt, k)
                            }
                            return t.preloadOnly || this._fireMoveEvents(i),
                            qe
                        }
                        ;
                        if (t.preloadOnly) {
                            const qe = this._emulate(Le, t.duration, h);
                            return this._preloadTiles(qe),
                            this
                        }
                        const Ge = {
                            moving: this._moving,
                            zooming: this._zooming,
                            rotating: this._rotating,
                            pitching: this._pitching
                        };
                        return this._zooming = Te,
                        this._rotating = be,
                        this._pitching = Ue,
                        this._padding = De,
                        this._easeId = t.easeId,
                        this._prepareEase(i, t.noMoveStart, Ge),
                        this._ease(Le(h), qe => {
                            "sea" === h.cameraElevationReference && h.recenterOnTerrain(),
                            this._afterEase(i, qe)
                        }
                        , t),
                        this
                    }
                    _prepareEase(t, i, h={}) {
                        this._moving = !0,
                        this.transform.cameraElevationReference = "sea",
                        this.transform._orthographicProjectionAtLowPitch && 0 === this.transform.pitch && "globe" !== this.transform.projection.name && (this.transform.cameraElevationReference = "ground"),
                        i || h.moving || this.fire(new s.z("movestart",t)),
                        this._zooming && !h.zooming && this.fire(new s.z("zoomstart",t)),
                        this._rotating && !h.rotating && this.fire(new s.z("rotatestart",t)),
                        this._pitching && !h.pitching && this.fire(new s.z("pitchstart",t))
                    }
                    _fireMoveEvents(t) {
                        this.fire(new s.z("move",t)),
                        this._zooming && this.fire(new s.z("zoom",t)),
                        this._rotating && this.fire(new s.z("rotate",t)),
                        this._pitching && this.fire(new s.z("pitch",t))
                    }
                    _afterEase(t, i) {
                        if (this._easeId && i && this._easeId === i)
                            return;
                        this._easeId = void 0,
                        this.transform.cameraElevationReference = "ground";
                        const h = this._zooming
                          , d = this._rotating
                          , m = this._pitching;
                        this._moving = !1,
                        this._zooming = !1,
                        this._rotating = !1,
                        this._pitching = !1,
                        this._padding = !1,
                        h && this.fire(new s.z("zoomend",t)),
                        d && this.fire(new s.z("rotateend",t)),
                        m && this.fire(new s.z("pitchend",t)),
                        this.fire(new s.z("moveend",t))
                    }
                    flyTo(t, i) {
                        if (this._prefersReducedMotion(t)) {
                            const wt = s.ay(t, ["center", "zoom", "bearing", "pitch", "around", "padding", "retainPadding"]);
                            return this.jumpTo(wt, i)
                        }
                        this.stop(),
                        t = s.l({
                            offset: [0, 0],
                            speed: 1.2,
                            curve: 1.42,
                            easing: s.dA
                        }, t);
                        const h = this.transform
                          , d = this.getZoom()
                          , m = this.getBearing()
                          , y = this.getPitch()
                          , M = this.getPadding()
                          , E = "zoom"in t ? s.aw(+t.zoom, h.minZoom, h.maxZoom) : d
                          , S = "bearing"in t ? this._normalizeBearing(t.bearing, m) : m
                          , I = "pitch"in t ? +t.pitch : y
                          , R = this._extendPadding(t.padding)
                          , D = h.zoomScale(E - d)
                          , k = s.P.convert(t.offset);
                        let H = h.centerPoint.add(k);
                        const j = h.pointLocation(H)
                          , Y = s.bO.convert(t.center || j);
                        this._normalizeCenter(Y);
                        const K = h.project(j)
                          , he = h.project(Y).sub(K);
                        let Te = t.curve;
                        const be = Math.max(h.width, h.height)
                          , Ue = be / D
                          , De = he.mag();
                        if ("minZoom"in t) {
                            const wt = s.aw(Math.min(t.minZoom, d, E), h.minZoom, h.maxZoom)
                              , qt = be / h.zoomScale(wt - d);
                            Te = Math.sqrt(qt / De * 2)
                        }
                        const ke = Te * Te;
                        function Le(wt) {
                            const qt = (Ue * Ue - be * be + (wt ? -1 : 1) * ke * ke * De * De) / (2 * (wt ? Ue : be) * ke * De);
                            return Math.log(Math.sqrt(qt * qt + 1) - qt)
                        }
                        function Ge(wt) {
                            return (Math.exp(wt) - Math.exp(-wt)) / 2
                        }
                        function qe(wt) {
                            return (Math.exp(wt) + Math.exp(-wt)) / 2
                        }
                        const vt = Le(0);
                        let dt = function(wt) {
                            return qe(vt) / qe(vt + Te * wt)
                        }
                          , Ze = function(wt) {
                            return be * ((qe(vt) * (Ge(qt = vt + Te * wt) / qe(qt)) - Ge(vt)) / ke) / De;
                            var qt
                        }
                          , nt = (Le(1) - vt) / Te;
                        if (Math.abs(De) < 1e-6 || !isFinite(nt)) {
                            if (Math.abs(be - Ue) < 1e-6)
                                return this.easeTo(t, i);
                            const wt = Ue < be ? -1 : 1;
                            nt = Math.abs(Math.log(Ue / be)) / Te,
                            Ze = function() {
                                return 0
                            }
                            ,
                            dt = function(qt) {
                                return Math.exp(wt * Te * qt)
                            }
                        }
                        t.duration = "duration"in t ? +t.duration : 1e3 * nt / ("screenSpeed"in t ? +t.screenSpeed / Te : +t.speed),
                        t.maxDuration && t.duration > t.maxDuration && (t.duration = 0);
                        const zt = m !== S
                          , Yt = I !== y
                          , to = !h.isPaddingEqual(R)
                          , ut = !1 === t.retainPadding ? h.clone() : h
                          , Gt = wt => qt => {
                            const Ht = qt * nt
                              , Dt = 1 / dt(Ht);
                            wt.zoom = 1 === qt ? E : d + wt.scaleZoom(Dt),
                            zt && (wt.bearing = s.af(m, S, qt)),
                            Yt && (wt.pitch = s.af(y, I, qt)),
                            to && (ut.interpolatePadding(M, R, qt),
                            H = ut.centerPoint.add(k));
                            const bo = 1 === qt ? Y : wt.unproject(K.add(he.mult(Ze(Ht))).mult(Dt));
                            return wt.setLocationAtPoint(wt.renderWorldCopies ? bo.wrap() : bo, H),
                            wt._updateCameraOnTerrain(),
                            t.preloadOnly || this._fireMoveEvents(i),
                            wt
                        }
                        ;
                        if (t.preloadOnly) {
                            const wt = this._emulate(Gt, t.duration, h);
                            return this._preloadTiles(wt),
                            this
                        }
                        return this._zooming = !0,
                        this._rotating = zt,
                        this._pitching = Yt,
                        this._padding = to,
                        this._prepareEase(i, !1),
                        this._ease(Gt(h), () => this._afterEase(i), t),
                        this
                    }
                    isEasing() {
                        return !!this._easeFrameId
                    }
                    stop() {
                        return this._stop()
                    }
                    _requestRenderFrame(t) {}
                    _cancelRenderFrame(t) {}
                    _stop(t, i) {
                        if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId),
                        this._easeFrameId = void 0,
                        this._onEaseFrame = void 0),
                        this._onEaseEnd) {
                            const h = this._onEaseEnd;
                            this._onEaseEnd = void 0,
                            h.call(this, i)
                        }
                        if (!t) {
                            const h = this.handlers;
                            h && h.stop(!1)
                        }
                        return this
                    }
                    _ease(t, i, h) {
                        !1 === h.animate || 0 === h.duration ? (t(1),
                        i()) : (this._easeStart = s.q.now(),
                        this._easeOptions = h,
                        this._onEaseFrame = t,
                        this._onEaseEnd = i,
                        this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback))
                    }
                    _renderFrameCallback() {
                        const t = Math.min((s.q.now() - this._easeStart) / this._easeOptions.duration, 1)
                          , i = this._onEaseFrame;
                        i && i(this._easeOptions.easing(t)),
                        t < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop()
                    }
                    _normalizeBearing(t, i) {
                        t = s.bF(t, -180, 180);
                        const h = Math.abs(t - i);
                        return Math.abs(t - 360 - i) < h && (t -= 360),
                        Math.abs(t + 360 - i) < h && (t += 360),
                        t
                    }
                    _normalizeCenter(t) {
                        const i = this.transform;
                        if (i.maxBounds || "globe" !== i.projection.name && !i.renderWorldCopies)
                            return;
                        const h = t.lng - i.center.lng;
                        t.lng += h > 180 ? -360 : h < -180 ? 360 : 0
                    }
                    _prefersReducedMotion(t) {
                        return this._respectPrefersReducedMotion && s.q.prefersReducedMotion && !(t && t.essential)
                    }
                    _emulate(t, i, h) {
                        const d = Math.ceil(15 * i / 1e3)
                          , m = []
                          , y = t(h.clone());
                        for (let M = 0; M <= d; M++) {
                            const E = y(M / d);
                            m.push(E.clone())
                        }
                        return m
                    }
                    _preloadTiles(t, i) {}
                }
                class Ap {
                    constructor(t={}) {
                        this.options = t,
                        s.aP(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this)
                    }
                    getDefaultPosition() {
                        return "bottom-right"
                    }
                    onAdd(t) {
                        const i = this.options && this.options.compact
                          , h = t._getUIString("AttributionControl.ToggleAttribution");
                        this._map = t,
                        this._container = Qe("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"),
                        this._compactButton = Qe("button", "mapboxgl-ctrl-attrib-button", this._container),
                        this._compactButton.type = "button",
                        this._compactButton.addEventListener("click", this._toggleAttribution),
                        this._compactButton.setAttribute("aria-label", h);
                        const d = Qe("span", "mapboxgl-ctrl-icon", this._compactButton);
                        return d.setAttribute("aria-hidden", "true"),
                        d.setAttribute("title", h),
                        this._innerContainer = Qe("div", "mapboxgl-ctrl-attrib-inner", this._container),
                        i && this._container.classList.add("mapboxgl-compact"),
                        this._updateAttributions(),
                        this._updateEditLink(),
                        this._map.on("styledata", this._updateData),
                        this._map.on("sourcedata", this._updateData),
                        this._map.on("moveend", this._updateEditLink),
                        void 0 === i && (this._map.on("resize", this._updateCompact),
                        this._updateCompact()),
                        this._container
                    }
                    onRemove() {
                        this._container.remove(),
                        this._map.off("styledata", this._updateData),
                        this._map.off("sourcedata", this._updateData),
                        this._map.off("moveend", this._updateEditLink),
                        this._map.off("resize", this._updateCompact),
                        this._map = void 0,
                        this._attribHTML = void 0
                    }
                    _toggleAttribution() {
                        this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"),
                        this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"),
                        this._compactButton.setAttribute("aria-expanded", "true"))
                    }
                    _updateEditLink() {
                        let t = this._editLink;
                        t || (t = this._editLink = this._container.querySelector(".mapbox-improve-map"));
                        const i = [{
                            key: "owner",
                            value: this.styleOwner
                        }, {
                            key: "id",
                            value: this.styleId
                        }, {
                            key: "access_token",
                            value: this._map._requestManager._customAccessToken || s.e.ACCESS_TOKEN
                        }];
                        if (t) {
                            const h = i.reduce( (d, m, y) => (m.value && (d += "".concat(m.key, "=").concat(m.value).concat(y < i.length - 1 ? "&" : "")),
                            d), "?");
                            t.href = "".concat(s.e.FEEDBACK_URL, "/").concat(h, "#").concat(Ah(this._map, !0)),
                            t.rel = "noopener nofollow"
                        }
                    }
                    _updateData(t) {
                        !t || "metadata" !== t.sourceDataType && "visibility" !== t.sourceDataType && "style" !== t.dataType || (this._updateAttributions(),
                        this._updateEditLink())
                    }
                    _updateAttributions() {
                        if (!this._map.style)
                            return;
                        let t = [];
                        if (this._map.style.stylesheet) {
                            const d = this._map.style.stylesheet;
                            this.styleOwner = d.owner,
                            this.styleId = d.id
                        }
                        const i = this._map.style._mergedSourceCaches;
                        for (const d in i) {
                            const m = i[d];
                            if (m.used) {
                                const y = m.getSource();
                                y.attribution && t.indexOf(y.attribution) < 0 && t.push(y.attribution)
                            }
                        }
                        t.sort( (d, m) => d.length - m.length),
                        t = t.filter( (d, m) => {
                            for (let y = m + 1; y < t.length; y++)
                                if (t[y].indexOf(d) >= 0)
                                    return !1;
                            return !0
                        }
                        ),
                        this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t = [...this.options.customAttribution, ...t] : t.unshift(this.options.customAttribution));
                        const h = t.join(" | ");
                        h !== this._attribHTML && (this._attribHTML = h,
                        t.length ? (this._innerContainer.innerHTML = h,
                        this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"),
                        this._editLink = null)
                    }
                    _updateCompact() {
                        this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show")
                    }
                }
                class Na {
                    constructor() {
                        s.aP(["_updateLogo", "_updateCompact"], this)
                    }
                    onAdd(t) {
                        this._map = t,
                        this._container = Qe("div", "mapboxgl-ctrl");
                        const i = Qe("a", "mapboxgl-ctrl-logo");
                        return i.target = "_blank",
                        i.rel = "noopener nofollow",
                        i.href = "https://www.mapbox.com/",
                        i.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")),
                        i.setAttribute("rel", "noopener nofollow"),
                        this._container.appendChild(i),
                        this._container.style.display = "none",
                        this._map.on("sourcedata", this._updateLogo),
                        this._updateLogo(),
                        this._map.on("resize", this._updateCompact),
                        this._updateCompact(),
                        this._container
                    }
                    onRemove() {
                        this._container.remove(),
                        this._map.off("sourcedata", this._updateLogo),
                        this._map.off("resize", this._updateCompact)
                    }
                    getDefaultPosition() {
                        return "bottom-left"
                    }
                    _updateLogo(t) {
                        t && "metadata" !== t.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none")
                    }
                    _logoRequired() {
                        if (!this._map.style)
                            return !0;
                        const t = this._map.style._sourceCaches;
                        if (0 === Object.entries(t).length)
                            return !0;
                        for (const i in t) {
                            const h = t[i].getSource();
                            if (h.hasOwnProperty("mapbox_logo") && !h.mapbox_logo)
                                return !1
                        }
                        return !0
                    }
                    _updateCompact() {
                        const t = this._container.children;
                        if (t.length) {
                            const i = t[0];
                            this._map.getCanvasContainer().offsetWidth < 250 ? i.classList.add("mapboxgl-compact") : i.classList.remove("mapboxgl-compact")
                        }
                    }
                }
                class kh {
                    constructor() {
                        this._queue = [],
                        this._id = 0,
                        this._cleared = !1,
                        this._currentlyRunning = !1
                    }
                    add(t) {
                        const i = ++this._id;
                        return this._queue.push({
                            callback: t,
                            id: i,
                            cancelled: !1
                        }),
                        i
                    }
                    remove(t) {
                        const i = this._currentlyRunning
                          , h = i ? this._queue.concat(i) : this._queue;
                        for (const d of h)
                            if (d.id === t)
                                return void (d.cancelled = !0)
                    }
                    run(t=0) {
                        const i = this._currentlyRunning = this._queue;
                        this._queue = [];
                        for (const h of i)
                            if (!h.cancelled && (h.callback(t),
                            this._cleared))
                                break;
                        this._cleared = !1,
                        this._currentlyRunning = !1
                    }
                    clear() {
                        this._currentlyRunning && (this._cleared = !0),
                        this._queue = []
                    }
                }
                class Gr {
                    constructor(t) {
                        this.jumpTo(t)
                    }
                    getValue(t) {
                        if (t <= this._startTime)
                            return this._start;
                        if (t >= this._endTime)
                            return this._end;
                        const i = s.cB((t - this._startTime) / (this._endTime - this._startTime));
                        return this._start * (1 - i) + this._end * i
                    }
                    isEasing(t) {
                        return t >= this._startTime && t <= this._endTime
                    }
                    jumpTo(t) {
                        this._startTime = -1 / 0,
                        this._endTime = -1 / 0,
                        this._start = t,
                        this._end = t
                    }
                    easeTo(t, i, h) {
                        this._start = this.getValue(i),
                        this._end = t,
                        this._startTime = i,
                        this._endTime = i + h
                    }
                }
                const jr = {
                    "AttributionControl.ToggleAttribution": "Toggle attribution",
                    "FullscreenControl.Enter": "Enter fullscreen",
                    "FullscreenControl.Exit": "Exit fullscreen",
                    "GeolocateControl.FindMyLocation": "Find my location",
                    "GeolocateControl.LocationNotAvailable": "Location not available",
                    "LogoControl.Title": "Mapbox homepage",
                    "Map.Title": "Map",
                    "NavigationControl.ResetBearing": "Reset bearing to north",
                    "NavigationControl.ZoomIn": "Zoom in",
                    "NavigationControl.ZoomOut": "Zoom out",
                    "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map",
                    "ScrollZoomBlocker.CmdMessage": "Use \u2318 + scroll to zoom the map",
                    "TouchPanBlocker.Message": "Use two fingers to move the map"
                }
                  , Sl = ["mouseenter", "mouseover", "mouseleave", "mouseout"];
                class _a extends s.z {
                    constructor(t, i, h, d) {
                        const {point: m, lngLat: y, originalEvent: M, target: E} = t;
                        super(t.type, {
                            point: m,
                            lngLat: y,
                            originalEvent: M,
                            target: E
                        }),
                        this.preventDefault = () => {
                            t.preventDefault()
                        }
                        ,
                        this.id = i,
                        this.interaction = h,
                        this.feature = d
                    }
                }
                class Il {
                    constructor(t) {
                        this.map = t,
                        this.interactionsByType = new Map,
                        this.typeById = new Map,
                        this.filters = new Map,
                        this.delegatedHandlers = new Map,
                        this.handleType = this.handleType.bind(this)
                    }
                    add(t, i) {
                        if (this.typeById.has(t))
                            throw new Error('Interaction id "'.concat(t, '" already exists.'));
                        const {type: h, filter: d} = i;
                        d && this.filters.set(t, s.aZ(d));
                        const m = this.interactionsByType.get(h) || new Map;
                        if (0 === m.size) {
                            if (Sl.includes(h)) {
                                const {mousemove: y, mouseout: M} = this._createDelegatedHandlers(t, i);
                                this.map.on("mousemove", y),
                                this.map.on("mouseout", M),
                                this.delegatedHandlers.set(t, {
                                    mousemove: y,
                                    mouseout: M
                                })
                            } else
                                this.map.on(h, this.handleType);
                            this.interactionsByType.set(h, m)
                        }
                        m.set(t, i),
                        this.typeById.set(t, h)
                    }
                    get(t) {
                        const i = this.typeById.get(t);
                        if (!i)
                            return;
                        const h = this.interactionsByType.get(i);
                        return h ? h.get(t) : void 0
                    }
                    remove(t) {
                        const i = this.typeById.get(t);
                        if (!i)
                            return;
                        this.typeById.delete(t),
                        this.filters.delete(t);
                        const h = this.interactionsByType.get(i);
                        if (h) {
                            if (h.delete(t),
                            this.delegatedHandlers.has(t)) {
                                const {mousemove: d, mouseout: m} = this.delegatedHandlers.get(t);
                                this.map.off("mousemove", d),
                                this.map.off("mouseout", m),
                                this.delegatedHandlers.delete(t)
                            }
                            0 === h.size && this.map.off(i, this.handleType)
                        }
                    }
                    queryTargets(t, i) {
                        const h = [];
                        for (const [d,m] of i)
                            m.target && h.push({
                                targetId: d,
                                target: m.target,
                                filter: this.filters.get(d)
                            });
                        return this.map.style.queryRenderedTargets(t, h, this.map.transform)
                    }
                    handleType(t, i) {
                        const h = this.interactionsByType.get(t.type)
                          , d = Array.from(h).reverse();
                        i = i || this.queryTargets(t.point, d);
                        let m = !1;
                        for (const y of i) {
                            for (const [M,E] of d) {
                                if (!E.target)
                                    continue;
                                const S = y.variants ? y.variants[M] : null;
                                if (S) {
                                    for (const I of S) {
                                        const R = new s.cw(y,I);
                                        if (!1 !== E.handler(new _a(t,M,E,R))) {
                                            m = !0;
                                            break
                                        }
                                    }
                                    if (m)
                                        break
                                }
                            }
                            if (m)
                                break
                        }
                        if (!m)
                            for (const [y,M] of d) {
                                const {handler: E, target: S} = M;
                                if (!S && !1 !== E(new _a(t,y,M,null)))
                                    break
                            }
                    }
                    _createDelegatedHandlers(t, i) {
                        switch (i.type) {
                        case "mouseenter":
                        case "mouseover":
                            {
                                let h = !1
                                  , d = new Set;
                                return {
                                    mousemove: m => {
                                        const y = this.queryTargets(m.point, [[t, i]])
                                          , M = new Set;
                                        if (!y.length)
                                            return h = !1,
                                            void d.clear();
                                        const E = [];
                                        for (const S of y)
                                            d.has(S.id) || (M.add(S.id),
                                            E.push(S));
                                        h && !E.length || (h = !0,
                                        d = M,
                                        m.type = i.type,
                                        this.handleType(m, E))
                                    }
                                    ,
                                    mouseout: () => {
                                        h = !1,
                                        d.clear()
                                    }
                                }
                            }
                        case "mouseleave":
                        case "mouseout":
                            {
                                let h = [];
                                return {
                                    mousemove: d => {
                                        const m = this.queryTargets(d.point, [[t, i]]);
                                        if (!m.length)
                                            return d.type = i.type,
                                            this.handleType(d, h),
                                            void (h = m);
                                        const y = []
                                          , M = new Set(m.map(E => E.id));
                                        for (const E of h)
                                            M.has(E.id) || y.push(E);
                                        y.length && (d.type = i.type,
                                        this.handleType(d, y)),
                                        h = m
                                    }
                                    ,
                                    mouseout: d => {
                                        h.length && (d.type = i.type,
                                        this.handleType(d, h),
                                        h = [])
                                    }
                                }
                            }
                        }
                    }
                }
                function Du(c, t) {
                    if (Array.isArray(c) && Array.isArray(t)) {
                        const i = new Set(c)
                          , h = new Set(t);
                        return i.size === h.size && c.every(d => h.has(d))
                    }
                    return s.bn(c, t)
                }
                const Mi = {
                    center: [0, 0],
                    zoom: 0,
                    bearing: 0,
                    pitch: 0,
                    minZoom: -2,
                    maxZoom: 22,
                    minPitch: 0,
                    maxPitch: 85,
                    interactive: !0,
                    scrollZoom: !0,
                    boxZoom: !0,
                    dragRotate: !0,
                    dragPan: !0,
                    keyboard: !0,
                    doubleClickZoom: !0,
                    touchZoomRotate: !0,
                    touchPitch: !0,
                    cooperativeGestures: !1,
                    performanceMetricsCollection: !0,
                    bearingSnap: 7,
                    clickTolerance: 3,
                    pitchWithRotate: !0,
                    hash: !1,
                    attributionControl: !0,
                    antialias: !1,
                    failIfMajorPerformanceCaveat: !1,
                    preserveDrawingBuffer: !1,
                    trackResize: !0,
                    renderWorldCopies: !0,
                    refreshExpiredTiles: !0,
                    minTileCacheSize: null,
                    maxTileCacheSize: null,
                    localIdeographFontFamily: "sans-serif",
                    localFontFamily: null,
                    transformRequest: null,
                    accessToken: null,
                    fadeDuration: 300,
                    respectPrefersReducedMotion: !0,
                    crossSourceCollisions: !0,
                    collectResourceTiming: !1,
                    testMode: !1,
                    precompilePrograms: !0,
                    scaleFactor: 1,
                    spriteFormat: "auto"
                }
                  , ga = {
                    showCompass: !0,
                    showZoom: !0,
                    visualizePitch: !1
                };
                class kd {
                    constructor(t, i, h=!1) {
                        this._clickTolerance = 10,
                        this.element = i,
                        this.mouseRotate = new Rh({
                            clickTolerance: t.dragRotate._mouseRotate._clickTolerance
                        }),
                        this.map = t,
                        h && (this.mousePitch = new Ac({
                            clickTolerance: t.dragRotate._mousePitch._clickTolerance
                        })),
                        s.aP(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this),
                        i.addEventListener("mousedown", this.mousedown),
                        i.addEventListener("touchstart", this.touchstart, {
                            passive: !1
                        }),
                        i.addEventListener("touchmove", this.touchmove),
                        i.addEventListener("touchend", this.touchend),
                        i.addEventListener("touchcancel", this.reset)
                    }
                    down(t, i) {
                        this.mouseRotate.mousedown(t, i),
                        this.mousePitch && this.mousePitch.mousedown(t, i),
                        et()
                    }
                    move(t, i) {
                        const h = this.map
                          , d = this.mouseRotate.mousemoveWindow(t, i)
                          , m = d && d.bearingDelta;
                        if (m && h.setBearing(h.getBearing() + m),
                        this.mousePitch) {
                            const y = this.mousePitch.mousemoveWindow(t, i)
                              , M = y && y.pitchDelta;
                            M && h.setPitch(h.getPitch() + M)
                        }
                    }
                    off() {
                        const t = this.element;
                        t.removeEventListener("mousedown", this.mousedown),
                        t.removeEventListener("touchstart", this.touchstart, {
                            passive: !1
                        }),
                        t.removeEventListener("touchmove", this.touchmove),
                        t.removeEventListener("touchend", this.touchend),
                        t.removeEventListener("touchcancel", this.reset),
                        this.offTemp()
                    }
                    offTemp() {
                        re(),
                        window.removeEventListener("mousemove", this.mousemove),
                        window.removeEventListener("mouseup", this.mouseup)
                    }
                    mousedown(t) {
                        this.down(s.l({}, t, {
                            ctrlKey: !0,
                            preventDefault: () => t.preventDefault()
                        }), ze(this.element, t)),
                        window.addEventListener("mousemove", this.mousemove),
                        window.addEventListener("mouseup", this.mouseup)
                    }
                    mousemove(t) {
                        this.move(t, ze(this.element, t))
                    }
                    mouseup(t) {
                        this.mouseRotate.mouseupWindow(t),
                        this.mousePitch && this.mousePitch.mouseupWindow(t),
                        this.offTemp()
                    }
                    touchstart(t) {
                        1 !== t.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = ye(this.element, t.targetTouches)[0],
                        this.down({
                            type: "mousedown",
                            button: 0,
                            ctrlKey: !0,
                            preventDefault: () => t.preventDefault()
                        }, this._startPos))
                    }
                    touchmove(t) {
                        1 !== t.targetTouches.length ? this.reset() : (this._lastPos = ye(this.element, t.targetTouches)[0],
                        this.move({
                            preventDefault: () => t.preventDefault()
                        }, this._lastPos))
                    }
                    touchend(t) {
                        0 === t.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(),
                        this.reset()
                    }
                    reset() {
                        this.mouseRotate.reset(),
                        this.mousePitch && this.mousePitch.reset(),
                        delete this._startPos,
                        delete this._lastPos,
                        this.offTemp()
                    }
                }
                function Op(c, t, i) {
                    if (c = new s.bO(c.lng,c.lat),
                    t) {
                        const h = new s.bO(c.lng - 360,c.lat)
                          , d = new s.bO(c.lng + 360,c.lat)
                          , m = 360 * Math.ceil(Math.abs(c.lng - i.center.lng) / 360)
                          , y = i.locationPoint(c).distSqr(t)
                          , M = t.x < 0 || t.y < 0 || t.x > i.width || t.y > i.height;
                        i.locationPoint(h).distSqr(t) < y && (M || Math.abs(h.lng - i.center.lng) < m) ? c = h : i.locationPoint(d).distSqr(t) < y && (M || Math.abs(d.lng - i.center.lng) < m) && (c = d)
                    }
                    for (; Math.abs(c.lng - i.center.lng) > 180; ) {
                        const h = i.locationPoint(c);
                        if (h.x >= 0 && h.y >= 0 && h.x <= i.width && h.y <= i.height)
                            break;
                        c.lng > i.center.lng ? c.lng -= 360 : c.lng += 360
                    }
                    return c
                }
                const Lc = {
                    center: "translate(-50%,-50%)",
                    top: "translate(-50%,0)",
                    "top-left": "translate(0,0)",
                    "top-right": "translate(-100%,0)",
                    bottom: "translate(-50%,-100%)",
                    "bottom-left": "translate(0,-100%)",
                    "bottom-right": "translate(-100%,-100%)",
                    left: "translate(0,-50%)",
                    right: "translate(-100%,-50%)"
                };
                class gs extends s.E {
                    constructor(t, i) {
                        if (super(),
                        (t instanceof HTMLElement || i) && (t = s.l({
                            element: t
                        }, i)),
                        s.aP(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this),
                        this._anchor = t && t.anchor || "center",
                        this._color = t && t.color || "#3FB1CE",
                        this._scale = t && t.scale || 1,
                        this._draggable = t && t.draggable || !1,
                        this._clickTolerance = t && t.clickTolerance || 0,
                        this._isDragging = !1,
                        this._state = "inactive",
                        this._rotation = t && t.rotation || 0,
                        this._rotationAlignment = t && t.rotationAlignment || "auto",
                        this._pitchAlignment = t && t.pitchAlignment && t.pitchAlignment || "auto",
                        this._updateMoving = () => this._update(!0),
                        this._occludedOpacity = t && t.occludedOpacity || .2,
                        t && t.element)
                            this._element = t.element,
                            this._offset = s.P.convert(t && t.offset || [0, 0]);
                        else {
                            this._defaultMarker = !0,
                            this._element = Qe("div");
                            const m = 41
                              , y = 27
                              , M = jt("svg", {
                                display: "block",
                                height: m * this._scale + "px",
                                width: y * this._scale + "px",
                                viewBox: "0 0 ".concat(y, " ").concat(m)
                            }, this._element)
                              , E = jt("radialGradient", {
                                id: "shadowGradient"
                            }, jt("defs", {}, M));
                            jt("stop", {
                                offset: "10%",
                                "stop-opacity": .4
                            }, E),
                            jt("stop", {
                                offset: "100%",
                                "stop-opacity": .05
                            }, E),
                            jt("ellipse", {
                                cx: 13.5,
                                cy: 34.8,
                                rx: 10.5,
                                ry: 5.25,
                                fill: "url(#shadowGradient)"
                            }, M),
                            jt("path", {
                                fill: this._color,
                                d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z"
                            }, M),
                            jt("path", {
                                opacity: .25,
                                d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z"
                            }, M),
                            jt("circle", {
                                fill: "white",
                                cx: 13.5,
                                cy: 13.5,
                                r: 5.5
                            }, M),
                            this._offset = s.P.convert(t && t.offset || [0, -14])
                        }
                        this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"),
                        this._element.hasAttribute("role") || this._element.setAttribute("role", "img"),
                        this._element.classList.add("mapboxgl-marker"),
                        this._element.addEventListener("dragstart", m => {
                            m.preventDefault()
                        }
                        ),
                        this._element.addEventListener("mousedown", m => {
                            m.preventDefault()
                        }
                        );
                        const h = this._element.classList;
                        for (const m in Lc)
                            h.remove("mapboxgl-marker-anchor-".concat(m));
                        h.add("mapboxgl-marker-anchor-".concat(this._anchor));
                        const d = t && t.className ? t.className.trim().split(/\s+/) : [];
                        h.add(...d),
                        this._popup = null
                    }
                    addTo(t) {
                        return t === this._map || (this.remove(),
                        this._map = t,
                        t.getCanvasContainer().appendChild(this._element),
                        t.on("move", this._updateMoving),
                        t.on("moveend", this._update),
                        t.on("remove", this._clearFadeTimer),
                        t._addMarker(this),
                        this.setDraggable(this._draggable),
                        this._update(),
                        t.on("click", this._onMapClick)),
                        this
                    }
                    remove() {
                        const t = this._map;
                        return t && (t.off("click", this._onMapClick),
                        t.off("move", this._updateMoving),
                        t.off("moveend", this._update),
                        t.off("mousedown", this._addDragHandler),
                        t.off("touchstart", this._addDragHandler),
                        t.off("mouseup", this._onUp),
                        t.off("touchend", this._onUp),
                        t.off("mousemove", this._onMove),
                        t.off("touchmove", this._onMove),
                        t.off("remove", this._clearFadeTimer),
                        t._removeMarker(this),
                        this._map = void 0),
                        this._clearFadeTimer(),
                        this._element.remove(),
                        this._popup && this._popup.remove(),
                        this
                    }
                    getLngLat() {
                        return this._lngLat
                    }
                    setLngLat(t) {
                        return this._lngLat = s.bO.convert(t),
                        this._pos = null,
                        this._popup && this._popup.setLngLat(this._lngLat),
                        this._update(!0),
                        this
                    }
                    getElement() {
                        return this._element
                    }
                    setPopup(t) {
                        if (this._popup && (this._popup.remove(),
                        this._popup = null,
                        this._element.removeAttribute("role"),
                        this._element.removeEventListener("keypress", this._onKeyPress),
                        this._originalTabIndex || this._element.removeAttribute("tabindex")),
                        t) {
                            if (!("offset"in t.options)) {
                                const d = Math.sqrt(Math.pow(13.5, 2) / 2);
                                t.options.offset = this._defaultMarker ? {
                                    top: [0, 0],
                                    "top-left": [0, 0],
                                    "top-right": [0, 0],
                                    bottom: [0, -38.1],
                                    "bottom-left": [d, -1 * (24.6 + d)],
                                    "bottom-right": [-d, -1 * (24.6 + d)],
                                    left: [13.5, -24.6],
                                    right: [-13.5, -24.6]
                                } : this._offset
                            }
                            this._popup = t,
                            t._marker = this,
                            this._lngLat && this._popup.setLngLat(this._lngLat),
                            this._element.setAttribute("role", "button"),
                            this._originalTabIndex = this._element.getAttribute("tabindex"),
                            this._originalTabIndex || this._element.setAttribute("tabindex", "0"),
                            this._element.addEventListener("keypress", this._onKeyPress),
                            this._element.setAttribute("aria-expanded", "false")
                        }
                        return this
                    }
                    _onKeyPress(t) {
                        const i = t.code
                          , h = t.charCode || t.keyCode;
                        "Space" !== i && "Enter" !== i && 32 !== h && 13 !== h || this.togglePopup()
                    }
                    _onMapClick(t) {
                        const i = t.originalEvent.target
                          , h = this._element;
                        this._popup && (i === h || h.contains(i)) && this.togglePopup()
                    }
                    getPopup() {
                        return this._popup
                    }
                    togglePopup() {
                        const t = this._popup;
                        return t ? (t.isOpen() ? (t.remove(),
                        this._element.setAttribute("aria-expanded", "false")) : this._map && (t.addTo(this._map),
                        this._element.setAttribute("aria-expanded", "true")),
                        this) : this
                    }
                    _behindTerrain() {
                        const t = this._map
                          , i = this._pos;
                        if (!t || !i)
                            return !1;
                        const h = t.unproject(i)
                          , d = t.getFreeCameraOptions();
                        if (!d.position)
                            return !1;
                        const m = d.position.toLngLat();
                        return m.distanceTo(h) < .9 * m.distanceTo(this._lngLat)
                    }
                    _evaluateOpacity() {
                        const t = this._map;
                        if (!t)
                            return;
                        const i = this._pos;
                        if (!i || i.x < 0 || i.x > t.transform.width || i.y < 0 || i.y > t.transform.height)
                            return void this._clearFadeTimer();
                        const h = t.unproject(i);
                        let d;
                        t._showingGlobe() && s.dH(t.transform, this._lngLat) ? d = 0 : (d = 1 - t._queryFogOpacity(h),
                        t.transform._terrainEnabled() && t.getTerrain() && this._behindTerrain() && (d *= this._occludedOpacity)),
                        this._element.style.opacity = "".concat(d),
                        this._element.style.pointerEvents = d > 0 ? "auto" : "none",
                        this._popup && this._popup._setOpacity(d),
                        this._fadeTimer = null
                    }
                    _clearFadeTimer() {
                        this._fadeTimer && (clearTimeout(this._fadeTimer),
                        this._fadeTimer = null)
                    }
                    _updateDOM() {
                        const t = this._pos;
                        if (!t || !this._map)
                            return;
                        const i = this._offset.mult(this._scale);
                        this._element.style.transform = "\n            translate(".concat(t.x, "px,").concat(t.y, "px)\n            ").concat(Lc[this._anchor], "\n            ").concat(this._calculateXYTransform(), " ").concat(this._calculateZTransform(), "\n            translate(").concat(i.x, "px,").concat(i.y, "px)\n        ")
                    }
                    _calculateXYTransform() {
                        const t = this._pos
                          , i = this._map
                          , h = this.getPitchAlignment();
                        if (!i || !t || "map" !== h)
                            return "";
                        if (!i._showingGlobe()) {
                            const E = i.getPitch();
                            return E ? "rotateX(".concat(E, "deg)") : ""
                        }
                        const d = s.c4(s.dI(i.transform, this._lngLat))
                          , m = t.sub(s.dJ(i.transform))
                          , y = Math.abs(m.x) + Math.abs(m.y);
                        if (0 === y)
                            return "";
                        const M = d / y;
                        return "rotateX(".concat(-m.y * M, "deg) rotateY(").concat(m.x * M, "deg)")
                    }
                    _calculateZTransform() {
                        const t = this._pos
                          , i = this._map;
                        if (!i || !t)
                            return "";
                        let h = 0;
                        const d = this.getRotationAlignment();
                        if ("map" === d)
                            if (i._showingGlobe()) {
                                const m = i.project(new s.bO(this._lngLat.lng,this._lngLat.lat + .001))
                                  , y = i.project(new s.bO(this._lngLat.lng,this._lngLat.lat - .001)).sub(m);
                                h = s.c4(Math.atan2(y.y, y.x)) - 90
                            } else
                                h = -i.getBearing();
                        else if ("horizon" === d) {
                            const m = s.ac(4, 6, i.getZoom())
                              , y = s.dJ(i.transform);
                            y.y += m * i.transform.height;
                            const M = t.sub(y)
                              , E = s.c4(Math.atan2(M.y, M.x));
                            h = (E > 90 ? E - 270 : E + 90) * (1 - m)
                        }
                        return h += this._rotation,
                        h ? "rotateZ(".concat(h, "deg)") : ""
                    }
                    _update(t) {
                        cancelAnimationFrame(this._updateFrameId);
                        const i = this._map;
                        i && (i.transform.renderWorldCopies && (this._lngLat = Op(this._lngLat, this._pos, i.transform)),
                        this._pos = i.project(this._lngLat),
                        !0 === t ? this._updateFrameId = requestAnimationFrame( () => {
                            this._element && this._pos && this._anchor && (this._pos = this._pos.round(),
                            this._updateDOM())
                        }
                        ) : this._pos = this._pos.round(),
                        i._requestDomTask( () => {
                            this._map && (this._element && this._pos && this._anchor && this._updateDOM(),
                            (i._showingGlobe() || i.getTerrain() || i.getFog()) && !this._fadeTimer && (this._fadeTimer = window.setTimeout(this._evaluateOpacity.bind(this), 60)))
                        }
                        ))
                    }
                    getOffset() {
                        return this._offset
                    }
                    setOffset(t) {
                        return this._offset = s.P.convert(t),
                        this._update(),
                        this
                    }
                    addClassName(t) {
                        return this._element.classList.add(t),
                        this
                    }
                    removeClassName(t) {
                        return this._element.classList.remove(t),
                        this
                    }
                    toggleClassName(t) {
                        return this._element.classList.toggle(t)
                    }
                    _onMove(t) {
                        const i = this._map;
                        if (!i)
                            return;
                        const h = this._pointerdownPos
                          , d = this._positionDelta;
                        if (h && d) {
                            if (!this._isDragging) {
                                const m = this._clickTolerance || i._clickTolerance;
                                if (t.point.dist(h) < m)
                                    return;
                                this._isDragging = !0
                            }
                            this._pos = t.point.sub(d),
                            this._lngLat = i.unproject(this._pos),
                            this.setLngLat(this._lngLat),
                            this._element.style.pointerEvents = "none",
                            "pending" === this._state && (this._state = "active",
                            this.fire(new s.z("dragstart"))),
                            this.fire(new s.z("drag"))
                        }
                    }
                    _onUp() {
                        this._element.style.pointerEvents = "auto",
                        this._positionDelta = null,
                        this._pointerdownPos = null,
                        this._isDragging = !1;
                        const t = this._map;
                        t && (t.off("mousemove", this._onMove),
                        t.off("touchmove", this._onMove)),
                        "active" === this._state && this.fire(new s.z("dragend")),
                        this._state = "inactive"
                    }
                    _addDragHandler(t) {
                        const i = this._map
                          , h = this._pos;
                        i && h && this._element.contains(t.originalEvent.target) && (t.preventDefault(),
                        this._positionDelta = t.point.sub(h),
                        this._pointerdownPos = t.point,
                        this._state = "pending",
                        i.on("mousemove", this._onMove),
                        i.on("touchmove", this._onMove),
                        i.once("mouseup", this._onUp),
                        i.once("touchend", this._onUp))
                    }
                    setDraggable(t) {
                        this._draggable = !!t;
                        const i = this._map;
                        return i && (t ? (i.on("mousedown", this._addDragHandler),
                        i.on("touchstart", this._addDragHandler)) : (i.off("mousedown", this._addDragHandler),
                        i.off("touchstart", this._addDragHandler))),
                        this
                    }
                    isDraggable() {
                        return this._draggable
                    }
                    setRotation(t) {
                        return this._rotation = t || 0,
                        this._update(),
                        this
                    }
                    getRotation() {
                        return this._rotation
                    }
                    setRotationAlignment(t) {
                        return this._rotationAlignment = t || "auto",
                        this._update(),
                        this
                    }
                    getRotationAlignment() {
                        return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment
                    }
                    setPitchAlignment(t) {
                        return this._pitchAlignment = t || "auto",
                        this._update(),
                        this
                    }
                    getPitchAlignment() {
                        return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment
                    }
                    setOccludedOpacity(t) {
                        return this._occludedOpacity = t || .2,
                        this._update(),
                        this
                    }
                    getOccludedOpacity() {
                        return this._occludedOpacity
                    }
                }
                const ks = {
                    positionOptions: {
                        enableHighAccuracy: !1,
                        maximumAge: 0,
                        timeout: 6e3
                    },
                    fitBoundsOptions: {
                        maxZoom: 15
                    },
                    trackUserLocation: !1,
                    showAccuracyCircle: !0,
                    showUserLocation: !0,
                    showUserHeading: !1
                }
                  , ar = {
                    maxWidth: 100,
                    unit: "metric"
                }
                  , Mr = {
                    kilometer: "km",
                    meter: "m",
                    mile: "mi",
                    foot: "ft",
                    "nautical-mile": "nm"
                }
                  , Gn = {
                    closeButton: !0,
                    closeOnClick: !0,
                    focusAfterOpen: !0,
                    className: "",
                    maxWidth: "240px"
                }
                  , Rp = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
                function un(c=new s.P(0,0), t="bottom") {
                    if ("number" == typeof c) {
                        const i = Math.round(Math.sqrt(.5 * Math.pow(c, 2)));
                        switch (t) {
                        case "top":
                            return new s.P(0,c);
                        case "top-left":
                            return new s.P(i,i);
                        case "top-right":
                            return new s.P(-i,i);
                        case "bottom":
                            return new s.P(0,-c);
                        case "bottom-left":
                            return new s.P(i,-i);
                        case "bottom-right":
                            return new s.P(-i,-i);
                        case "left":
                            return new s.P(c,0);
                        case "right":
                            return new s.P(-c,0)
                        }
                        return new s.P(0,0)
                    }
                    return c instanceof s.P || Array.isArray(c) ? s.P.convert(c) : s.P.convert(c[t] || [0, 0])
                }
                return {
                    version: so,
                    supported: Tt.supported,
                    setRTLTextPlugin: s.dK,
                    getRTLTextPluginStatus: s.dL,
                    Map: class extends Ip {
                        constructor(c) {
                            _t.mark(Wt.create);
                            const t = c;
                            if (null != (c = s.l({}, Mi, c)).minZoom && null != c.maxZoom && c.minZoom > c.maxZoom)
                                throw new Error("maxZoom must be greater than or equal to minZoom");
                            if (null != c.minPitch && null != c.maxPitch && c.minPitch > c.maxPitch)
                                throw new Error("maxPitch must be greater than or equal to minPitch");
                            if (null != c.minPitch && c.minPitch < 0)
                                throw new Error("minPitch must be greater than or equal to 0");
                            if (null != c.maxPitch && c.maxPitch > 85)
                                throw new Error("maxPitch must be less than or equal to 85");
                            if (c.antialias && s.dF(window) && (c.antialias = !1,
                            s.w("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")),
                            super(new sl(c.minZoom,c.maxZoom,c.minPitch,c.maxPitch,c.renderWorldCopies), c),
                            this._repaint = !!c.repaint,
                            this._interactive = c.interactive,
                            this._minTileCacheSize = c.minTileCacheSize,
                            this._maxTileCacheSize = c.maxTileCacheSize,
                            this._failIfMajorPerformanceCaveat = c.failIfMajorPerformanceCaveat,
                            this._preserveDrawingBuffer = c.preserveDrawingBuffer,
                            this._antialias = c.antialias,
                            this._trackResize = c.trackResize,
                            this._bearingSnap = c.bearingSnap,
                            this._refreshExpiredTiles = c.refreshExpiredTiles,
                            this._fadeDuration = c.fadeDuration,
                            this._isInitialLoad = !0,
                            this._crossSourceCollisions = c.crossSourceCollisions,
                            this._collectResourceTiming = c.collectResourceTiming,
                            this._language = this._parseLanguage(c.language),
                            this._worldview = c.worldview,
                            this._renderTaskQueue = new kh,
                            this._domRenderTaskQueue = new kh,
                            this._controls = [],
                            this._markers = [],
                            this._popups = [],
                            this._mapId = s.aV(),
                            this._locale = s.l({}, jr, c.locale),
                            this._clickTolerance = c.clickTolerance,
                            this._cooperativeGestures = c.cooperativeGestures,
                            this._performanceMetricsCollection = c.performanceMetricsCollection,
                            this._tessellationStep = c.tessellationStep,
                            this._containerWidth = 0,
                            this._containerHeight = 0,
                            this._showParseStatus = !0,
                            this._precompilePrograms = c.precompilePrograms,
                            this._scaleFactorChanged = !1,
                            this._averageElevationLastSampledAt = -1 / 0,
                            this._averageElevationExaggeration = 0,
                            this._averageElevation = new Gr(0),
                            this._interactionRange = [1 / 0, -1 / 0],
                            this._visibilityHidden = 0,
                            this._useExplicitProjection = !1,
                            this._frameId = 0,
                            this._scaleFactor = c.scaleFactor,
                            this._requestManager = new yt(c.transformRequest,c.accessToken,c.testMode),
                            this._silenceAuthErrors = !!c.testMode,
                            this._contextCreateOptions = c.contextCreateOptions ? {
                                ...c.contextCreateOptions
                            } : {},
                            "string" == typeof c.container) {
                                const i = document.getElementById(c.container);
                                if (!i)
                                    throw new Error("Container '".concat(c.container.toString(), "' not found."));
                                this._container = i
                            } else {
                                if (!(c.container instanceof HTMLElement))
                                    throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                                this._container = c.container
                            }
                            if (this._container.childNodes.length > 0 && s.w("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."),
                            c.maxBounds && this.setMaxBounds(c.maxBounds),
                            this._spriteFormat = c.spriteFormat,
                            s.aP(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this),
                            this._setupContainer(),
                            this._tp || (this._tp = new Th),
                            this._tp.registerParameter(this, ["Debug"], "showOverdrawInspector"),
                            this._tp.registerParameter(this, ["Debug"], "showTileBoundaries"),
                            this._tp.registerParameter(this, ["Debug"], "showParseStatus"),
                            this._tp.registerParameter(this, ["Debug"], "repaint"),
                            this._tp.registerParameter(this, ["Debug"], "showTileAABBs"),
                            this._tp.registerParameter(this, ["Debug"], "showPadding"),
                            this._tp.registerParameter(this, ["Debug"], "showCollisionBoxes", {
                                noSave: !0
                            }),
                            this._tp.registerParameter(this.transform, ["Debug"], "freezeTileCoverage", {
                                noSave: !0
                            }, () => {
                                this._update()
                            }
                            ),
                            this._tp.registerParameter(this, ["Debug", "Wireframe"], "showTerrainWireframe"),
                            this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers2DWireframe"),
                            this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers3DWireframe"),
                            this._tp.registerParameter(this, ["Scaling"], "_scaleFactor", {
                                min: .1,
                                max: 10,
                                step: .1
                            }, () => {
                                this.setScaleFactor(this._scaleFactor)
                            }
                            ),
                            this._setupPainter(),
                            void 0 === this.painter)
                                throw new Error("Failed to initialize WebGL.");
                            if (this.on("move", () => this._update(!1)),
                            this.on("moveend", () => this._update(!1)),
                            this.on("zoom", () => this._update(!0)),
                            this._fullscreenchangeEvent = "onfullscreenchange"in document ? "fullscreenchange" : "webkitfullscreenchange",
                            window.addEventListener("online", this._onWindowOnline, !1),
                            window.addEventListener("resize", this._onWindowResize, !1),
                            window.addEventListener("orientationchange", this._onWindowResize, !1),
                            window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1),
                            window.addEventListener("visibilitychange", this._onVisibilityChange, !1),
                            this.handlers = new sr(this,c),
                            this._localFontFamily = c.localFontFamily,
                            this._localIdeographFontFamily = c.localIdeographFontFamily,
                            (c.style || !c.testMode) && this.setStyle(c.style || s.e.DEFAULT_STYLE, {
                                config: c.config,
                                localFontFamily: this._localFontFamily,
                                localIdeographFontFamily: this._localIdeographFontFamily
                            }),
                            c.projection && this.setProjection(c.projection),
                            this.indoor = new au(this),
                            c.hash && (this._hash = new Su("string" == typeof c.hash && c.hash || void 0).addTo(this)),
                            !this._hash || !this._hash._onHashChange()) {
                                null == t.center && null == t.zoom || (this.transform._unmodified = !1),
                                this.jumpTo({
                                    center: c.center,
                                    zoom: c.zoom,
                                    bearing: c.bearing,
                                    pitch: c.pitch
                                });
                                const i = c.bounds;
                                i && (this.resize(),
                                this.fitBounds(i, s.l({}, c.fitBoundsOptions, {
                                    duration: 0
                                })))
                            }
                            this.resize(),
                            c.attributionControl && this.addControl(new Ap({
                                customAttribution: c.customAttribution
                            })),
                            this._logoControl = new Na,
                            this.addControl(this._logoControl, c.logoPosition),
                            this.on("style.load", () => {
                                this.transform.unmodified && this.jumpTo(this.style.stylesheet),
                                this._postStyleLoadEvent()
                            }
                            ),
                            this.on("data", i => {
                                this._update("style" === i.dataType),
                                this.fire(new s.z("".concat(i.dataType, "data"),i))
                            }
                            ),
                            this.on("dataloading", i => {
                                this.fire(new s.z("".concat(i.dataType, "dataloading"),i))
                            }
                            ),
                            this._interactions = new Il(this)
                        }
                        _getMapId() {
                            return this._mapId
                        }
                        addControl(c, t) {
                            if (void 0 === t && (t = c.getDefaultPosition ? c.getDefaultPosition() : "top-right"),
                            !c || !c.onAdd)
                                return this.fire(new s.y(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
                            const i = c.onAdd(this);
                            this._controls.push(c);
                            const h = this._controlPositions[t];
                            return -1 !== t.indexOf("bottom") ? h.insertBefore(i, h.firstChild) : h.appendChild(i),
                            this
                        }
                        removeControl(c) {
                            if (!c || !c.onRemove)
                                return this.fire(new s.y(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
                            const t = this._controls.indexOf(c);
                            return t > -1 && this._controls.splice(t, 1),
                            c.onRemove(this),
                            this
                        }
                        hasControl(c) {
                            return this._controls.indexOf(c) > -1
                        }
                        getContainer() {
                            return this._container
                        }
                        getCanvasContainer() {
                            return this._canvasContainer
                        }
                        getCanvas() {
                            return this._canvas
                        }
                        resize(c) {
                            if (this._updateContainerDimensions(),
                            this._containerWidth === this.transform.width && this._containerHeight === this.transform.height)
                                return this;
                            this._resizeCanvas(this._containerWidth, this._containerHeight),
                            this.transform.resize(this._containerWidth, this._containerHeight),
                            this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
                            const t = !this._moving;
                            return t && this.fire(new s.z("movestart",c)).fire(new s.z("move",c)),
                            this.fire(new s.z("resize",c)),
                            t && this.fire(new s.z("moveend",c)),
                            this
                        }
                        getBounds() {
                            return this.transform.getBounds()
                        }
                        getMaxBounds() {
                            return this.transform.getMaxBounds() || null
                        }
                        setMaxBounds(c) {
                            return this.transform.setMaxBounds(s.az.convert(c)),
                            this._update()
                        }
                        setMinZoom(c) {
                            if ((c = null != c ? c : -2) >= -2 && c <= this.transform.maxZoom)
                                return this.transform.minZoom = c,
                                this._update(),
                                this.getZoom() < c ? this.setZoom(c) : this.fire(new s.z("zoomstart")).fire(new s.z("zoom")).fire(new s.z("zoomend")),
                                this;
                            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")
                        }
                        getMinZoom() {
                            return this.transform.minZoom
                        }
                        setMaxZoom(c) {
                            if ((c = null != c ? c : 22) >= this.transform.minZoom)
                                return this.transform.maxZoom = c,
                                this._update(),
                                this.getZoom() > c ? this.setZoom(c) : this.fire(new s.z("zoomstart")).fire(new s.z("zoom")).fire(new s.z("zoomend")),
                                this;
                            throw new Error("maxZoom must be greater than the current minZoom")
                        }
                        getMaxZoom() {
                            return this.transform.maxZoom
                        }
                        setMinPitch(c) {
                            if ((c = null != c ? c : 0) < 0)
                                throw new Error("minPitch must be greater than or equal to 0");
                            if (c >= 0 && c <= this.transform.maxPitch)
                                return this.transform.minPitch = c,
                                this._update(),
                                this.getPitch() < c ? this.setPitch(c) : this.fire(new s.z("pitchstart")).fire(new s.z("pitch")).fire(new s.z("pitchend")),
                                this;
                            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
                        }
                        getMinPitch() {
                            return this.transform.minPitch
                        }
                        setMaxPitch(c) {
                            if ((c = null != c ? c : 85) > 85)
                                throw new Error("maxPitch must be less than or equal to 85");
                            if (c >= this.transform.minPitch)
                                return this.transform.maxPitch = c,
                                this._update(),
                                this.getPitch() > c ? this.setPitch(c) : this.fire(new s.z("pitchstart")).fire(new s.z("pitch")).fire(new s.z("pitchend")),
                                this;
                            throw new Error("maxPitch must be greater than or equal to minPitch")
                        }
                        getMaxPitch() {
                            return this.transform.maxPitch
                        }
                        getScaleFactor() {
                            return this._scaleFactor
                        }
                        setScaleFactor(c) {
                            return this._scaleFactor = c,
                            this.painter.scaleFactor = c,
                            this._tp.refreshUI(),
                            this._scaleFactorChanged = !0,
                            this.style._updateFilteredLayers(t => "symbol" === t.type),
                            this._update(!0),
                            this
                        }
                        getRenderWorldCopies() {
                            return this.transform.renderWorldCopies
                        }
                        setRenderWorldCopies(c) {
                            return this.transform.renderWorldCopies = c,
                            this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0),
                            this._update()
                        }
                        getLanguage() {
                            return this._language
                        }
                        _parseLanguage(c) {
                            return "auto" === c ? navigator.language : Array.isArray(c) ? 0 === c.length ? void 0 : c.map(t => "auto" === t ? navigator.language : t) : c
                        }
                        setLanguage(c) {
                            const t = this._parseLanguage(c);
                            if (!this.style || t === this._language)
                                return this;
                            this._language = t,
                            this.style.reloadSources();
                            for (const i of this._controls)
                                i._setLanguage && i._setLanguage(this._language);
                            return this
                        }
                        getWorldview() {
                            return this._worldview
                        }
                        setWorldview(c) {
                            return this.style && c !== this._worldview ? (this._worldview = c,
                            this.style.reloadSources(),
                            this) : this
                        }
                        getProjection() {
                            return this.transform.mercatorFromTransition ? {
                                name: "globe",
                                center: [0, 0]
                            } : this.transform.getProjection()
                        }
                        _showingGlobe() {
                            return "globe" === this.transform.projection.name
                        }
                        setProjection(c) {
                            return this._lazyInitEmptyStyle(),
                            c ? "string" == typeof c && (c = {
                                name: c
                            }) : c = null,
                            this._useExplicitProjection = !!c,
                            this._prioritizeAndUpdateProjection(c, this.style.projection)
                        }
                        _updateProjectionTransition() {
                            if ("globe" !== this.getProjection().name)
                                return;
                            const c = this.transform
                              , t = c.projection.name;
                            let i;
                            "globe" === t && c.zoom >= s.bY ? (c.setMercatorFromTransition(),
                            i = !0) : "mercator" === t && c.zoom < s.bY && (c.setProjection({
                                name: "globe"
                            }),
                            i = !0),
                            i && (this.style.applyProjectionUpdate(),
                            this.style._forceSymbolLayerUpdate())
                        }
                        _prioritizeAndUpdateProjection(c, t) {
                            return this._updateProjection(c || t || {
                                name: "mercator"
                            })
                        }
                        _updateProjection(c) {
                            let t;
                            return t = "globe" === c.name && this.transform.zoom >= s.bY ? this.transform.setMercatorFromTransition() : this.transform.setProjection(c),
                            this.style.applyProjectionUpdate(),
                            t && (this.painter.clearBackgroundTiles(),
                            this.style.clearSources(),
                            this._update(!0),
                            this._forceMarkerAndPopupUpdate(!0)),
                            this
                        }
                        project(c) {
                            return this.transform.locationPoint3D(s.bO.convert(c))
                        }
                        unproject(c) {
                            return this.transform.pointLocation3D(s.P.convert(c))
                        }
                        isMoving() {
                            return this._moving || this.handlers && this.handlers.isMoving() || !1
                        }
                        isZooming() {
                            return this._zooming || this.handlers && this.handlers.isZooming() || !1
                        }
                        isRotating() {
                            return this._rotating || this.handlers && this.handlers.isRotating() || !1
                        }
                        _isDragging() {
                            return this.handlers && this.handlers._isDragging() || !1
                        }
                        _createDelegatedListener(c, t, i) {
                            const h = d => {
                                let m = [];
                                if (Array.isArray(t)) {
                                    const y = t.filter(M => this.getLayer(M));
                                    m = y.length ? this.queryRenderedFeatures(d, {
                                        layers: y
                                    }) : []
                                } else
                                    m = this.queryRenderedFeatures(d, {
                                        target: t
                                    });
                                return m
                            }
                            ;
                            if ("mouseenter" === c || "mouseover" === c) {
                                let d = !1;
                                return {
                                    listener: i,
                                    targets: t,
                                    delegates: {
                                        mousemove: y => {
                                            const M = h(y.point);
                                            M.length ? d || (d = !0,
                                            i.call(this, new Pr(c,this,y.originalEvent,{
                                                features: M
                                            }))) : d = !1
                                        }
                                        ,
                                        mouseout: () => {
                                            d = !1
                                        }
                                    }
                                }
                            }
                            if ("mouseleave" === c || "mouseout" === c) {
                                let d = !1;
                                return {
                                    listener: i,
                                    targets: t,
                                    delegates: {
                                        mousemove: M => {
                                            h(M.point).length ? d = !0 : d && (d = !1,
                                            i.call(this, new Pr(c,this,M.originalEvent)))
                                        }
                                        ,
                                        mouseout: M => {
                                            d && (d = !1,
                                            i.call(this, new Pr(c,this,M.originalEvent)))
                                        }
                                    }
                                }
                            }
                            {
                                const d = m => {
                                    const y = h(m.point);
                                    y.length && (m.features = y,
                                    i.call(this, m),
                                    delete m.features)
                                }
                                ;
                                return {
                                    listener: i,
                                    targets: t,
                                    delegates: {
                                        [c]: d
                                    }
                                }
                            }
                        }
                        on(c, t, i) {
                            if ("function" == typeof t || void 0 === i)
                                return super.on(c, t);
                            if ("string" == typeof t && (t = [t]),
                            !this._areTargetsValid(t))
                                return this;
                            const h = this._createDelegatedListener(c, t, i);
                            this._delegatedListeners = this._delegatedListeners || {},
                            this._delegatedListeners[c] = this._delegatedListeners[c] || [],
                            this._delegatedListeners[c].push(h);
                            for (const d in h.delegates)
                                this.on(d, h.delegates[d]);
                            return this
                        }
                        once(c, t, i) {
                            if ("function" == typeof t || void 0 === i)
                                return super.once(c, t);
                            if ("string" == typeof t && (t = [t]),
                            !this._areTargetsValid(t))
                                return this;
                            const h = this._createDelegatedListener(c, t, i);
                            for (const d in h.delegates)
                                this.once(d, h.delegates[d]);
                            return this
                        }
                        off(c, t, i) {
                            if ("function" == typeof t || void 0 === i)
                                return super.off(c, t);
                            if ("string" == typeof t && (t = [t]),
                            !this._areTargetsValid(t))
                                return this;
                            const h = this._delegatedListeners ? this._delegatedListeners[c] : void 0;
                            return h && (d => {
                                for (let m = 0; m < d.length; m++) {
                                    const y = d[m];
                                    if (y.listener === i && Du(y.targets, t)) {
                                        for (const M in y.delegates)
                                            this.off(M, y.delegates[M]);
                                        return d.splice(m, 1),
                                        this
                                    }
                                }
                            }
                            )(h),
                            this
                        }
                        queryRenderedFeatures(c, t) {
                            if (!this.style)
                                return [];
                            if (void 0 === c || c instanceof s.P || Array.isArray(c) || void 0 !== t || (t = c,
                            c = void 0),
                            c = c || [[0, 0], [this.transform.width, this.transform.height]],
                            !t) {
                                const m = this.style.queryRenderedFeatures(c, void 0, this.transform)
                                  , y = this.style.queryRenderedFeatureset(c, void 0, this.transform);
                                return m.concat(y)
                            }
                            let i = !0;
                            if (t.target && (i = this._isTargetValid(t.target),
                            i && !t.layers))
                                return this.style.queryRenderedFeatureset(c, t, this.transform);
                            let h = !0;
                            if (t.layers && Array.isArray(t.layers)) {
                                for (const m of t.layers)
                                    if (!this._isValidId(m)) {
                                        h = !1;
                                        break
                                    }
                                if (h && !t.target)
                                    return this.style.queryRenderedFeatures(c, t, this.transform)
                            }
                            let d = [];
                            return h && (d = d.concat(this.style.queryRenderedFeatures(c, t, this.transform))),
                            i && (d = d.concat(this.style.queryRenderedFeatureset(c, t, this.transform))),
                            d
                        }
                        querySourceFeatures(c, t) {
                            return !c || "string" == typeof c && !this._isValidId(c) ? [] : this.style.querySourceFeatures(c, t)
                        }
                        isPointOnSurface(c) {
                            const {name: t} = this.transform.projection;
                            return "globe" !== t && "mercator" !== t && s.w("".concat(t, " projection does not support isPointOnSurface, this API may behave unexpectedly.")),
                            this.transform.isPointOnSurface(s.P.convert(c))
                        }
                        addInteraction(c, t) {
                            return this._interactions.add(c, t),
                            this
                        }
                        removeInteraction(c) {
                            return this._interactions.remove(c),
                            this
                        }
                        setStyle(c, t) {
                            return t = s.l({}, {
                                localIdeographFontFamily: this._localIdeographFontFamily,
                                localFontFamily: this._localFontFamily
                            }, t),
                            this.style && c && !1 !== t.diff && t.localFontFamily === this._localFontFamily && t.localIdeographFontFamily === this._localIdeographFontFamily && !t.config ? (this.style._diffStyle(c, (i, h) => {
                                i ? (s.w("Unable to perform style diff: ".concat(String(i.message || i.error || i), ". Rebuilding the style from scratch.")),
                                this._updateStyle(c, t)) : h && this._update(!0)
                            }
                            , () => {
                                this._postStyleLoadEvent()
                            }
                            ),
                            this) : (this._localIdeographFontFamily = t.localIdeographFontFamily,
                            this._localFontFamily = t.localFontFamily,
                            this._updateStyle(c, t))
                        }
                        _getUIString(c) {
                            const t = this._locale[c];
                            if (null == t)
                                throw new Error("Missing UI string '".concat(c, "'"));
                            return t
                        }
                        _updateStyle(c, t) {
                            if (this.style && (this.style.setEventedParent(null),
                            this.style._remove(),
                            this.style = void 0),
                            c) {
                                const i = s.l({}, t);
                                t && t.config && (i.initialConfig = t.config,
                                delete i.config),
                                this.style = new pr(this,i).load(c),
                                this.style.setEventedParent(this, {
                                    style: this.style
                                })
                            }
                            return this._updateTerrain(),
                            this
                        }
                        _lazyInitEmptyStyle() {
                            this.style || (this.style = new pr(this,{}),
                            this.style.setEventedParent(this, {
                                style: this.style
                            }),
                            this.style.loadEmpty())
                        }
                        getStyle() {
                            if (this.style)
                                return this.style.serialize()
                        }
                        isStyleLoaded() {
                            return this.style ? this.style.loaded() : (s.w("There is no style added to the map."),
                            !1)
                        }
                        _isValidId(c) {
                            return null == c ? (this.fire(new s.y(new Error("IDs can't be empty."))),
                            !1) : !s.cr(c) || (this.fire(new s.y(new Error("IDs can't contain special symbols: \"".concat(c, '".')))),
                            !1)
                        }
                        _isTargetValid(c) {
                            return "featuresetId"in c ? this._isValidId("importId"in c ? c.importId : c.featuresetId) : "layerId"in c && this._isValidId(c.layerId)
                        }
                        _areTargetsValid(c) {
                            if (Array.isArray(c)) {
                                for (const t of c)
                                    if (!this._isValidId(t))
                                        return !1;
                                return !0
                            }
                            return this._isTargetValid(c)
                        }
                        addSource(c, t) {
                            return this._isValidId(c) ? (this._lazyInitEmptyStyle(),
                            this.style.addSource(c, t),
                            this._update(!0)) : this
                        }
                        isSourceLoaded(c) {
                            return !!this._isValidId(c) && !!this.style && this.style._isSourceCacheLoaded(c)
                        }
                        areTilesLoaded() {
                            return this.style.areTilesLoaded()
                        }
                        addSourceType(c, t, i) {
                            this._lazyInitEmptyStyle(),
                            this.style.addSourceType(c, t, i)
                        }
                        removeSource(c) {
                            return this._isValidId(c) ? (this.style.removeSource(c),
                            this._updateTerrain(),
                            this._update(!0)) : this
                        }
                        getSource(c) {
                            return this._isValidId(c) ? this.style.getOwnSource(c) : null
                        }
                        addImage(c, t, {pixelRatio: i=1, sdf: h=!1, stretchX: d, stretchY: m, content: y}={}) {
                            if (this._lazyInitEmptyStyle(),
                            t instanceof HTMLImageElement || ImageBitmap && t instanceof ImageBitmap) {
                                const {width: M, height: E, data: S} = s.q.getImageData(t);
                                this.style.addImage(c, {
                                    data: new s.r({
                                        width: M,
                                        height: E
                                    },S),
                                    pixelRatio: i,
                                    stretchX: d,
                                    stretchY: m,
                                    content: y,
                                    sdf: h,
                                    version: 0,
                                    usvg: !1
                                })
                            } else if (void 0 === t.width || void 0 === t.height)
                                this.fire(new s.y(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                            else {
                                const {width: M, height: E} = t
                                  , S = t;
                                this.style.addImage(c, {
                                    data: new s.r({
                                        width: M,
                                        height: E
                                    },new Uint8Array(S.data)),
                                    pixelRatio: i,
                                    stretchX: d,
                                    stretchY: m,
                                    content: y,
                                    sdf: h,
                                    usvg: !1,
                                    version: 0,
                                    userImage: S
                                }),
                                S.onAdd && S.onAdd(this, c)
                            }
                        }
                        updateImage(c, t) {
                            this._lazyInitEmptyStyle();
                            const i = this.style.getImage(c);
                            if (!i)
                                return void this.fire(new s.y(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
                            const h = t instanceof HTMLImageElement || ImageBitmap && t instanceof ImageBitmap ? s.q.getImageData(t) : t
                              , {width: d, height: m, data: y} = h;
                            if (void 0 === d || void 0 === m)
                                return void this.fire(new s.y(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                            if (d !== (i.usvg ? i.icon.usvg_tree.width : i.data.width) || m !== (i.usvg ? i.icon.usvg_tree.height : i.data.height))
                                return void this.fire(new s.y(new Error("The width and height of the updated image (".concat(d, ", ").concat(m, ")\n                must be that same as the previous version of the image\n                (").concat(i.data.width, ", ").concat(i.data.height, ")"))));
                            const M = !(t instanceof HTMLImageElement || ImageBitmap && t instanceof ImageBitmap);
                            let E = !1;
                            i.usvg ? (i.data = new s.r({
                                width: d,
                                height: m
                            },new Uint8Array(y)),
                            i.usvg = !1,
                            i.icon = void 0,
                            E = !0) : i.data.replace(y, M),
                            this.style.updateImage(c, i, E)
                        }
                        hasImage(c) {
                            return c ? !!this.style && !!this.style.getImage(c) : (this.fire(new s.y(new Error("Missing required image id"))),
                            !1)
                        }
                        removeImage(c) {
                            this.style.removeImage(c)
                        }
                        loadImage(c, t) {
                            s.o(this._requestManager.transformRequest(c, s.R.Image), (i, h) => {
                                t(i, h instanceof HTMLImageElement ? s.q.getImageData(h) : h)
                            }
                            )
                        }
                        listImages() {
                            return this.style.listImages()
                        }
                        addModel(c, t) {
                            this._lazyInitEmptyStyle(),
                            this.style.addModel(c, t)
                        }
                        hasModel(c) {
                            return c ? this.style.hasModel(c) : (this.fire(new s.y(new Error("Missing required model id"))),
                            !1)
                        }
                        removeModel(c) {
                            this.style.removeModel(c)
                        }
                        listModels() {
                            return this.style.listModels()
                        }
                        addLayer(c, t) {
                            return this._isValidId(c.id) ? (this._lazyInitEmptyStyle(),
                            this.style.addLayer(c, t),
                            this._update(!0)) : this
                        }
                        getSlot(c) {
                            const t = this.getLayer(c);
                            return t && t.slot || null
                        }
                        setSlot(c, t) {
                            return this.style.setSlot(c, t),
                            this.style.mergeLayers(),
                            this._update(!0)
                        }
                        addImport(c, t) {
                            return this.style.addImport(c, t),
                            this
                        }
                        updateImport(c, t) {
                            return "string" != typeof t && t.id !== c ? (this.removeImport(c),
                            this.addImport(t)) : (this.style.updateImport(c, t),
                            this._update(!0))
                        }
                        removeImport(c) {
                            return this.style.removeImport(c),
                            this
                        }
                        moveImport(c, t) {
                            return this.style.moveImport(c, t),
                            this._update(!0)
                        }
                        moveLayer(c, t) {
                            return this._isValidId(c) ? (this.style.moveLayer(c, t),
                            this._update(!0)) : this
                        }
                        removeLayer(c) {
                            return this._isValidId(c) ? (this.style.removeLayer(c),
                            this._update(!0)) : this
                        }
                        getLayer(c) {
                            if (!this._isValidId(c))
                                return null;
                            const t = this.style.getOwnLayer(c);
                            return t ? "custom" === t.type ? t.implementation : t.serialize() : void 0
                        }
                        getSlots() {
                            return this.style.getSlots()
                        }
                        setLayerZoomRange(c, t, i) {
                            return this._isValidId(c) ? (this.style.setLayerZoomRange(c, t, i),
                            this._update(!0)) : this
                        }
                        setFilter(c, t, i={}) {
                            return this._isValidId(c) ? (this.style.setFilter(c, t, i),
                            this._update(!0)) : this
                        }
                        getFilter(c) {
                            return this._isValidId(c) ? this.style.getFilter(c) : null
                        }
                        setPaintProperty(c, t, i, h={}) {
                            return this._isValidId(c) ? (this.style.setPaintProperty(c, t, i, h),
                            this._update(!0)) : this
                        }
                        getPaintProperty(c, t) {
                            return this._isValidId(c) ? this.style.getPaintProperty(c, t) : null
                        }
                        setLayoutProperty(c, t, i, h={}) {
                            return this._isValidId(c) ? (this.style.setLayoutProperty(c, t, i, h),
                            this._update(!0)) : this
                        }
                        getLayoutProperty(c, t) {
                            return this._isValidId(c) ? this.style.getLayoutProperty(c, t) : null
                        }
                        getSchema(c) {
                            return this.style.getSchema(c)
                        }
                        setSchema(c, t) {
                            return this.style.setSchema(c, t),
                            this._update(!0)
                        }
                        getConfig(c) {
                            return this.style.getConfig(c)
                        }
                        setConfig(c, t) {
                            return this.style.setConfig(c, t),
                            this._update(!0)
                        }
                        getConfigProperty(c, t) {
                            return this.style.getConfigProperty(c, t)
                        }
                        setConfigProperty(c, t, i) {
                            return this.style.setConfigProperty(c, t, i),
                            this._update(!0)
                        }
                        getFeaturesetDescriptors(c) {
                            return this.style.getFeaturesetDescriptors(c)
                        }
                        setLights(c) {
                            if (this._lazyInitEmptyStyle(),
                            c && 1 === c.length && "flat" === c[0].type) {
                                const t = c[0];
                                t.properties ? this.style.setFlatLight(t.properties, t.id, {}) : this.style.setFlatLight({}, "flat")
                            } else
                                this.style.setLights(c),
                                this.painter.terrain && (this.painter.terrain.invalidateRenderCache = !0);
                            return this._update(!0)
                        }
                        getLights() {
                            const c = this.style.getLights() || [];
                            return 0 === c.length && c.push({
                                id: this.style.light.id,
                                type: "flat",
                                properties: this.style.getFlatLight()
                            }),
                            c
                        }
                        setLight(c, t={}) {
                            return console.log("The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead."),
                            this.setLights([{
                                id: "flat",
                                type: "flat",
                                properties: c
                            }])
                        }
                        getLight() {
                            return console.log("The `map.getLight` function is deprecated, prefer using `map.getLights` instead."),
                            this.style.getFlatLight()
                        }
                        setTerrain(c) {
                            return this._lazyInitEmptyStyle(),
                            !c && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(c),
                            this._averageElevationLastSampledAt = -1 / 0,
                            this._update(!0)
                        }
                        getTerrain() {
                            return this.style ? this.style.getTerrain() : null
                        }
                        setFog(c) {
                            return this._lazyInitEmptyStyle(),
                            this.style.setFog(c),
                            this._update(!0)
                        }
                        getFog() {
                            return this.style ? this.style.getFog() : null
                        }
                        setSnow(c) {
                            return this._lazyInitEmptyStyle(),
                            this.style.setSnow(c),
                            this._update(!0)
                        }
                        getSnow() {
                            return this.style ? this.style.getSnow() : null
                        }
                        setRain(c) {
                            return this._lazyInitEmptyStyle(),
                            this.style.setRain(c),
                            this._update(!0)
                        }
                        getRain() {
                            return this.style ? this.style.getRain() : null
                        }
                        setColorTheme(c) {
                            return this._lazyInitEmptyStyle(),
                            this.style.setColorTheme(c),
                            this._update(!0)
                        }
                        setImportColorTheme(c, t) {
                            return this._lazyInitEmptyStyle(),
                            this.style.setImportColorTheme(c, t),
                            this._update(!0)
                        }
                        setCamera(c) {
                            return this.style.setCamera(c),
                            this._triggerCameraUpdate(c)
                        }
                        _triggerCameraUpdate(c) {
                            return this._update(this.transform.setOrthographicProjectionAtLowPitch("orthographic" === c["camera-projection"]))
                        }
                        getCamera() {
                            return this.style.camera
                        }
                        _queryFogOpacity(c) {
                            return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(s.bO.convert(c), this.transform) : 0
                        }
                        setFeatureState(c, t) {
                            return c.source && !this._isValidId(c.source) ? this : (this.style.setFeatureState(c, t),
                            this._update())
                        }
                        removeFeatureState(c, t) {
                            return c.source && !this._isValidId(c.source) ? this : (this.style.removeFeatureState(c, t),
                            this._update())
                        }
                        getFeatureState(c) {
                            return c.source && !this._isValidId(c.source) ? null : this.style.getFeatureState(c)
                        }
                        _updateContainerDimensions() {
                            if (!this._container)
                                return;
                            const c = this._container.getBoundingClientRect().width || 400
                              , t = this._container.getBoundingClientRect().height || 300;
                            let i, h, d, m = this._container;
                            for (; m && (!h || !d); ) {
                                const y = window.getComputedStyle(m).transform;
                                y && "none" !== y && (i = y.match(/matrix.*\((.+)\)/)[1].split(", "),
                                i[0] && "0" !== i[0] && "1" !== i[0] && (h = i[0]),
                                i[3] && "0" !== i[3] && "1" !== i[3] && (d = i[3])),
                                m = m.parentElement
                            }
                            this._containerWidth = h ? Math.abs(c / h) : c,
                            this._containerHeight = d ? Math.abs(t / d) : t
                        }
                        _detectMissingCSS() {
                            "rgb(250, 128, 114)" !== window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && s.w("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.")
                        }
                        _setupContainer() {
                            const c = this._container;
                            c.classList.add("mapboxgl-map"),
                            (this._missingCSSCanary = Qe("div", "mapboxgl-canary", c)).style.visibility = "hidden",
                            this._detectMissingCSS();
                            const t = this._canvasContainer = Qe("div", "mapboxgl-canvas-container", c);
                            this._canvas = Qe("canvas", "mapboxgl-canvas", t),
                            this._interactive && (t.classList.add("mapboxgl-interactive"),
                            this._canvas.setAttribute("tabindex", "0")),
                            this._canvas.addEventListener("webglcontextlost", this._contextLost, !1),
                            this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1),
                            this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")),
                            this._canvas.setAttribute("role", "region"),
                            this._updateContainerDimensions(),
                            this._resizeCanvas(this._containerWidth, this._containerHeight);
                            const i = this._controlContainer = Qe("div", "mapboxgl-control-container", c)
                              , h = this._controlPositions = {};
                            ["top-left", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left"].forEach(d => {
                                h[d] = Qe("div", "mapboxgl-ctrl-".concat(d), i)
                            }
                            ),
                            this._container.addEventListener("scroll", this._onMapScroll, !1)
                        }
                        _resizeCanvas(c, t) {
                            const i = s.q.devicePixelRatio || 1;
                            this._canvas.width = i * Math.ceil(c),
                            this._canvas.height = i * Math.ceil(t),
                            this._canvas.style.width = "".concat(c, "px"),
                            this._canvas.style.height = "".concat(t, "px")
                        }
                        _addMarker(c) {
                            this._markers.push(c)
                        }
                        _removeMarker(c) {
                            const t = this._markers.indexOf(c);
                            -1 !== t && this._markers.splice(t, 1)
                        }
                        _addPopup(c) {
                            this._popups.push(c)
                        }
                        _removePopup(c) {
                            const t = this._popups.indexOf(c);
                            -1 !== t && this._popups.splice(t, 1)
                        }
                        _setupPainter() {
                            const c = s.l({}, Tt.supported.webGLContextAttributes, {
                                failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
                                preserveDrawingBuffer: this._preserveDrawingBuffer,
                                antialias: this._antialias || !1
                            })
                              , t = this._canvas.getContext("webgl2", c);
                            t ? (lt(t, !0),
                            this.painter = new Eu(t,this._contextCreateOptions,this.transform,this._scaleFactor,this._tp),
                            this.on("data", i => {
                                "source" === i.dataType && this.painter.setTileLoadedFlag(!0)
                            }
                            ),
                            s.m.testSupport(t)) : this.fire(new s.y(new Error("Failed to initialize WebGL")))
                        }
                        _contextLost(c) {
                            c.preventDefault(),
                            this._frame && (this._frame.cancel(),
                            this._frame = null),
                            this.fire(new s.z("webglcontextlost",{
                                originalEvent: c
                            }))
                        }
                        _contextRestored(c) {
                            this._setupPainter(),
                            this.resize(),
                            this._update(),
                            this.fire(new s.z("webglcontextrestored",{
                                originalEvent: c
                            }))
                        }
                        _onMapScroll(c) {
                            if (c.target === this._container)
                                return this._container.scrollTop = 0,
                                this._container.scrollLeft = 0,
                                !1
                        }
                        idle() {
                            return !this.isMoving() && this.loaded()
                        }
                        loaded() {
                            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
                        }
                        frameReady() {
                            return this.loaded() && !this._placementDirty
                        }
                        _update(c) {
                            return this.style ? (this._styleDirty = this._styleDirty || c,
                            this._sourcesDirty = !0,
                            this.triggerRepaint(),
                            this) : this
                        }
                        _requestRenderFrame(c) {
                            return this._update(),
                            this._renderTaskQueue.add(c)
                        }
                        _cancelRenderFrame(c) {
                            this._renderTaskQueue.remove(c)
                        }
                        _requestDomTask(c) {
                            !this.loaded() || this.loaded() && !this.isMoving() ? c() : this._domRenderTaskQueue.add(c)
                        }
                        _render(c) {
                            let t;
                            this.fire(new s.z("renderstart")),
                            ++this._frameId;
                            const i = this.painter.context.extTimerQuery
                              , h = s.q.now()
                              , d = this.painter.context.gl;
                            if (this.listens("gpu-timing-frame") && (t = d.createQuery(),
                            d.beginQuery(i.TIME_ELAPSED_EXT, t)),
                            this.painter.context.setDirty(),
                            this.painter.setBaseState(),
                            (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()),
                            this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())),
                            this._renderTaskQueue.run(c),
                            this._domRenderTaskQueue.run(c),
                            this._removed)
                                return;
                            this._updateProjectionTransition();
                            const m = this._isInitialLoad ? 0 : this._fadeDuration;
                            if (this.style && this._styleDirty) {
                                this._styleDirty = !1;
                                const S = this.transform.zoom
                                  , I = this.transform.pitch
                                  , R = s.q.now()
                                  , D = new s.a8(S,{
                                    now: R,
                                    fadeDuration: m,
                                    pitch: I,
                                    transition: this.style.transition
                                });
                                this.style.update(D)
                            }
                            this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = !0,
                            this._sourcesDirty = !0);
                            let y = !1;
                            this.style && this._sourcesDirty ? (this._sourcesDirty = !1,
                            this.painter._updateFog(this.style),
                            this._updateTerrain(),
                            y = this._updateAverageElevation(h),
                            this.style.updateSources(this.transform),
                            this._forceMarkerAndPopupUpdate()) : y = this._updateAverageElevation(h);
                            const M = this.style && this.style._updatePlacement(this.painter, this.painter.transform, this.showCollisionBoxes, m, this._crossSourceCollisions, this.painter.replacementSource, this._scaleFactorChanged);
                            if (this._scaleFactorChanged && (this._scaleFactorChanged = !1),
                            M && (this._placementDirty = M.needsRerender),
                            this.style && this.painter.render(this.style, {
                                showTileBoundaries: this.showTileBoundaries,
                                showParseStatus: this.showParseStatus,
                                wireframe: {
                                    terrain: this.showTerrainWireframe,
                                    layers2D: this.showLayers2DWireframe,
                                    layers3D: this.showLayers3DWireframe
                                },
                                showOverdrawInspector: this._showOverdrawInspector,
                                showQueryGeometry: !!this._showQueryGeometry,
                                showTileAABBs: this.showTileAABBs,
                                rotating: this.isRotating(),
                                zooming: this.isZooming(),
                                moving: this.isMoving(),
                                fadeDuration: m,
                                isInitialLoad: this._isInitialLoad,
                                showPadding: this.showPadding,
                                gpuTiming: !!this.listens("gpu-timing-layer"),
                                gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"),
                                speedIndexTiming: this.speedIndexTiming
                            }),
                            this.fire(new s.z("render")),
                            this.loaded() && !this._loaded && (this._loaded = !0,
                            _t.mark(Wt.load),
                            this.fire(new s.z("load"))),
                            this.style && this.style.hasTransitions() && (this._styleDirty = !0),
                            this.style && (this.style.snow || this.style.rain) && (this._styleDirty = !0),
                            this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(),
                            t) {
                                const S = s.q.now() - h;
                                d.endQuery(i.TIME_ELAPSED_EXT),
                                setTimeout( () => {
                                    const I = d.getQueryParameter(t, d.QUERY_RESULT) / 1e6;
                                    d.deleteQuery(t),
                                    this.fire(new s.z("gpu-timing-frame",{
                                        cpuTime: S,
                                        gpuTime: I
                                    }))
                                }
                                , 50)
                            }
                            if (this.listens("gpu-timing-layer")) {
                                const S = this.painter.collectGpuTimers();
                                setTimeout( () => {
                                    const I = this.painter.queryGpuTimers(S);
                                    this.fire(new s.z("gpu-timing-layer",{
                                        layerTimes: I
                                    }))
                                }
                                , 50)
                            }
                            if (this.listens("gpu-timing-deferred-render")) {
                                const S = this.painter.collectDeferredRenderGpuQueries();
                                setTimeout( () => {
                                    const I = this.painter.queryGpuTimeDeferredRender(S);
                                    this.fire(new s.z("gpu-timing-deferred-render",{
                                        gpuTime: I
                                    }))
                                }
                                , 50)
                            }
                            const E = this._sourcesDirty || this._styleDirty || this._placementDirty || y;
                            if (E || this._repaint)
                                this.triggerRepaint();
                            else {
                                const S = this.idle();
                                if (S && (y = this._updateAverageElevation(h, !0)),
                                y)
                                    this.triggerRepaint();
                                else if (this._triggerFrame(!1),
                                S && (this.fire(new s.z("idle")),
                                this._isInitialLoad = !1,
                                this.speedIndexTiming)) {
                                    const I = this._calculateSpeedIndex();
                                    this.fire(new s.z("speedindexcompleted",{
                                        speedIndex: I
                                    })),
                                    this.speedIndexTiming = !1
                                }
                            }
                            !this._loaded || this._fullyLoaded || E || (this._fullyLoaded = !0,
                            _t.mark(Wt.fullLoad),
                            this._performanceMetricsCollection && ve(this._requestManager._customAccessToken, {
                                width: this.painter.width,
                                height: this.painter.height,
                                interactionRange: this._interactionRange,
                                visibilityHidden: this._visibilityHidden,
                                terrainEnabled: !!this.painter.style.getTerrain(),
                                fogEnabled: !!this.painter.style.getFog(),
                                projection: this.getProjection().name,
                                zoom: this.transform.zoom,
                                renderer: this.painter.context.renderer,
                                vendor: this.painter.context.vendor
                            }),
                            this._authenticate())
                        }
                        _forceMarkerAndPopupUpdate(c) {
                            for (const t of this._markers)
                                c && !this.getRenderWorldCopies() && (t._lngLat = t._lngLat.wrap()),
                                t._update();
                            for (const t of this._popups)
                                !c || this.getRenderWorldCopies() || t._trackPointer || (t._lngLat = t._lngLat.wrap()),
                                t._update()
                        }
                        _updateAverageElevation(c, t=!1) {
                            const i = d => (this.transform.averageElevation = d,
                            this._update(!1),
                            !0);
                            if (!this.painter.averageElevationNeedsEasing())
                                return 0 !== this.transform.averageElevation && i(0);
                            const h = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;
                            if (h || (t || c - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(c)) {
                                const d = this.transform.averageElevation;
                                let m = this.transform.sampleAverageElevation();
                                null != this.transform.elevation && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()),
                                isNaN(m) ? m = 0 : this._averageElevationLastSampledAt = c;
                                const y = Math.abs(d - m);
                                if (y > 1) {
                                    if (this._isInitialLoad || h)
                                        return this._averageElevation.jumpTo(m),
                                        i(m);
                                    this._averageElevation.easeTo(m, c, 300)
                                } else if (y > 1e-4)
                                    return this._averageElevation.jumpTo(m),
                                    i(m)
                            }
                            return !!this._averageElevation.isEasing(c) && i(this._averageElevation.getValue(c))
                        }
                        _authenticate() {
                            B(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, c => {
                                if (c && (c.message === Ye || 401 === c.status)) {
                                    const t = this.painter.context.gl;
                                    lt(t, !1),
                                    this._logoControl instanceof Na && this._logoControl._updateLogo(),
                                    t && t.clear(t.DEPTH_BUFFER_BIT | t.COLOR_BUFFER_BIT | t.STENCIL_BUFFER_BIT),
                                    this._silenceAuthErrors || this.fire(new s.y(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")))
                                }
                            }
                            ),
                            Et(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {}
                            )
                        }
                        _postStyleLoadEvent() {
                            this.style.globalId && At(this._requestManager._customAccessToken, {
                                map: this,
                                skuToken: this._requestManager._skuToken,
                                style: this.style.globalId,
                                importedStyles: this.style.getImportGlobalIds()
                            })
                        }
                        _updateTerrain() {
                            const c = this._isDragging();
                            this.painter.updateTerrain(this.style, c)
                        }
                        _calculateSpeedIndex() {
                            const c = this.painter.canvasCopy()
                              , t = this.painter.getCanvasCopiesAndTimestamps();
                            t.timeStamps.push(performance.now());
                            const i = this.painter.context.gl
                              , h = i.createFramebuffer();
                            function d(m) {
                                i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, m, 0);
                                const y = new Uint8Array(i.drawingBufferWidth * i.drawingBufferHeight * 4);
                                return i.readPixels(0, 0, i.drawingBufferWidth, i.drawingBufferHeight, i.RGBA, i.UNSIGNED_BYTE, y),
                                y
                            }
                            return i.bindFramebuffer(i.FRAMEBUFFER, h),
                            this._canvasPixelComparison(d(c), t.canvasCopies.map(d), t.timeStamps)
                        }
                        _canvasPixelComparison(c, t, i) {
                            let h = i[1] - i[0];
                            const d = c.length / 4;
                            for (let m = 0; m < t.length; m++) {
                                const y = t[m];
                                let M = 0;
                                for (let E = 0; E < y.length; E += 4)
                                    y[E] === c[E] && y[E + 1] === c[E + 1] && y[E + 2] === c[E + 2] && y[E + 3] === c[E + 3] && (M += 1);
                                h += (i[m + 2] - i[m + 1]) * (1 - M / d)
                            }
                            return h
                        }
                        remove() {
                            this._hash && this._hash.remove();
                            for (const t of this._controls)
                                t.onRemove(this);
                            this._controls = [],
                            this._frame && (this._frame.cancel(),
                            this._frame = null),
                            this._renderTaskQueue.clear(),
                            this._domRenderTaskQueue.clear(),
                            this.style && this.style.destroy(),
                            this.indoor.destroy(),
                            this.painter.destroy(),
                            this.handlers && this.handlers.destroy(),
                            this.handlers = void 0,
                            this.setStyle(null),
                            window.removeEventListener("resize", this._onWindowResize, !1),
                            window.removeEventListener("orientationchange", this._onWindowResize, !1),
                            window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1),
                            window.removeEventListener("online", this._onWindowOnline, !1),
                            window.removeEventListener("visibilitychange", this._onVisibilityChange, !1);
                            const c = this.painter.context.gl.getExtension("WEBGL_lose_context");
                            c && c.loseContext(),
                            this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1),
                            this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1),
                            this._canvasContainer.remove(),
                            this._controlContainer.remove(),
                            this._missingCSSCanary.remove(),
                            this._canvas = void 0,
                            this._canvasContainer = void 0,
                            this._controlContainer = void 0,
                            this._missingCSSCanary = void 0,
                            this._container.classList.remove("mapboxgl-map"),
                            this._container.removeEventListener("scroll", this._onMapScroll, !1),
                            de.delete(this.painter.context.gl),
                            ne.remove(),
                            po.remove(),
                            this._removed = !0,
                            this.fire(new s.z("remove"))
                        }
                        triggerRepaint() {
                            this._triggerFrame(!0)
                        }
                        _triggerFrame(c) {
                            this._renderNextFrame = this._renderNextFrame || c,
                            this.style && !this._frame && (this._frame = s.q.frame(t => {
                                const i = !!this._renderNextFrame;
                                this._frame = null,
                                this._renderNextFrame = null,
                                i && this._render(t)
                            }
                            ))
                        }
                        _preloadTiles(c) {
                            const t = this.style ? this.style.getSourceCaches() : [];
                            return s.bl(t, (i, h) => i._preloadTiles(c, h), () => {
                                this.triggerRepaint()
                            }
                            ),
                            this
                        }
                        _onWindowOnline() {
                            this._update()
                        }
                        _onWindowResize(c) {
                            this._trackResize && this.resize({
                                originalEvent: c
                            })._update()
                        }
                        _onVisibilityChange() {
                            "hidden" === document.visibilityState && this._visibilityHidden++
                        }
                        get showTileBoundaries() {
                            return !!this._showTileBoundaries
                        }
                        set showTileBoundaries(c) {
                            this._showTileBoundaries !== c && (this._showTileBoundaries = c,
                            this._tp.refreshUI(),
                            this._update())
                        }
                        get showParseStatus() {
                            return !!this._showParseStatus
                        }
                        set showParseStatus(c) {
                            this._showParseStatus !== c && (this._showParseStatus = c,
                            this._tp.refreshUI(),
                            this._update())
                        }
                        get showTerrainWireframe() {
                            return !!this._showTerrainWireframe
                        }
                        set showTerrainWireframe(c) {
                            this._showTerrainWireframe !== c && (this._showTerrainWireframe = c,
                            this._tp.refreshUI(),
                            this._update())
                        }
                        get showLayers2DWireframe() {
                            return !!this._showLayers2DWireframe
                        }
                        set showLayers2DWireframe(c) {
                            this._showLayers2DWireframe !== c && (this._showLayers2DWireframe = c,
                            this._tp.refreshUI(),
                            this._update())
                        }
                        get showLayers3DWireframe() {
                            return !!this._showLayers3DWireframe
                        }
                        set showLayers3DWireframe(c) {
                            this._showLayers3DWireframe !== c && (this._showLayers3DWireframe = c,
                            this._tp.refreshUI(),
                            this._update())
                        }
                        get speedIndexTiming() {
                            return !!this._speedIndexTiming
                        }
                        set speedIndexTiming(c) {
                            this._speedIndexTiming !== c && (this._speedIndexTiming = c,
                            this._update())
                        }
                        get showPadding() {
                            return !!this._showPadding
                        }
                        set showPadding(c) {
                            this._showPadding !== c && (this._showPadding = c,
                            this._tp.refreshUI(),
                            this._update())
                        }
                        get showCollisionBoxes() {
                            return !!this._showCollisionBoxes
                        }
                        set showCollisionBoxes(c) {
                            this._showCollisionBoxes !== c && (this._showCollisionBoxes = c,
                            this._tp.refreshUI(),
                            c ? this.style._generateCollisionBoxes() : this._update())
                        }
                        get showOverdrawInspector() {
                            return !!this._showOverdrawInspector
                        }
                        set showOverdrawInspector(c) {
                            this._showOverdrawInspector !== c && (this._showOverdrawInspector = c,
                            this._tp.refreshUI(),
                            this._update())
                        }
                        get repaint() {
                            return !!this._repaint
                        }
                        set repaint(c) {
                            this._repaint !== c && (this._repaint = c,
                            this._tp.refreshUI(),
                            this.triggerRepaint())
                        }
                        get vertices() {
                            return !!this._vertices
                        }
                        set vertices(c) {
                            this._vertices = c,
                            this._update()
                        }
                        get showTileAABBs() {
                            return !!this._showTileAABBs
                        }
                        set showTileAABBs(c) {
                            this._showTileAABBs !== c && (this._showTileAABBs = c,
                            this._tp.refreshUI(),
                            c && this._update())
                        }
                        _setCacheLimits(c, t) {
                            s.dG(c, t)
                        }
                        get version() {
                            return so
                        }
                    }
                    ,
                    NavigationControl: class {
                        constructor(c={}) {
                            this.options = s.l({}, ga, c),
                            this._container = Qe("div", "mapboxgl-ctrl mapboxgl-ctrl-group"),
                            this._container.addEventListener("contextmenu", t => t.preventDefault()),
                            this.options.showZoom && (s.aP(["_setButtonTitle", "_updateZoomButtons"], this),
                            this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", t => {
                                this._map && this._map.zoomIn({}, {
                                    originalEvent: t
                                })
                            }
                            ),
                            Qe("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"),
                            this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", t => {
                                this._map && this._map.zoomOut({}, {
                                    originalEvent: t
                                })
                            }
                            ),
                            Qe("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")),
                            this.options.showCompass && (s.aP(["_rotateCompassArrow"], this),
                            this._compass = this._createButton("mapboxgl-ctrl-compass", t => {
                                const i = this._map;
                                i && (this.options.visualizePitch ? i.resetNorthPitch({}, {
                                    originalEvent: t
                                }) : i.resetNorth({}, {
                                    originalEvent: t
                                }))
                            }
                            ),
                            this._compassIcon = Qe("span", "mapboxgl-ctrl-icon", this._compass),
                            this._compassIcon.setAttribute("aria-hidden", "true"))
                        }
                        _updateZoomButtons() {
                            const c = this._map;
                            if (!c)
                                return;
                            const t = c.getZoom()
                              , i = t === c.getMaxZoom()
                              , h = t === c.getMinZoom();
                            this._zoomInButton.disabled = i,
                            this._zoomOutButton.disabled = h,
                            this._zoomInButton.setAttribute("aria-disabled", i.toString()),
                            this._zoomOutButton.setAttribute("aria-disabled", h.toString())
                        }
                        _rotateCompassArrow() {
                            const c = this._map;
                            if (!c)
                                return;
                            const t = this.options.visualizePitch ? "scale(".concat(1 / Math.pow(Math.cos(c.transform.pitch * (Math.PI / 180)), .5), ") rotateX(").concat(c.transform.pitch, "deg) rotateZ(").concat(c.transform.angle * (180 / Math.PI), "deg)") : "rotate(".concat(c.transform.angle * (180 / Math.PI), "deg)");
                            c._requestDomTask( () => {
                                this._compassIcon && (this._compassIcon.style.transform = t)
                            }
                            )
                        }
                        onAdd(c) {
                            return this._map = c,
                            this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"),
                            this._setButtonTitle(this._zoomOutButton, "ZoomOut"),
                            c.on("zoom", this._updateZoomButtons),
                            this._updateZoomButtons()),
                            this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"),
                            this.options.visualizePitch && c.on("pitch", this._rotateCompassArrow),
                            c.on("rotate", this._rotateCompassArrow),
                            this._rotateCompassArrow(),
                            this._handler = new kd(c,this._compass,this.options.visualizePitch)),
                            this._container
                        }
                        onRemove() {
                            const c = this._map;
                            c && (this._container.remove(),
                            this.options.showZoom && c.off("zoom", this._updateZoomButtons),
                            this.options.showCompass && (this.options.visualizePitch && c.off("pitch", this._rotateCompassArrow),
                            c.off("rotate", this._rotateCompassArrow),
                            this._handler && this._handler.off(),
                            this._handler = void 0),
                            this._map = void 0)
                        }
                        _createButton(c, t) {
                            const i = Qe("button", c, this._container);
                            return i.type = "button",
                            i.addEventListener("click", t),
                            i
                        }
                        _setButtonTitle(c, t) {
                            if (!this._map)
                                return;
                            const i = this._map._getUIString("NavigationControl.".concat(t));
                            c.setAttribute("aria-label", i),
                            c.firstElementChild && c.firstElementChild.setAttribute("title", i)
                        }
                    }
                    ,
                    GeolocateControl: class extends s.E {
                        constructor(c={}) {
                            super();
                            const t = navigator.geolocation;
                            this.options = s.l({
                                geolocation: t
                            }, ks, c),
                            s.aP(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this),
                            this._updateMarkerRotationThrottled = Tc(this._updateMarkerRotation, 20),
                            this._numberOfWatches = 0
                        }
                        onAdd(c) {
                            return this._map = c,
                            this._container = Qe("div", "mapboxgl-ctrl mapboxgl-ctrl-group"),
                            this._checkGeolocationSupport(this._setupUI),
                            this._container
                        }
                        onRemove() {
                            void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID),
                            this._geolocationWatchID = void 0),
                            this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(),
                            this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(),
                            this._container.remove(),
                            this._map.off("zoom", this._onZoom),
                            this._map = void 0,
                            this._numberOfWatches = 0,
                            this._noTimeout = !1
                        }
                        _checkGeolocationSupport(c) {
                            const t = (i=!!this.options.geolocation) => {
                                this._supportsGeolocation = i,
                                c(i)
                            }
                            ;
                            void 0 !== this._supportsGeolocation ? c(this._supportsGeolocation) : void 0 !== navigator.permissions ? navigator.permissions.query({
                                name: "geolocation"
                            }).then(i => t("denied" !== i.state)).catch( () => t()) : t()
                        }
                        _isOutOfMapMaxBounds(c) {
                            const t = this._map.getMaxBounds()
                              , i = c.coords;
                            return !!t && (i.longitude < t.getWest() || i.longitude > t.getEast() || i.latitude < t.getSouth() || i.latitude > t.getNorth())
                        }
                        _setErrorState() {
                            switch (this._watchState) {
                            case "WAITING_ACTIVE":
                                this._watchState = "ACTIVE_ERROR",
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                                break;
                            case "ACTIVE_LOCK":
                                this._watchState = "ACTIVE_ERROR",
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"),
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                                break;
                            case "BACKGROUND":
                                this._watchState = "BACKGROUND_ERROR",
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"),
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting")
                            }
                        }
                        _onSuccess(c) {
                            if (this._map) {
                                if (this._isOutOfMapMaxBounds(c))
                                    return this._setErrorState(),
                                    this.fire(new s.z("outofmaxbounds",c)),
                                    this._updateMarker(),
                                    void this._finish();
                                if (this.options.trackUserLocation)
                                    switch (this._lastKnownPosition = c,
                                    this._watchState) {
                                    case "WAITING_ACTIVE":
                                    case "ACTIVE_LOCK":
                                    case "ACTIVE_ERROR":
                                        this._watchState = "ACTIVE_LOCK",
                                        this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),
                                        this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),
                                        this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                        break;
                                    case "BACKGROUND":
                                    case "BACKGROUND_ERROR":
                                        this._watchState = "BACKGROUND",
                                        this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),
                                        this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),
                                        this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background")
                                    }
                                this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(c),
                                this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(c),
                                this.options.showUserLocation && this._userLocationDotMarker.removeClassName("mapboxgl-user-location-dot-stale"),
                                this.fire(new s.z("geolocate",c)),
                                this._finish()
                            }
                        }
                        _updateCamera(c) {
                            const t = new s.bO(c.coords.longitude,c.coords.latitude)
                              , i = c.coords.accuracy
                              , h = this._map.getBearing()
                              , d = s.l({
                                bearing: h
                            }, this.options.fitBoundsOptions);
                            this._map.fitBounds(t.toBounds(i), d, {
                                geolocateSource: !0
                            })
                        }
                        _updateMarker(c) {
                            if (c) {
                                const t = new s.bO(c.coords.longitude,c.coords.latitude);
                                this._accuracyCircleMarker.setLngLat(t).addTo(this._map),
                                this._userLocationDotMarker.setLngLat(t).addTo(this._map),
                                this._accuracy = c.coords.accuracy,
                                this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                            } else
                                this._userLocationDotMarker.remove(),
                                this._accuracyCircleMarker.remove()
                        }
                        _updateCircleRadius() {
                            const c = this._map.transform
                              , t = s.bH(1, c._center.lat) * c.worldSize
                              , i = Math.ceil(2 * this._accuracy * t);
                            this._circleElement.style.width = "".concat(i, "px"),
                            this._circleElement.style.height = "".concat(i, "px")
                        }
                        _onZoom() {
                            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                        }
                        _updateMarkerRotation() {
                            this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading),
                            this._userLocationDotMarker.addClassName("mapboxgl-user-location-show-heading")) : (this._userLocationDotMarker.removeClassName("mapboxgl-user-location-show-heading"),
                            this._userLocationDotMarker.setRotation(0))
                        }
                        _onError(c) {
                            if (this._map) {
                                if (this.options.trackUserLocation)
                                    if (1 === c.code) {
                                        this._watchState = "OFF",
                                        this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),
                                        this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),
                                        this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),
                                        this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),
                                        this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),
                                        this._geolocateButton.disabled = !0;
                                        const t = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                        this._geolocateButton.setAttribute("aria-label", t),
                                        this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t),
                                        void 0 !== this._geolocationWatchID && this._clearWatch()
                                    } else {
                                        if (3 === c.code && this._noTimeout)
                                            return;
                                        this._setErrorState()
                                    }
                                "OFF" !== this._watchState && this.options.showUserLocation && this._userLocationDotMarker.addClassName("mapboxgl-user-location-dot-stale"),
                                this.fire(new s.z("error",c)),
                                this._finish()
                            }
                        }
                        _finish() {
                            this._timeoutId && clearTimeout(this._timeoutId),
                            this._timeoutId = void 0
                        }
                        _setupUI(c) {
                            if (void 0 !== this._map) {
                                if (this._container.addEventListener("contextmenu", t => t.preventDefault()),
                                this._geolocateButton = Qe("button", "mapboxgl-ctrl-geolocate", this._container),
                                Qe("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"),
                                this._geolocateButton.type = "button",
                                !1 === c) {
                                    s.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                                    const t = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                    this._geolocateButton.disabled = !0,
                                    this._geolocateButton.setAttribute("aria-label", t),
                                    this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t)
                                } else {
                                    const t = this._map._getUIString("GeolocateControl.FindMyLocation");
                                    this._geolocateButton.setAttribute("aria-label", t),
                                    this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t)
                                }
                                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"),
                                this._watchState = "OFF"),
                                this.options.showUserLocation && (this._dotElement = Qe("div", "mapboxgl-user-location"),
                                this._dotElement.appendChild(Qe("div", "mapboxgl-user-location-dot")),
                                this._dotElement.appendChild(Qe("div", "mapboxgl-user-location-heading")),
                                this._userLocationDotMarker = new gs({
                                    element: this._dotElement,
                                    rotationAlignment: "map",
                                    pitchAlignment: "map"
                                }),
                                this._circleElement = Qe("div", "mapboxgl-user-location-accuracy-circle"),
                                this._accuracyCircleMarker = new gs({
                                    element: this._circleElement,
                                    pitchAlignment: "map"
                                }),
                                this.options.trackUserLocation && (this._watchState = "OFF"),
                                this._map.on("zoom", this._onZoom)),
                                this._geolocateButton.addEventListener("click", this.trigger.bind(this)),
                                this._setup = !0,
                                this.options.trackUserLocation && this._map.on("movestart", t => {
                                    t.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t.originalEvent && "resize" === t.originalEvent.type || (this._watchState = "BACKGROUND",
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"),
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),
                                    this.fire(new s.z("trackuserlocationend")))
                                }
                                )
                            }
                        }
                        _onDeviceOrientation(c) {
                            this._userLocationDotMarker && (c.webkitCompassHeading ? this._heading = c.webkitCompassHeading : !0 === c.absolute && (this._heading = -1 * c.alpha),
                            this._updateMarkerRotationThrottled())
                        }
                        trigger() {
                            if (!this._setup)
                                return s.w("Geolocate control triggered before added to a map"),
                                !1;
                            if (this.options.trackUserLocation) {
                                switch (this._watchState) {
                                case "OFF":
                                    this._watchState = "WAITING_ACTIVE",
                                    this.fire(new s.z("trackuserlocationstart"));
                                    break;
                                case "WAITING_ACTIVE":
                                case "ACTIVE_LOCK":
                                case "ACTIVE_ERROR":
                                case "BACKGROUND_ERROR":
                                    this._numberOfWatches--,
                                    this._noTimeout = !1,
                                    this._watchState = "OFF",
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),
                                    this.fire(new s.z("trackuserlocationend"));
                                    break;
                                case "BACKGROUND":
                                    this._watchState = "ACTIVE_LOCK",
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),
                                    this._lastKnownPosition && this._updateCamera(this._lastKnownPosition),
                                    this.fire(new s.z("trackuserlocationstart"))
                                }
                                switch (this._watchState) {
                                case "WAITING_ACTIVE":
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                    break;
                                case "ACTIVE_LOCK":
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                    break;
                                case "ACTIVE_ERROR":
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                                    break;
                                case "BACKGROUND":
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                                    break;
                                case "BACKGROUND_ERROR":
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error")
                                }
                                if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
                                    this._clearWatch();
                                else if (void 0 === this._geolocationWatchID) {
                                    let c;
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),
                                    this._geolocateButton.setAttribute("aria-pressed", "true"),
                                    this._numberOfWatches++,
                                    this._numberOfWatches > 1 ? (c = {
                                        maximumAge: 6e5,
                                        timeout: 0
                                    },
                                    this._noTimeout = !0) : (c = this.options.positionOptions,
                                    this._noTimeout = !1),
                                    this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, c),
                                    this.options.showUserHeading && this._addDeviceOrientationListener()
                                }
                            } else
                                this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions),
                                this._timeoutId = window.setTimeout(this._finish, 1e4);
                            return !0
                        }
                        _addDeviceOrientationListener() {
                            const c = () => {
                                "ondeviceorientationabsolute"in window ? window.addEventListener("deviceorientationabsolute", this._onDeviceOrientation) : window.addEventListener("deviceorientation", this._onDeviceOrientation)
                            }
                            ;
                            typeof DeviceMotionEvent < "u" && "function" == typeof DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then(t => {
                                "granted" === t && c()
                            }
                            ).catch(console.error) : c()
                        }
                        _clearWatch() {
                            this.options.geolocation.clearWatch(this._geolocationWatchID),
                            window.removeEventListener("deviceorientation", this._onDeviceOrientation),
                            window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation),
                            this._geolocationWatchID = void 0,
                            this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),
                            this._geolocateButton.setAttribute("aria-pressed", "false"),
                            this.options.showUserLocation && this._updateMarker(null)
                        }
                    }
                    ,
                    AttributionControl: Ap,
                    ScaleControl: class {
                        constructor(c={}) {
                            this.options = s.l({}, ar, c),
                            this._isNumberFormatSupported = function() {
                                try {
                                    return new Intl.NumberFormat("en",{
                                        style: "unit",
                                        unitDisplay: "short",
                                        unit: "meter"
                                    }),
                                    !0
                                } catch {
                                    return !1
                                }
                            }(),
                            s.aP(["_update", "_setScale", "setUnit"], this)
                        }
                        getDefaultPosition() {
                            return "bottom-left"
                        }
                        _update() {
                            const c = this.options.maxWidth || 100
                              , t = this._map
                              , i = t._containerHeight / 2
                              , h = t._containerWidth / 2 - c / 2
                              , d = t.unproject([h, i])
                              , m = t.unproject([h + c, i])
                              , y = d.distanceTo(m);
                            if ("imperial" === this.options.unit) {
                                const M = 3.2808 * y;
                                M > 5280 ? this._setScale(c, M / 5280, "mile") : this._setScale(c, M, "foot")
                            } else
                                "nautical" === this.options.unit ? this._setScale(c, y / 1852, "nautical-mile") : y >= 1e3 ? this._setScale(c, y / 1e3, "kilometer") : this._setScale(c, y, "meter")
                        }
                        _setScale(c, t, i) {
                            this._map._requestDomTask( () => {
                                const h = function(m) {
                                    const y = Math.pow(10, "".concat(Math.floor(m)).length - 1);
                                    let M = m / y;
                                    return M = M >= 10 ? 10 : M >= 5 ? 5 : M >= 3 ? 3 : M >= 2 ? 2 : M >= 1 ? 1 : function(E) {
                                        const S = Math.pow(10, Math.ceil(-Math.log(E) / Math.LN10));
                                        return Math.round(E * S) / S
                                    }(M),
                                    y * M
                                }(t)
                                  , d = h / t;
                                this._container.innerHTML = this._isNumberFormatSupported && "nautical-mile" !== i ? new Intl.NumberFormat(this._language,{
                                    style: "unit",
                                    unitDisplay: "short",
                                    unit: i
                                }).format(h) : "".concat(h, "&nbsp;").concat(Mr[i]),
                                this._container.style.width = c * d + "px"
                            }
                            )
                        }
                        onAdd(c) {
                            return this._map = c,
                            this._language = c.getLanguage(),
                            this._container = Qe("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", c.getContainer()),
                            this._container.dir = "auto",
                            this._map.on("move", this._update),
                            this._update(),
                            this._container
                        }
                        onRemove() {
                            this._container.remove(),
                            this._map.off("move", this._update),
                            this._map = void 0
                        }
                        _setLanguage(c) {
                            this._language = c,
                            this._update()
                        }
                        setUnit(c) {
                            this.options.unit = c,
                            this._update()
                        }
                    }
                    ,
                    FullscreenControl: class {
                        constructor(c={}) {
                            this._fullscreen = !1,
                            c && c.container && (c.container instanceof HTMLElement ? this._container = c.container : s.w("Full screen control 'container' must be a DOM element.")),
                            s.aP(["_onClickFullscreen", "_changeIcon"], this),
                            "onfullscreenchange"in document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange"in document && (this._fullscreenchange = "webkitfullscreenchange")
                        }
                        onAdd(c) {
                            return this._map = c,
                            this._container || (this._container = this._map.getContainer()),
                            this._controlContainer = Qe("div", "mapboxgl-ctrl mapboxgl-ctrl-group"),
                            this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none",
                            s.w("This device does not support fullscreen mode.")),
                            this._controlContainer
                        }
                        onRemove() {
                            this._controlContainer.remove(),
                            this._map = null,
                            document.removeEventListener(this._fullscreenchange, this._changeIcon)
                        }
                        _checkFullscreenSupport() {
                            return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled)
                        }
                        _setupUI() {
                            const c = this._fullscreenButton = Qe("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
                            Qe("span", "mapboxgl-ctrl-icon", c).setAttribute("aria-hidden", "true"),
                            c.type = "button",
                            this._updateTitle(),
                            this._fullscreenButton.addEventListener("click", this._onClickFullscreen),
                            document.addEventListener(this._fullscreenchange, this._changeIcon)
                        }
                        _updateTitle() {
                            const c = this._getTitle();
                            this._fullscreenButton.setAttribute("aria-label", c),
                            this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", c)
                        }
                        _getTitle() {
                            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
                        }
                        _isFullscreen() {
                            return this._fullscreen
                        }
                        _changeIcon() {
                            (document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen,
                            this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"),
                            this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"),
                            this._updateTitle())
                        }
                        _onClickFullscreen() {
                            this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen()
                        }
                    }
                    ,
                    Popup: class extends s.E {
                        constructor(c) {
                            super(),
                            this.options = s.l(Object.create(Gn), c),
                            s.aP(["_update", "_onClose", "remove", "_onMouseEvent"], this),
                            this._classList = new Set(c && c.className ? c.className.trim().split(/\s+/) : [])
                        }
                        addTo(c) {
                            return this._map && this.remove(),
                            this._map = c,
                            this.options.closeOnClick && c.on("preclick", this._onClose),
                            this.options.closeOnMove && c.on("move", this._onClose),
                            c.on("remove", this.remove),
                            this._update(),
                            c._addPopup(this),
                            this._focusFirstElement(),
                            this._trackPointer ? (c.on("mousemove", this._onMouseEvent),
                            c.on("mouseup", this._onMouseEvent),
                            c._canvasContainer.classList.add("mapboxgl-track-pointer")) : c.on("move", this._update),
                            this.fire(new s.z("open")),
                            this
                        }
                        isOpen() {
                            return !!this._map
                        }
                        remove() {
                            this._content && this._content.remove(),
                            this._container && (this._container.remove(),
                            this._container = void 0);
                            const c = this._map;
                            return c && (c.off("move", this._update),
                            c.off("move", this._onClose),
                            c.off("preclick", this._onClose),
                            c.off("click", this._onClose),
                            c.off("remove", this.remove),
                            c.off("mousemove", this._onMouseEvent),
                            c.off("mouseup", this._onMouseEvent),
                            c.off("drag", this._onMouseEvent),
                            c._canvasContainer && c._canvasContainer.classList.remove("mapboxgl-track-pointer"),
                            c._removePopup(this),
                            this._map = void 0),
                            this.fire(new s.z("close")),
                            this
                        }
                        getLngLat() {
                            return this._lngLat
                        }
                        setLngLat(c) {
                            this._lngLat = s.bO.convert(c),
                            this._pos = null,
                            this._trackPointer = !1,
                            this._update();
                            const t = this._map;
                            return t && (t.on("move", this._update),
                            t.off("mousemove", this._onMouseEvent),
                            t._canvasContainer.classList.remove("mapboxgl-track-pointer")),
                            this
                        }
                        trackPointer() {
                            this._trackPointer = !0,
                            this._pos = null,
                            this._update();
                            const c = this._map;
                            return c && (c.off("move", this._update),
                            c.on("mousemove", this._onMouseEvent),
                            c.on("drag", this._onMouseEvent),
                            c._canvasContainer.classList.add("mapboxgl-track-pointer")),
                            this
                        }
                        getElement() {
                            return this._container
                        }
                        setText(c) {
                            return this.setDOMContent(document.createTextNode(c))
                        }
                        setHTML(c) {
                            const t = document.createDocumentFragment()
                              , i = document.createElement("body");
                            let h;
                            for (i.innerHTML = c; h = i.firstChild,
                            h; )
                                t.appendChild(h);
                            return this.setDOMContent(t)
                        }
                        getMaxWidth() {
                            return this._container && this._container.style.maxWidth
                        }
                        setMaxWidth(c) {
                            return this.options.maxWidth = c,
                            this._update(),
                            this
                        }
                        setDOMContent(c) {
                            let t = this._content;
                            if (t)
                                for (; t.hasChildNodes(); )
                                    t.firstChild && t.removeChild(t.firstChild);
                            else
                                t = this._content = Qe("div", "mapboxgl-popup-content", this._container || void 0);
                            if (t.appendChild(c),
                            this.options.closeButton) {
                                const i = this._closeButton = Qe("button", "mapboxgl-popup-close-button", t);
                                i.type = "button",
                                i.setAttribute("aria-label", "Close popup"),
                                i.setAttribute("aria-hidden", "true"),
                                i.innerHTML = "&#215;",
                                i.addEventListener("click", this._onClose)
                            }
                            return this._update(),
                            this._focusFirstElement(),
                            this
                        }
                        addClassName(c) {
                            return this._classList.add(c),
                            this._updateClassList(),
                            this
                        }
                        removeClassName(c) {
                            return this._classList.delete(c),
                            this._updateClassList(),
                            this
                        }
                        setOffset(c) {
                            return this.options.offset = c,
                            this._update(),
                            this
                        }
                        toggleClassName(c) {
                            let t;
                            return this._classList.delete(c) ? t = !1 : (this._classList.add(c),
                            t = !0),
                            this._updateClassList(),
                            t
                        }
                        _onMouseEvent(c) {
                            this._update(c.point)
                        }
                        _getAnchor(c) {
                            if (this.options.anchor)
                                return this.options.anchor;
                            const t = this._map
                              , i = this._container
                              , h = this._pos;
                            if (!t || !i || !h)
                                return "bottom";
                            const d = i.offsetWidth
                              , m = i.offsetHeight
                              , y = h.x < d / 2
                              , M = h.x > t.transform.width - d / 2;
                            if (h.y + c < m)
                                return y ? "top-left" : M ? "top-right" : "top";
                            if (h.y > t.transform.height - m) {
                                if (y)
                                    return "bottom-left";
                                if (M)
                                    return "bottom-right"
                            }
                            return y ? "left" : M ? "right" : "bottom"
                        }
                        _updateClassList() {
                            const c = this._container;
                            if (!c)
                                return;
                            const t = [...this._classList];
                            t.push("mapboxgl-popup"),
                            this._anchor && t.push("mapboxgl-popup-anchor-".concat(this._anchor)),
                            this._trackPointer && t.push("mapboxgl-popup-track-pointer"),
                            c.className = t.join(" ")
                        }
                        _update(c) {
                            const t = this._map
                              , i = this._content;
                            if (!t || !this._lngLat && !this._trackPointer || !i)
                                return;
                            let h = this._container;
                            if (h || (h = this._container = Qe("div", "mapboxgl-popup", t.getContainer()),
                            this._tip = Qe("div", "mapboxgl-popup-tip", h),
                            h.appendChild(i)),
                            this.options.maxWidth && h.style.maxWidth !== this.options.maxWidth && (h.style.maxWidth = this.options.maxWidth),
                            t.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Op(this._lngLat, this._pos, t.transform)),
                            !this._trackPointer || c) {
                                const d = this._pos = this._trackPointer && c instanceof s.P ? c : t.project(this._lngLat)
                                  , m = un(this.options.offset)
                                  , y = this._anchor = this._getAnchor(m.y)
                                  , M = un(this.options.offset, y)
                                  , E = d.add(M).round();
                                t._requestDomTask( () => {
                                    this._container && y && (this._container.style.transform = "".concat(Lc[y], " translate(").concat(E.x, "px,").concat(E.y, "px)"))
                                }
                                )
                            }
                            if (!this._marker && t._showingGlobe()) {
                                const d = s.dH(t.transform, this._lngLat) ? 0 : 1;
                                this._setOpacity(d)
                            }
                            this._updateClassList()
                        }
                        _focusFirstElement() {
                            if (!this.options.focusAfterOpen || !this._container)
                                return;
                            const c = this._container.querySelector(Rp);
                            c && c.focus()
                        }
                        _onClose() {
                            this.remove()
                        }
                        _setOpacity(c) {
                            this._container && (this._container.style.opacity = "".concat(c)),
                            this._content && (this._content.style.pointerEvents = c ? "auto" : "none")
                        }
                    }
                    ,
                    Marker: gs,
                    Style: pr,
                    LngLat: s.bO,
                    LngLatBounds: s.az,
                    Point: s.P,
                    MercatorCoordinate: s.aa,
                    FreeCameraOptions: Cs,
                    Evented: s.E,
                    config: s.e,
                    prewarm: s.dM,
                    clearPrewarmedResources: s.dN,
                    get accessToken() {
                        return s.e.ACCESS_TOKEN
                    },
                    set accessToken(c) {
                        s.e.ACCESS_TOKEN = c
                    },
                    get baseApiUrl() {
                        return s.e.API_URL
                    },
                    set baseApiUrl(c) {
                        s.e.API_URL = c
                    },
                    get workerCount() {
                        return s.dO.workerCount
                    },
                    set workerCount(c) {
                        s.dO.workerCount = c
                    },
                    get maxParallelImageRequests() {
                        return s.e.MAX_PARALLEL_IMAGE_REQUESTS
                    },
                    set maxParallelImageRequests(c) {
                        s.e.MAX_PARALLEL_IMAGE_REQUESTS = c
                    },
                    clearStorage(c) {
                        s.dP(c)
                    },
                    get workerUrl() {
                        return s.dQ.workerUrl
                    },
                    set workerUrl(c) {
                        s.dQ.workerUrl = c
                    },
                    get workerClass() {
                        return s.dQ.workerClass
                    },
                    set workerClass(c) {
                        s.dQ.workerClass = c
                    },
                    get workerParams() {
                        return s.dQ.workerParams
                    },
                    set workerParams(c) {
                        s.dQ.workerParams = c
                    },
                    get dracoUrl() {
                        return s.dR()
                    },
                    set dracoUrl(c) {
                        s.dS(c)
                    },
                    get meshoptUrl() {
                        return s.dT()
                    },
                    set meshoptUrl(c) {
                        s.dU(c)
                    },
                    setNow: s.q.setNow,
                    restoreNow: s.q.restoreNow
                }
            }),
            Ut
        }()
    },
    81572: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            h: () => s
        });
        var Ut = $(54438);
        const r = new WeakMap
          , Mt = new ResizeObserver(so => {
            for (const Wt of so)
                r.has(Wt.target) && r.get(Wt.target)._resizeCallback(Wt)
        }
        );
        let s = ( () => {
            var so;
            class Wt {
                constructor(Ae) {
                    this.el = Ae,
                    this.resizeCallback = new Ut.bkB;
                    const Me = this.el.nativeElement;
                    r.set(Me, this),
                    Mt.observe(Me)
                }
                _resizeCallback(Ae) {
                    this.resizeCallback.emit(Ae)
                }
                ngOnDestroy() {
                    const Ae = this.el.nativeElement;
                    Mt.unobserve(Ae),
                    r.delete(Ae)
                }
            }
            return (so = Wt).\u0275fac = function(Ae) {
                return new (Ae || so)(Ut.rXU(Ut.aKT))
            }
            ,
            so.\u0275dir = Ut.FsC({
                type: so,
                selectors: [["", "ppPosterResizeObserver", ""]],
                outputs: {
                    resizeCallback: "resizeCallback"
                }
            }),
            Wt
        }
        )()
    }
    ,
    84457: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            o: () => Re
        });
        var Ut = $(10467)
          , r = $(7494)
          , Mt = $(9566)
          , s = $(13620)
          , so = $(69847)
          , Wt = $(60177)
          , _t = $(27617)
          , Ae = $(78606)
          , Me = $(28105)
          , ct = $(61762)
          , Tt = $(84412)
          , Qe = $(5116)
          , jt = $(63597)
          , Xe = $(54843)
          , Ce = $(41046)
          , it = $(93967)
          , et = $(66985)
          , re = $(54438)
          , pt = $(21626)
          , Be = $(345);
        const ze = ve => ({
            fill: ve,
            width: "100%",
            height: "100%"
        })
          , ye = (ve, ne) => ({
            fill: ve,
            stroke: ne,
            width: "100%",
            height: "100%"
        })
          , ge = ve => ({
            stroke: ve,
            strokeWidth: "8px",
            width: "100%",
            height: "100%"
        });
        function Ie(ve, ne) {
            if (1 & ve && re.nrm(0, "div", 16, 1),
            2 & ve) {
                const B = re.XpG(2);
                re.AVh("preview", !B.isFinalPoster),
                re.Y8G("innerHTML", B.stars.image, re.npT)
            }
        }
        function gt(ve, ne) {
            if (1 & ve && (re.nrm(0, "pp-poster-stars-area", 11),
            re.nI1(1, "async"),
            re.nI1(2, "async"),
            re.nI1(3, "async")),
            2 & ve) {
                const B = re.XpG(2);
                re.Y8G("appConfiguration", re.bMT(1, 3, B.appConfiguration$))("location", re.bMT(2, 5, B.location$))("skyConfiguration", re.bMT(3, 7, B.skyConfiguration$))
            }
        }
        function Ye(ve, ne) {
            if (1 & ve && re.nrm(0, "svg-icon", 17),
            2 & ve) {
                const B = re.XpG(3);
                re.Y8G("svgStyle", re.eq3(2, ze, B.stars.background))("src", "/assets/pp-posters/stars/punching-die-circle-with-shield.svg")
            }
        }
        function yt(ve, ne) {
            if (1 & ve && re.nrm(0, "svg-icon", 17),
            2 & ve) {
                const B = re.XpG(3);
                re.Y8G("svgStyle", re.eq3(2, ze, B.stars.background))("src", "/assets/pp-posters/stars/punching-die-circle-no-shield.svg")
            }
        }
        function ht(ve, ne) {
            if (1 & ve && re.nrm(0, "svg-icon", 18),
            2 & ve) {
                const B = re.XpG(3);
                re.Y8G("svgStyle", re.l_i(2, ye, B.stars.background, B.stars.heartShieldColor))("src", "/assets/pp-posters/stars/punching-die-heart.svg")
            }
        }
        function mo(ve, ne) {
            if (1 & ve && re.nrm(0, "svg-icon", 18),
            2 & ve) {
                const B = re.XpG(3);
                re.Y8G("svgStyle", re.eq3(2, ze, B.stars.heartShieldColor))("src", "/assets/pp-posters/stars/punching-die-heart-shield.svg")
            }
        }
        function no(ve, ne) {
            if (1 & ve && re.nrm(0, "svg-icon", 18),
            2 & ve) {
                const B = re.XpG(3);
                re.Y8G("svgStyle", re.eq3(2, ge, B.stars.background))("src", "/assets/pp-posters/stars/punching-die-heart-cover.svg")
            }
        }
        function Co(ve, ne) {
            if (1 & ve && (re.j41(0, "div", 19),
            re.nrm(1, "svg-icon", 20),
            re.k0s()),
            2 & ve) {
                const B = re.XpG(3);
                re.R7$(),
                re.Y8G("svgStyle", re.eq3(2, ze, B.stars.shieldColor))("src", "/assets/pp-posters/stars/shields/" + B.stars.shieldId + ".svg")
            }
        }
        function Lt(ve, ne) {
            if (1 & ve && re.DNE(0, Ye, 1, 4, "svg-icon", 17)(1, yt, 1, 4, "svg-icon", 17)(2, ht, 1, 5, "svg-icon", 18)(3, mo, 1, 4, "svg-icon", 18)(4, no, 1, 4, "svg-icon", 18)(5, Co, 2, 4, "div", 19),
            2 & ve) {
                const B = re.XpG(2);
                re.vxM(B.stars.shape !== B.StarsShapesEnum.HEARTS && B.stars.colorScheme !== B.StarsColorSchemeEnum.COSMIC_LOVE ? 0 : B.stars.shape !== B.StarsShapesEnum.HEARTS ? 1 : B.stars.shape === B.StarsShapesEnum.HEARTS ? 2 : -1),
                re.R7$(3),
                re.vxM(B.stars.shape === B.StarsShapesEnum.HEARTS && B.stars.heartShield ? 3 : -1),
                re.R7$(),
                re.vxM(B.stars.shape === B.StarsShapesEnum.HEARTS ? 4 : -1),
                re.R7$(),
                re.vxM(B.stars.shieldId && B.stars.shape !== B.StarsShapesEnum.HEARTS ? 5 : -1)
            }
        }
        function Ft(ve, ne) {
            if (1 & ve && (re.j41(0, "div", 22),
            re.nrm(1, "svg-icon", 23),
            re.k0s()),
            2 & ve) {
                const B = re.XpG(3);
                re.xc7("margin-top", B.Math.round(B.stars.specialShieldMarginTop * (B.stars.isPortrait ? .96 : .75)), "px")("height", B.Math.round(B.stars.specialShieldHeight), "px"),
                re.R7$(),
                re.Y8G("svgStyle", re.eq3(6, ze, B.stars.shieldColor))("src", "/assets/pp-posters/stars/shields/heart.svg")
            }
        }
        function co(ve, ne) {
            if (1 & ve && (re.j41(0, "div", 22),
            re.nrm(1, "svg-icon", 23),
            re.k0s()),
            2 & ve) {
                const B = re.XpG(3);
                re.xc7("margin-top", B.Math.round(B.stars.specialShieldMarginTop), "px")("height", B.Math.round(B.stars.specialShieldHeight), "px"),
                re.R7$(),
                re.Y8G("svgStyle", re.eq3(6, ze, B.stars.shieldColor))("src", "/assets/pp-posters/stars/shields/circle.svg")
            }
        }
        function Jt(ve, ne) {
            if (1 & ve && re.DNE(0, Ft, 2, 8, "div", 21)(1, co, 2, 8, "div", 21),
            2 & ve) {
                const B = re.XpG(2);
                re.vxM(B.stars.shape === B.StarsShapesEnum.HEARTS && B.stars.heartShield ? 0 : B.stars.shape === B.StarsShapesEnum.CIRCLES ? 1 : -1)
            }
        }
        function po(ve, ne) {
            if (1 & ve && (re.j41(0, "div", 24),
            re.EFF(1, " \u2665 "),
            re.k0s()),
            2 & ve) {
                const B = ne.ngIf;
                re.xc7("font-family", "Dejavu Sans,NotoColorEmoji,sans-serif")("font-size", B.width, "px")("line-height", B.width, "px")("margin-bottom", B.marginBottom, "px")
            }
        }
        function Et(ve, ne) {
            if (1 & ve && (re.j41(0, "pp-poster-printing-registration", 5)(1, "pp-poster-arrangement-wrapper", 6)(2, "pp-poster-image-area")(3, "div", 7)(4, "div", 8),
            re.nrm(5, "div"),
            re.k0s(),
            re.j41(6, "div", 9),
            re.DNE(7, Ie, 2, 3, "div", 10)(8, gt, 4, 9, "pp-poster-stars-area", 11),
            re.nrm(9, "pp-poster-preview", 12),
            re.k0s(),
            re.j41(10, "div", 13),
            re.DNE(11, Lt, 6, 4),
            re.k0s()(),
            re.DNE(12, Jt, 2, 1),
            re.k0s(),
            re.j41(13, "pp-poster-text-area", 14),
            re.nI1(14, "async"),
            re.nI1(15, "async"),
            re.nI1(16, "async"),
            re.nI1(17, "async"),
            re.nI1(18, "async"),
            re.nI1(19, "async"),
            re.nI1(20, "async"),
            re.DNE(21, po, 2, 8, "div", 15),
            re.nI1(22, "async"),
            re.k0s()()()),
            2 & ve) {
                const B = ne.ngIf
                  , de = re.XpG();
                re.Y8G("poster", B),
                re.R7$(),
                re.Y8G("internalPadding", de.stars.internalPadding)("internalBorder", de.stars.internalBorder)("internalBorderColor", de.stars.internalBorderColor),
                re.R7$(2),
                re.xc7("margin-top", de.Math.round(de.stars.marginTop), "px")("width", de.Math.round(de.stars.width), "px")("height", de.stars.shape !== de.StarsShapesEnum.HEARTS || B.isPortrait ? de.stars.height : de.Math.round(.8531232414 * de.stars.height), "px"),
                re.R7$(),
                re.xc7("padding", de.stars.padding, "px")("width", 100, "%")("height", 100, "%"),
                re.R7$(),
                re.xc7("background", de.stars.circleBackground),
                re.AVh("circle-background", de.stars.shape !== de.StarsShapesEnum.HEARTS)("heart-background", de.stars.shape === de.StarsShapesEnum.HEARTS),
                re.R7$(),
                re.xc7("scale", de.stars.shape === de.StarsShapesEnum.HEARTS ? 1.22 : 1)("margin-top", de.stars.shape !== de.StarsShapesEnum.HEARTS ? 0 : -6, "%")("width", (de.stars.shape === de.StarsShapesEnum.HEARTS ? .95 : 1) * de.stars.height, "px")("height", (de.stars.shape === de.StarsShapesEnum.HEARTS ? .95 : 1) * de.stars.height, "px"),
                re.AVh("special-punching-die", de.isRasterBackground(de.stars.colorScheme))("special-heart", de.stars.shape === de.StarsShapesEnum.HEARTS)("special-circle", de.stars.shape === de.StarsShapesEnum.CIRCLES)("special-sky", de.stars.colorScheme === de.StarsColorSchemeEnum.SKY)("special-emerald", de.stars.colorScheme === de.StarsColorSchemeEnum.EMERALD)("special-purple-galaxy", de.stars.colorScheme === de.StarsColorSchemeEnum.PURPLE_GALAXY),
                re.R7$(),
                re.vxM(de.isSvgStars ? 7 : 8),
                re.R7$(2),
                re.Y8G("showPreview", !de.isFinalPoster)("previewType", "star-dimmed")("marginTop", de.stars.shape === de.StarsShapesEnum.HEARTS),
                re.R7$(2),
                re.vxM(de.isRasterBackground(de.stars.colorScheme) ? -1 : 11),
                re.R7$(),
                re.vxM(de.isRasterBackground(de.stars.colorScheme) ? 12 : -1),
                re.R7$(),
                re.Y8G("poster", re.bMT(14, 56, de.poster$))("color", re.bMT(15, 58, de.textColor$))("textArea", re.bMT(16, 60, de.textArea$))("title", re.bMT(17, 62, de.title$))("subtitle", re.bMT(18, 64, de.subtitle$))("footer", re.bMT(19, 66, de.footer$))("date", re.bMT(20, 68, de.date$)),
                re.R7$(8),
                re.Y8G("ngIf", de.stars.colorScheme === de.StarsColorSchemeEnum.COSMIC_LOVE && re.bMT(22, 70, de.pretext$))
            }
        }
        function Kt(ve, ne) {
            1 & ve && re.nrm(0, "pp-poster-loaded-element")
        }
        function At(ve, ne) {
            if (1 & ve && (re.SS7(0)(1),
            re.qSk(),
            re.j41(2, "svg", 25)(3, "defs")(4, "mask", 26),
            re.nrm(5, "circle", 27),
            re.k0s()()(),
            re.SS7(6)(7)(8),
            re.j41(9, "svg", 28)(10, "defs")(11, "mask", 29),
            re.nrm(12, "path", 30),
            re.k0s()()()),
            2 & ve) {
                const B = re.XpG()
                  , de = B.stars.width / 2
                  , lt = .95 * de;
                re.R7$(2),
                re.BMQ("width", de)("height", de),
                re.R7$(3),
                re.BMQ("cx", de)("cy", de)("r", lt);
                const St = B.stars.width * (B.stars.isPortrait ? .8075 : .84)
                  , tt = St / 1777
                  , $t = B.stars.isPortrait ? 0 : .0657 * St;
                re.R7$(4),
                re.BMQ("width", St)("height", St)("viewBox", "0 0 1777 1777"),
                re.R7$(3),
                re.BMQ("transform", "translate(" + $t + ", 0) scale(" + tt + "," + tt + ")")
            }
        }
        let Re = ( () => {
            var ve;
            class ne extends jt.l {
                constructor(de, lt, St, tt, $t, Nt, Vt) {
                    super(lt, St, tt, $t, Nt),
                    this.document = de,
                    this.host = lt,
                    this.zone = St,
                    this.httpClient = tt,
                    this.domSanitizer = $t,
                    this.cdr = Nt,
                    this.renderer = Vt,
                    this.stars = {
                        marginTop: 0,
                        width: 0,
                        height: 0,
                        padding: 0,
                        background: "#FFF",
                        internalPadding: 0,
                        internalBorder: 0,
                        internalBorderColor: "transparent",
                        circleBackground: "transparent",
                        shieldBackground: "transparent",
                        shieldColor: "transparent",
                        heartShieldColor: "transparent",
                        shieldWidth: 0,
                        shieldId: null,
                        uuid: void 0,
                        image: "",
                        heartShield: !1,
                        colorScheme: _t.th1.COSMIC_LOVE,
                        shape: _t.nhL.CIRCLES,
                        specialShieldMarginTop: 0,
                        specialShieldHeight: 0,
                        isPortrait: !1
                    },
                    this.appConfiguration$ = new Tt.t(null),
                    this.skyConfiguration$ = new Tt.t(null),
                    this.location$ = new Tt.t(null),
                    this.StarsShapesEnum = _t.nhL,
                    this.Math = Math
                }
                setAllTextSettings(de) {
                    var lt;
                    const St = de.starMapConfig[0]
                      , tt = this.isBorderLayout(de.shape, de.colorScheme)
                      , $t = tt ? .9523809524 : 1
                      , Nt = tt ? 1.02120069495 : 1
                      , Vt = {
                        text: St.title,
                        isDefaultFont: !St.titleFont
                    }
                      , _o = null != Vt && Vt.isDefaultFont ? .03035 * $t : .04158 * $t
                      , Lo = null != Vt && Vt.isDefaultFont ? .02134148565 * $t : .029 * $t
                      , ao = this.textColor(de.colorScheme, de.customColors);
                    this.setText(Vt, this.title$, {
                        font: null != Vt && Vt.isDefaultFont ? _t.n3q.CAPSUULA_BOLD : _t.n3q.LUXUS_BRUT,
                        fontVariantLigatures: "none",
                        portrait: {
                            sizeFactor: _o,
                            bottomFactor: 0,
                            lineHeightFactor: 1.2 * _o,
                            letterSpacingFactor: .015 * Lo,
                            topFactor: 0,
                            isBold: !(null != Vt && Vt.isDefaultFont),
                            textShadow: !this.isSvgStars || !this.isFinalPoster || null != Vt && Vt.isDefaultFont ? "unset" : "-1px -1px 0 ".concat(ao, ", 1px -1px 0 ").concat(ao, ", -1px 1px 0 ").concat(ao, ", 1px 1px 0 ").concat(ao)
                        },
                        square: {
                            sizeFactor: _o / 1.3,
                            bottomFactor: 0,
                            lineHeightFactor: _o / 1.3 * 1.2,
                            letterSpacingFactor: .015 * Lo,
                            topFactor: 0,
                            isBold: !(null != Vt && Vt.isDefaultFont),
                            textShadow: !this.isSvgStars || !this.isFinalPoster || null != Vt && Vt.isDefaultFont ? "unset" : "-1px -1px 0 ".concat(ao, ", 1px -1px 0 ").concat(ao, ", -1px 1px 0 ").concat(ao, ", 1px 1px 0 ").concat(ao)
                        },
                        horizontal: {
                            sizeFactor: Lo,
                            bottomFactor: 0,
                            lineHeightFactor: 1.2 * Lo,
                            letterSpacingFactor: .05 * Lo,
                            topFactor: 0,
                            isBold: !(null != Vt && Vt.isDefaultFont),
                            textShadow: !this.isSvgStars || !this.isFinalPoster || null != Vt && Vt.isDefaultFont ? "unset" : "-1px -1px 0 ".concat(ao, ", 1px -1px 0 ").concat(ao, ", -1px 1px 0 ").concat(ao, ", 1px 1px 0 ").concat(ao)
                        }
                    });
                    const bt = {
                        text: 0 === (null === (lt = St.subtitle) || void 0 === lt ? void 0 : lt.length) ? "&nbsp;" : St.subtitle,
                        isDefaultFont: !St.subtitleFont
                    }
                      , Do = null != bt && bt.isDefaultFont ? .02344021967 * $t : .03552359607 * $t
                      , Xt = null != bt && bt.isDefaultFont ? .01637484636 * Nt : .025 * Nt;
                    this.setText(bt, this.subtitle$, {
                        font: null != bt && bt.isDefaultFont ? _t.n3q.CAPSUULA : _t.n3q.LUXUS_BRUT,
                        fontVariantLigatures: "none",
                        portrait: {
                            sizeFactor: Do,
                            bottomFactor: .0258,
                            lineHeightFactor: 1.2 * Do,
                            topFactor: 0
                        },
                        square: {
                            sizeFactor: Do / 1.3,
                            bottomFactor: .0258,
                            lineHeightFactor: Do / 1.3 * 1.2,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: Xt,
                            bottomFactor: .01801144853,
                            lineHeightFactor: 1.2 * Xt,
                            topFactor: 0
                        }
                    });
                    const we = .0184197665 * $t
                      , Oe = .0128853141 * Nt;
                    this.setText({
                        text: St.coordinates,
                        isDefaultFont: !0
                    }, this.footer$, {
                        font: _t.n3q.CAPSUULA,
                        portrait: {
                            sizeFactor: we,
                            bottomFactor: 0,
                            lineHeightFactor: 1.2 * we,
                            topFactor: 0
                        },
                        square: {
                            sizeFactor: we / 1.3,
                            bottomFactor: 0,
                            lineHeightFactor: we / 1.3 * 1.2,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: Oe,
                            bottomFactor: 0,
                            lineHeightFactor: 1.2 * Oe,
                            topFactor: 0
                        }
                    }),
                    this.setText({
                        text: St.dateField,
                        isDefaultFont: !0
                    }, this.date$, {
                        font: _t.n3q.CAPSUULA,
                        portrait: {
                            sizeFactor: we,
                            bottomFactor: 0,
                            lineHeightFactor: 1.2 * we,
                            topFactor: 0
                        },
                        square: {
                            sizeFactor: we / 1.3,
                            bottomFactor: 0,
                            lineHeightFactor: we / 1.3 * 1.2,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: Oe,
                            bottomFactor: 0,
                            lineHeightFactor: 1.2 * Oe,
                            topFactor: 0
                        }
                    })
                }
                setTextArea(de, lt) {
                    const St = this.isBorderLayout(lt.shape, lt.colorScheme);
                    if (de.isPortrait) {
                        const tt = de.size.width > 5e3;
                        this.textArea$.next({
                            bottomFactor: St ? tt ? .12 : .115 : tt ? .088 : .1,
                            marginFactor: .08
                        })
                    } else
                        this.textArea$.next(de.isSquare ? {
                            bottomFactor: St ? .075 : .06,
                            marginFactor: St ? .08 : .04
                        } : {
                            bottomFactor: St ? .08 : .05,
                            marginFactor: St ? .08 : .04
                        });
                    this.setPretext(de)
                }
                setDesign(de, lt) {
                    var St = this;
                    return (0,
                    Ut.A)(function*() {
                        var tt;
                        St.setMap(lt);
                        const $t = St.isBorderLayout(lt.shape, lt.colorScheme);
                        if (St.stars.colorScheme = lt.colorScheme,
                        St.stars.shape = lt.shape,
                        St.stars.heartShield = lt.heartShield,
                        St.setSizes(de, $t),
                        St.stars.internalBorderColor = $t ? [_t.th1.NAVY, _t.th1.BLACK_HOLE].includes(lt.colorScheme) ? "#FFF" : "#0e1111" : "transparent",
                        St.stars.background = St.starsBackground(lt.colorScheme, lt.customColors, St.isFinalPoster, (0,
                        it.v)(de)),
                        St.stars.circleBackground = St.circleColor(lt.colorScheme, lt.customColors),
                        St.stars.shieldBackground = St.shieldBackground(lt.colorScheme, lt.customColors),
                        St.renderer.setProperty(St.document.documentElement, "style", "--rosette-stars-background: ".concat(St.stars.shieldBackground)),
                        St.stars.shieldColor = St.shieldColor(lt.colorScheme, lt.customColors),
                        St.stars.heartShieldColor = St.heartShieldColor(lt.colorScheme, lt.customColors),
                        St.stars.shieldId = St.shieldId(lt.colorScheme, lt.shape),
                        St.isSvgStars && (St.stars.uuid = lt.starMapConfig[0].uuid),
                        St.textColor$.next(St.textColor(lt.colorScheme, lt.customColors)),
                        !St.isSvgStars)
                            return;
                        const Vt = yield(0,
                        Xe._)(St.httpClient.get("/api/stars/d3-celestial/svg", {
                            params: {
                                uuid: null !== (tt = St.stars.uuid) && void 0 !== tt ? tt : ""
                            },
                            responseType: "text"
                        }));
                        if (!Vt)
                            return;
                        let Lo = (new DOMParser).parseFromString(Vt, "image/svg+xml");
                        Lo = (0,
                        Qe.t2)(Lo, !1),
                        Lo = (0,
                        Qe.Jr)(Lo),
                        St.stars.image = St.domSanitizer.bypassSecurityTrustHtml(Lo.documentElement.outerHTML),
                        setTimeout( () => {
                            (0,
                            Qe.Gj)(St.starsSvg.nativeElement),
                            requestAnimationFrame(St.onImageLoad.bind(St))
                        }
                        )
                    })()
                }
                setSizes(de, lt) {
                    if (this.stars.isPortrait = de.isPortrait,
                    de.isPortrait) {
                        if (lt && this.stars.shape !== _t.nhL.HEARTS)
                            this.stars.width = .708 * de.size.width,
                            this.stars.height = this.stars.width,
                            this.stars.marginTop = .034 * de.size.height,
                            this.stars.internalPadding = .1 * de.size.width,
                            this.stars.padding = .01 * this.stars.width,
                            this.stars.internalBorder = this.isFinalPoster ? 8 : 2,
                            this.stars.shieldWidth = .0162 * de.size.width;
                        else {
                            if (this.stars.shape === _t.nhL.HEARTS)
                                this.stars.width = .93 * de.size.width,
                                this.stars.height = .85 * this.stars.width,
                                this.stars.marginTop = .085 * de.size.height;
                            else {
                                const St = this.stars.colorScheme === _t.th1.COSMIC_LOVE ? .007 * de.size.width : 0;
                                this.stars.width = .84 * de.size.width + St,
                                this.stars.height = this.stars.width,
                                this.stars.marginTop = .089 * de.size.height - St / 2
                            }
                            this.stars.padding = .01 * this.stars.width,
                            this.stars.internalPadding = 0,
                            this.stars.internalBorder = 0,
                            this.stars.shieldWidth = .018 * de.size.width
                        }
                        this.stars.specialShieldMarginTop = .955 * this.stars.marginTop,
                        this.stars.specialShieldHeight = 1.008 * this.stars.height
                    } else
                        lt && this.stars.shape !== _t.nhL.HEARTS ? (this.stars.width = .6 * de.size.height,
                        this.stars.height = this.stars.width,
                        this.stars.marginTop = .054 * de.size.height,
                        this.stars.internalPadding = .05 * de.size.width,
                        this.stars.padding = .01 * this.stars.width,
                        this.stars.internalBorder = this.isFinalPoster ? 8 : 2,
                        this.stars.shieldWidth = .014 * de.size.height) : (this.stars.shape === _t.nhL.HEARTS ? (this.stars.width = .775 * de.size.height,
                        this.stars.height = this.stars.width,
                        this.stars.marginTop = .055 * de.size.height) : (this.stars.width = .7 * de.size.height,
                        this.stars.height = this.stars.width,
                        this.stars.marginTop = .06 * de.size.height),
                        this.stars.padding = .01 * this.stars.width,
                        this.stars.internalPadding = 0,
                        this.stars.internalBorder = 0,
                        this.stars.shieldWidth = .016 * de.size.height),
                        this.stars.shape === _t.nhL.HEARTS ? (this.stars.specialShieldMarginTop = .955 * this.stars.marginTop,
                        this.stars.specialShieldHeight = .89 * this.stars.height) : (this.stars.specialShieldMarginTop = .955 * this.stars.marginTop,
                        this.stars.specialShieldHeight = 1.008 * this.stars.height)
                }
                onImageLoad() {
                    this.load++,
                    1 === this.load && (this.initiateRender(),
                    this.cdr.detectChanges())
                }
                setPretext(de) {
                    this.pretext$.next({
                        width: de.isPortrait ? .0375 * de.size.width : .0264 * de.size.height,
                        marginBottom: de.isPortrait ? .0055 * de.size.height : .0075 * de.size.height
                    })
                }
                setMap(de) {
                    var lt;
                    const St = de.starMapConfig[0];
                    null != St && St.date && null != St && null !== (lt = St.place) && void 0 !== lt && lt.center && this.location$.next({
                        UTCTimestamp: St.date,
                        lat: St.place.center.latitude,
                        lng: St.place.center.longitude,
                        timezone: St.timezone
                    }),
                    this.skyConfiguration$.next({
                        ecliptic: de.ecliptic,
                        constellations: de.constellations,
                        constellationsName: de.constellationsName,
                        planets: de.planets,
                        planetNames: de.planetNames,
                        milkyWay: de.milkyWay,
                        grid: de.grid,
                        moon: de.moon,
                        colorScheme: de.colorScheme,
                        shape: de.shape,
                        jewelryColors: "",
                        jewelryBackground: "",
                        language: "ja" === de.lang ? "en" : de.lang,
                        ...de.customColors
                    }),
                    this.appConfiguration$.next({
                        size: 618,
                        id: 1,
                        starLimit: this.isMobile ? 5.2 : 5.4,
                        starSize: 5.0756,
                        lineWidth: .2,
                        isJewelry: !1,
                        containerId: "celestial-map"
                    })
                }
                shieldBackground(de, lt) {
                    switch (de) {
                    case _t.th1.NAVY:
                    case _t.th1.COSMIC_LOVE:
                    case _t.th1.SUPERNOVA:
                    case _t.th1.BLACK_HOLE:
                    case _t.th1.MIDNIGHT_BLUE:
                        return this.circleColor(de, lt);
                    case _t.th1.COSMIC_LATTE:
                        return "#0F1620";
                    case _t.th1.DEEP_SPACE_BLUE:
                        return "#f6e5ce";
                    case _t.th1.CUSTOM:
                        return "#".concat(lt.shield);
                    case _t.th1.SKY:
                    case _t.th1.EMERALD:
                    case _t.th1.PURPLE_GALAXY:
                        return "red";
                    default:
                        return de
                    }
                }
                shieldColor(de, lt) {
                    switch (de) {
                    case _t.th1.BLACK_HOLE:
                    case _t.th1.MIDNIGHT_BLUE:
                    case _t.th1.SUPERNOVA:
                    case _t.th1.NAVY:
                        return "#fff";
                    case _t.th1.DEEP_SPACE_BLUE:
                        return "#0F1C27";
                    case _t.th1.COSMIC_LATTE:
                        return "#F6E8D3";
                    case _t.th1.COSMIC_LOVE:
                        return "transparent";
                    case _t.th1.CUSTOM:
                        return "#".concat(lt.starMapsElements);
                    case _t.th1.SKY:
                    case _t.th1.EMERALD:
                    case _t.th1.PURPLE_GALAXY:
                        return "transparent";
                    default:
                        return de
                    }
                }
                heartShieldColor(de, lt) {
                    switch (de) {
                    case _t.th1.BLACK_HOLE:
                    case _t.th1.NAVY:
                        return "#fff";
                    case _t.th1.DEEP_SPACE_BLUE:
                        return "#f6E5CE";
                    case _t.th1.MIDNIGHT_BLUE:
                        return "#111e3f";
                    case _t.th1.COSMIC_LATTE:
                    case _t.th1.SUPERNOVA:
                        return "#101620";
                    case _t.th1.COSMIC_LOVE:
                        return "transparent";
                    case _t.th1.CUSTOM:
                        return "#".concat(lt.starMapsElements);
                    case _t.th1.SKY:
                    case _t.th1.EMERALD:
                    case _t.th1.PURPLE_GALAXY:
                        return "red";
                    default:
                        return de
                    }
                }
                shieldId(de, lt) {
                    return lt === _t.nhL.HEARTS ? "heart" : de === _t.th1.COSMIC_LOVE ? null : "shield"
                }
                isBorderLayout(de, lt) {
                    return de !== _t.nhL.HEARTS && [_t.th1.NAVY, _t.th1.BLACK_HOLE, _t.th1.SUPERNOVA].includes(lt)
                }
            }
            return (ve = ne).\u0275fac = function(de) {
                return new (de || ve)(re.rXU(Wt.qQ),re.rXU(re.aKT),re.rXU(re.SKi),re.rXU(pt.Qq),re.rXU(Be.up),re.rXU(re.gRc),re.rXU(re.sFG))
            }
            ,
            ve.\u0275cmp = re.VBU({
                type: ve,
                selectors: [["pp-poster-stars"]],
                features: [re.Vt3],
                decls: 7,
                vars: 8,
                consts: [["posterWrapper", ""], ["starsSvg", ""], [3, "background"], [3, "poster", 4, "ngIf"], [4, "ngIf"], [3, "poster"], [3, "internalPadding", "internalBorder", "internalBorderColor"], [1, "stars-instance"], [1, "background-area"], [1, "stars-area"], [1, "stars-svg", 3, "preview", "innerHTML"], [3, "appConfiguration", "location", "skyConfiguration"], [3, "showPreview", "previewType", "marginTop"], [1, "punching-die"], [3, "poster", "color", "textArea", "title", "subtitle", "footer", "date"], ["class", "sign", "pretext", "", 3, "fontFamily", "fontSize", "lineHeight", "marginBottom", 4, "ngIf"], [1, "stars-svg", 3, "innerHTML"], [3, "svgStyle", "src"], [1, "punching-die-hearts", 3, "svgStyle", "src"], [1, "shield-image"], [1, "shield-image-to-style", 3, "svgStyle", "src"], [1, "special-shield", 3, "marginTop", "height"], [1, "special-shield"], [1, "special-shield-image-to-style", 3, "svgStyle", "src"], ["pretext", "", 1, "sign"], ["shape-rendering", "geometricPrecision", 2, "position", "absolute"], ["id", "circleClipPath", "clipPathUnits", "objectBoundingBox"], ["fill", "white"], [2, "top", "0", "position", "absolute"], ["id", "heartClipPath"], ["fill", "white", "d", "M1666.1,954.9h0s-56.1,217.2-319.8,454c-238.8,214.4-457.8,325.9-457.8,325.9,0,0-219-111.5-457.8-325.9-263.6-236.7-319.8-454-319.8-454-89.7-290.5,54-462.9,54-462.9,0,0,136.4-188.9,368.9-188.9s354.6,209.8,354.6,209.8c0,0,122.1-209.8,354.6-209.8s368.9,188.9,368.9,188.9c0,0,143.7,172.4,54,462.9h.2Z"]],
                template: function(de, lt) {
                    if (1 & de && (re.j41(0, "pp-poster-background", 2, 0),
                    re.DNE(2, Et, 23, 72, "pp-poster-printing-registration", 3),
                    re.nI1(3, "async"),
                    re.k0s(),
                    re.DNE(4, Kt, 1, 0, "pp-poster-loaded-element", 4)(5, At, 13, 9),
                    re.nI1(6, "async")),
                    2 & de) {
                        let St;
                        re.Y8G("background", lt.stars.background),
                        re.R7$(2),
                        re.Y8G("ngIf", re.bMT(3, 4, lt.poster$)),
                        re.R7$(2),
                        re.Y8G("ngIf", lt.isImageRendered),
                        re.R7$(),
                        re.vxM((St = re.bMT(6, 6, lt.poster$)) ? 5 : -1, St)
                    }
                },
                dependencies: [Wt.MD, Wt.bT, Wt.Jj, r.Z, Mt.R, so.c, s.y, Me.Y, Ae.iu, Ae.DM, ct.W, Ce.C, et.P],
                styles: ["[_nghost-%COMP%]{width:100%;height:100%;display:block}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]{box-sizing:border-box;position:relative;overflow:hidden}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .background-area[_ngcontent-%COMP%]{width:100%;height:100%;box-sizing:border-box;margin:auto}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .background-area[_ngcontent-%COMP%]   .circle-background[_ngcontent-%COMP%]{width:100%;height:100%;border-radius:50%;box-sizing:border-box}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .background-area[_ngcontent-%COMP%]   .heart-background[_ngcontent-%COMP%]{width:100%;height:100%;box-sizing:border-box}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .stars-area[_ngcontent-%COMP%]{margin:auto;position:absolute;top:0;right:0;bottom:0;left:0;overflow:hidden;border-radius:50%}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]{position:absolute;top:0;right:0;bottom:0;left:0}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .punching-die[_ngcontent-%COMP%]   .punching-die-hearts[_ngcontent-%COMP%]{position:absolute;top:-2px;right:-2px;bottom:-2px;left:-2px}[_nghost-%COMP%]   .stars-instance[_ngcontent-%COMP%]   .shield-image[_ngcontent-%COMP%]{position:absolute;top:0;right:0;bottom:0;left:0}[_nghost-%COMP%]   .sign[_ngcontent-%COMP%]{display:flex;width:100%;justify-content:center;color:red}.stars-svg[_ngcontent-%COMP%]{width:100%;height:100%;box-sizing:border-box}.stars-svg[_ngcontent-%COMP%]     svg{width:100%;height:100%}.stars-svg[_ngcontent-%COMP%]     svg g#planesecliptic path{stroke-width:2.2222220833px;vector-effect:non-scaling-stroke!important;stroke-dasharray:66 61.2500000005}.stars-svg[_ngcontent-%COMP%]     svg g#constLines path{stroke-width:2.2222220833px;vector-effect:non-scaling-stroke!important}.stars-svg[_ngcontent-%COMP%]     svg g#gridLines path{stroke-width:1.1104166667px;vector-effect:non-scaling-stroke!important}.stars-svg.preview[_ngcontent-%COMP%]     svg g#constLines path, .stars-svg.preview[_ngcontent-%COMP%]     svg g#planesecliptic path{stroke-width:.5333333px}.stars-svg.preview[_ngcontent-%COMP%]     svg g#gridLines path{stroke-width:.2665px}.special-shield[_ngcontent-%COMP%]{position:absolute;top:0;left:0;right:0;bottom:0}  .special-punching-die.special-sky pp-poster-stars-area canvas{background:#0c3159}  .special-punching-die.special-sky .stars-svg svg{background:#0c3159}  .special-punching-die.special-emerald pp-poster-stars-area canvas{background:#123843}  .special-punching-die.special-emerald .stars-svg svg{background:#123843}  .special-punching-die.special-purple-galaxy pp-poster-stars-area canvas{background:#151d46}  .special-punching-die.special-purple-galaxy .stars-svg svg{background:#151d46}  .special-punching-die.special-heart canvas,   .special-punching-die.special-heart svg{-webkit-mask:url(#heartClipPath);mask:url(#heartClipPath)}  .special-punching-die.special-circle canvas,   .special-punching-die.special-circle svg{-webkit-mask:url(#circleClipPath);mask:url(#circleClipPath)}"]
            }),
            ne
        }
        )()
    }
    ,
    88455: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            A: () => so
        });
        var Ut = $(10467)
          , r = $(27617);
        const Mt = new Set;
        function so(_t) {
            return Wt.apply(this, arguments)
        }
        function Wt() {
            return (Wt = (0,
            Ut.A)(function*(_t) {
                if (Mt.has(_t))
                    return;
                const Ae = (_t => {
                    switch (_t) {
                    case r.n3q.LEANDER_SCRIPT_PRO:
                        return "/assets/pp-posters/fonts/leanderscriptpro-regular.otf";
                    case r.n3q.MEDINA_SCRIPT:
                        return "/assets/pp-posters/fonts/Madina-Script.ttf";
                    case r.n3q.PROXIMA_NOVA:
                        return "/assets/pp-posters/fonts/proximanova-regular.otf";
                    case r.n3q.SOURCE_CODE_PRO:
                        return "/assets/pp-posters/fonts/SourceCodePro-Regular.ttf";
                    case r.n3q.MACHO:
                        return "/assets/pp-posters/fonts/Macho-Regular.woff";
                    case r.n3q.EB_GARAMOND:
                        return "/assets/pp-posters/fonts/EBGaramond-Regular.ttf";
                    case r.n3q.EB_GARAMOND_BOLD:
                        return "/assets/pp-posters/fonts/EBGaramond-Bold.ttf";
                    case r.n3q.MONTSERRAT_EXTRABOLD:
                        return "/assets/pp-posters/fonts/Montserrat-ExtraBold.ttf";
                    case r.n3q.MONTSERRAT_MEDIUM:
                        return "/assets/pp-posters/fonts/Montserrat-Medium.ttf";
                    case r.n3q.MONTSERRAT_THIN:
                        return "/assets/pp-posters/fonts/Montserrat-Thin.ttf";
                    case r.n3q.MONTSERRAT_LIGHT:
                        return "/assets/pp-posters/fonts/Montserrat-Light.ttf";
                    case r.n3q.ABRIL_FATFACE_REGULAR:
                        return "/assets/pp-posters/fonts/AbrilFatface-Regular.ttf";
                    case r.n3q.EB_GARAMOND_SEMIBOLD:
                        return "/assets/pp-posters/fonts/EBGaramond-SemiBold.ttf";
                    case r.n3q.CAPSUULA:
                        return "/assets/pp-posters/fonts/Capsuula.ttf";
                    case r.n3q.CAPSUULA_BOLD:
                        return "/assets/pp-posters/fonts/Capsuula-bold.ttf";
                    case r.n3q.YESEVA_ONE:
                        return "/assets/pp-posters/fonts/YesevaOne-Regular.ttf";
                    case r.n3q.LUXUS_BRUT:
                        return "/assets/pp-posters/fonts/LuxusBrut.otf";
                    case r.n3q.POSITIVE_PRINTS_SCRIPT_2:
                        return "/assets/pp-posters/fonts/positive-prints-script-2.otf";
                    case r.n3q.POSITIVE_PRINTS_SCRIPT:
                        return "/assets/pp-posters/fonts/PositivePrintsScript.ttf";
                    case r.n3q.DEJAVU_SANS:
                        return "/assets/pp-posters/fonts/DejaVuSans.ttf";
                    case r.n3q.ROOBERT:
                        return "/assets/pp-posters/fonts/roobert-regular.otf";
                    case r.n3q.ROBOTO_THIN:
                        return "/assets/pp-posters/fonts/Roboto-Thin.ttf";
                    case r.n3q.SOPHIA_RONALD:
                        return "/assets/pp-posters/fonts/SophiaRonald.ttf";
                    case r.n3q.HELLO_OCTOBER:
                        return "/assets/pp-posters/fonts/Hello_October.otf";
                    case r.n3q.SIGNATURE_FONT:
                        return "/assets/pp-posters/fonts/SignatureFont.otf";
                    case r.n3q.MENLO_REGULAR:
                        return "/assets/pp-posters/fonts/MenloRegular.ttf";
                    case r.n3q.MENLO_BOLD_ITALIC:
                        return "/assets/pp-posters/fonts/MenloBoldItalic.ttf";
                    default:
                        return _t
                    }
                }
                )(_t)
                  , Me = new FontFace(_t,"url(".concat(Ae, ")"));
                yield Me.load(),
                document.fonts.add(Me),
                Mt.add(_t)
            })).apply(this, arguments)
        }
    }
    ,
    91054: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            c: () => ze
        });
        var Ut = $(10467)
          , r = $(54438)
          , Mt = $(60177)
          , s = $(84412)
          , so = $(21413)
          , Wt = $(84572)
          , _t = $(5964)
          , Ae = $(23294)
          , Me = $(56977)
          , ct = $(54843)
          , Qe = ($(27617),
        $(49427))
          , jt = $(81836)
          , Xe = $(73955)
          , Ce = $(21626)
          , it = $(345);
        const et = ["charComponents"]
          , re = () => [".jpeg", ".jpg", ".png", ".heic"];
        function pt(ge, Ie) {
            1 & ge && (r.j41(0, "div", 2),
            r.nrm(1, "img", 4),
            r.k0s())
        }
        function Be(ge, Ie) {
            if (1 & ge) {
                const gt = r.RV6();
                r.j41(0, "pp-controls-file-uploader-photo", 5),
                r.nI1(1, "translate"),
                r.bIt("openAdvancedOptions", function() {
                    r.eBV(gt);
                    const yt = r.XpG();
                    return r.Njj(yt.openAdvancedOptions.emit(yt.charId))
                })("setFileUploadingProgress", function() {
                    r.eBV(gt);
                    const yt = r.XpG();
                    return r.Njj(yt.setFileUploadingProgress.emit(yt.charId))
                })("openErrorMsg", function(yt) {
                    r.eBV(gt);
                    const ht = r.XpG();
                    return r.Njj(ht.openErrorMsg.emit(yt))
                }),
                r.k0s()
            }
            if (2 & ge) {
                const gt = r.XpG();
                r.Y8G("photoFileGroup", gt.photoFileGroup)("photoCropGroup", gt.photoCropGroup)("photoId", gt.charId)("multiFile", gt.multiFile)("defaultZoom", gt.letterDefaultZoom)("isSubmitted", !1)("onlySingleInput", gt.onlySingleInput)("acceptable", r.lJ4(16, re))("isBase64Response", !0)("fullHeight", !0)("isBigPictureMode", !0)("showUploadInfoText", gt.showUploadInfoText)("isFileUploadingInProgress", gt.isFileUploadingInProgress)("legalNote", r.bMT(1, 14, "soundwave.details.instruction"))
            }
        }
        let ze = ( () => {
            var ge;
            class Ie {
                set character(Ye) {
                    this.character$.next(Ye)
                }
                set imageUrl(Ye) {
                    this.imageUrl$.next(Ye)
                }
                set readyToLoad(Ye) {
                    this.readyToLoad$.next(Ye)
                }
                set imageId(Ye) {
                    this.imageId$.next(Ye)
                }
                constructor(Ye, yt, ht) {
                    this.httpClient = Ye,
                    this.domSanitizer = yt,
                    this.host = ht,
                    this.isFinalPoster = !1,
                    this.multiFile = !1,
                    this.isFileUploadingInProgress = !1,
                    this.isInteractive = !1,
                    this.setFileUploadingProgress = new r.bkB,
                    this.openErrorMsg = new r.bkB,
                    this.openAdvancedOptions = new r.bkB,
                    this.selectPhoto = new r.bkB,
                    this.photoLoaded = new r.bkB,
                    this.fillWhite = !1,
                    this.showUploadInfoText = !1,
                    this.letterDefaultZoom = jt.X1,
                    this.onlySingleInput = !0,
                    this.character$ = new s.t(null),
                    this.readyToLoad$ = new s.t(!1),
                    this.imageUrl$ = new s.t(null),
                    this.imageId$ = new s.t(null),
                    this.openHideModal = !1,
                    this.ngUnsubscribe = new so.B,
                    this.svgContent = ""
                }
                selectLetter(Ye) {
                    this.imageUrl$.value && this.letterSupportUpload() && this.selectPhoto.emit({
                        photoId: Ye,
                        imageInstanceSize: {
                            width: this.host.nativeElement.offsetWidth,
                            height: this.host.nativeElement.offsetHeight
                        }
                    })
                }
                ngOnInit() {
                    var Ye = this;
                    (0,
                    Wt.z)([this.character$, this.imageUrl$, this.readyToLoad$]).pipe((0,
                    _t.p)( ([,,yt]) => !!yt), (0,
                    Ae.F)( ([yt,ht], [mo,no]) => yt === mo && ht === no), (0,
                    Me.Q)(this.ngUnsubscribe)).subscribe(function() {
                        var yt = (0,
                        Ut.A)(function*([ht,mo]) {
                            if (!ht)
                                return;
                            const no = Ye.charactersDefinition[ht.toUpperCase()];
                            let Co = yield(0,
                            ct._)(Ye.httpClient.get("".concat(Ye.svgCharFilesPath, "/").concat(no.name, ".svg"), {
                                responseType: "text"
                            }));
                            if (mo) {
                                const Lt = yield(0,
                                ct._)(Ye.httpClient.get(mo, {
                                    responseType: "blob"
                                }))
                                  , Ft = yield function ye(ge) {
                                    return new Promise( (Ie, gt) => {
                                        const Ye = new FileReader;
                                        Ye.onloadend = () => {
                                            Ie(Ye.result.split(",")[1])
                                        }
                                        ,
                                        Ye.onerror = gt,
                                        Ye.readAsDataURL(ge)
                                    }
                                    )
                                }(Lt);
                                Co = Co.replace('href=""', 'href="data:image/jpeg;base64,'.concat(Ft, '"')),
                                Ye.careAboutSvgVisibility()
                            } else
                                Co = Co.replace('href=""', Ye.fillWhite ? 'href="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw=="' : 'href="data:image/gif;base64,R0lGODlhAQABAIAAAMLCwgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw=="');
                            Ye.svgContent = Ye.domSanitizer.bypassSecurityTrustHtml(Co)
                        });
                        return function(ht) {
                            return yt.apply(this, arguments)
                        }
                    }())
                }
                cropsAccess(Ye) {
                    var yt;
                    return null === (yt = this.photoCropGroup) || void 0 === yt ? void 0 : yt.at(Ye)
                }
                photoAccess(Ye) {
                    return this.photoFileGroup.at(Ye)
                }
                letterSupportUpload() {
                    var Ye, yt;
                    const ht = null !== (Ye = null === (yt = this.character$.getValue()) || void 0 === yt ? void 0 : yt.toUpperCase()) && void 0 !== Ye ? Ye : "A";
                    return !this.charactersDefinition[ht].withoutPhoto
                }
                careAboutSvgVisibility() {
                    var Ye;
                    const yt = null === (Ye = this.charComponents) || void 0 === Ye || null === (Ye = Ye.nativeElement) || void 0 === Ye ? void 0 : Ye.querySelector("svg");
                    (null == yt ? void 0 : yt.querySelector("image")) ? this.photoLoaded.emit() : setTimeout( () => {
                        this.careAboutSvgVisibility()
                    }
                    , 100)
                }
                ngOnDestroy() {
                    this.ngUnsubscribe.next(!0),
                    this.ngUnsubscribe.complete()
                }
            }
            return (ge = Ie).\u0275fac = function(Ye) {
                return new (Ye || ge)(r.rXU(Ce.Qq),r.rXU(it.up),r.rXU(r.aKT))
            }
            ,
            ge.\u0275cmp = r.VBU({
                type: ge,
                selectors: [["pp-poster-character"]],
                viewQuery: function(Ye, yt) {
                    if (1 & Ye && r.GBs(et, 5),
                    2 & Ye) {
                        let ht;
                        r.mGM(ht = r.lsd()) && (yt.charComponents = ht.first)
                    }
                },
                inputs: {
                    isFinalPoster: "isFinalPoster",
                    character: "character",
                    imageUrl: "imageUrl",
                    readyToLoad: "readyToLoad",
                    imageId: "imageId",
                    svgCharFilesPath: "svgCharFilesPath",
                    charactersDefinition: "charactersDefinition",
                    photoFileGroup: "photoFileGroup",
                    photoCropGroup: "photoCropGroup",
                    multiFile: "multiFile",
                    isFileUploadingInProgress: "isFileUploadingInProgress",
                    isInteractive: "isInteractive",
                    charId: "charId",
                    fillWhite: "fillWhite",
                    showUploadInfoText: "showUploadInfoText",
                    letterDefaultZoom: "letterDefaultZoom",
                    onlySingleInput: "onlySingleInput"
                },
                outputs: {
                    setFileUploadingProgress: "setFileUploadingProgress",
                    openErrorMsg: "openErrorMsg",
                    openAdvancedOptions: "openAdvancedOptions",
                    selectPhoto: "selectPhoto",
                    photoLoaded: "photoLoaded"
                },
                decls: 6,
                vars: 9,
                consts: [["charComponents", ""], [1, "pp-poster-character", 3, "click", "innerHTML"], [1, "warning-wrapper"], [3, "photoFileGroup", "photoCropGroup", "photoId", "multiFile", "defaultZoom", "isSubmitted", "onlySingleInput", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "showUploadInfoText", "isFileUploadingInProgress", "legalNote", "openAdvancedOptions", "setFileUploadingProgress", "openErrorMsg", 4, "ngIf"], ["src", "/assets/pp-controls/warning.png", 1, "warning-icon"], [3, "openAdvancedOptions", "setFileUploadingProgress", "openErrorMsg", "photoFileGroup", "photoCropGroup", "photoId", "multiFile", "defaultZoom", "isSubmitted", "onlySingleInput", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "showUploadInfoText", "isFileUploadingInProgress", "legalNote"]],
                template: function(Ye, yt) {
                    if (1 & Ye) {
                        const ht = r.RV6();
                        r.j41(0, "div", 1, 0),
                        r.nI1(2, "async"),
                        r.bIt("click", function() {
                            return r.eBV(ht),
                            r.Njj(yt.selectLetter(yt.charId))
                        }),
                        r.k0s(),
                        r.DNE(3, pt, 2, 0, "div", 2)(4, Be, 2, 17, "pp-controls-file-uploader-photo", 3),
                        r.nI1(5, "async")
                    }
                    2 & Ye && (r.AVh("pp-poster-character-to-upload", !r.bMT(2, 5, yt.imageUrl$)),
                    r.Y8G("innerHTML", yt.svgContent, r.npT),
                    r.R7$(3),
                    r.vxM(yt.isInteractive && yt.photoAccess(yt.charId).controls.uuid.value && yt.cropsAccess(yt.charId).controls.dpi.value < 120 ? 3 : -1),
                    r.R7$(),
                    r.Y8G("ngIf", yt.photoFileGroup && yt.photoCropGroup && !r.bMT(5, 7, yt.imageUrl$) && yt.letterSupportUpload()))
                },
                dependencies: [Mt.MD, Mt.bT, Mt.Jj, Qe.ex, Xe.h, Xe.D9],
                styles: ["[_nghost-%COMP%]{width:100%;height:100%;position:absolute;overflow:hidden}[_nghost-%COMP%]   .warning-wrapper[_ngcontent-%COMP%]{width:100%;height:100%;display:flex;justify-content:center;align-items:center;pointer-events:none}[_nghost-%COMP%]   .warning-wrapper[_ngcontent-%COMP%]   .warning-icon[_ngcontent-%COMP%]{position:relative;width:27px;height:25px;pointer-events:none}[_nghost-%COMP%]   img[_ngcontent-%COMP%]{position:absolute;left:0;top:0;width:100%;height:100%;object-fit:cover}[_nghost-%COMP%]   .pp-poster-character.pp-poster-character-to-upload[_ngcontent-%COMP%]{pointer-events:none}[_nghost-%COMP%]     .pp-poster-character{position:absolute;left:0;top:0;width:100%;height:100%;display:flex;justify-content:center}[_nghost-%COMP%]     .pp-poster-character svg{height:100%}[_nghost-%COMP%]     .pp-poster-character svg path.cover{display:none}"]
            }),
            Ie
        }
        )()
    }
    ,
    92034: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            t: () => yc
        });
        var Ut = $(10467)
          , r = $(54438)
          , Mt = $(7494)
          , s = $(9566)
          , so = $(13620)
          , Wt = $(61762)
          , _t = $(69847)
          , Ae = $(60177)
          , Me = $(27617)
          , ct = $(50552)
          , Xe = $(84572)
          , Ce = $(56977)
          , it = $(54843);
        const {min: et, max: re} = Math
          , pt = (U, V=0, te=1) => et(re(V, U), te)
          , Be = U => {
            U._clipped = !1,
            U._unclipped = U.slice(0);
            for (let V = 0; V <= 3; V++)
                V < 3 ? ((U[V] < 0 || U[V] > 255) && (U._clipped = !0),
                U[V] = pt(U[V], 0, 255)) : 3 === V && (U[V] = pt(U[V], 0, 1));
            return U
        }
          , ze = {};
        for (let U of ["Boolean", "Number", "String", "Function", "Array", "Date", "RegExp", "Undefined", "Null"])
            ze["[object ".concat(U, "]")] = U.toLowerCase();
        function ye(U) {
            return ze[Object.prototype.toString.call(U)] || "object"
        }
        const ge = (U, V=null) => U.length >= 3 ? Array.prototype.slice.call(U) : "object" == ye(U[0]) && V ? V.split("").filter(te => void 0 !== U[0][te]).map(te => U[0][te]) : U[0].slice(0)
          , Ie = U => {
            if (U.length < 2)
                return null;
            const V = U.length - 1;
            return "string" == ye(U[V]) ? U[V].toLowerCase() : null
        }
          , {PI: gt, min: Ye, max: yt} = Math
          , ht = U => Math.round(100 * U) / 100
          , mo = U => Math.round(100 * U) / 100
          , no = 2 * gt
          , Co = gt / 3
          , Lt = gt / 180
          , Ft = 180 / gt;
        function co(U) {
            return [...U.slice(0, 3).reverse(), ...U.slice(3)]
        }
        const Jt = {
            format: {},
            autodetect: []
        }
          , Et = class po {
            constructor(...V) {
                const te = this;
                if ("object" === ye(V[0]) && V[0].constructor && V[0].constructor === this.constructor)
                    return V[0];
                let Q = Ie(V)
                  , ce = !1;
                if (!Q) {
                    ce = !0,
                    Jt.sorted || (Jt.autodetect = Jt.autodetect.sort( (xe, Je) => Je.p - xe.p),
                    Jt.sorted = !0);
                    for (let xe of Jt.autodetect)
                        if (Q = xe.test(...V),
                        Q)
                            break
                }
                if (!Jt.format[Q])
                    throw new Error("unknown format: " + V);
                {
                    const xe = Jt.format[Q].apply(null, ce ? V : V.slice(0, -1));
                    te._rgb = Be(xe)
                }
                3 === te._rgb.length && te._rgb.push(1)
            }
            toString() {
                return "function" == ye(this.hex) ? this.hex() : "[".concat(this._rgb.join(","), "]")
            }
        }
          , At = (...U) => new Et(...U);
        At.version = "3.1.2";
        const Re = At
          , ne = {
            aliceblue: "#f0f8ff",
            antiquewhite: "#faebd7",
            aqua: "#00ffff",
            aquamarine: "#7fffd4",
            azure: "#f0ffff",
            beige: "#f5f5dc",
            bisque: "#ffe4c4",
            black: "#000000",
            blanchedalmond: "#ffebcd",
            blue: "#0000ff",
            blueviolet: "#8a2be2",
            brown: "#a52a2a",
            burlywood: "#deb887",
            cadetblue: "#5f9ea0",
            chartreuse: "#7fff00",
            chocolate: "#d2691e",
            coral: "#ff7f50",
            cornflowerblue: "#6495ed",
            cornsilk: "#fff8dc",
            crimson: "#dc143c",
            cyan: "#00ffff",
            darkblue: "#00008b",
            darkcyan: "#008b8b",
            darkgoldenrod: "#b8860b",
            darkgray: "#a9a9a9",
            darkgreen: "#006400",
            darkgrey: "#a9a9a9",
            darkkhaki: "#bdb76b",
            darkmagenta: "#8b008b",
            darkolivegreen: "#556b2f",
            darkorange: "#ff8c00",
            darkorchid: "#9932cc",
            darkred: "#8b0000",
            darksalmon: "#e9967a",
            darkseagreen: "#8fbc8f",
            darkslateblue: "#483d8b",
            darkslategray: "#2f4f4f",
            darkslategrey: "#2f4f4f",
            darkturquoise: "#00ced1",
            darkviolet: "#9400d3",
            deeppink: "#ff1493",
            deepskyblue: "#00bfff",
            dimgray: "#696969",
            dimgrey: "#696969",
            dodgerblue: "#1e90ff",
            firebrick: "#b22222",
            floralwhite: "#fffaf0",
            forestgreen: "#228b22",
            fuchsia: "#ff00ff",
            gainsboro: "#dcdcdc",
            ghostwhite: "#f8f8ff",
            gold: "#ffd700",
            goldenrod: "#daa520",
            gray: "#808080",
            green: "#008000",
            greenyellow: "#adff2f",
            grey: "#808080",
            honeydew: "#f0fff0",
            hotpink: "#ff69b4",
            indianred: "#cd5c5c",
            indigo: "#4b0082",
            ivory: "#fffff0",
            khaki: "#f0e68c",
            laserlemon: "#ffff54",
            lavender: "#e6e6fa",
            lavenderblush: "#fff0f5",
            lawngreen: "#7cfc00",
            lemonchiffon: "#fffacd",
            lightblue: "#add8e6",
            lightcoral: "#f08080",
            lightcyan: "#e0ffff",
            lightgoldenrod: "#fafad2",
            lightgoldenrodyellow: "#fafad2",
            lightgray: "#d3d3d3",
            lightgreen: "#90ee90",
            lightgrey: "#d3d3d3",
            lightpink: "#ffb6c1",
            lightsalmon: "#ffa07a",
            lightseagreen: "#20b2aa",
            lightskyblue: "#87cefa",
            lightslategray: "#778899",
            lightslategrey: "#778899",
            lightsteelblue: "#b0c4de",
            lightyellow: "#ffffe0",
            lime: "#00ff00",
            limegreen: "#32cd32",
            linen: "#faf0e6",
            magenta: "#ff00ff",
            maroon: "#800000",
            maroon2: "#7f0000",
            maroon3: "#b03060",
            mediumaquamarine: "#66cdaa",
            mediumblue: "#0000cd",
            mediumorchid: "#ba55d3",
            mediumpurple: "#9370db",
            mediumseagreen: "#3cb371",
            mediumslateblue: "#7b68ee",
            mediumspringgreen: "#00fa9a",
            mediumturquoise: "#48d1cc",
            mediumvioletred: "#c71585",
            midnightblue: "#191970",
            mintcream: "#f5fffa",
            mistyrose: "#ffe4e1",
            moccasin: "#ffe4b5",
            navajowhite: "#ffdead",
            navy: "#000080",
            oldlace: "#fdf5e6",
            olive: "#808000",
            olivedrab: "#6b8e23",
            orange: "#ffa500",
            orangered: "#ff4500",
            orchid: "#da70d6",
            palegoldenrod: "#eee8aa",
            palegreen: "#98fb98",
            paleturquoise: "#afeeee",
            palevioletred: "#db7093",
            papayawhip: "#ffefd5",
            peachpuff: "#ffdab9",
            peru: "#cd853f",
            pink: "#ffc0cb",
            plum: "#dda0dd",
            powderblue: "#b0e0e6",
            purple: "#800080",
            purple2: "#7f007f",
            purple3: "#a020f0",
            rebeccapurple: "#663399",
            red: "#ff0000",
            rosybrown: "#bc8f8f",
            royalblue: "#4169e1",
            saddlebrown: "#8b4513",
            salmon: "#fa8072",
            sandybrown: "#f4a460",
            seagreen: "#2e8b57",
            seashell: "#fff5ee",
            sienna: "#a0522d",
            silver: "#c0c0c0",
            skyblue: "#87ceeb",
            slateblue: "#6a5acd",
            slategray: "#708090",
            slategrey: "#708090",
            snow: "#fffafa",
            springgreen: "#00ff7f",
            steelblue: "#4682b4",
            tan: "#d2b48c",
            teal: "#008080",
            thistle: "#d8bfd8",
            tomato: "#ff6347",
            turquoise: "#40e0d0",
            violet: "#ee82ee",
            wheat: "#f5deb3",
            white: "#ffffff",
            whitesmoke: "#f5f5f5",
            yellow: "#ffff00",
            yellowgreen: "#9acd32"
        }
          , B = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/
          , de = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/
          , St = U => {
            if (U.match(B)) {
                (4 === U.length || 7 === U.length) && (U = U.substr(1)),
                3 === U.length && (U = (U = U.split(""))[0] + U[0] + U[1] + U[1] + U[2] + U[2]);
                const V = parseInt(U, 16);
                return [V >> 16, V >> 8 & 255, 255 & V, 1]
            }
            if (U.match(de)) {
                (5 === U.length || 9 === U.length) && (U = U.substr(1)),
                4 === U.length && (U = (U = U.split(""))[0] + U[0] + U[1] + U[1] + U[2] + U[2] + U[3] + U[3]);
                const V = parseInt(U, 16);
                return [V >> 24 & 255, V >> 16 & 255, V >> 8 & 255, Math.round((255 & V) / 255 * 100) / 100]
            }
            throw new Error("unknown hex color: ".concat(U))
        }
          , {round: tt} = Math
          , Nt = (...U) => {
            let[V,te,Q,ce] = ge(U, "rgba")
              , xe = Ie(U) || "auto";
            void 0 === ce && (ce = 1),
            "auto" === xe && (xe = ce < 1 ? "rgba" : "rgb"),
            V = tt(V),
            te = tt(te),
            Q = tt(Q);
            let Fe = "000000" + (V << 16 | te << 8 | Q).toString(16);
            Fe = Fe.substr(Fe.length - 6);
            let It = "0" + tt(255 * ce).toString(16);
            switch (It = It.substr(It.length - 2),
            xe.toLowerCase()) {
            case "rgba":
                return "#".concat(Fe).concat(It);
            case "argb":
                return "#".concat(It).concat(Fe);
            default:
                return "#".concat(Fe)
            }
        }
        ;
        Et.prototype.name = function() {
            const U = Nt(this._rgb, "rgb");
            for (let V of Object.keys(ne))
                if (ne[V] === U)
                    return V.toLowerCase();
            return U
        }
        ,
        Jt.format.named = U => {
            if (U = U.toLowerCase(),
            ne[U])
                return St(ne[U]);
            throw new Error("unknown color name: " + U)
        }
        ,
        Jt.autodetect.push({
            p: 5,
            test: (U, ...V) => {
                if (!V.length && "string" === ye(U) && ne[U.toLowerCase()])
                    return "named"
            }
        }),
        Et.prototype.alpha = function(U, V=!1) {
            return void 0 !== U && "number" === ye(U) ? V ? (this._rgb[3] = U,
            this) : new Et([this._rgb[0], this._rgb[1], this._rgb[2], U],"rgb") : this._rgb[3]
        }
        ,
        Et.prototype.clipped = function() {
            return this._rgb._clipped || !1
        }
        ;
        const Vt = {
            Kn: 18,
            labWhitePoint: "d65",
            Xn: .95047,
            Yn: 1,
            Zn: 1.08883,
            t0: .137931034,
            t1: .206896552,
            t2: .12841855,
            t3: .008856452,
            kE: 216 / 24389,
            kKE: 8,
            kK: 24389 / 27,
            RefWhiteRGB: {
                X: .95047,
                Y: 1,
                Z: 1.08883
            },
            MtxRGB2XYZ: {
                m00: .4124564390896922,
                m01: .21267285140562253,
                m02: .0193338955823293,
                m10: .357576077643909,
                m11: .715152155287818,
                m12: .11919202588130297,
                m20: .18043748326639894,
                m21: .07217499330655958,
                m22: .9503040785363679
            },
            MtxXYZ2RGB: {
                m00: 3.2404541621141045,
                m01: -.9692660305051868,
                m02: .055643430959114726,
                m10: -1.5371385127977166,
                m11: 1.8760108454466942,
                m12: -.2040259135167538,
                m20: -.498531409556016,
                m21: .041556017530349834,
                m22: 1.0572251882231791
            },
            As: .9414285350000001,
            Bs: 1.040417467,
            Cs: 1.089532651,
            MtxAdaptMa: {
                m00: .8951,
                m01: -.7502,
                m02: .0389,
                m10: .2664,
                m11: 1.7135,
                m12: -.0685,
                m20: -.1614,
                m21: .0367,
                m22: 1.0296
            },
            MtxAdaptMaI: {
                m00: .9869929054667123,
                m01: .43230526972339456,
                m02: -.008528664575177328,
                m10: -.14705425642099013,
                m11: .5183602715367776,
                m12: .04004282165408487,
                m20: .15996265166373125,
                m21: .0492912282128556,
                m22: .9684866957875502
            }
        }
          , _o = Vt
          , Lo = new Map([["a", [1.0985, .35585]], ["b", [1.0985, .35585]], ["c", [.98074, 1.18232]], ["d50", [.96422, .82521]], ["d55", [.95682, .92149]], ["d65", [.95047, 1.08883]], ["e", [1, 1, 1]], ["f2", [.99186, .67393]], ["f7", [.95041, 1.08747]], ["f11", [1.00962, .6435]], ["icc", [.96422, .82521]]]);
        function ao(U) {
            const V = Lo.get(String(U).toLowerCase());
            if (!V)
                throw new Error("unknown Lab illuminant " + U);
            Vt.labWhitePoint = U,
            Vt.Xn = V[0],
            Vt.Zn = V[1]
        }
        function bt() {
            return Vt.labWhitePoint
        }
        const ie = U => {
            const V = Math.sign(U);
            return ((U = Math.abs(U)) <= .0031308 ? 12.92 * U : 1.055 * Math.pow(U, 1 / 2.4) - .055) * V
        }
          , we = (U, V, te) => {
            const {MtxAdaptMa: Q, MtxAdaptMaI: ce, MtxXYZ2RGB: xe, RefWhiteRGB: Je, Xn: Fe, Yn: It, Zn: go} = _o
              , ai = (Je.X * Q.m00 + Je.Y * Q.m10 + Je.Z * Q.m20) / (Fe * Q.m00 + It * Q.m10 + go * Q.m20) * (U * Q.m00 + V * Q.m10 + te * Q.m20)
              , oi = (Je.X * Q.m01 + Je.Y * Q.m11 + Je.Z * Q.m21) / (Fe * Q.m01 + It * Q.m11 + go * Q.m21) * (U * Q.m01 + V * Q.m11 + te * Q.m21)
              , rn = (Je.X * Q.m02 + Je.Y * Q.m12 + Je.Z * Q.m22) / (Fe * Q.m02 + It * Q.m12 + go * Q.m22) * (U * Q.m02 + V * Q.m12 + te * Q.m22)
              , Pn = ai * ce.m00 + oi * ce.m10 + rn * ce.m20
              , _n = ai * ce.m01 + oi * ce.m11 + rn * ce.m21
              , Bn = ai * ce.m02 + oi * ce.m12 + rn * ce.m22;
            return [255 * ie(Pn * xe.m00 + _n * xe.m10 + Bn * xe.m20), 255 * ie(Pn * xe.m01 + _n * xe.m11 + Bn * xe.m21), 255 * ie(Pn * xe.m02 + _n * xe.m12 + Bn * xe.m22)]
        }
          , Oe = (...U) => {
            U = ge(U, "lab");
            const [V,te,Q] = U
              , [ce,xe,Je] = ( (U, V, te) => {
                const {kE: Q, kK: ce, kKE: xe, Xn: Je, Yn: Fe, Zn: It} = _o
                  , go = (U + 16) / 116
                  , yo = .002 * V + go
                  , Io = go - .005 * te
                  , kt = yo * yo * yo
                  , Wo = Io * Io * Io;
                return [(kt > Q ? kt : (116 * yo - 16) / ce) * Je, (U > xe ? Math.pow((U + 16) / 116, 3) : U / ce) * Fe, (Wo > Q ? Wo : (116 * Io - 16) / ce) * It]
            }
            )(V, te, Q)
              , [Fe,It,go] = we(ce, xe, Je);
            return [Fe, It, go, U.length > 3 ? U[3] : 1]
        }
        ;
        function ae(U) {
            const V = Math.sign(U);
            return ((U = Math.abs(U)) <= .04045 ? U / 12.92 : Math.pow((U + .055) / 1.055, 2.4)) * V
        }
        const Ve = (U, V, te) => {
            U = ae(U / 255),
            V = ae(V / 255),
            te = ae(te / 255);
            const {MtxRGB2XYZ: Q, MtxAdaptMa: ce, MtxAdaptMaI: xe, Xn: Je, Yn: Fe, Zn: It, As: go, Bs: yo, Cs: Io} = _o;
            let kt = U * Q.m00 + V * Q.m10 + te * Q.m20
              , Wo = U * Q.m01 + V * Q.m11 + te * Q.m21
              , ti = U * Q.m02 + V * Q.m12 + te * Q.m22
              , rn = kt * ce.m00 + Wo * ce.m10 + ti * ce.m20
              , Pn = kt * ce.m01 + Wo * ce.m11 + ti * ce.m21
              , _n = kt * ce.m02 + Wo * ce.m12 + ti * ce.m22;
            return rn *= (Je * ce.m00 + Fe * ce.m10 + It * ce.m20) / go,
            Pn *= (Je * ce.m01 + Fe * ce.m11 + It * ce.m21) / yo,
            _n *= (Je * ce.m02 + Fe * ce.m12 + It * ce.m22) / Io,
            kt = rn * xe.m00 + Pn * xe.m10 + _n * xe.m20,
            Wo = rn * xe.m01 + Pn * xe.m11 + _n * xe.m21,
            ti = rn * xe.m02 + Pn * xe.m12 + _n * xe.m22,
            [kt, Wo, ti]
        }
          , fe = (...U) => {
            const [V,te,Q,...ce] = ge(U, "rgb")
              , [xe,Je,Fe] = Ve(V, te, Q)
              , [It,go,yo] = function W(U, V, te) {
                const {Xn: Q, Yn: ce, Zn: xe, kE: Je, kK: Fe} = _o
                  , It = U / Q
                  , go = V / ce
                  , yo = te / xe
                  , Io = It > Je ? Math.pow(It, 1 / 3) : (Fe * It + 16) / 116
                  , kt = go > Je ? Math.pow(go, 1 / 3) : (Fe * go + 16) / 116;
                return [116 * kt - 16, 500 * (Io - kt), 200 * (kt - (yo > Je ? Math.pow(yo, 1 / 3) : (Fe * yo + 16) / 116))]
            }(xe, Je, Fe);
            return [It, go, yo, ...ce.length > 0 && ce[0] < 1 ? [ce[0]] : []]
        }
        ;
        Et.prototype.lab = function() {
            return fe(this._rgb)
        }
        ,
        Object.assign(Re, {
            lab: (...U) => new Et(...U,"lab"),
            getLabWhitePoint: bt,
            setLabWhitePoint: ao
        }),
        Jt.format.lab = Oe,
        Jt.autodetect.push({
            p: 2,
            test: (...U) => {
                if ("array" === ye(U = ge(U, "lab")) && 3 === U.length)
                    return "lab"
            }
        }),
        Et.prototype.darken = function(U=1) {
            const te = this.lab();
            return te[0] -= _o.Kn * U,
            new Et(te,"lab").alpha(this.alpha(), !0)
        }
        ,
        Et.prototype.brighten = function(U=1) {
            return this.darken(-U)
        }
        ,
        Et.prototype.darker = Et.prototype.darken,
        Et.prototype.brighter = Et.prototype.brighten,
        Et.prototype.get = function(U) {
            const [V,te] = U.split(".")
              , Q = this[V]();
            if (te) {
                const ce = V.indexOf(te) - ("ok" === V.substr(0, 2) ? 2 : 0);
                if (ce > -1)
                    return Q[ce];
                throw new Error("unknown channel ".concat(te, " in mode ").concat(V))
            }
            return Q
        }
        ;
        const {pow: mt} = Math;
        Et.prototype.luminance = function(U, V="rgb") {
            if (void 0 !== U && "number" === ye(U)) {
                if (0 === U)
                    return new Et([0, 0, 0, this._rgb[3]],"rgb");
                if (1 === U)
                    return new Et([255, 255, 255, this._rgb[3]],"rgb");
                let te = this.luminance()
                  , Q = 20;
                const ce = (Je, Fe) => {
                    const It = Je.interpolate(Fe, .5, V)
                      , go = It.luminance();
                    return Math.abs(U - go) < 1e-7 || !Q-- ? It : go > U ? ce(Je, It) : ce(It, Fe)
                }
                  , xe = (te > U ? ce(new Et([0, 0, 0]), this) : ce(this, new Et([255, 255, 255]))).rgb();
                return new Et([...xe, this._rgb[3]])
            }
            return ro(...this._rgb.slice(0, 3))
        }
        ;
        const ro = (U, V, te) => .2126 * (U = Vo(U)) + .7152 * (V = Vo(V)) + .0722 * Vo(te)
          , Vo = U => (U /= 255) <= .03928 ? U / 12.92 : mt((U + .055) / 1.055, 2.4)
          , vo = {}
          , ei = (U, V, te=.5, ...Q) => {
            let ce = Q[0] || "lrgb";
            if (!vo[ce] && !Q.length && (ce = Object.keys(vo)[0]),
            !vo[ce])
                throw new Error("interpolation mode ".concat(ce, " is not defined"));
            return "object" !== ye(U) && (U = new Et(U)),
            "object" !== ye(V) && (V = new Et(V)),
            vo[ce](U, V, te).alpha(U.alpha() + te * (V.alpha() - U.alpha()))
        }
        ;
        Et.prototype.mix = Et.prototype.interpolate = function(U, V=.5, ...te) {
            return ei(this, U, V, ...te)
        }
        ,
        Et.prototype.premultiply = function(U=!1) {
            const V = this._rgb
              , te = V[3];
            return U ? (this._rgb = [V[0] * te, V[1] * te, V[2] * te, te],
            this) : new Et([V[0] * te, V[1] * te, V[2] * te, te],"rgb")
        }
        ;
        const {sin: Ti, cos: ci} = Math
          , yn = (...U) => {
            let[V,te,Q] = ge(U, "lch");
            return isNaN(Q) && (Q = 0),
            Q *= Lt,
            [V, ci(Q) * te, Ti(Q) * te]
        }
          , Ln = (...U) => {
            U = ge(U, "lch");
            const [V,te,Q] = U
              , [ce,xe,Je] = yn(V, te, Q)
              , [Fe,It,go] = Oe(ce, xe, Je);
            return [Fe, It, go, U.length > 3 ? U[3] : 1]
        }
          , {sqrt: Z, atan2: se, round: Ee} = Math
          , oe = (...U) => {
            const [V,te,Q] = ge(U, "lab")
              , ce = Z(te * te + Q * Q);
            let xe = (se(Q, te) * Ft + 360) % 360;
            return 0 === Ee(1e4 * ce) && (xe = Number.NaN),
            [V, ce, xe]
        }
          , J = (...U) => {
            const [V,te,Q,...ce] = ge(U, "rgb")
              , [xe,Je,Fe] = fe(V, te, Q)
              , [It,go,yo] = oe(xe, Je, Fe);
            return [It, go, yo, ...ce.length > 0 && ce[0] < 1 ? [ce[0]] : []]
        }
        ;
        Et.prototype.lch = function() {
            return J(this._rgb)
        }
        ,
        Et.prototype.hcl = function() {
            return co(J(this._rgb))
        }
        ,
        Object.assign(Re, {
            lch: (...U) => new Et(...U,"lch"),
            hcl: (...U) => new Et(...U,"hcl")
        }),
        Jt.format.lch = Ln,
        Jt.format.hcl = (...U) => {
            const V = co(ge(U, "hcl"));
            return Ln(...V)
        }
        ,
        ["lch", "hcl"].forEach(U => Jt.autodetect.push({
            p: 2,
            test: (...V) => {
                if ("array" === ye(V = ge(V, U)) && 3 === V.length)
                    return U
            }
        })),
        Et.prototype.saturate = function(U=1) {
            const te = this.lch();
            return te[1] += _o.Kn * U,
            te[1] < 0 && (te[1] = 0),
            new Et(te,"lch").alpha(this.alpha(), !0)
        }
        ,
        Et.prototype.desaturate = function(U=1) {
            return this.saturate(-U)
        }
        ,
        Et.prototype.set = function(U, V, te=!1) {
            const [Q,ce] = U.split(".")
              , xe = this[Q]();
            if (ce) {
                const Je = Q.indexOf(ce) - ("ok" === Q.substr(0, 2) ? 2 : 0);
                if (Je > -1) {
                    if ("string" == ye(V))
                        switch (V.charAt(0)) {
                        case "+":
                        case "-":
                            xe[Je] += +V;
                            break;
                        case "*":
                            xe[Je] *= +V.substr(1);
                            break;
                        case "/":
                            xe[Je] /= +V.substr(1);
                            break;
                        default:
                            xe[Je] = +V
                        }
                    else {
                        if ("number" !== ye(V))
                            throw new Error("unsupported value for Color.set");
                        xe[Je] = V
                    }
                    const Fe = new Et(xe,Q);
                    return te ? (this._rgb = Fe._rgb,
                    this) : Fe
                }
                throw new Error("unknown channel ".concat(ce, " in mode ").concat(Q))
            }
            return xe
        }
        ,
        Et.prototype.tint = function(U=.5, ...V) {
            return ei(this, "white", U, ...V)
        }
        ,
        Et.prototype.shade = function(U=.5, ...V) {
            return ei(this, "black", U, ...V)
        }
        ,
        vo.rgb = (U, V, te) => {
            const Q = U._rgb
              , ce = V._rgb;
            return new Et(Q[0] + te * (ce[0] - Q[0]),Q[1] + te * (ce[1] - Q[1]),Q[2] + te * (ce[2] - Q[2]),"rgb")
        }
        ;
        const {sqrt: Rt, pow: Qt} = Math;
        vo.lrgb = (U, V, te) => {
            const [Q,ce,xe] = U._rgb
              , [Je,Fe,It] = V._rgb;
            return new Et(Rt(Qt(Q, 2) * (1 - te) + Qt(Je, 2) * te),Rt(Qt(ce, 2) * (1 - te) + Qt(Fe, 2) * te),Rt(Qt(xe, 2) * (1 - te) + Qt(It, 2) * te),"rgb")
        }
        ,
        vo.lab = (U, V, te) => {
            const Q = U.lab()
              , ce = V.lab();
            return new Et(Q[0] + te * (ce[0] - Q[0]),Q[1] + te * (ce[1] - Q[1]),Q[2] + te * (ce[2] - Q[2]),"lab")
        }
        ;
        const Go = (U, V, te, Q) => {
            let ce, xe, Je, Fe, It, go, yo, Io, kt, Wo, ti, Bi;
            return "hsl" === Q ? (ce = U.hsl(),
            xe = V.hsl()) : "hsv" === Q ? (ce = U.hsv(),
            xe = V.hsv()) : "hcg" === Q ? (ce = U.hcg(),
            xe = V.hcg()) : "hsi" === Q ? (ce = U.hsi(),
            xe = V.hsi()) : "lch" === Q || "hcl" === Q ? (Q = "hcl",
            ce = U.hcl(),
            xe = V.hcl()) : "oklch" === Q && (ce = U.oklch().reverse(),
            xe = V.oklch().reverse()),
            ("h" === Q.substr(0, 1) || "oklch" === Q) && ([Je,It,yo] = ce,
            [Fe,go,Io] = xe),
            isNaN(Je) || isNaN(Fe) ? isNaN(Je) ? isNaN(Fe) ? Wo = Number.NaN : (Wo = Fe,
            (1 == yo || 0 == yo) && "hsv" != Q && (kt = go)) : (Wo = Je,
            (1 == Io || 0 == Io) && "hsv" != Q && (kt = It)) : (Bi = Fe > Je && Fe - Je > 180 ? Fe - (Je + 360) : Fe < Je && Je - Fe > 180 ? Fe + 360 - Je : Fe - Je,
            Wo = Je + te * Bi),
            void 0 === kt && (kt = It + te * (go - It)),
            ti = yo + te * (Io - yo),
            new Et("oklch" === Q ? [ti, kt, Wo] : [Wo, kt, ti],Q)
        }
          , Ii = (U, V, te) => Go(U, V, te, "lch");
        vo.lch = Ii,
        vo.hcl = Ii,
        Et.prototype.num = function() {
            return ( (...U) => {
                const [V,te,Q] = ge(U, "rgb");
                return (V << 16) + (te << 8) + Q
            }
            )(this._rgb)
        }
        ,
        Object.assign(Re, {
            num: (...U) => new Et(...U,"num")
        }),
        Jt.format.num = U => {
            if ("number" == ye(U) && U >= 0 && U <= 16777215)
                return [U >> 16, U >> 8 & 255, 255 & U, 1];
            throw new Error("unknown num color: " + U)
        }
        ,
        Jt.autodetect.push({
            p: 5,
            test: (...U) => {
                if (1 === U.length && "number" === ye(U[0]) && U[0] >= 0 && U[0] <= 16777215)
                    return "num"
            }
        }),
        vo.num = (U, V, te) => {
            const Q = U.num()
              , ce = V.num();
            return new Et(Q + te * (ce - Q),"num")
        }
        ;
        const {floor: xs} = Math;
        Et.prototype.hcg = function() {
            return ( (...U) => {
                const [V,te,Q] = ge(U, "rgb")
                  , ce = Ye(V, te, Q)
                  , xe = yt(V, te, Q)
                  , Je = xe - ce;
                let go;
                return 0 === Je ? go = Number.NaN : (V === xe && (go = (te - Q) / Je),
                te === xe && (go = 2 + (Q - V) / Je),
                Q === xe && (go = 4 + (V - te) / Je),
                go *= 60,
                go < 0 && (go += 360)),
                [go, 100 * Je / 255, ce / (255 - Je) * 100]
            }
            )(this._rgb)
        }
        ,
        Re.hcg = (...U) => new Et(...U,"hcg"),
        Jt.format.hcg = (...U) => {
            U = ge(U, "hcg");
            let ce, xe, Je, [V,te,Q] = U;
            Q *= 255;
            const Fe = 255 * te;
            if (0 === te)
                ce = xe = Je = Q;
            else {
                360 === V && (V = 0),
                V > 360 && (V -= 360),
                V < 0 && (V += 360),
                V /= 60;
                const It = xs(V)
                  , go = V - It
                  , yo = Q * (1 - te)
                  , Io = yo + Fe * (1 - go)
                  , kt = yo + Fe * go
                  , Wo = yo + Fe;
                switch (It) {
                case 0:
                    [ce,xe,Je] = [Wo, kt, yo];
                    break;
                case 1:
                    [ce,xe,Je] = [Io, Wo, yo];
                    break;
                case 2:
                    [ce,xe,Je] = [yo, Wo, kt];
                    break;
                case 3:
                    [ce,xe,Je] = [yo, Io, Wo];
                    break;
                case 4:
                    [ce,xe,Je] = [kt, yo, Wo];
                    break;
                case 5:
                    [ce,xe,Je] = [Wo, yo, Io]
                }
            }
            return [ce, xe, Je, U.length > 3 ? U[3] : 1]
        }
        ,
        Jt.autodetect.push({
            p: 1,
            test: (...U) => {
                if ("array" === ye(U = ge(U, "hcg")) && 3 === U.length)
                    return "hcg"
            }
        }),
        vo.hcg = (U, V, te) => Go(U, V, te, "hcg");
        const {cos: fr} = Math
          , {min: Ha, sqrt: wa, acos: Wa} = Math;
        Et.prototype.hsi = function() {
            return ( (...U) => {
                let ce, [V,te,Q] = ge(U, "rgb");
                V /= 255,
                te /= 255,
                Q /= 255;
                const xe = Ha(V, te, Q)
                  , Je = (V + te + Q) / 3
                  , Fe = Je > 0 ? 1 - xe / Je : 0;
                return 0 === Fe ? ce = NaN : (ce = (V - te + (V - Q)) / 2,
                ce /= wa((V - te) * (V - te) + (V - Q) * (te - Q)),
                ce = Wa(ce),
                Q > te && (ce = no - ce),
                ce /= no),
                [360 * ce, Fe, Je]
            }
            )(this._rgb)
        }
        ,
        Re.hsi = (...U) => new Et(...U,"hsi"),
        Jt.format.hsi = (...U) => {
            U = ge(U, "hsi");
            let ce, xe, Je, [V,te,Q] = U;
            return isNaN(V) && (V = 0),
            isNaN(te) && (te = 0),
            V > 360 && (V -= 360),
            V < 0 && (V += 360),
            V /= 360,
            V < 1 / 3 ? (Je = (1 - te) / 3,
            ce = (1 + te * fr(no * V) / fr(Co - no * V)) / 3,
            xe = 1 - (Je + ce)) : V < 2 / 3 ? (V -= 1 / 3,
            ce = (1 - te) / 3,
            xe = (1 + te * fr(no * V) / fr(Co - no * V)) / 3,
            Je = 1 - (ce + xe)) : (V -= 2 / 3,
            xe = (1 - te) / 3,
            Je = (1 + te * fr(no * V) / fr(Co - no * V)) / 3,
            ce = 1 - (xe + Je)),
            ce = pt(Q * ce * 3),
            xe = pt(Q * xe * 3),
            Je = pt(Q * Je * 3),
            [255 * ce, 255 * xe, 255 * Je, U.length > 3 ? U[3] : 1]
        }
        ,
        Jt.autodetect.push({
            p: 2,
            test: (...U) => {
                if ("array" === ye(U = ge(U, "hsi")) && 3 === U.length)
                    return "hsi"
            }
        }),
        vo.hsi = (U, V, te) => Go(U, V, te, "hsi");
        const Vs = (...U) => {
            U = ge(U, "hsl");
            const [V,te,Q] = U;
            let ce, xe, Je;
            if (0 === te)
                ce = xe = Je = 255 * Q;
            else {
                const Fe = [0, 0, 0]
                  , It = [0, 0, 0]
                  , go = Q < .5 ? Q * (1 + te) : Q + te - Q * te
                  , yo = 2 * Q - go
                  , Io = V / 360;
                Fe[0] = Io + 1 / 3,
                Fe[1] = Io,
                Fe[2] = Io - 1 / 3;
                for (let kt = 0; kt < 3; kt++)
                    Fe[kt] < 0 && (Fe[kt] += 1),
                    Fe[kt] > 1 && (Fe[kt] -= 1),
                    It[kt] = 6 * Fe[kt] < 1 ? yo + 6 * (go - yo) * Fe[kt] : 2 * Fe[kt] < 1 ? go : 3 * Fe[kt] < 2 ? yo + (go - yo) * (2 / 3 - Fe[kt]) * 6 : yo;
                [ce,xe,Je] = [255 * It[0], 255 * It[1], 255 * It[2]]
            }
            return U.length > 3 ? [ce, xe, Je, U[3]] : [ce, xe, Je, 1]
        }
          , Wr = (...U) => {
            U = ge(U, "rgba");
            let[V,te,Q] = U;
            V /= 255,
            te /= 255,
            Q /= 255;
            const ce = Ye(V, te, Q)
              , xe = yt(V, te, Q)
              , Je = (xe + ce) / 2;
            let Fe, It;
            return xe === ce ? (Fe = 0,
            It = Number.NaN) : Fe = Je < .5 ? (xe - ce) / (xe + ce) : (xe - ce) / (2 - xe - ce),
            V == xe ? It = (te - Q) / (xe - ce) : te == xe ? It = 2 + (Q - V) / (xe - ce) : Q == xe && (It = 4 + (V - te) / (xe - ce)),
            It *= 60,
            It < 0 && (It += 360),
            U.length > 3 && void 0 !== U[3] ? [It, Fe, Je, U[3]] : [It, Fe, Je]
        }
        ;
        Et.prototype.hsl = function() {
            return Wr(this._rgb)
        }
        ,
        Re.hsl = (...U) => new Et(...U,"hsl"),
        Jt.format.hsl = Vs,
        Jt.autodetect.push({
            p: 2,
            test: (...U) => {
                if ("array" === ye(U = ge(U, "hsl")) && 3 === U.length)
                    return "hsl"
            }
        }),
        vo.hsl = (U, V, te) => Go(U, V, te, "hsl");
        const {floor: Hs} = Math
          , {min: Ka, max: wi} = Math;
        function Zn(U, V) {
            let te = U.length;
            Array.isArray(U[0]) || (U = [U]),
            Array.isArray(V[0]) || (V = V.map(Je => [Je]));
            let Q = V[0].length
              , ce = V[0].map( (Je, Fe) => V.map(It => It[Fe]))
              , xe = U.map(Je => ce.map(Fe => Array.isArray(Je) ? Je.reduce( (It, go, yo) => It + go * (Fe[yo] || 0), 0) : Fe.reduce( (It, go) => It + go * Je, 0)));
            return 1 === te && (xe = xe[0]),
            1 === Q ? xe.map(Je => Je[0]) : xe
        }
        Et.prototype.hsv = function() {
            return ( (...U) => {
                U = ge(U, "rgb");
                let[V,te,Q] = U;
                const ce = Ka(V, te, Q)
                  , xe = wi(V, te, Q)
                  , Je = xe - ce;
                let Fe, It, go;
                return go = xe / 255,
                0 === xe ? (Fe = Number.NaN,
                It = 0) : (It = Je / xe,
                V === xe && (Fe = (te - Q) / Je),
                te === xe && (Fe = 2 + (Q - V) / Je),
                Q === xe && (Fe = 4 + (V - te) / Je),
                Fe *= 60,
                Fe < 0 && (Fe += 360)),
                [Fe, It, go]
            }
            )(this._rgb)
        }
        ,
        Re.hsv = (...U) => new Et(...U,"hsv"),
        Jt.format.hsv = (...U) => {
            U = ge(U, "hsv");
            let ce, xe, Je, [V,te,Q] = U;
            if (Q *= 255,
            0 === te)
                ce = xe = Je = Q;
            else {
                360 === V && (V = 0),
                V > 360 && (V -= 360),
                V < 0 && (V += 360),
                V /= 60;
                const Fe = Hs(V)
                  , It = V - Fe
                  , go = Q * (1 - te)
                  , yo = Q * (1 - te * It)
                  , Io = Q * (1 - te * (1 - It));
                switch (Fe) {
                case 0:
                    [ce,xe,Je] = [Q, Io, go];
                    break;
                case 1:
                    [ce,xe,Je] = [yo, Q, go];
                    break;
                case 2:
                    [ce,xe,Je] = [go, Q, Io];
                    break;
                case 3:
                    [ce,xe,Je] = [go, yo, Q];
                    break;
                case 4:
                    [ce,xe,Je] = [Io, go, Q];
                    break;
                case 5:
                    [ce,xe,Je] = [Q, go, yo]
                }
            }
            return [ce, xe, Je, U.length > 3 ? U[3] : 1]
        }
        ,
        Jt.autodetect.push({
            p: 2,
            test: (...U) => {
                if ("array" === ye(U = ge(U, "hsv")) && 3 === U.length)
                    return "hsv"
            }
        }),
        vo.hsv = (U, V, te) => Go(U, V, te, "hsv");
        const To = (...U) => {
            U = ge(U, "lab");
            const [V,te,Q,...ce] = U
              , [xe,Je,Fe] = function Ws(U) {
                var Q = Zn([[1, .3963377773761749, .2158037573099136], [1, -.1055613458156586, -.0638541728258133], [1, -.0894841775298119, -1.2914855480194092]], U);
                return Zn([[1.2268798758459243, -.5578149944602171, .2813910456659647], [-.0405757452148008, 1.112286803280317, -.0717110580655164], [-.0763729366746601, -.4214933324022432, 1.5869240198367816]], Q.map(ce => ce ** 3))
            }([V, te, Q])
              , [It,go,yo] = we(xe, Je, Fe);
            return [It, go, yo, ...ce.length > 0 && ce[0] < 1 ? [ce[0]] : []]
        }
        ;
        function bi(U) {
            const Q = Zn([[.819022437996703, .3619062600528904, -.1288737815209879], [.0329836539323885, .9292868615863434, .0361446663506424], [.0481771893596242, .2642395317527308, .6335478284694309]], U);
            return Zn([[.210454268309314, .7936177747023054, -.0040720430116193], [1.9779985324311684, -2.42859224204858, .450593709617411], [.0259040424655478, .7827717124575296, -.8086757549230774]], Q.map(ce => Math.cbrt(ce)))
        }
        const Hn = (...U) => {
            const [V,te,Q,...ce] = ge(U, "rgb");
            return [...bi(Ve(V, te, Q)), ...ce.length > 0 && ce[0] < 1 ? [ce[0]] : []]
        }
        ;
        Et.prototype.oklab = function() {
            return Hn(this._rgb)
        }
        ,
        Object.assign(Re, {
            oklab: (...U) => new Et(...U,"oklab")
        }),
        Jt.format.oklab = To,
        Jt.autodetect.push({
            p: 2,
            test: (...U) => {
                if ("array" === ye(U = ge(U, "oklab")) && 3 === U.length)
                    return "oklab"
            }
        }),
        vo.oklab = (U, V, te) => {
            const Q = U.oklab()
              , ce = V.oklab();
            return new Et(Q[0] + te * (ce[0] - Q[0]),Q[1] + te * (ce[1] - Q[1]),Q[2] + te * (ce[2] - Q[2]),"oklab")
        }
        ,
        vo.oklch = (U, V, te) => Go(U, V, te, "oklch");
        const {pow: An, sqrt: Vi, PI: qa, cos: Zs, sin: Pa, atan2: Ks} = Math
          , {pow: Nn} = Math;
        function ir(U) {
            let V = "rgb"
              , te = Re("#ccc")
              , Q = 0
              , ce = [0, 1]
              , xe = []
              , Je = [0, 0]
              , Fe = !1
              , It = []
              , go = !1
              , yo = 0
              , Io = 1
              , kt = !1
              , Wo = {}
              , ti = !0
              , Bi = 1;
            const ai = function(Oo) {
                if ((Oo = Oo || ["#fff", "#000"]) && "string" === ye(Oo) && Re.brewer && Re.brewer[Oo.toLowerCase()] && (Oo = Re.brewer[Oo.toLowerCase()]),
                "array" === ye(Oo)) {
                    1 === Oo.length && (Oo = [Oo[0], Oo[0]]),
                    Oo = Oo.slice(0);
                    for (let ui = 0; ui < Oo.length; ui++)
                        Oo[ui] = Re(Oo[ui]);
                    xe.length = 0;
                    for (let ui = 0; ui < Oo.length; ui++)
                        xe.push(ui / (Oo.length - 1))
                }
                return Bn(),
                It = Oo
            };
            let rn = Oo => Oo
              , Pn = Oo => Oo;
            const _n = function(Oo, ui) {
                let hi, pi;
                if (null == ui && (ui = !1),
                isNaN(Oo) || null === Oo)
                    return te;
                pi = ui ? Oo : Fe && Fe.length > 2 ? function(Oo) {
                    if (null != Fe) {
                        const ui = Fe.length - 1;
                        let hi = 0;
                        for (; hi < ui && Oo >= Fe[hi]; )
                            hi++;
                        return hi - 1
                    }
                    return 0
                }(Oo) / (Fe.length - 2) : Io !== yo ? (Oo - yo) / (Io - yo) : 1,
                pi = Pn(pi),
                ui || (pi = rn(pi)),
                1 !== Bi && (pi = Nn(pi, Bi)),
                pi = Je[0] + pi * (1 - Je[0] - Je[1]),
                pi = pt(pi, 0, 1);
                const Ui = Math.floor(1e4 * pi);
                if (ti && Wo[Ui])
                    hi = Wo[Ui];
                else {
                    if ("array" === ye(It))
                        for (let Li = 0; Li < xe.length; Li++) {
                            const sn = xe[Li];
                            if (pi <= sn) {
                                hi = It[Li];
                                break
                            }
                            if (pi >= sn && Li === xe.length - 1) {
                                hi = It[Li];
                                break
                            }
                            if (pi > sn && pi < xe[Li + 1]) {
                                pi = (pi - sn) / (xe[Li + 1] - sn),
                                hi = Re.interpolate(It[Li], It[Li + 1], pi, V);
                                break
                            }
                        }
                    else
                        "function" === ye(It) && (hi = It(pi));
                    ti && (Wo[Ui] = hi)
                }
                return hi
            };
            var Bn = () => Wo = {};
            ai(U);
            const Oi = function(Oo) {
                const ui = Re(_n(Oo));
                return go && ui[go] ? ui[go]() : ui
            };
            return Oi.classes = function(Oo) {
                if (null != Oo) {
                    if ("array" === ye(Oo))
                        Fe = Oo,
                        ce = [Oo[0], Oo[Oo.length - 1]];
                    else {
                        const ui = Re.analyze(ce);
                        Fe = 0 === Oo ? [ui.min, ui.max] : Re.limits(ui, "e", Oo)
                    }
                    return Oi
                }
                return Fe
            }
            ,
            Oi.domain = function(Oo) {
                if (!arguments.length)
                    return ce;
                yo = Oo[0],
                Io = Oo[Oo.length - 1],
                xe = [];
                const ui = It.length;
                if (Oo.length === ui && yo !== Io)
                    for (let hi of Array.from(Oo))
                        xe.push((hi - yo) / (Io - yo));
                else {
                    for (let hi = 0; hi < ui; hi++)
                        xe.push(hi / (ui - 1));
                    if (Oo.length > 2) {
                        const hi = Oo.map( (Ui, Li) => Li / (Oo.length - 1))
                          , pi = Oo.map(Ui => (Ui - yo) / (Io - yo));
                        pi.every( (Ui, Li) => hi[Li] === Ui) || (Pn = Ui => {
                            if (Ui <= 0 || Ui >= 1)
                                return Ui;
                            let Li = 0;
                            for (; Ui >= pi[Li + 1]; )
                                Li++;
                            return hi[Li] + (Ui - pi[Li]) / (pi[Li + 1] - pi[Li]) * (hi[Li + 1] - hi[Li])
                        }
                        )
                    }
                }
                return ce = [yo, Io],
                Oi
            }
            ,
            Oi.mode = function(Oo) {
                return arguments.length ? (V = Oo,
                Bn(),
                Oi) : V
            }
            ,
            Oi.range = function(Oo, ui) {
                return ai(Oo),
                Oi
            }
            ,
            Oi.out = function(Oo) {
                return go = Oo,
                Oi
            }
            ,
            Oi.spread = function(Oo) {
                return arguments.length ? (Q = Oo,
                Oi) : Q
            }
            ,
            Oi.correctLightness = function(Oo) {
                return null == Oo && (Oo = !0),
                kt = Oo,
                Bn(),
                rn = kt ? function(ui) {
                    const hi = _n(0, !0).lab()[0]
                      , pi = _n(1, !0).lab()[0]
                      , Ui = hi > pi;
                    let Li = _n(ui, !0).lab()[0];
                    const sn = hi + (pi - hi) * ui;
                    let Nr = Li - sn
                      , la = 0
                      , Qn = 1
                      , Hi = 20;
                    for (; Math.abs(Nr) > .01 && Hi-- > 0; )
                        Ui && (Nr *= -1),
                        Nr < 0 ? (la = ui,
                        ui += .5 * (Qn - ui)) : (Qn = ui,
                        ui += .5 * (la - ui)),
                        Li = _n(ui, !0).lab()[0],
                        Nr = Li - sn;
                    return ui
                }
                : ui => ui,
                Oi
            }
            ,
            Oi.padding = function(Oo) {
                return null != Oo ? ("number" === ye(Oo) && (Oo = [Oo, Oo]),
                Je = Oo,
                Oi) : Je
            }
            ,
            Oi.colors = function(Oo, ui) {
                arguments.length < 2 && (ui = "hex");
                let hi = [];
                if (0 === arguments.length)
                    hi = It.slice(0);
                else if (1 === Oo)
                    hi = [Oi(.5)];
                else if (Oo > 1) {
                    const pi = ce[0]
                      , Ui = ce[1] - pi;
                    hi = function In(U, V, te) {
                        let Q = []
                          , ce = U < V
                          , xe = te ? ce ? V + 1 : V - 1 : V;
                        for (let Je = U; ce ? Je < xe : Je > xe; ce ? Je++ : Je--)
                            Q.push(Je);
                        return Q
                    }(0, Oo, !1).map(Li => Oi(pi + Li / (Oo - 1) * Ui))
                } else {
                    U = [];
                    let pi = [];
                    if (Fe && Fe.length > 2)
                        for (let Ui = 1, Li = Fe.length, sn = 1 <= Li; sn ? Ui < Li : Ui > Li; sn ? Ui++ : Ui--)
                            pi.push(.5 * (Fe[Ui - 1] + Fe[Ui]));
                    else
                        pi = ce;
                    hi = pi.map(Ui => Oi(Ui))
                }
                return Re[ui] && (hi = hi.map(pi => pi[ui]())),
                hi
            }
            ,
            Oi.cache = function(Oo) {
                return null != Oo ? (ti = Oo,
                Oi) : ti
            }
            ,
            Oi.gamma = function(Oo) {
                return null != Oo ? (Bi = Oo,
                Oi) : Bi
            }
            ,
            Oi.nodata = function(Oo) {
                return null != Oo ? (te = Re(Oo),
                Oi) : te
            }
            ,
            Oi
        }
        const {round: gr} = Math;
        Et.prototype.rgb = function(U=!0) {
            return !1 === U ? this._rgb.slice(0, 3) : this._rgb.slice(0, 3).map(gr)
        }
        ,
        Et.prototype.rgba = function(U=!0) {
            return this._rgb.slice(0, 4).map( (V, te) => te < 3 ? !1 === U ? V : gr(V) : V)
        }
        ,
        Object.assign(Re, {
            rgb: (...U) => new Et(...U,"rgb")
        }),
        Jt.format.rgb = (...U) => {
            const V = ge(U, "rgba");
            return void 0 === V[3] && (V[3] = 1),
            V
        }
        ,
        Jt.autodetect.push({
            p: 3,
            test: (...U) => {
                if ("array" === ye(U = ge(U, "rgba")) && (3 === U.length || 4 === U.length && "number" == ye(U[3]) && U[3] >= 0 && U[3] <= 1))
                    return "rgb"
            }
        });
        const Xi = (U, V, te) => {
            if (!Xi[te])
                throw new Error("unknown blend mode " + te);
            return Xi[te](U, V)
        }
          , yr = U => (V, te) => {
            const Q = Re(te).rgb()
              , ce = Re(V).rgb();
            return Re.rgb(U(Q, ce))
        }
          , On = U => (V, te) => {
            const Q = [];
            return Q[0] = U(V[0], te[0]),
            Q[1] = U(V[1], te[1]),
            Q[2] = U(V[2], te[2]),
            Q
        }
        ;
        Xi.normal = yr(On(U => U)),
        Xi.multiply = yr(On( (U, V) => U * V / 255)),
        Xi.screen = yr(On( (U, V) => 255 * (1 - (1 - U / 255) * (1 - V / 255)))),
        Xi.overlay = yr(On( (U, V) => V < 128 ? 2 * U * V / 255 : 255 * (1 - 2 * (1 - U / 255) * (1 - V / 255)))),
        Xi.darken = yr(On( (U, V) => U > V ? V : U)),
        Xi.lighten = yr(On( (U, V) => U > V ? U : V)),
        Xi.dodge = yr(On( (U, V) => 255 === U || (U = V / 255 * 255 / (1 - U / 255)) > 255 ? 255 : U)),
        Xi.burn = yr(On( (U, V) => 255 * (1 - (1 - V / 255) / (U / 255))));
        const el = Xi
          , {pow: tl, sin: Yc, cos: Ta} = Math
          , {floor: Ca, random: Ea} = Math
          , {log: vr, pow: Kc, floor: ol, abs: kr} = Math;
        function qc(U, V=null) {
            const te = {
                min: Number.MAX_VALUE,
                max: -1 * Number.MAX_VALUE,
                sum: 0,
                values: [],
                count: 0
            };
            return "object" === ye(U) && (U = Object.values(U)),
            U.forEach(Q => {
                V && "object" === ye(Q) && (Q = Q[V]),
                null != Q && !isNaN(Q) && (te.values.push(Q),
                te.sum += Q,
                Q < te.min && (te.min = Q),
                Q > te.max && (te.max = Q),
                te.count += 1)
            }
            ),
            te.domain = [te.min, te.max],
            te.limits = (Q, ce) => Jc(te, Q, ce),
            te
        }
        function Jc(U, V="equal", te=7) {
            "array" == ye(U) && (U = qc(U));
            const {min: Q, max: ce} = U
              , xe = U.values.sort( (Fe, It) => Fe - It);
            if (1 === te)
                return [Q, ce];
            const Je = [];
            if ("c" === V.substr(0, 1) && (Je.push(Q),
            Je.push(ce)),
            "e" === V.substr(0, 1)) {
                Je.push(Q);
                for (let Fe = 1; Fe < te; Fe++)
                    Je.push(Q + Fe / te * (ce - Q));
                Je.push(ce)
            } else if ("l" === V.substr(0, 1)) {
                if (Q <= 0)
                    throw new Error("Logarithmic scales are only possible for values > 0");
                const Fe = Math.LOG10E * vr(Q)
                  , It = Math.LOG10E * vr(ce);
                Je.push(Q);
                for (let go = 1; go < te; go++)
                    Je.push(Kc(10, Fe + go / te * (It - Fe)));
                Je.push(ce)
            } else if ("q" === V.substr(0, 1)) {
                Je.push(Q);
                for (let Fe = 1; Fe < te; Fe++) {
                    const It = (xe.length - 1) * Fe / te
                      , go = ol(It);
                    if (go === It)
                        Je.push(xe[go]);
                    else {
                        const yo = It - go;
                        Je.push(xe[go] * (1 - yo) + xe[go + 1] * yo)
                    }
                }
                Je.push(ce)
            } else if ("k" === V.substr(0, 1)) {
                let Fe;
                const It = xe.length
                  , go = new Array(It)
                  , yo = new Array(te);
                let Io = !0
                  , kt = 0
                  , Wo = null;
                Wo = [],
                Wo.push(Q);
                for (let ai = 1; ai < te; ai++)
                    Wo.push(Q + ai / te * (ce - Q));
                for (Wo.push(ce); Io; ) {
                    for (let oi = 0; oi < te; oi++)
                        yo[oi] = 0;
                    for (let oi = 0; oi < It; oi++) {
                        const rn = xe[oi];
                        let _n, Pn = Number.MAX_VALUE;
                        for (let Bn = 0; Bn < te; Bn++) {
                            const Oi = kr(Wo[Bn] - rn);
                            Oi < Pn && (Pn = Oi,
                            _n = Bn),
                            yo[_n]++,
                            go[oi] = _n
                        }
                    }
                    const ai = new Array(te);
                    for (let oi = 0; oi < te; oi++)
                        ai[oi] = null;
                    for (let oi = 0; oi < It; oi++)
                        Fe = go[oi],
                        null === ai[Fe] ? ai[Fe] = xe[oi] : ai[Fe] += xe[oi];
                    for (let oi = 0; oi < te; oi++)
                        ai[oi] *= 1 / yo[oi];
                    Io = !1;
                    for (let oi = 0; oi < te; oi++)
                        if (ai[oi] !== Wo[oi]) {
                            Io = !0;
                            break
                        }
                    Wo = ai,
                    kt++,
                    kt > 200 && (Io = !1)
                }
                const ti = {};
                for (let ai = 0; ai < te; ai++)
                    ti[ai] = [];
                for (let ai = 0; ai < It; ai++)
                    Fe = go[ai],
                    ti[Fe].push(xe[ai]);
                let Bi = [];
                for (let ai = 0; ai < te; ai++)
                    Bi.push(ti[ai][0]),
                    Bi.push(ti[ai][ti[ai].length - 1]);
                Bi = Bi.sort( (ai, oi) => ai - oi),
                Je.push(Bi[0]);
                for (let ai = 1; ai < Bi.length; ai += 2) {
                    const oi = Bi[ai];
                    !isNaN(oi) && -1 === Je.indexOf(oi) && Je.push(oi)
                }
            }
            return Je
        }
        const Ts = .022;
        /**
       * @license
       *
       * The APCA contrast prediction algorithm is based of the formulas published
       * in the APCA-1.0.98G specification by Myndex. The specification is available at:
       * https://raw.githubusercontent.com/Myndex/apca-w3/master/images/APCAw3_0.1.17_APCA0.0.98G.svg
       *
       * Note that the APCA implementation is still beta, so please update to
       * future versions of chroma.js when they become available.
       *
       * You can read more about the APCA Readability Criterion at
       * https://readtech.org/ARC/
       */
        function zr(U, V, te) {
            return .2126729 * Math.pow(U / 255, 2.4) + .7151522 * Math.pow(V / 255, 2.4) + .072175 * Math.pow(te / 255, 2.4)
        }
        const {sqrt: zo, pow: vn, min: nl, max: Qs, atan2: Cs, abs: ea, cos: wn, sin: Kn, exp: rl, PI: uo} = Math
          , Qc = {
            cool: () => ir([Re.hsl(180, 1, .9), Re.hsl(250, .7, .4)]),
            hot: () => ir(["#000", "#f00", "#ff0", "#fff"]).mode("rgb")
        }
          , ta = {
            OrRd: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"],
            PuBu: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"],
            BuPu: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"],
            Oranges: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
            BuGn: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"],
            YlOrBr: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
            YlGn: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
            Reds: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
            RdPu: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
            Greens: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],
            YlGnBu: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
            Purples: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],
            GnBu: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"],
            Greys: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],
            YlOrRd: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
            PuRd: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"],
            Blues: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],
            PuBuGn: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"],
            Viridis: ["#440154", "#482777", "#3f4a8a", "#31678e", "#26838f", "#1f9d8a", "#6cce5a", "#b6de2b", "#fee825"],
            Spectral: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
            RdYlGn: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
            RdBu: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
            PiYG: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
            PRGn: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
            RdYlBu: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
            BrBG: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
            RdGy: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
            PuOr: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
            Set2: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"],
            Accent: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"],
            Set1: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"],
            Set3: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"],
            Dark2: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"],
            Paired: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"],
            Pastel2: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"],
            Pastel1: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
        }
          , Br = Object.keys(ta)
          , Es = new Map(Br.map(U => [U.toLowerCase(), U]))
          , oa = "function" == typeof Proxy ? new Proxy(ta,{
            get(U, V) {
                const te = V.toLowerCase();
                if (Es.has(te))
                    return U[Es.get(te)]
            },
            getOwnPropertyNames: () => Object.getOwnPropertyNames(Br)
        }) : ta
          , {max: eh} = Math;
        Et.prototype.cmyk = function() {
            return ( (...U) => {
                let[V,te,Q] = ge(U, "rgb");
                V /= 255,
                te /= 255,
                Q /= 255;
                const ce = 1 - eh(V, eh(te, Q))
                  , xe = ce < 1 ? 1 / (1 - ce) : 0;
                return [(1 - V - ce) * xe, (1 - te - ce) * xe, (1 - Q - ce) * xe, ce]
            }
            )(this._rgb)
        }
        ,
        Object.assign(Re, {
            cmyk: (...U) => new Et(...U,"cmyk")
        }),
        Jt.format.cmyk = (...U) => {
            U = ge(U, "cmyk");
            const [V,te,Q,ce] = U
              , xe = U.length > 4 ? U[4] : 1;
            return 1 === ce ? [0, 0, 0, xe] : [V >= 1 ? 0 : 255 * (1 - V) * (1 - ce), te >= 1 ? 0 : 255 * (1 - te) * (1 - ce), Q >= 1 ? 0 : 255 * (1 - Q) * (1 - ce), xe]
        }
        ,
        Jt.autodetect.push({
            p: 2,
            test: (...U) => {
                if ("array" === ye(U = ge(U, "cmyk")) && 4 === U.length)
                    return "cmyk"
            }
        });
        const Kl = (...U) => {
            const [V,te,Q,...ce] = ge(U, "rgb")
              , [xe,Je,Fe] = Hn(V, te, Q)
              , [It,go,yo] = oe(xe, Je, Fe);
            return [It, go, yo, ...ce.length > 0 && ce[0] < 1 ? [ce[0]] : []]
        }
          , {round: Is} = Math
          , cl = (...U) => {
            U = ge(U, "lch");
            const [V,te,Q,...ce] = U
              , [xe,Je,Fe] = yn(V, te, Q)
              , [It,go,yo] = To(xe, Je, Fe);
            return [It, go, yo, ...ce.length > 0 && ce[0] < 1 ? [ce[0]] : []]
        }
          , qn = /((?:-?\d+)|(?:-?\d+(?:\.\d+)?)%|none)/.source
          , Wn = /((?:-?(?:\d+(?:\.\d*)?|\.\d+)%?)|none)/.source
          , ps = /((?:-?(?:\d+(?:\.\d*)?|\.\d+)%)|none)/.source
          , zn = /\s*/.source
          , rr = /\s+/.source
          , qr = /\s*,\s*/.source
          , As = /((?:-?(?:\d+(?:\.\d*)?|\.\d+)(?:deg)?)|none)/.source
          , ds = /\s*(?:\/\s*((?:[01]|[01]?\.\d+)|\d+(?:\.\d+)?%))?/.source
          , Ia = new RegExp("^rgba?\\(" + zn + [qn, qn, qn].join(rr) + ds + "\\)$")
          , Ur = new RegExp("^rgb\\(" + zn + [qn, qn, qn].join(qr) + zn + "\\)$")
          , mi = new RegExp("^rgba\\(" + zn + [qn, qn, qn, Wn].join(qr) + zn + "\\)$")
          , Ql = new RegExp("^hsla?\\(" + zn + [As, ps, ps].join(rr) + ds + "\\)$")
          , ec = new RegExp("^hsl?\\(" + zn + [As, ps, ps].join(qr) + zn + "\\)$")
          , tc = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/
          , ms = new RegExp("^lab\\(" + zn + [Wn, Wn, Wn].join(rr) + ds + "\\)$")
          , oc = new RegExp("^lch\\(" + zn + [Wn, Wn, As].join(rr) + ds + "\\)$")
          , qi = new RegExp("^oklab\\(" + zn + [Wn, Wn, Wn].join(rr) + ds + "\\)$")
          , sh = new RegExp("^oklch\\(" + zn + [Wn, Wn, As].join(rr) + ds + "\\)$")
          , {round: ah} = Math
          , fs = U => U.map( (V, te) => te <= 2 ? pt(ah(V), 0, 255) : V)
          , xn = (U, V=0, te=100, Q=!1) => ("string" == typeof U && U.endsWith("%") && (U = parseFloat(U.substring(0, U.length - 1)) / 100,
        U = Q ? V + .5 * (U + 1) * (te - V) : V + U * (te - V)),
        +U)
          , $n = (U, V) => "none" === U ? V : U
          , hl = U => {
            if ("transparent" === (U = U.toLowerCase().trim()))
                return [0, 0, 0, 0];
            let V;
            if (Jt.format.named)
                try {
                    return Jt.format.named(U)
                } catch {}
            if ((V = U.match(Ia)) || (V = U.match(Ur))) {
                let te = V.slice(1, 4);
                for (let ce = 0; ce < 3; ce++)
                    te[ce] = +xn($n(te[ce], 0), 0, 255);
                te = fs(te);
                const Q = void 0 !== V[4] ? +xn(V[4], 0, 1) : 1;
                return te[3] = Q,
                te
            }
            if (V = U.match(mi)) {
                const te = V.slice(1, 5);
                for (let Q = 0; Q < 4; Q++)
                    te[Q] = +xn(te[Q], 0, 255);
                return te
            }
            if ((V = U.match(Ql)) || (V = U.match(ec))) {
                const te = V.slice(1, 4);
                te[0] = +$n(te[0].replace("deg", ""), 0),
                te[1] = .01 * +xn($n(te[1], 0), 0, 100),
                te[2] = .01 * +xn($n(te[2], 0), 0, 100);
                const Q = fs(Vs(te))
                  , ce = void 0 !== V[4] ? +xn(V[4], 0, 1) : 1;
                return Q[3] = ce,
                Q
            }
            if (V = U.match(tc)) {
                const te = V.slice(1, 4);
                te[1] *= .01,
                te[2] *= .01;
                const Q = Vs(te);
                for (let ce = 0; ce < 3; ce++)
                    Q[ce] = ah(Q[ce]);
                return Q[3] = +V[4],
                Q
            }
            if (V = U.match(ms)) {
                const te = V.slice(1, 4);
                te[0] = xn($n(te[0], 0), 0, 100),
                te[1] = xn($n(te[1], 0), -125, 125, !0),
                te[2] = xn($n(te[2], 0), -125, 125, !0);
                const Q = bt();
                ao("d50");
                const ce = fs(Oe(te));
                ao(Q);
                const xe = void 0 !== V[4] ? +xn(V[4], 0, 1) : 1;
                return ce[3] = xe,
                ce
            }
            if (V = U.match(oc)) {
                const te = V.slice(1, 4);
                te[0] = xn(te[0], 0, 100),
                te[1] = xn($n(te[1], 0), 0, 150, !1),
                te[2] = +$n(te[2].replace("deg", ""), 0);
                const Q = bt();
                ao("d50");
                const ce = fs(Ln(te));
                ao(Q);
                const xe = void 0 !== V[4] ? +xn(V[4], 0, 1) : 1;
                return ce[3] = xe,
                ce
            }
            if (V = U.match(qi)) {
                const te = V.slice(1, 4);
                te[0] = xn($n(te[0], 0), 0, 1),
                te[1] = xn($n(te[1], 0), -.4, .4, !0),
                te[2] = xn($n(te[2], 0), -.4, .4, !0);
                const Q = fs(To(te))
                  , ce = void 0 !== V[4] ? +xn(V[4], 0, 1) : 1;
                return Q[3] = ce,
                Q
            }
            if (V = U.match(sh)) {
                const te = V.slice(1, 4);
                te[0] = xn($n(te[0], 0), 0, 1),
                te[1] = xn($n(te[1], 0), 0, .4, !1),
                te[2] = +$n(te[2].replace("deg", ""), 0);
                const Q = fs(cl(te))
                  , ce = void 0 !== V[4] ? +xn(V[4], 0, 1) : 1;
                return Q[3] = ce,
                Q
            }
        }
        ;
        hl.test = U => Ia.test(U) || Ql.test(U) || ms.test(U) || oc.test(U) || qi.test(U) || sh.test(U) || Ur.test(U) || mi.test(U) || ec.test(U) || tc.test(U) || "transparent" === U;
        const ic = hl;
        Et.prototype.css = function(U) {
            return ( (...U) => {
                const V = ge(U, "rgba");
                let te = Ie(U) || "rgb";
                if ("hsl" === te.substr(0, 3))
                    return ( (...U) => {
                        const V = ge(U, "hsla");
                        let te = Ie(U) || "lsa";
                        return V[0] = ht(V[0] || 0) + "deg",
                        V[1] = ht(100 * V[1]) + "%",
                        V[2] = ht(100 * V[2]) + "%",
                        "hsla" === te || V.length > 3 && V[3] < 1 ? (V[3] = "/ " + (V.length > 3 ? V[3] : 1),
                        te = "hsla") : V.length = 3,
                        "".concat(te.substr(0, 3), "(").concat(V.join(" "), ")")
                    }
                    )(Wr(V), te);
                if ("lab" === te.substr(0, 3)) {
                    const Q = bt();
                    ao("d50");
                    const ce = ( (...U) => {
                        const V = ge(U, "lab");
                        let te = Ie(U) || "lab";
                        return V[0] = ht(V[0]) + "%",
                        V[1] = ht(V[1]),
                        V[2] = ht(V[2]),
                        "laba" === te || V.length > 3 && V[3] < 1 ? V[3] = "/ " + (V.length > 3 ? V[3] : 1) : V.length = 3,
                        "lab(".concat(V.join(" "), ")")
                    }
                    )(fe(V), te);
                    return ao(Q),
                    ce
                }
                if ("lch" === te.substr(0, 3)) {
                    const Q = bt();
                    ao("d50");
                    const ce = ( (...U) => {
                        const V = ge(U, "lch");
                        let te = Ie(U) || "lab";
                        return V[0] = ht(V[0]) + "%",
                        V[1] = ht(V[1]),
                        V[2] = isNaN(V[2]) ? "none" : ht(V[2]) + "deg",
                        "lcha" === te || V.length > 3 && V[3] < 1 ? V[3] = "/ " + (V.length > 3 ? V[3] : 1) : V.length = 3,
                        "lch(".concat(V.join(" "), ")")
                    }
                    )(J(V), te);
                    return ao(Q),
                    ce
                }
                return "oklab" === te.substr(0, 5) ? ( (...U) => {
                    const V = ge(U, "lab");
                    return V[0] = ht(100 * V[0]) + "%",
                    V[1] = mo(V[1]),
                    V[2] = mo(V[2]),
                    V.length > 3 && V[3] < 1 ? V[3] = "/ " + (V.length > 3 ? V[3] : 1) : V.length = 3,
                    "oklab(".concat(V.join(" "), ")")
                }
                )(Hn(V)) : "oklch" === te.substr(0, 5) ? ( (...U) => {
                    const V = ge(U, "lch");
                    return V[0] = ht(100 * V[0]) + "%",
                    V[1] = mo(V[1]),
                    V[2] = isNaN(V[2]) ? "none" : ht(V[2]) + "deg",
                    V.length > 3 && V[3] < 1 ? V[3] = "/ " + (V.length > 3 ? V[3] : 1) : V.length = 3,
                    "oklch(".concat(V.join(" "), ")")
                }
                )(Kl(V)) : (V[0] = Is(V[0]),
                V[1] = Is(V[1]),
                V[2] = Is(V[2]),
                ("rgba" === te || V.length > 3 && V[3] < 1) && (V[3] = "/ " + (V.length > 3 ? V[3] : 1),
                te = "rgba"),
                "".concat(te.substr(0, 3), "(").concat(V.slice(0, "rgb" === te ? 3 : 4).join(" "), ")"))
            }
            )(this._rgb, U)
        }
        ,
        Re.css = (...U) => new Et(...U,"css"),
        Jt.format.css = ic,
        Jt.autodetect.push({
            p: 5,
            test: (U, ...V) => {
                if (!V.length && "string" === ye(U) && ic.test(U))
                    return "css"
            }
        }),
        Jt.format.gl = (...U) => {
            const V = ge(U, "rgba");
            return V[0] *= 255,
            V[1] *= 255,
            V[2] *= 255,
            V
        }
        ,
        Re.gl = (...U) => new Et(...U,"gl"),
        Et.prototype.gl = function() {
            const U = this._rgb;
            return [U[0] / 255, U[1] / 255, U[2] / 255, U[3]]
        }
        ,
        Et.prototype.hex = function(U) {
            return Nt(this._rgb, U)
        }
        ,
        Re.hex = (...U) => new Et(...U,"hex"),
        Jt.format.hex = St,
        Jt.autodetect.push({
            p: 4,
            test: (U, ...V) => {
                if (!V.length && "string" === ye(U) && [3, 4, 5, 6, 7, 8, 9].indexOf(U.length) >= 0)
                    return "hex"
            }
        });
        const {log: _s} = Math
          , Jn = U => {
            const V = U / 100;
            let te, Q, ce;
            return V < 66 ? (te = 255,
            Q = V < 6 ? 0 : -155.25485562709179 - .44596950469579133 * (Q = V - 2) + 104.49216199393888 * _s(Q),
            ce = V < 20 ? 0 : .8274096064007395 * (ce = V - 10) - 254.76935184120902 + 115.67994401066147 * _s(ce)) : (te = 351.97690566805693 + .114206453784165 * (te = V - 55) - 40.25366309332127 * _s(te),
            Q = 325.4494125711974 + .07943456536662342 * (Q = V - 50) - 28.0852963507957 * _s(Q),
            ce = 255),
            [te, Q, ce, 1]
        }
          , {round: nc} = Math;
        Et.prototype.temp = Et.prototype.kelvin = Et.prototype.temperature = function() {
            return ( () => {
                const V = ge([this._rgb], "rgb")
                  , te = V[0]
                  , Q = V[2];
                let Fe, ce = 1e3, xe = 4e4;
                for (; xe - ce > .4; ) {
                    Fe = .5 * (xe + ce);
                    const It = Jn(Fe);
                    It[2] / It[0] >= Q / te ? xe = Fe : ce = Fe
                }
                return nc(Fe)
            }
            )()
        }
        ;
        const Oa = (...U) => new Et(...U,"temp");
        Object.assign(Re, {
            temp: Oa,
            kelvin: Oa,
            temperature: Oa
        }),
        Jt.format.temp = Jt.format.kelvin = Jt.format.temperature = Jn,
        Et.prototype.oklch = function() {
            return Kl(this._rgb)
        }
        ,
        Object.assign(Re, {
            oklch: (...U) => new Et(...U,"oklch")
        }),
        Jt.format.oklch = cl,
        Jt.autodetect.push({
            p: 2,
            test: (...U) => {
                if ("array" === ye(U = ge(U, "oklch")) && 3 === U.length)
                    return "oklch"
            }
        }),
        Object.assign(Re, {
            analyze: qc,
            average: (U, V="lrgb", te=null) => {
                const Q = U.length;
                te || (te = Array.from(new Array(Q)).map( () => 1));
                const ce = Q / te.reduce(function(Io, kt) {
                    return Io + kt
                });
                if (te.forEach( (Io, kt) => {
                    te[kt] *= ce
                }
                ),
                U = U.map(Io => new Et(Io)),
                "lrgb" === V)
                    return ( (U, V) => {
                        const te = U.length
                          , Q = [0, 0, 0, 0];
                        for (let ce = 0; ce < U.length; ce++) {
                            const Je = V[ce] / te
                              , Fe = U[ce]._rgb;
                            Q[0] += An(Fe[0], 2) * Je,
                            Q[1] += An(Fe[1], 2) * Je,
                            Q[2] += An(Fe[2], 2) * Je,
                            Q[3] += Fe[3] * Je
                        }
                        return Q[0] = Vi(Q[0]),
                        Q[1] = Vi(Q[1]),
                        Q[2] = Vi(Q[2]),
                        Q[3] > .9999999 && (Q[3] = 1),
                        new Et(Be(Q))
                    }
                    )(U, te);
                const xe = U.shift()
                  , Je = xe.get(V)
                  , Fe = [];
                let It = 0
                  , go = 0;
                for (let Io = 0; Io < Je.length; Io++)
                    if (Je[Io] = (Je[Io] || 0) * te[0],
                    Fe.push(isNaN(Je[Io]) ? 0 : te[0]),
                    "h" === V.charAt(Io) && !isNaN(Je[Io])) {
                        const kt = Je[Io] / 180 * qa;
                        It += Zs(kt) * te[0],
                        go += Pa(kt) * te[0]
                    }
                let yo = xe.alpha() * te[0];
                U.forEach( (Io, kt) => {
                    const Wo = Io.get(V);
                    yo += Io.alpha() * te[kt + 1];
                    for (let ti = 0; ti < Je.length; ti++)
                        if (!isNaN(Wo[ti]))
                            if (Fe[ti] += te[kt + 1],
                            "h" === V.charAt(ti)) {
                                const Bi = Wo[ti] / 180 * qa;
                                It += Zs(Bi) * te[kt + 1],
                                go += Pa(Bi) * te[kt + 1]
                            } else
                                Je[ti] += Wo[ti] * te[kt + 1]
                }
                );
                for (let Io = 0; Io < Je.length; Io++)
                    if ("h" === V.charAt(Io)) {
                        let kt = Ks(go / Fe[Io], It / Fe[Io]) / qa * 180;
                        for (; kt < 0; )
                            kt += 360;
                        for (; kt >= 360; )
                            kt -= 360;
                        Je[Io] = kt
                    } else
                        Je[Io] = Je[Io] / Fe[Io];
                return yo /= Q,
                new Et(Je,V).alpha(yo > .99999 ? 1 : yo, !0)
            }
            ,
            bezier: U => {
                const V = function(U) {
                    let V, te, Q, ce;
                    if (2 === (U = U.map(xe => new Et(xe))).length)
                        [te,Q] = U.map(xe => xe.lab()),
                        V = function(xe) {
                            const Je = [0, 1, 2].map(Fe => te[Fe] + xe * (Q[Fe] - te[Fe]));
                            return new Et(Je,"lab")
                        }
                        ;
                    else if (3 === U.length)
                        [te,Q,ce] = U.map(xe => xe.lab()),
                        V = function(xe) {
                            const Je = [0, 1, 2].map(Fe => (1 - xe) * (1 - xe) * te[Fe] + 2 * (1 - xe) * xe * Q[Fe] + xe * xe * ce[Fe]);
                            return new Et(Je,"lab")
                        }
                        ;
                    else if (4 === U.length) {
                        let xe;
                        [te,Q,ce,xe] = U.map(Je => Je.lab()),
                        V = function(Je) {
                            const Fe = [0, 1, 2].map(It => (1 - Je) * (1 - Je) * (1 - Je) * te[It] + 3 * (1 - Je) * (1 - Je) * Je * Q[It] + 3 * (1 - Je) * Je * Je * ce[It] + Je * Je * Je * xe[It]);
                            return new Et(Fe,"lab")
                        }
                    } else {
                        if (!(U.length >= 5))
                            throw new RangeError("No point in running bezier with only one color.");
                        {
                            let xe, Je, Fe;
                            xe = U.map(It => It.lab()),
                            Fe = U.length - 1,
                            Je = function(U) {
                                let V = [1, 1];
                                for (let te = 1; te < U; te++) {
                                    let Q = [1];
                                    for (let ce = 1; ce <= V.length; ce++)
                                        Q[ce] = (V[ce] || 0) + V[ce - 1];
                                    V = Q
                                }
                                return V
                            }(Fe),
                            V = function(It) {
                                const go = 1 - It
                                  , yo = [0, 1, 2].map(Io => xe.reduce( (kt, Wo, ti) => kt + Je[ti] * go ** (Fe - ti) * It ** ti * Wo[Io], 0));
                                return new Et(yo,"lab")
                            }
                        }
                    }
                    return V
                }(U);
                return V.scale = () => ir(V),
                V
            }
            ,
            blend: el,
            brewer: oa,
            Color: Et,
            colors: ne,
            contrast: (U, V) => {
                U = new Et(U),
                V = new Et(V);
                const te = U.luminance()
                  , Q = V.luminance();
                return te > Q ? (te + .05) / (Q + .05) : (Q + .05) / (te + .05)
            }
            ,
            contrastAPCA: (U, V) => {
                U = new Et(U),
                V = new Et(V),
                U.alpha() < 1 && (U = ei(V, U, U.alpha(), "rgb"));
                const te = zr(...U.rgb())
                  , Q = zr(...V.rgb())
                  , ce = te >= Ts ? te : te + Math.pow(Ts - te, 1.414)
                  , xe = Q >= Ts ? Q : Q + Math.pow(Ts - Q, 1.414)
                  , Je = Math.pow(xe, .56) - Math.pow(ce, .57)
                  , Fe = Math.pow(xe, .65) - Math.pow(ce, .62)
                  , It = Math.abs(xe - ce) < 5e-4 ? 0 : ce < xe ? 1.14 * Je : 1.14 * Fe;
                return 100 * (Math.abs(It) < .1 ? 0 : It > 0 ? It - .027 : It + .027)
            }
            ,
            cubehelix: function iu(U=300, V=-1.5, te=1, Q=1, ce=[0, 1]) {
                let Je, xe = 0;
                "array" === ye(ce) ? Je = ce[1] - ce[0] : (Je = 0,
                ce = [ce, ce]);
                const Fe = function(It) {
                    const go = no * ((U + 120) / 360 + V * It)
                      , yo = tl(ce[0] + Je * It, Q)
                      , kt = (0 !== xe ? te[0] + It * xe : te) * yo * (1 - yo) / 2
                      , Wo = Ta(go)
                      , ti = Yc(go);
                    return Re(Be([255 * (yo + kt * (-.14861 * Wo + 1.78277 * ti)), 255 * (yo + kt * (-.29227 * Wo - .90649 * ti)), 255 * (yo + kt * (1.97294 * Wo)), 1]))
                };
                return Fe.start = function(It) {
                    return null == It ? U : (U = It,
                    Fe)
                }
                ,
                Fe.rotations = function(It) {
                    return null == It ? V : (V = It,
                    Fe)
                }
                ,
                Fe.gamma = function(It) {
                    return null == It ? Q : (Q = It,
                    Fe)
                }
                ,
                Fe.hue = function(It) {
                    return null == It ? te : ("array" === ye(te = It) ? (xe = te[1] - te[0],
                    0 === xe && (te = te[1])) : xe = 0,
                    Fe)
                }
                ,
                Fe.lightness = function(It) {
                    return null == It ? ce : ("array" === ye(It) ? (ce = It,
                    Je = It[1] - It[0]) : (ce = [It, It],
                    Je = 0),
                    Fe)
                }
                ,
                Fe.scale = () => Re.scale(Fe),
                Fe.hue(te),
                Fe
            },
            deltaE: function sl(U, V, te=1, Q=1, ce=1) {
                var xe = function(vc) {
                    return 360 * vc / (2 * uo)
                }
                  , Je = function(vc) {
                    return 2 * uo * vc / 360
                };
                U = new Et(U),
                V = new Et(V);
                const [Fe,It,go] = Array.from(U.lab())
                  , [yo,Io,kt] = Array.from(V.lab())
                  , Wo = (Fe + yo) / 2
                  , ai = (zo(vn(It, 2) + vn(go, 2)) + zo(vn(Io, 2) + vn(kt, 2))) / 2
                  , oi = .5 * (1 - zo(vn(ai, 7) / (vn(ai, 7) + vn(25, 7))))
                  , rn = It * (1 + oi)
                  , Pn = Io * (1 + oi)
                  , _n = zo(vn(rn, 2) + vn(go, 2))
                  , Bn = zo(vn(Pn, 2) + vn(kt, 2))
                  , Oi = (_n + Bn) / 2
                  , Oo = xe(Cs(go, rn))
                  , ui = xe(Cs(kt, Pn))
                  , hi = Oo >= 0 ? Oo : Oo + 360
                  , pi = ui >= 0 ? ui : ui + 360
                  , Ui = ea(hi - pi) > 180 ? (hi + pi + 360) / 2 : (hi + pi) / 2
                  , Li = 1 - .17 * wn(Je(Ui - 30)) + .24 * wn(Je(2 * Ui)) + .32 * wn(Je(3 * Ui + 6)) - .2 * wn(Je(4 * Ui - 63));
                let sn = pi - hi;
                sn = ea(sn) <= 180 ? sn : pi <= hi ? sn + 360 : sn - 360,
                sn = 2 * zo(_n * Bn) * Kn(Je(sn) / 2);
                const Nr = yo - Fe
                  , la = Bn - _n
                  , Qn = 1 + .015 * vn(Wo - 50, 2) / zo(20 + vn(Wo - 50, 2))
                  , Hi = 1 + .045 * Oi
                  , Os = 1 + .015 * Oi * Li
                  , vl = 30 * rl(-vn((Ui - 275) / 25, 2))
                  , Rs = -2 * zo(vn(Oi, 7) / (vn(Oi, 7) + vn(25, 7))) * Kn(2 * Je(vl))
                  , yh = zo(vn(Nr / (te * Qn), 2) + vn(la / (Q * Hi), 2) + vn(sn / (ce * Os), 2) + Rs * (la / (Q * Hi)) * (sn / (ce * Os)));
                return Qs(0, nl(100, yh))
            },
            distance: function Kr(U, V, te="lab") {
                U = new Et(U),
                V = new Et(V);
                const Q = U.get(te)
                  , ce = V.get(te);
                let xe = 0;
                for (let Je in Q) {
                    const Fe = (Q[Je] || 0) - (ce[Je] || 0);
                    xe += Fe * Fe
                }
                return Math.sqrt(xe)
            },
            input: Jt,
            interpolate: ei,
            limits: Jc,
            mix: ei,
            random: () => {
                let U = "#";
                for (let V = 0; V < 6; V++)
                    U += "0123456789abcdef".charAt(Ca(16 * Ea()));
                return new Et(U,"hex")
            }
            ,
            scale: ir,
            scales: Qc,
            valid: (...U) => {
                try {
                    return new Et(...U),
                    !0
                } catch {
                    return !1
                }
            }
        });
        function dl() {
            return (dl = (0,
            Ut.A)(function*(U, V) {
                return function hh(U, V) {
                    const te = U.length / V
                      , Q = [];
                    for (let ce = 0; ce < V; ce++) {
                        const xe = ce * te
                          , Je = (ce + 1) * te;
                        let Fe = 0
                          , It = 0;
                        for (let go = Math.floor(xe); go < Math.ceil(Je); go++) {
                            const yo = Math.min(Je, go + 1) - Math.max(xe, go);
                            Fe += U[go] * yo,
                            It += yo
                        }
                        Q.push(Fe / It)
                    }
                    return Q
                }(U, V)
            })).apply(this, arguments)
        }
        function cc() {
            return (cc = (0,
            Ut.A)(function*(U, V) {
                const te = mu(U)
                  , Q = du()
                  , ce = yield Q.decodeAudioData(te)
                  , xe = Q.createGain();
                xe.gain.value = .2,
                xe.connect(Q.destination);
                const Je = Q.createBufferSource();
                yield Q.close(),
                Je.buffer = ce,
                Je.connect(xe);
                const Fe = pu(ce, V);
                return {
                    samples: fu(Fe),
                    audioSource: Je
                }
            })).apply(this, arguments)
        }
        const pu = (U, V) => {
            const te = U.getChannelData(0)
              , Q = Math.floor(te.length / V);
            return uh(V).reduce( (ce, xe, Je) => {
                const Fe = Q * Je
                  , It = uh(Q).reduce( (go, yo, Io) => go + Math.abs(te[Fe + Io]), 0);
                return ce.push(It / Q),
                ce
            }
            , [])
        }
          , du = () => new (window.AudioContext || window.webkitAudioContext)
          , mu = U => {
            const V = new ArrayBuffer(U.byteLength);
            return new Uint8Array(V).set(new Uint8Array(U)),
            V
        }
          , uh = U => Array(U).fill("")
          , fu = U => {
            const V = .7 * Math.pow(Math.max(...U), -1);
            return U.map(te => te * V)
        }
        ;
        var xr = $(84412)
          , hc = $(70152)
          , uc = $(74023);
        const ra = U => {
            switch (U) {
            case Me.lR$.SKY:
            case Me.lR$.EMERALD:
            case Me.lR$.PURPLE_GALAXY:
                return "#000";
            case Me.lR$.LAZULI:
            case Me.lR$.COFFEE:
            case Me.lR$.MIDNIGHT:
            case Me.lR$.DARK:
            case Me.lR$.CUSTOM:
            case Me.lR$.PHOTO:
            case Me.lR$.SIMPLE:
            case Me.lR$.LIGHT_PINK:
                return "#FFF";
            default:
                return U
            }
        }
          , dh = U => {
            switch (U) {
            case Me.lR$.SKY:
            case Me.lR$.EMERALD:
            case Me.lR$.PURPLE_GALAXY:
                return "#FFF";
            case Me.lR$.LAZULI:
            case Me.lR$.COFFEE:
            case Me.lR$.MIDNIGHT:
            case Me.lR$.DARK:
            case Me.lR$.CUSTOM:
            case Me.lR$.SIMPLE:
            case Me.lR$.PHOTO:
                return "#000";
            case Me.lR$.LIGHT_PINK:
                return "#4C4C4C";
            default:
                return U
            }
        }
        ;
        var ml = $(49427)
          , Ra = $(73955)
          , br = $(21626)
          , pc = $(345);
        const Jr = ["playerUpload"]
          , dc = ["playerYoutube"]
          , sa = ["svgElement"]
          , fl = () => [".jpeg", ".jpg", ".png", ".heic"];
        function mh(U, V) {
            if (1 & U && (r.j41(0, "div", 7),
            r.nrm(1, "div", 13)(2, "div", 14)(3, "div", 15)(4, "div", 16),
            r.k0s()),
            2 & U) {
                const te = V
                  , Q = r.XpG(2);
                r.R7$(),
                r.xc7("height", te.printingRegistration.width + Q.soundwave.passepartoutWidth, "px"),
                r.R7$(),
                r.xc7("width", te.printingRegistration.width + Q.soundwave.passepartoutWidth, "px"),
                r.R7$(),
                r.xc7("width", te.printingRegistration.width + Q.soundwave.passepartoutWidth, "px"),
                r.R7$(),
                r.xc7("height", te.printingRegistration.width + Q.soundwave.passepartoutWidth + 2, "px")
            }
        }
        function mc(U, V) {
            if (1 & U) {
                const te = r.RV6();
                r.j41(0, "img", 19),
                r.bIt("load", function() {
                    r.eBV(te);
                    const ce = r.XpG(3);
                    return r.Njj(ce.onImageLoad())
                })("click", function() {
                    r.eBV(te);
                    const ce = r.XpG(3);
                    return r.Njj(ce.onPhotoSelect())
                }),
                r.k0s()
            }
            if (2 & U) {
                const te = r.XpG(3);
                r.Y8G("src", te.soundwave.imageBackground, r.B4B)
            }
        }
        function _l(U, V) {
            if (1 & U) {
                const te = r.RV6();
                r.j41(0, "pp-controls-file-uploader-photo", 20),
                r.nI1(1, "translate"),
                r.bIt("setFileUploadingProgress", function(ce) {
                    r.eBV(te);
                    const xe = r.XpG(3);
                    return r.Njj(xe.setFileUpploadingProgress.emit(ce))
                }),
                r.k0s()
            }
            if (2 & U) {
                const te = r.XpG(3);
                r.Y8G("photoFileGroup", te.photoFileGroup)("photoCropGroup", te.photoCropGroup)("photoId", te.photoId)("multiFile", te.multiFile)("isSubmitted", !1)("acceptable", r.lJ4(13, fl))("isBase64Response", !0)("fullHeight", !0)("isBigPictureMode", !0)("isFileUploadingInProgress", te.isFileUploadingInProgress)("legalNote", r.bMT(1, 11, "soundwave.details.instruction"))
            }
        }
        function fh(U, V) {
            if (1 & U && r.DNE(0, mc, 1, 1, "img", 17)(1, _l, 2, 14, "pp-controls-file-uploader-photo", 18),
            2 & U) {
                const te = r.XpG(2);
                r.vxM(te.soundwave.imageBackground ? 0 : te.photoFileGroup ? 1 : -1)
            }
        }
        function _h(U, V) {
            if (1 & U && r.nrm(0, "div", 21),
            2 & U) {
                const te = r.XpG(2);
                r.xc7("font-size", 400, "px")("margin-top", te.soundwave.passepartoutWidth, "px")("height", te.soundwave.soundwave.height, "px")("width", te.soundwave.soundwave.width, "px"),
                r.AVh("classic", te.soundwave.layout === te.SoundwaveLayoutEnum.CLASSIC)("bars", te.soundwave.layout === te.SoundwaveLayoutEnum.BARS),
                r.Y8G("innerHTML", te.svgImage, r.npT)
            }
        }
        function Da(U, V) {
            1 & U && (r.j41(0, "div", 23),
            r.nrm(1, "pp-controls-loader", 25),
            r.k0s()),
            2 & U && (r.R7$(),
            r.Y8G("showStatus", !1)("fontColor", "#000")("disableText", !0)("reverse", !0))
        }
        function _u(U, V) {
            if (1 & U && (r.qSk(),
            r.nrm(0, "rect")),
            2 & U) {
                const te = V.$implicit
                  , Q = r.XpG(4);
                r.BMQ("fill", te.color)("width", Q.soundwave.model.barWidth)("x", te.x)("y", te.y)("height", te.height)("rx", Q.soundwave.model.rx)("ry", Q.soundwave.model.ry)
            }
        }
        function gh(U, V) {
            if (1 & U && (r.qSk(),
            r.j41(0, "svg", 26, 0)(2, "g", 27),
            r.Z7z(3, _u, 1, 7, ":svg:rect", null, r.fX1),
            r.k0s()()),
            2 & U) {
                const te = r.XpG(3);
                r.AVh("classic", te.soundwave.layout === te.SoundwaveLayoutEnum.CLASSIC)("bars", te.soundwave.layout === te.SoundwaveLayoutEnum.BARS)("isLandscape", !0),
                r.qtP("viewBox", "0 0 ", te.soundwave.soundwave.width, " ", te.soundwave.soundwave.height, ""),
                r.BMQ("width", te.soundwave.soundwave.width)("height", te.soundwave.soundwave.height),
                r.R7$(3),
                r.Dyx(te.soundwave.samples)
            }
        }
        function fc(U, V) {
            if (1 & U && r.nrm(0, "div", 29),
            2 & U) {
                const te = r.XpG(4);
                r.xc7("margin-left", te.soundwave.model.startX, "px")("margin-right", te.soundwave.model.startX, "px")("background-color", te.soundwave.samples[0].color)("transform", V)
            }
        }
        function gl(U, V) {
            if (1 & U && (r.DNE(0, fc, 1, 8, "div", 28),
            r.nI1(1, "async")),
            2 & U) {
                let te;
                const Q = r.XpG(3);
                r.vxM((te = r.bMT(1, 1, Q.audioPlayPosition$)) ? 0 : -1, te)
            }
        }
        function _c(U, V) {
            if (1 & U && (r.j41(0, "div", 22),
            r.DNE(1, Da, 2, 4, "div", 23),
            r.nI1(2, "async"),
            r.DNE(3, gh, 5, 11, ":svg:svg", 24)(4, gl, 2, 3),
            r.nI1(5, "async"),
            r.k0s()),
            2 & U) {
                const te = r.XpG(2);
                r.xc7("margin-top", te.soundwave.passepartoutWidth, "px")("height", te.soundwave.soundwave.height, "px")("width", te.soundwave.soundwave.width, "px"),
                r.R7$(),
                r.vxM(r.bMT(2, 8, te.loader$) ? 1 : 3),
                r.R7$(3),
                r.vxM(r.bMT(5, 10, te.isAudioPlay$) ? 4 : -1)
            }
        }
        function yl(U, V) {
            if (1 & U && r.nrm(0, "div", 30),
            2 & U) {
                const te = r.XpG().ngIf
                  , Q = r.XpG();
                r.xc7("background", Q.soundwave.qrCode.background)("width", Q.soundwave.qrCode.width, "px")("height", Q.soundwave.qrCode.width, "px")("right", te.printingRegistration.width + Q.soundwave.passepartoutWidth, "px")("bottom", te.printingRegistration.width + Q.soundwave.passepartoutWidth / 2, "px"),
                r.AVh("no-final-poster", !Q.isFinalPoster),
                r.Y8G("innerHTML", Q.soundwave.qrCode.html, r.npT)
            }
        }
        function La(U, V) {
            if (1 & U) {
                const te = r.RV6();
                r.j41(0, "pp-poster-printing-registration", 6),
                r.DNE(1, mh, 5, 8, "div", 7),
                r.nI1(2, "async"),
                r.j41(3, "pp-poster-arrangement-wrapper")(4, "pp-poster-image-area")(5, "div", 8),
                r.DNE(6, fh, 2, 1),
                r.k0s(),
                r.DNE(7, _h, 1, 13, "div", 9)(8, _c, 6, 12, "div", 10),
                r.k0s(),
                r.j41(9, "pp-poster-text-area", 11),
                r.nI1(10, "async"),
                r.nI1(11, "async"),
                r.nI1(12, "async"),
                r.nI1(13, "async"),
                r.bIt("textareaHeightCallback", function(ce) {
                    r.eBV(te);
                    const xe = r.XpG();
                    return r.Njj(xe.newTopTextareaHeight(ce))
                }),
                r.k0s()(),
                r.DNE(14, yl, 1, 13, "div", 12),
                r.k0s()
            }
            if (2 & U) {
                let te;
                const Q = V.ngIf
                  , ce = r.XpG();
                r.Y8G("poster", Q),
                r.R7$(),
                r.vxM((te = ce.soundwave.isPassepartout && r.bMT(2, 19, ce.poster$)) ? 1 : -1, te),
                r.R7$(4),
                r.xc7("margin-top", ce.soundwave.passepartoutWidth, "px")("height", ce.soundwave.soundwave.height, "px")("width", ce.soundwave.soundwave.width, "px"),
                r.AVh("image-instance-first-layer", ce.soundwave.style === ce.SoundwaveStyleEnum.PHOTO && !ce.soundwave.imageBackground),
                r.R7$(),
                r.vxM(ce.soundwave.style === ce.SoundwaveStyleEnum.PHOTO ? 6 : -1),
                r.R7$(),
                r.vxM(ce.svgImage ? 7 : 8),
                r.R7$(2),
                r.Y8G("poster", Q)("color", r.bMT(10, 21, ce.textColor$))("background", ce.soundwave.isPassepartout ? "#FFF" : "unset")("textArea", r.bMT(11, 23, ce.textArea$))("title", r.bMT(12, 25, ce.title$))("subtitle", r.bMT(13, 27, ce.subtitle$)),
                r.R7$(5),
                r.vxM(ce.soundwave.qrCode.show ? 14 : -1)
            }
        }
        function gc(U, V) {
            if (1 & U && (r.j41(0, "audio", 5, 1),
            r.nrm(2, "source", 31),
            r.k0s()),
            2 & U) {
                const te = r.XpG();
                r.R7$(2),
                r.Y8G("src", te.audioUpload, r.B4B)("type", "audio/mp3")
            }
        }
        function aa(U, V) {
            if (1 & U && (r.j41(0, "audio", 5, 2),
            r.nrm(2, "source", 31),
            r.k0s()),
            2 & U) {
                const te = r.XpG();
                r.R7$(2),
                r.Y8G("src", te.audioYoutube, r.B4B)("type", "audio/mp3")
            }
        }
        let yc = ( () => {
            var U;
            class V extends ct.C {
                newTopTextareaHeight(Q) {
                    this.textAreaHeight$.next(Q)
                }
                constructor(Q, ce, xe, Je, Fe) {
                    super(Q, ce),
                    this.host = Q,
                    this.zone = ce,
                    this.cdr = xe,
                    this.httpClient = Je,
                    this.domSanitizer = Fe,
                    this.isSvgSoundwave = !1,
                    this.youtubeLading = new r.bkB,
                    this.youtubeError = new r.bkB,
                    this.photoId = 0,
                    this.multiFile = !1,
                    this.photoSelect = new r.bkB,
                    this.setFileUpploadingProgress = new r.bkB,
                    this.isFileUploadingInProgress = !1,
                    this.soundwave = {
                        background: "#FFF",
                        imageBackground: "",
                        imageBackgroundBottom: 0,
                        isPassepartout: !1,
                        passepartoutWidth: 0,
                        source: Me.ftn.upload,
                        soundwave: {
                            width: 0,
                            height: 0
                        },
                        svg: "",
                        layout: Me.kGm.CLASSIC,
                        style: Me.lR$.SKY,
                        model: {
                            samples: 0,
                            barWidth: 0,
                            rx: 0,
                            ry: 0,
                            breakBetweenBarCallback: It => 0,
                            breakBetweenBarWidth: 0,
                            startX: 0,
                            startY: 0
                        },
                        samples: [],
                        qrCode: {
                            show: !1,
                            html: "",
                            width: 0,
                            background: "transparent"
                        }
                    },
                    this.audioUpload = null,
                    this.audioYoutube = null,
                    this.updateSoundwave$ = new xr.t(null),
                    this.passepartoutWidth$ = new xr.t(null),
                    this.textAreaHeight$ = new xr.t(null),
                    this.isAudioPlay$ = new xr.t(!1),
                    this.isAudioPlayAvailable$ = new xr.t(!1),
                    this.audioPlayInterval = null,
                    this.audioPlayPosition$ = new xr.t(null),
                    this.sampleCache = new Map,
                    this.loader$ = new xr.t(!1),
                    this.downloadInProgress$ = new xr.t(!1),
                    this.SoundwaveStyleEnum = Me.lR$,
                    this.fileYoutube = {
                        key: null,
                        audioBuffer: null
                    },
                    this.fileUpload = {
                        key: null,
                        audioBuffer: null
                    },
                    this.spotifyUpload = {
                        key: null,
                        audioSamples: null
                    },
                    this.fileDefault = {
                        key: null,
                        audioBuffer: null
                    },
                    this.SoundwaveLayoutEnum = Me.kGm,
                    this.SoundwaveSourceEnum = Me.ftn
                }
                ngAfterViewInit() {
                    var Q = this;
                    (0,
                    Xe.z)([this.poster$, this.posterConfiguration$, this.textAreaHeight$, this.passepartoutWidth$, this.updateSoundwave$]).pipe((0,
                    hc.B)(200), (0,
                    Ce.Q)(this.ngUnsubscribe)).subscribe(function() {
                        var ce = (0,
                        Ut.A)(function*([xe,Je,Fe,It,go]) {
                            var yo, Io;
                            if (null == xe || null === (yo = xe.size) || void 0 === yo || !yo.height || !Je)
                                return;
                            Q.loader$.next(!0);
                            const kt = null !== (Io = xe.size.height) && void 0 !== Io ? Io : 0
                              , ti = null != Fe ? Fe : 0;
                            Q.soundwave.soundwave.height = Math.ceil(kt - 2 * (null != It ? It : 0) - ti),
                            Q.imageInstanceSize = {
                                width: xe.size.width - 2 * Q.soundwave.passepartoutWidth,
                                height: Q.soundwave.soundwave.height
                            },
                            Q.soundwave.imageBackgroundBottom = Q.soundwave.passepartoutWidth + ti,
                            Q.isInteractive && !Q.downloadInProgress$.getValue() && (console.time("GENERATE SVG"),
                            yield Q.generateSvg(Q.soundwave.soundwave.width, Q.soundwave.soundwave.height, xe, Je),
                            console.timeEnd("GENERATE SVG"),
                            Q.loader$.next(!1))
                        });
                        return function(xe) {
                            return ce.apply(this, arguments)
                        }
                    }())
                }
                setAllTextSettings(Q) {
                    const ce = {
                        text: Q.customMessage ? Q.title : "",
                        isDefaultFont: !Q.titleFont
                    };
                    this.setText(ce, this.title$, {
                        font: null != ce && ce.isDefaultFont ? Me.n3q.MACHO : Me.n3q.LUXUS_BRUT,
                        portrait: {
                            sizeFactor: .057,
                            bottomFactor: .028,
                            topFactor: .04,
                            isBold: !0
                        },
                        square: {
                            sizeFactor: null != ce && ce.isDefaultFont ? .046 : .058,
                            bottomFactor: .028,
                            topFactor: .05,
                            isBold: !0
                        },
                        horizontal: {
                            sizeFactor: null != ce && ce.isDefaultFont ? .046 : .058,
                            bottomFactor: .02,
                            topFactor: .05,
                            isBold: !0
                        }
                    });
                    const xe = {
                        text: Q.customMessage ? Q.subtitle : "",
                        isDefaultFont: !Q.subtitleFont
                    };
                    this.setText(xe, this.subtitle$, {
                        font: null != xe && xe.isDefaultFont ? Me.n3q.MACHO : Me.n3q.LUXUS_BRUT,
                        portrait: {
                            sizeFactor: .035,
                            bottomFactor: 0,
                            topFactor: ce.text ? 0 : .04
                        },
                        square: {
                            sizeFactor: null != xe && xe.isDefaultFont ? .0215 : .045,
                            bottomFactor: -.009,
                            topFactor: ce.text ? 0 : .02
                        },
                        horizontal: {
                            sizeFactor: null != xe && xe.isDefaultFont ? .0286 : .045,
                            bottomFactor: -.0208,
                            topFactor: ce.text ? 0 : .02
                        }
                    })
                }
                setTextArea(Q) {
                    this.textArea$.next({
                        bottomFactor: Q.isPortrait || Q.isSquare ? .048 : .06,
                        marginFactor: .04,
                        paddingFactor: Q.isPortrait ? .042 : .03,
                        minHeightFactor: Q.isPortrait ? .064 : .052
                    })
                }
                play() {
                    this.resetPlayer(),
                    this.isAudioPlay$.next(!0);
                    const Q = this.soundwave.source === Me.ftn.upload ? this.playerUpload : this.playerYoutube
                      , ce = this.soundwave.source === Me.ftn.upload ? this.playerYoutube : this.playerUpload;
                    ce && ce.nativeElement.pause(),
                    Q && (Q.nativeElement.play(),
                    this.audioPlayInterval = setInterval( () => {
                        const xe = this.soundwave.source === Me.ftn.upload ? this.playerUpload : this.playerYoutube;
                        if (!xe)
                            return;
                        const Je = Math.ceil(xe.nativeElement.currentTime / xe.nativeElement.duration * (this.soundwave.soundwave.width - 2 * this.soundwave.model.startX));
                        this.audioPlayPosition$.next("translateX(".concat(Je, "px)")),
                        xe.nativeElement.currentTime / xe.nativeElement.duration == 1 && this.resetPlayer()
                    }
                    ))
                }
                stop() {
                    this.isAudioPlay$.next(!1);
                    const Q = this.soundwave.source === Me.ftn.upload ? this.playerUpload : this.playerYoutube;
                    this.resetPlayer(),
                    Q && (Q.nativeElement.pause(),
                    Q.nativeElement.currentTime = 0)
                }
                resetPlayer() {
                    this.isAudioPlay$.value && (this.audioPlayInterval && clearInterval(this.audioPlayInterval),
                    this.audioPlayPosition$.next(null),
                    this.isAudioPlay$.next(!1))
                }
                setDesign(Q, ce) {
                    var xe = this;
                    return (0,
                    Ut.A)(function*() {
                        if (xe.soundwave.background = ( (U, V, te, Q) => {
                            switch (U) {
                            case Me.lR$.LAZULI:
                                return "#AAC3C4";
                            case Me.lR$.COFFEE:
                                return "#DBCBC3";
                            case Me.lR$.SKY:
                                return "url('/assets/pp-posters/soundwave/".concat(V ? "_HQ_/" : "", "background/").concat(Q, "/4.jpg') center/cover no-repeat border-box");
                            case Me.lR$.MIDNIGHT:
                                return "#F7E6D2";
                            case Me.lR$.EMERALD:
                                return "url('/assets/pp-posters/soundwave/".concat(V ? "_HQ_/" : "", "background/").concat(Q, "/6.jpg') center/cover no-repeat border-box");
                            case Me.lR$.PURPLE_GALAXY:
                                return "url('/assets/pp-posters/soundwave/".concat(V ? "_HQ_/" : "", "background/").concat(Q, "/7.jpg') center/cover no-repeat border-box");
                            case Me.lR$.DARK:
                                return "#000000";
                            case Me.lR$.CUSTOM:
                                return "#".concat(te);
                            case Me.lR$.LIGHT_PINK:
                                return "url('/assets/pp-posters/soundwave/".concat(V ? "_HQ_/" : "", "background/").concat(Q, "/11.jpg') center/cover no-repeat border-box");
                            case Me.lR$.SIMPLE:
                                return "#FFF";
                            case Me.lR$.PHOTO:
                                return "transparent";
                            default:
                                return U
                            }
                        }
                        )(ce.style, xe.isFinalPoster, ce.customColors.background, Q.isPortrait ? "portrait" : Q.isSquare ? "square" : "landscape"),
                        xe.soundwave.layout = ce.layout,
                        xe.soundwave.style = ce.style,
                        xe.soundwave.imageBackground = ce.style === Me.lR$.PHOTO ? xe.getImageConfig(ce, 0) : "",
                        xe.soundwave.isPassepartout = (U => {
                            switch (U) {
                            case Me.lR$.EMERALD:
                            case Me.lR$.PURPLE_GALAXY:
                            case Me.lR$.SKY:
                            case Me.lR$.LIGHT_PINK:
                                return !1;
                            case Me.lR$.LAZULI:
                            case Me.lR$.COFFEE:
                            case Me.lR$.MIDNIGHT:
                            case Me.lR$.DARK:
                            case Me.lR$.SIMPLE:
                            case Me.lR$.CUSTOM:
                            case Me.lR$.PHOTO:
                                return !0;
                            default:
                                return U
                            }
                        }
                        )(ce.style),
                        xe.soundwave.passepartoutWidth = Q.isLandscape ? .06 * Q.size.height : .048 * Q.size.width,
                        xe.passepartoutWidth$.getValue() !== xe.soundwave.passepartoutWidth && xe.passepartoutWidth$.next(xe.soundwave.passepartoutWidth),
                        xe.soundwave.soundwave.width = Q.size.width - 2 * xe.soundwave.passepartoutWidth,
                        xe.textColor$.next((U => {
                            switch (U) {
                            case Me.lR$.EMERALD:
                            case Me.lR$.PURPLE_GALAXY:
                            case Me.lR$.SKY:
                            case Me.lR$.LIGHT_PINK:
                                return "#fff";
                            case Me.lR$.LAZULI:
                            case Me.lR$.COFFEE:
                            case Me.lR$.MIDNIGHT:
                            case Me.lR$.DARK:
                            case Me.lR$.SIMPLE:
                            case Me.lR$.CUSTOM:
                            case Me.lR$.PHOTO:
                                return "#000";
                            default:
                                return U
                            }
                        }
                        )(ce.style)),
                        xe.isSvgSoundwave) {
                            let Fe = yield(0,
                            it._)(xe.httpClient.get("/api/soundwave/svg/".concat(ce.uuid), {
                                responseType: "text"
                            }));
                            Fe = Fe.replace(/<svg /, '<svg id="pp-element-loaded" '),
                            xe.temporarySvg = xe.domSanitizer.bypassSecurityTrustHtml(Fe),
                            ce.style !== Me.lR$.PHOTO && (xe.svgImage = xe.temporarySvg)
                        } else {
                            var Je;
                            xe.soundwave.source !== ce.source && xe.stop(),
                            xe.soundwave.source = ce.source;
                            let Fe = !1;
                            if (ce.source === Me.ftn.youtube && ce.youtubeURL && ce.youtubeURL !== (null === (Je = xe.fileYoutube) || void 0 === Je ? void 0 : Je.key)) {
                                xe.downloadInProgress$.next(!0),
                                xe.youtubeLading.next(!0),
                                xe.loader$.next(!0),
                                xe.isAudioPlayAvailable$.next(!1),
                                Fe = !0,
                                xe.stop(),
                                xe.fileYoutube.key = ce.youtubeURL;
                                try {
                                    xe.youtubeError.next(""),
                                    xe.fileYoutube.audioBuffer = yield(0,
                                    it._)(xe.httpClient.get("/api/sound/youtube", {
                                        params: {
                                            url: encodeURIComponent(ce.youtubeURL)
                                        },
                                        responseType: "arraybuffer",
                                        reportProgress: !0
                                    })),
                                    xe.audioYoutube = xe.domSanitizer.bypassSecurityTrustUrl("data:audio/mpeg;base64,".concat(xe.arrayBufferToBase64(xe.fileYoutube.audioBuffer))),
                                    xe.isAudioPlayAvailable$.next(!0)
                                } catch {
                                    xe.fileYoutube.key = null,
                                    xe.fileYoutube.audioBuffer = null,
                                    xe.audioYoutube = "",
                                    xe.youtubeError.next("soundwave.youtube.error.cant-generate-soundwave"),
                                    xe.isAudioPlayAvailable$.next(!1)
                                } finally {
                                    xe.downloadInProgress$.next(!1)
                                }
                                xe.updateSoundwave$.next((new Date).getTime()),
                                xe.youtubeLading.next(!1)
                            } else
                                ce.source === Me.ftn.youtube && !ce.youtubeURL && xe.stop();
                            if (ce.source === Me.ftn.upload && ce.soundFiles[0].uuid && ce.soundFiles[0].uuid !== xe.fileUpload.key) {
                                xe.downloadInProgress$.next(!0),
                                xe.loader$.next(!0),
                                xe.isAudioPlayAvailable$.next(!1),
                                Fe = !0,
                                xe.stop();
                                const It = ce.soundFiles[0].uuid;
                                xe.fileUpload.key = It;
                                try {
                                    xe.fileUpload.audioBuffer = yield(0,
                                    it._)(xe.httpClient.get("/api/sound/files/".concat(It), {
                                        responseType: "arraybuffer",
                                        reportProgress: !0
                                    })),
                                    xe.audioUpload = xe.domSanitizer.bypassSecurityTrustUrl("data:audio/mpeg;base64,".concat(xe.arrayBufferToBase64(xe.fileUpload.audioBuffer)))
                                } catch {
                                    xe.fileUpload.key = null,
                                    xe.fileUpload.audioBuffer = null,
                                    xe.audioUpload = ""
                                } finally {
                                    xe.downloadInProgress$.next(!1)
                                }
                                xe.updateSoundwave$.next((new Date).getTime()),
                                xe.isAudioPlayAvailable$.next(!0)
                            } else
                                ce.source === Me.ftn.upload && !ce.soundFiles[0].uuid && xe.stop();
                            if (ce.source === Me.ftn.spotify && ce.spotify && ce.spotify.id !== xe.spotifyUpload.key) {
                                xe.downloadInProgress$.next(!0),
                                xe.loader$.next(!0),
                                xe.isAudioPlayAvailable$.next(!1),
                                Fe = !0,
                                xe.stop();
                                const It = ce.spotify.id;
                                xe.fileUpload.key = It;
                                try {
                                    xe.spotifyUpload.audioSamples = yield(0,
                                    it._)(xe.httpClient.get("/api/sound/spotify/".concat(It)))
                                } catch {
                                    xe.fileUpload.key = null,
                                    xe.fileUpload.audioBuffer = null,
                                    xe.audioUpload = ""
                                } finally {
                                    xe.downloadInProgress$.next(!1)
                                }
                                xe.updateSoundwave$.next((new Date).getTime()),
                                xe.isAudioPlayAvailable$.next(!0)
                            }
                            if (!Fe && xe.defaultSoundwave && !xe.fileDefault.key) {
                                xe.loader$.next(!0),
                                xe.stop();
                                const It = xe.defaultSoundwave;
                                xe.fileDefault.key = It,
                                xe.fileDefault.audioBuffer = yield(0,
                                it._)(xe.httpClient.get("/api/sound/files/".concat(It), {
                                    responseType: "arraybuffer",
                                    reportProgress: !0
                                })),
                                xe.audioUpload = xe.domSanitizer.bypassSecurityTrustUrl("data:audio/mpeg;base64,".concat(xe.arrayBufferToBase64(xe.fileDefault.audioBuffer))),
                                xe.updateSoundwave$.next((new Date).getTime())
                            }
                        }
                        xe.soundwave.qrCode.show = ce.showQRCode,
                        ce.showQRCode && (xe.soundwave.qrCode.width = .057 * (Q.isPortrait ? Q.size.width : Q.size.height),
                        xe.soundwave.qrCode.background = (U => {
                            switch (U) {
                            case Me.lR$.SKY:
                            case Me.lR$.EMERALD:
                            case Me.lR$.PURPLE_GALAXY:
                            case Me.lR$.LAZULI:
                            case Me.lR$.COFFEE:
                            case Me.lR$.MIDNIGHT:
                            case Me.lR$.DARK:
                            case Me.lR$.CUSTOM:
                            case Me.lR$.SIMPLE:
                            case Me.lR$.LIGHT_PINK:
                            case Me.lR$.PHOTO:
                                return "transparent";
                            default:
                                return U
                            }
                        }
                        )(ce.style),
                        xe.soundwave.qrCode.html = xe.getQRCode(ce, Math.round(xe.soundwave.qrCode.width)))
                    })()
                }
                getQRCode(Q, ce) {
                    let xe = "".concat(Q.domain, "/").concat(Q.lang, "/soundwave-editor");
                    var Je;
                    return this.isFinalPoster && (Q.source === Me.ftn.upload ? xe = "".concat(Q.domain, "/").concat(Q.lang, "/soundwave-play?soundId=").concat(Q.soundFiles[0].uuid, "&layout=").concat(Q.layout) : Q.source === Me.ftn.youtube ? xe = "".concat(Q.domain, "/").concat(Q.lang, "/soundwave-play?youtube=").concat(decodeURIComponent(Q.youtubeURL), "&layout=").concat(Q.layout) : Q.source === Me.ftn.spotify && null !== (Je = Q.spotify) && void 0 !== Je && Je.id && (xe = "".concat(Q.domain, "/").concat(Q.lang, "/soundwave-play?spotify=").concat(Q.spotify.id, "&layout=").concat(Q.layout))),
                    this.domSanitizer.bypassSecurityTrustHtml(new uc({
                        content: xe,
                        background: ra(Q.style),
                        color: dh(Q.style),
                        width: ce,
                        height: ce,
                        padding: 0,
                        ecl: "L",
                        container: "svg-viewbox"
                    }).svg().replace("<svg ", '<svg style="position:absolute;width:'.concat(ce, "px;height:").concat(ce, 'px;" ')))
                }
                generateSvg(Q, ce, xe, Je) {
                    var Fe = this;
                    return (0,
                    Ut.A)(function*() {
                        var It;
                        let go = !1
                          , yo = null
                          , Io = null;
                        if (Je.source === Me.ftn.upload && Je.soundFiles[0].uuid ? yo = Fe.fileUpload.audioBuffer : Je.source === Me.ftn.youtube && Je.youtubeURL ? yo = Fe.fileYoutube.audioBuffer : Je.source === Me.ftn.spotify && null !== (It = Je.spotify) && void 0 !== It && It.id && (Io = Fe.spotifyUpload.audioSamples),
                        !yo && !Io && (go = !0,
                        yo = Fe.fileDefault.audioBuffer),
                        !yo && !Io)
                            return;
                        Fe.soundwave.model = Fe.getMode(Q, ce, Je.layout, xe);
                        const Wo = Fe.cacheKey(go, Je.source, Je.source === Me.ftn.spotify ? null !== (oi = null === (rn = Je.spotify) || void 0 === rn ? void 0 : rn.id) && void 0 !== oi ? oi : "" : Je.source === Me.ftn.upload ? Je.soundFiles[0].uuid : Je.youtubeURL, Fe.soundwave.model.samples);
                        var oi, rn;
                        let ti = [];
                        var Bi;
                        Fe.sampleCache.has(Wo) ? ti = Fe.sampleCache.get(Wo) || [] : (Je.source === Me.ftn.spotify && null !== (Bi = Je.spotify) && void 0 !== Bi && Bi.id ? ti = yield function pl(U, V) {
                            return dl.apply(this, arguments)
                        }(null != Io ? Io : [0, 0], Fe.soundwave.model.samples) : yo && (ti = (yield function na(U, V) {
                            return cc.apply(this, arguments)
                        }(yo, Fe.soundwave.model.samples)).samples),
                        Fe.sampleCache.set(Wo, ti));
                        let ai = 0;
                        Je.style === Me.lR$.PHOTO && (Je.soundwavePosition === Me.nYI.TOP ? ai = -.25 : Je.soundwavePosition === Me.nYI.BOTTOM && (ai = .25)),
                        Fe.soundwave.samples = ( (U, V, te, Q, ce, xe) => {
                            const Fe = (kt, Wo) => U.startY - Wo / 2
                              , It = V * Q
                              , go = kt => U.breakBetweenBarCallback({
                                sampleNumber: kt
                            })
                              , yo = ( (U, V, te) => {
                                switch (U) {
                                case Me.lR$.LAZULI:
                                    return ["#2C889A"];
                                case Me.lR$.COFFEE:
                                    return ["#383331"];
                                case Me.lR$.EMERALD:
                                case Me.lR$.SKY:
                                case Me.lR$.PURPLE_GALAXY:
                                case Me.lR$.DARK:
                                case Me.lR$.LIGHT_PINK:
                                    return ["#FFFFFF"];
                                case Me.lR$.PHOTO:
                                    return ["rgba(255,255,255,0.7)"];
                                case Me.lR$.SIMPLE:
                                    return ["#16212C"];
                                case Me.lR$.MIDNIGHT:
                                    return ["#142437"];
                                case Me.lR$.CUSTOM:
                                    return ["".concat(V), "".concat(te)];
                                default:
                                    return U
                                }
                            }
                            )(xe.style, xe.customColors.soundwaveStart, xe.customColors.soundwaveEnd)
                              , Io = ir(yo).colors(ce.length);
                            return ce.map( (kt, Wo) => {
                                const ti = (kt => Math.ceil(kt * (V * te)))(kt);
                                return {
                                    x: go(Wo),
                                    y: Fe(0, ti) + It,
                                    height: ti,
                                    color: Io[Wo]
                                }
                            }
                            )
                        }
                        )(Fe.soundwave.model, ce, .7, ai, ti, Je)
                    })()
                }
                cacheKey(Q, ce, xe, Je) {
                    return Q ? "DEFAULT_SOUND_".concat(Je) : "".concat(ce, "_").concat(xe, "_").concat(Je)
                }
                getMode(Q, ce, xe, Je) {
                    if (xe === Me.kGm.CLASSIC) {
                        const It = Math.round(.9498 * Q);
                        return {
                            rx: 0,
                            ry: 0,
                            startY: ce / 2,
                            startX: Math.round(.05 * Q / 2),
                            barWidth: 1,
                            breakBetweenBarWidth: 0,
                            breakBetweenBarCallback: function({sampleNumber: Io}) {
                                return Math.round(this.startX + 2 * Io / 2)
                            },
                            samples: It
                        }
                    }
                    {
                        const It = Je.isPortrait ? 122 : Je.isSquare ? 156 : 159
                          , Io = .48 * Q / It
                          , ti = .98 * Q / It;
                        return {
                            rx: 0,
                            ry: 0,
                            startX: (Q - (ti * (It - 1) + Io)) / 2,
                            startY: ce / 2,
                            barWidth: Io,
                            breakBetweenBarWidth: ti,
                            samples: It,
                            breakBetweenBarCallback: function({sampleNumber: rn}) {
                                return Math.round(this.startX + rn * this.breakBetweenBarWidth)
                            }
                        }
                    }
                }
                exportSvg() {
                    var Q = this;
                    return (0,
                    Ut.A)(function*() {
                        var ce, xe;
                        const Je = yield(0,
                        it._)(yield Q.httpClient.post("/api/soundwave/svg", {
                            svg: null !== (ce = null === (xe = Q.svgElement) || void 0 === xe ? void 0 : xe.nativeElement.outerHTML) && void 0 !== ce ? ce : ""
                        }));
                        Q.soundwaveForm.controls.uuid.setValue(Je.svgId)
                    })()
                }
                arrayBufferToBase64(Q) {
                    let ce = "";
                    const xe = new Uint8Array(Q)
                      , Je = xe.byteLength;
                    for (let Fe = 0; Fe < Je; Fe++)
                        ce += String.fromCharCode(xe[Fe]);
                    return window.btoa(ce)
                }
                onPhotoSelect() {
                    this.photoSelect.emit([this.imageInstanceSize.width, this.imageInstanceSize.height])
                }
                onImageLoad() {
                    this.load++,
                    1 === this.load && (this.svgImage = this.temporarySvg,
                    this.cdr.detectChanges())
                }
                getImageConfig(Q, ce) {
                    return Q.photoFiles[ce].uuid ? "".concat(this.environmentPhotoApi, "/v2/").concat(this.isFinalPoster ? "photo" : "image", "/").concat(Q.photoFiles[ce].uuid, "?type=").concat(Q.cropsData[ce].filter, "&left=").concat(Q.cropsData[ce].cropData.x, "&top=").concat(Q.cropsData[ce].cropData.y, "&width=").concat(Q.cropsData[ce].cropData.width, "&height=").concat(Q.cropsData[ce].cropData.height, "&rotate=").concat(Q.cropsData[ce].rotate, "&flipped=").concat(Q.cropsData[ce].flip) : ""
                }
            }
            return (U = V).\u0275fac = function(Q) {
                return new (Q || U)(r.rXU(r.aKT),r.rXU(r.SKi),r.rXU(r.gRc),r.rXU(br.Qq),r.rXU(pc.up))
            }
            ,
            U.\u0275cmp = r.VBU({
                type: U,
                selectors: [["pp-poster-soundwave"]],
                viewQuery: function(Q, ce) {
                    if (1 & Q && (r.GBs(Jr, 5),
                    r.GBs(dc, 5),
                    r.GBs(sa, 5)),
                    2 & Q) {
                        let xe;
                        r.mGM(xe = r.lsd()) && (ce.playerUpload = xe.first),
                        r.mGM(xe = r.lsd()) && (ce.playerYoutube = xe.first),
                        r.mGM(xe = r.lsd()) && (ce.svgElement = xe.first)
                    }
                },
                inputs: {
                    soundwaveForm: "soundwaveForm",
                    isSvgSoundwave: "isSvgSoundwave",
                    defaultSoundwave: "defaultSoundwave",
                    photoFileGroup: "photoFileGroup",
                    photoCropGroup: "photoCropGroup",
                    photoId: "photoId",
                    multiFile: "multiFile",
                    environmentPhotoApi: "environmentPhotoApi",
                    isFileUploadingInProgress: "isFileUploadingInProgress"
                },
                outputs: {
                    youtubeLading: "youtubeLading",
                    youtubeError: "youtubeError",
                    photoSelect: "photoSelect",
                    setFileUpploadingProgress: "setFileUpploadingProgress"
                },
                features: [r.Vt3],
                decls: 7,
                vars: 10,
                consts: [["svgElement", ""], ["playerUpload", ""], ["playerYoutube", ""], [3, "background"], [3, "poster", 4, "ngIf"], ["controls", "controls", "autobuffer", "autobuffer", 1, "audioPlayer"], [3, "poster"], [1, "passepartout-wrapper"], [1, "image-instance"], [1, "svg-container", 3, "fontSize", "marginTop", "height", "width", "classic", "bars", "innerHTML"], [1, "soundwave-wrapper", 3, "marginTop", "height", "width"], [3, "textareaHeightCallback", "poster", "color", "background", "textArea", "title", "subtitle"], [1, "qr-code", 3, "no-final-poster", "background", "width", "height", "right", "bottom", "innerHTML"], [1, "passepartout", "top"], [1, "passepartout", "left"], [1, "passepartout", "right"], [1, "passepartout", "bottom"], [3, "src"], [3, "photoFileGroup", "photoCropGroup", "photoId", "multiFile", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "isFileUploadingInProgress", "legalNote"], [3, "load", "click", "src"], [3, "setFileUploadingProgress", "photoFileGroup", "photoCropGroup", "photoId", "multiFile", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "isFileUploadingInProgress", "legalNote"], [1, "svg-container", 3, "innerHTML"], [1, "soundwave-wrapper"], [1, "loader-wrapper"], ["id", "waveform", "preserveAspectRatio", "xMidYMid meet", "xmlns", "http://www.w3.org/2000/svg", 3, "classic", "bars", "isLandscape"], [3, "showStatus", "fontColor", "disableText", "reverse"], ["id", "waveform", "preserveAspectRatio", "xMidYMid meet", "xmlns", "http://www.w3.org/2000/svg"], ["fill-opacity", "1", "stroke-opacity", "1", "id", "waveformgroup"], [1, "play-line", 3, "margin-left", "margin-right", "background-color", "transform"], [1, "play-line"], [1, "qr-code", 3, "innerHTML"], [3, "src", "type"]],
                template: function(Q, ce) {
                    1 & Q && (r.j41(0, "pp-poster-background", 3),
                    r.DNE(1, La, 15, 29, "pp-poster-printing-registration", 4),
                    r.nI1(2, "async"),
                    r.k0s(),
                    r.DNE(3, gc, 3, 2, "audio", 5),
                    r.nI1(4, "async"),
                    r.DNE(5, aa, 3, 2, "audio", 5),
                    r.nI1(6, "async")),
                    2 & Q && (r.Y8G("background", ce.soundwave.background),
                    r.R7$(),
                    r.Y8G("ngIf", r.bMT(2, 4, ce.poster$)),
                    r.R7$(2),
                    r.vxM(ce.audioUpload && r.bMT(4, 6, ce.isAudioPlayAvailable$) ? 3 : -1),
                    r.R7$(2),
                    r.vxM(ce.audioYoutube && r.bMT(6, 8, ce.isAudioPlayAvailable$) ? 5 : -1))
                },
                dependencies: [Mt.Z, s.R, _t.c, so.y, Wt.W, Ae.MD, Ae.bT, Ae.Jj, ml.VU, ml.ex, Ra.h, Ra.D9],
                styles: ["[_nghost-%COMP%]{width:100%;height:100%;display:block}[_nghost-%COMP%]   .image-instance[_ngcontent-%COMP%]{position:absolute}[_nghost-%COMP%]   .image-instance.image-instance-first-layer[_ngcontent-%COMP%]{z-index:2}[_nghost-%COMP%]   .image-instance[_ngcontent-%COMP%]   pp-controls-file-uploader[_ngcontent-%COMP%]{position:absolute;top:0;left:0;right:0;bottom:0;z-index:1020}[_nghost-%COMP%]   .image-instance[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:100%;height:100%;object-fit:cover;cursor:pointer}[_nghost-%COMP%]   img.moon-instance[_ngcontent-%COMP%]{width:100%;height:100%}[_nghost-%COMP%]   .passepartout-wrapper[_ngcontent-%COMP%]{position:absolute;width:100%;height:100%;left:0;top:0}[_nghost-%COMP%]   .passepartout-wrapper[_ngcontent-%COMP%]   .passepartout[_ngcontent-%COMP%]{position:absolute;background:#fff}[_nghost-%COMP%]   .passepartout-wrapper[_ngcontent-%COMP%]   .passepartout.top[_ngcontent-%COMP%]{left:0;top:0;right:0}[_nghost-%COMP%]   .passepartout-wrapper[_ngcontent-%COMP%]   .passepartout.bottom[_ngcontent-%COMP%]{left:0;bottom:0;right:0}[_nghost-%COMP%]   .passepartout-wrapper[_ngcontent-%COMP%]   .passepartout.left[_ngcontent-%COMP%]{left:0;top:0;bottom:0}[_nghost-%COMP%]   .passepartout-wrapper[_ngcontent-%COMP%]   .passepartout.right[_ngcontent-%COMP%]{right:0;top:0;bottom:0}[_nghost-%COMP%]   .qr-code[_ngcontent-%COMP%]{background:pink;position:absolute;z-index:10;overflow:hidden;display:flex;justify-content:center;align-items:center}[_nghost-%COMP%]   .qr-code.no-final-poster[_ngcontent-%COMP%]{transform:translate3d(0,1px,0)}[_nghost-%COMP%]   .svg-container[_ngcontent-%COMP%]{display:block;overflow:hidden;position:relative}[_nghost-%COMP%]   .svg-container[_ngcontent-%COMP%]     svg{width:100%;height:100%;position:absolute}[_nghost-%COMP%]   .svg-container.classic[_ngcontent-%COMP%]     svg{shape-rendering:crispEdges}[_nghost-%COMP%]   .svg-container.bars[_ngcontent-%COMP%]     svg{shape-rendering:geometricPrecision}[_nghost-%COMP%]   .soundwave-wrapper[_ngcontent-%COMP%]{display:block;overflow:hidden;position:relative;pointer-events:none}[_nghost-%COMP%]   .soundwave-wrapper[_ngcontent-%COMP%]   .loader-wrapper[_ngcontent-%COMP%]{width:100%;height:100%;display:flex;align-items:center;justify-content:center}[_nghost-%COMP%]   .soundwave-wrapper[_ngcontent-%COMP%]   .play-line[_ngcontent-%COMP%]{width:1px;position:absolute;display:block;top:0;bottom:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}[_nghost-%COMP%]   .soundwave-wrapper[_ngcontent-%COMP%]     svg.classic{shape-rendering:crispEdges}[_nghost-%COMP%]   .soundwave-wrapper[_ngcontent-%COMP%]     svg.bars{-webkit-backface-visibility:hidden;backface-visibility:hidden}[_nghost-%COMP%]   .soundwave-wrapper[_ngcontent-%COMP%]     svg.bars.isLandscape{shape-rendering:geometricPrecision}"]
            }),
            V
        }
        )()
    }
    ,
    92237: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            a: () => mo
        });
        var Ut = $(10467)
          , r = $(7494)
          , Mt = $(9566)
          , s = $(13620)
          , so = $(61762)
          , Wt = $(69847)
          , _t = $(60177)
          , Ae = $(27617)
          , Me = $(78606)
          , ct = $(50552)
          , Tt = $(15996)
          , Qe = $(84412)
          , jt = $(84572)
          , Xe = $(56977)
          , Ce = $(54843)
          , it = $(96354)
          , et = $(70152)
          , re = $(41046)
          , pt = $(76675)
          , Be = $(54438)
          , ze = $(21626)
          , ye = $(345);
        const ge = ["svgContainer"];
        function Ie(no, Co) {
            if (1 & no) {
                const Lt = Be.RV6();
                Be.j41(0, "pp-poster-text-area", 12),
                Be.nI1(1, "async"),
                Be.nI1(2, "async"),
                Be.nI1(3, "async"),
                Be.nI1(4, "async"),
                Be.bIt("textareaHeightCallback", function(co) {
                    Be.eBV(Lt);
                    const Jt = Be.XpG(2);
                    return Be.Njj(Jt.newTopTextareaHeight(co))
                }),
                Be.k0s()
            }
            if (2 & no) {
                const Lt = Be.XpG(2);
                Be.Y8G("poster", Be.bMT(1, 4, Lt.poster$))("color", Be.bMT(2, 6, Lt.textColor$))("textArea", Be.bMT(3, 8, Lt.topTextArea$))("title", Be.bMT(4, 10, Lt.title$))
            }
        }
        function gt(no, Co) {
            if (1 & no && Be.nrm(0, "div", 13),
            2 & no) {
                const Lt = Be.XpG(2);
                Be.xc7("background-color", Lt.lineArt.background)("color", Lt.lineArt.color),
                Be.Y8G("innerHTML", Lt.lineArt.exampleInformation, Be.npT)
            }
        }
        function Ye(no, Co) {
            if (1 & no && Be.nrm(0, "div", 14, 1),
            2 & no) {
                const Lt = Be.XpG(2);
                Be.xc7("stroke", "unset")("fill", Lt.lineArt.color)("width", Lt.lineArt.width, "px")("height", Lt.lineArt.height, "px"),
                Be.Y8G("innerHTML", Lt.lineArt.image, Be.npT)
            }
        }
        function yt(no, Co) {
            if (1 & no) {
                const Lt = Be.RV6();
                Be.j41(0, "pp-poster-printing-registration", 5)(1, "pp-poster-arrangement-wrapper", 6),
                Be.DNE(2, Ie, 5, 12, "pp-poster-text-area", 7),
                Be.j41(3, "pp-poster-image-area")(4, "div", 8),
                Be.DNE(5, gt, 1, 5, "div", 9)(6, Ye, 2, 9, "div", 10),
                Be.k0s()(),
                Be.j41(7, "pp-poster-text-area", 11),
                Be.nI1(8, "async"),
                Be.nI1(9, "async"),
                Be.nI1(10, "async"),
                Be.nI1(11, "async"),
                Be.nI1(12, "async"),
                Be.nI1(13, "async"),
                Be.bIt("textareaHeightCallback", function(co) {
                    Be.eBV(Lt);
                    const Jt = Be.XpG();
                    return Be.Njj(Jt.newTextareaHeight(co))
                }),
                Be.k0s()()()
            }
            if (2 & no) {
                const Lt = Co.ngIf
                  , Ft = Be.XpG();
                Be.Y8G("poster", Lt)("withPassepartout", Ft.lineArt.passepartoutSize > 0),
                Be.R7$(),
                Be.Y8G("passepartoutSize", Ft.lineArt.passepartoutSize),
                Be.R7$(),
                Be.Y8G("ngIf", Ft.lineArt.topTitle),
                Be.R7$(2),
                Be.xc7("top", Ft.lineArt.top, "px")("width", Ft.lineArt.width, "px")("height", Ft.lineArt.height, "px"),
                Be.R7$(),
                Be.vxM(Ft.lineArt.exampleInformation && !Ft.lineArt.isPredefinedImage ? 5 : -1),
                Be.R7$(),
                Be.vxM(!Ft.isFinalPoster || Ft.isFinalPoster && Ft.lineArt.isPredefinedImage ? 6 : -1),
                Be.R7$(),
                Be.Y8G("poster", Be.bMT(8, 19, Ft.poster$))("color", Be.bMT(9, 21, Ft.textColor$))("textArea", Be.bMT(10, 23, Ft.textArea$))("title", Ft.lineArt.topTitle ? void 0 : Be.bMT(11, 25, Ft.title$))("subtitle", Be.bMT(12, 27, Ft.subtitle$))("footer", Be.bMT(13, 29, Ft.footer$))("background", Ft.lineArt.textBackground)
            }
        }
        function ht(no, Co) {
            1 & no && Be.nrm(0, "pp-poster-loaded-element")
        }
        let mo = ( () => {
            var no;
            class Co extends ct.C {
                constructor(Ft, co, Jt, po, Et) {
                    super(Ft, co),
                    this.host = Ft,
                    this.zone = co,
                    this.cdr = Jt,
                    this.httpClient = po,
                    this.domSanitizer = Et,
                    this.lineArt = {
                        top: 0,
                        width: 0,
                        height: 0,
                        background: "#DCCCC0",
                        color: "#FFF",
                        layout: Ae.WTf.MINIMAL,
                        textBackground: "transparent",
                        exampleInformation: "",
                        isPredefinedImage: !0,
                        passepartoutSize: 0,
                        topTitle: !1,
                        graphic: Ae.UzR.ANNIVERSARY,
                        image: ""
                    },
                    this.textAreaHeight$ = new Qe.t(null),
                    this.topTextAreaHeight$ = new Qe.t(null),
                    this.careAboutSvgVisibility()
                }
                ngAfterViewInit() {
                    (0,
                    jt.z)([this.poster$, this.textArea$, this.topTextArea$, this.textAreaHeight$, this.topTextAreaHeight$]).pipe((0,
                    et.B)(200), (0,
                    Xe.Q)(this.ngUnsubscribe)).subscribe( ([Ft,co,Jt,po,Et]) => {
                        var Kt, At;
                        if (!Ft || null === po)
                            return;
                        const ve = (null !== (Kt = null == Jt ? void 0 : Jt.topFactor) && void 0 !== Kt ? Kt : 0) * (Ft.isPortrait ? Ft.size.width : Ft.size.height)
                          , ne = this.lineArt.topTitle ? (Et || 0) + ve : 0
                          , B = (null !== (At = null == co ? void 0 : co.bottomFactor) && void 0 !== At ? At : 0) * (Ft.isPortrait ? Ft.size.width : Ft.size.height) + po
                          , de = Ft.size.height - B - ne;
                        this.lineArt.height = .98 * de,
                        this.lineArt.top = .02 * de + ne,
                        this.lineArt.width = Ft.isPortrait ? .9 * Ft.size.width : .69 * Ft.size.height
                    }
                    )
                }
                setAllTextSettings(Ft) {
                    const co = {
                        text: Ft.customMessage ? Ft.title : "",
                        isDefaultFont: !Ft.titleFontScript
                    };
                    this.setText(co, this.title$, {
                        font: null != co && co.isDefaultFont ? Ae.n3q.ROBOTO_THIN : Ae.n3q.HELLO_OCTOBER,
                        portrait: {
                            sizeFactor: null != co && co.isDefaultFont ? .058 : .088,
                            bottomFactor: 1.35 * (null != co && co.isDefaultFont ? .014 : .018),
                            topFactor: .03,
                            isBold: !1
                        },
                        horizontal: {
                            sizeFactor: null != co && co.isDefaultFont ? .058 : .08,
                            bottomFactor: null != co && co.isDefaultFont ? .014 : .018,
                            topFactor: .03,
                            isBold: !1
                        }
                    });
                    const Jt = {
                        text: Ft.customMessage ? Ft.subtitle : "",
                        isDefaultFont: !Ft.subtitleFontScript
                    }
                      , po = {
                        text: Ft.customMessage ? Ft.footer : "",
                        isDefaultFont: !0
                    };
                    this.setText(Jt, this.subtitle$, {
                        font: null != Jt && Jt.isDefaultFont ? Ae.n3q.ROBOTO_THIN : Ae.n3q.HELLO_OCTOBER,
                        portrait: {
                            sizeFactor: null != Jt && Jt.isDefaultFont ? .032 : .052,
                            bottomFactor: Ft.textLayout !== Ae.fq_.PASSEPARTOUT || po.text ? 0 : .01,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: null != Jt && Jt.isDefaultFont ? .032 : .052,
                            bottomFactor: Ft.textLayout !== Ae.fq_.PASSEPARTOUT || po.text ? 0 : .01,
                            topFactor: 0
                        }
                    }),
                    this.setText(po, this.footer$, {
                        font: Ae.n3q.CAPSUULA,
                        portrait: {
                            sizeFactor: .025,
                            bottomFactor: Ft.textLayout === Ae.fq_.PASSEPARTOUT ? .01 : 0,
                            topFactor: .02
                        },
                        horizontal: {
                            sizeFactor: .016,
                            bottomFactor: Ft.textLayout === Ae.fq_.PASSEPARTOUT ? .01 : 0,
                            topFactor: .02
                        }
                    })
                }
                setTextArea(Ft, co) {
                    this.textArea$.next(co.textLayout === Ae.fq_.PASSEPARTOUT ? {
                        bottomFactor: .035,
                        marginFactor: Ft.isPortrait ? .03 : .02,
                        topFactor: 0
                    } : {
                        bottomFactor: .04,
                        marginFactor: Ft.isPortrait ? .07 : .04,
                        topFactor: 0
                    }),
                    this.topTextArea$.next({
                        topFactor: .04,
                        marginFactor: Ft.isPortrait ? .08 : .04
                    }),
                    this.setPretext(Ft)
                }
                setDesign(Ft, co) {
                    var Jt = this;
                    return (0,
                    Ut.A)(function*() {
                        var Et;
                        Jt.lineArt.background = Jt.lineArtBackground(co.colorScheme, co.customColors),
                        Jt.lineArt.color = Jt.lineArtColor(co.colorScheme, co.customColors),
                        Jt.lineArt.layout = co.layout,
                        Jt.lineArt.textBackground = co.textLayout === Ae.fq_.PASSEPARTOUT ? "#FFF" : "transparent",
                        Jt.lineArt.exampleInformation = Jt.isFinalPoster ? "" : co.exampleMessage,
                        Jt.lineArt.graphic = co.graphic,
                        Jt.lineArt.passepartoutSize = co.textLayout === Ae.fq_.PASSEPARTOUT ? .035 * (Ft.isPortrait ? Ft.size.width : Ft.size.height) : 0,
                        Jt.lineArt.topTitle = co.textLayout === Ae.fq_.TOP_AND_BOTTOM,
                        Jt.textColor$.next(Jt.getTextColor(co.colorScheme, co.customColors, co.textLayout === Ae.fq_.PASSEPARTOUT)),
                        Jt.lineArt.isPredefinedImage = co.isSelectedIllustration,
                        Jt.lineArt.image = Jt.domSanitizer.bypassSecurityTrustHtml(co.isSelectedIllustration ? yield(0,
                        Ce._)(Jt.httpClient.get((Et = co.illustrationUuid,
                        "".concat(window.location.origin, "/api/files-management/").concat(Et, "/").concat(co.layout === Ae.WTf.MINIMAL ? Ae.Iwg.primary : Ae.Iwg.secondary, "?editor=").concat(Ae.hb4.lineArt))).pipe((0,
                        it.T)(Et => (0,
                        pt.k9)((0,
                        pt.ID)("image/svg+xml", Et.image))))) : yield(0,
                        Ce._)(Jt.httpClient.get("/assets/pp-posters/line-art/".concat(Jt.lineArt.layout, "/").concat(Jt.lineArt.graphic, ".svg"), {
                            responseType: "text"
                        })))
                    })()
                }
                careAboutSvgVisibility() {
                    var Ft;
                    if (this.isFinalPoster && !this.lineArt.isPredefinedImage)
                        return void this.onImageLoad();
                    const co = null === (Ft = this.svgContainer) || void 0 === Ft || null === (Ft = Ft.nativeElement) || void 0 === Ft ? void 0 : Ft.querySelector("svg");
                    co && co.clientWidth > 0 ? this.onImageLoad() : setTimeout( () => {
                        this.careAboutSvgVisibility()
                    }
                    , 100)
                }
                newTextareaHeight(Ft) {
                    this.textAreaHeight$.next(Ft)
                }
                newTopTextareaHeight(Ft) {
                    this.topTextAreaHeight$.next(Ft)
                }
                setPretext(Ft) {
                    this.pretext$.next({
                        width: Ft.isPortrait ? .045 * Ft.size.width : .035 * Ft.size.height,
                        marginBottom: Ft.isPortrait ? .02 * Ft.size.width : .015 * Ft.size.height
                    })
                }
                getTextColor(Ft, co, Jt) {
                    if (Jt)
                        switch (Ft) {
                        case Ae.vBG.BLUE_GRAY:
                            return "#376570";
                        case Ae.vBG.VINTAGE:
                            return "#AE7C62";
                        default:
                            return "#0e1111"
                        }
                    return Ft === Ae.vBG.CUSTOM ? (0,
                    Tt.V)(co.background) ? "#FFF" : "#0e1111" : this.lineArtColor(Ft, co)
                }
                lineArtBackground(Ft, co) {
                    switch (Ft) {
                    case Ae.vBG.COSMIC_LATTE:
                        return "#f6E5CE";
                    case Ae.vBG.DEEP_SPACE_BLUE:
                        return "#0f1721";
                    case Ae.vBG.SIMPLE:
                        return "#FFF";
                    case Ae.vBG.VINTAGE:
                        return "#ECEAE2";
                    case Ae.vBG.OLD_PAPER:
                        return "#DCCCBF";
                    case Ae.vBG.BLUE_GRAY:
                        return "#A0B0B8";
                    case Ae.vBG.PINK:
                        return "#F6E1D4";
                    case Ae.vBG.CUSTOM:
                        return "#".concat(co.background)
                    }
                }
                lineArtColor(Ft, co) {
                    switch (Ft) {
                    case Ae.vBG.COSMIC_LATTE:
                        return "#0f1721";
                    case Ae.vBG.DEEP_SPACE_BLUE:
                        return "#f6E5CE";
                    case Ae.vBG.SIMPLE:
                    case Ae.vBG.OLD_PAPER:
                    case Ae.vBG.PINK:
                        return "#0e1111";
                    case Ae.vBG.BLUE_GRAY:
                        return "#376570";
                    case Ae.vBG.VINTAGE:
                        return "#AE7C62";
                    case Ae.vBG.CUSTOM:
                        return "#".concat(co.lineArt)
                    }
                }
                onImageLoad() {
                    this.load++,
                    1 === this.load && (this.initiateRender(),
                    this.cdr.detectChanges())
                }
            }
            return (no = Co).\u0275fac = function(Ft) {
                return new (Ft || no)(Be.rXU(Be.aKT),Be.rXU(Be.SKi),Be.rXU(Be.gRc),Be.rXU(ze.Qq),Be.rXU(ye.up))
            }
            ,
            no.\u0275cmp = Be.VBU({
                type: no,
                selectors: [["pp-poster-line-art"]],
                viewQuery: function(Ft, co) {
                    if (1 & Ft && Be.GBs(ge, 5),
                    2 & Ft) {
                        let Jt;
                        Be.mGM(Jt = Be.lsd()) && (co.svgContainer = Jt.first)
                    }
                },
                features: [Be.Vt3],
                decls: 5,
                vars: 5,
                consts: [["posterWrapper", ""], ["svgContainer", ""], [3, "background"], [3, "poster", "withPassepartout", 4, "ngIf"], [4, "ngIf"], [3, "poster", "withPassepartout"], [3, "passepartoutSize"], [3, "poster", "color", "textArea", "title", "textareaHeightCallback", 4, "ngIf"], [1, "line-art-instance"], [1, "example-information", 3, "innerHTML", "background-color", "color"], [3, "innerHTML", "stroke", "fill", "width", "height"], [3, "textareaHeightCallback", "poster", "color", "textArea", "title", "subtitle", "footer", "background"], [3, "textareaHeightCallback", "poster", "color", "textArea", "title"], [1, "example-information", 3, "innerHTML"], [3, "innerHTML"]],
                template: function(Ft, co) {
                    1 & Ft && (Be.j41(0, "pp-poster-background", 2, 0),
                    Be.DNE(2, yt, 14, 31, "pp-poster-printing-registration", 3),
                    Be.nI1(3, "async"),
                    Be.k0s(),
                    Be.DNE(4, ht, 1, 0, "pp-poster-loaded-element", 4)),
                    2 & Ft && (Be.Y8G("background", co.lineArt.background),
                    Be.R7$(2),
                    Be.Y8G("ngIf", Be.bMT(3, 3, co.poster$)),
                    Be.R7$(2),
                    Be.Y8G("ngIf", co.isImageRendered))
                },
                dependencies: [_t.MD, _t.bT, _t.Jj, r.Z, Mt.R, Wt.c, s.y, so.W, Me.iu, re.C],
                styles: ["[_nghost-%COMP%]{width:100%;height:100%;display:block}[_nghost-%COMP%]   .line-art-instance[_ngcontent-%COMP%]{box-sizing:border-box;display:flex;justify-content:center;align-items:center;position:absolute;left:0;right:0;margin:auto}[_nghost-%COMP%]   .line-art-instance[_ngcontent-%COMP%]     svg{width:100%;height:100%}[_nghost-%COMP%]   .line-art-instance[_ngcontent-%COMP%]   .example-information[_ngcontent-%COMP%]{font-family:roobert,Arial,sans-serif;position:absolute;line-height:1.1em;font-size:1.3em;text-align:center;padding:4px;transform:rotate(346.8deg)}@media (max-width: 510px){[_nghost-%COMP%]   .line-art-instance[_ngcontent-%COMP%]   .example-information[_ngcontent-%COMP%]{font-size:1.2em}}@media (max-width: 450px){[_nghost-%COMP%]   .line-art-instance[_ngcontent-%COMP%]   .example-information[_ngcontent-%COMP%]{font-size:1.1em}}"]
            }),
            Co
        }
        )()
    }
    ,
    93967: (zi, Bo, $) => {
        "use strict";
        function Ut(r) {
            return r.isPortrait ? "portrait" : r.isSquare ? "square" : "landscape"
        }
        $.d(Bo, {
            v: () => Ut
        })
    }
    ,
    94917: (zi, Bo, $) => {
        "use strict";
        $.d(Bo, {
            _: () => Et
        });
        var Ut = $(10467)
          , r = $(54438)
          , Mt = $(7494)
          , s = $(9566)
          , so = $(13620)
          , Wt = $(61762)
          , _t = $(69847)
          , Ae = $(60177)
          , Me = $(27617)
          , ct = $(15996)
          , Tt = $(50552)
          , Qe = $(74412)
          , jt = $(41046)
          , Xe = $(2745)
          , Ce = $(84412)
          , it = $(84572)
          , et = $(56977)
          , re = $(70152)
          , pt = $(49427)
          , Be = $(73955)
          , ze = $(66985);
        const ye = (Kt, At, Re, ve) => ({
            title$: Kt,
            footer$: At,
            moonElement: Re,
            photo$: ve,
            moonId: 0
        })
          , ge = (Kt, At, Re, ve) => ({
            title$: Kt,
            footer$: At,
            moonElement: Re,
            photo$: ve,
            moonId: 1
        })
          , Ie = (Kt, At, Re, ve) => ({
            title$: Kt,
            footer$: At,
            moonElement: Re,
            photo$: ve,
            moonId: 2
        })
          , gt = (Kt, At) => [Kt, At]
          , Ye = () => [".jpeg", ".jpg", ".png", ".heic"];
        function yt(Kt, At) {
            if (1 & Kt && (r.j41(0, "pp-poster-space-splitter", 14),
            r.eu8(1, 15)(2, 16)(3, 17),
            r.k0s()),
            2 & Kt) {
                const Re = r.XpG().ngIf
                  , ve = r.XpG(2)
                  , ne = r.sdS(5);
                r.xc7("width", Re.width, "px")("height", Re.height, "px")("margin-top", Re.marginTop, "px"),
                r.Y8G("isTriple", !0),
                r.R7$(),
                r.Y8G("ngTemplateOutlet", ne)("ngTemplateOutletContext", r.ziG(13, ye, ve.title1$, ve.footer1$, ve.moonElement1, ve.photo1$)),
                r.R7$(),
                r.Y8G("ngTemplateOutlet", ne)("ngTemplateOutletContext", r.ziG(18, ge, ve.title2$, ve.footer2$, ve.moonElement2, ve.photo2$)),
                r.R7$(),
                r.Y8G("ngTemplateOutlet", ne)("ngTemplateOutletContext", r.ziG(23, Ie, ve.title3$, ve.footer3$, ve.moonElement3, ve.photo3$))
            }
        }
        function ht(Kt, At) {
            if (1 & Kt && (r.qex(0),
            r.DNE(1, yt, 4, 28, "pp-poster-space-splitter", 13),
            r.bVm()),
            2 & Kt) {
                const Re = At.ngIf;
                r.R7$(),
                r.Y8G("ngIf", Re.width && Re.height)
            }
        }
        function mo(Kt, At) {
            if (1 & Kt) {
                const Re = r.RV6();
                r.j41(0, "pp-poster-printing-registration", 11)(1, "pp-poster-arrangement-wrapper")(2, "pp-poster-text-area", 12),
                r.nI1(3, "async"),
                r.nI1(4, "async"),
                r.nI1(5, "async"),
                r.nI1(6, "async"),
                r.nI1(7, "async"),
                r.bIt("textareaHeightCallback", function(ne) {
                    r.eBV(Re);
                    const B = r.XpG();
                    return r.Njj(B.newTopTextareaHeight(ne))
                })("textareaWidthCallback", function(ne) {
                    r.eBV(Re);
                    const B = r.XpG();
                    return r.Njj(B.newTopTextareaWidth(ne))
                }),
                r.k0s(),
                r.DNE(8, ht, 2, 1, "ng-container", 4),
                r.nI1(9, "async"),
                r.k0s()()
            }
            if (2 & Kt) {
                const Re = At.ngIf
                  , ve = r.XpG();
                r.Y8G("poster", Re),
                r.R7$(2),
                r.Y8G("poster", r.bMT(3, 7, ve.poster$))("color", r.bMT(4, 9, ve.textColor$))("textArea", r.bMT(5, 11, ve.topTextArea$))("title", r.bMT(6, 13, ve.title$))("subtitle", r.bMT(7, 15, ve.subtitle$)),
                r.R7$(6),
                r.Y8G("ngIf", r.bMT(9, 17, ve.splitElementsSize$))
            }
        }
        function no(Kt, At) {
            if (1 & Kt) {
                const Re = r.RV6();
                r.j41(0, "pp-poster-image-area", 22)(1, "img", 24),
                r.bIt("load", function() {
                    r.eBV(Re);
                    const ne = r.XpG(3);
                    return r.Njj(ne.onImageLoad())
                }),
                r.k0s(),
                r.nrm(2, "pp-poster-preview", 25),
                r.k0s()
            }
            if (2 & Kt) {
                const Re = r.XpG(2).moonElement
                  , ve = r.XpG();
                r.Y8G("relative", !0),
                r.R7$(),
                r.xc7("margin-top", ve.moon.margin, "px")("width", ve.moon.width, "px")("height", ve.moon.width, "px")("transform", "rotate(" + Re.rotation + "deg)"),
                r.Y8G("src", Re.image, r.B4B),
                r.R7$(),
                r.Y8G("showPreview", !ve.isFinalPoster)("marginTop", !1)("previewType", "moon")
            }
        }
        function Co(Kt, At) {
            if (1 & Kt) {
                const Re = r.RV6();
                r.j41(0, "img", 29),
                r.bIt("load", function() {
                    r.eBV(Re);
                    const ne = r.XpG(4);
                    return r.Njj(ne.onImageLoad())
                })("click", function() {
                    r.eBV(Re);
                    const ne = r.XpG(4);
                    return r.Njj(ne.onPhotoSelect())
                }),
                r.k0s()
            }
            if (2 & Kt) {
                const Re = r.XpG(2).ngIf
                  , ve = r.XpG(2);
                r.Y8G("src", ve.getPhotoWithType(Re).imageUrl, r.B4B)
            }
        }
        function Lt(Kt, At) {
            if (1 & Kt) {
                const Re = r.RV6();
                r.j41(0, "pp-controls-file-uploader-photo", 30),
                r.nI1(1, "translate"),
                r.bIt("setFileUploadingProgress", function(ne) {
                    r.eBV(Re);
                    const B = r.XpG(4);
                    return r.Njj(B.setFileUpploadingProgress.emit(ne))
                }),
                r.k0s()
            }
            if (2 & Kt) {
                const Re = r.XpG(4);
                r.Y8G("photoFileGroup", Re.photoFileGroup)("photoCropGroup", Re.photoCropGroup)("photoId", Re.photoId)("multiFile", Re.multiFile)("isSubmitted", !1)("acceptable", r.lJ4(14, Ye))("isBase64Response", !0)("fullHeight", !0)("isBigPictureMode", !0)("withBackgroundGray", !0)("isFileUploadingInProgress", Re.isFileUploadingInProgress)("legalNote", r.bMT(1, 12, "soundwave.details.instruction"))
            }
        }
        function Ft(Kt, At) {
            if (1 & Kt && (r.j41(0, "div", 26),
            r.DNE(1, Co, 1, 1, "img", 27)(2, Lt, 2, 15, "pp-controls-file-uploader-photo", 28),
            r.k0s()),
            2 & Kt) {
                const Re = r.XpG().ngIf
                  , ve = r.XpG(2);
                r.xc7("margin-top", Re.isHeart ? -.08 * ve.moon.width : 0, "px"),
                r.AVh("special-circle", !Re.isHeart)("special-heart", Re.isHeart),
                r.R7$(),
                r.Y8G("ngIf", !ve.getPhotoWithType(Re).showAddPhoto),
                r.R7$(),
                r.Y8G("ngIf", ve.photoFileGroup && ve.getPhotoWithType(Re).showAddPhoto)
            }
        }
        function co(Kt, At) {
            if (1 & Kt && (r.j41(0, "div", 21),
            r.DNE(1, no, 3, 13, "pp-poster-image-area", 22)(2, Ft, 3, 8, "div", 23),
            r.k0s()),
            2 & Kt) {
                const Re = r.XpG().moonId
                  , ve = r.XpG();
                r.xc7("width", ve.moon.height, "px")("height", ve.moon.height, "px"),
                r.R7$(),
                r.vxM(!r.l_i(5, gt, ve.MoonShapesEnum.TRIPLE_WITH_PHOTO, ve.MoonShapesEnum.TRIPLE_WITH_HEART_PHOTO).includes(ve.moon.layout) || r.l_i(8, gt, ve.MoonShapesEnum.TRIPLE_WITH_PHOTO, ve.MoonShapesEnum.TRIPLE_WITH_HEART_PHOTO).includes(ve.moon.layout) && 1 !== Re ? 1 : 2)
            }
        }
        function Jt(Kt, At) {
            if (1 & Kt && (r.j41(0, "pp-poster-image-area")(1, "div", 18),
            r.DNE(2, co, 3, 11, "div", 19),
            r.nI1(3, "async"),
            r.k0s()(),
            r.nrm(4, "pp-poster-text-area", 20),
            r.nI1(5, "async"),
            r.nI1(6, "async"),
            r.nI1(7, "async"),
            r.nI1(8, "async"),
            r.nI1(9, "async")),
            2 & Kt) {
                const Re = At.photo$
                  , ve = At.title$
                  , ne = At.footer$
                  , B = r.XpG();
                r.R7$(),
                r.xc7("margin-top", B.moon.marginTop, "px")("width", B.moon.width, "px")("height", B.moon.height, "px"),
                r.R7$(),
                r.Y8G("ngIf", r.bMT(3, 12, Re)),
                r.R7$(2),
                r.Y8G("poster", r.bMT(5, 14, B.poster$))("color", r.bMT(6, 16, B.textColor$))("textArea", r.bMT(7, 18, B.textArea$))("title", r.bMT(8, 20, ve))("footer", r.bMT(9, 22, ne))
            }
        }
        function po(Kt, At) {
            1 & Kt && r.nrm(0, "pp-poster-loaded-element")
        }
        let Et = ( () => {
            var Kt;
            class At extends Tt.C {
                constructor(ve, ne, B) {
                    super(ve, ne),
                    this.host = ve,
                    this.zone = ne,
                    this.cdr = B,
                    this.MoonShapesEnum = Me.HmI,
                    this.photoId = 1,
                    this.multiFile = !1,
                    this.photoSelect = new r.bkB,
                    this.setFileUpploadingProgress = new r.bkB,
                    this.isFileUploadingInProgress = !1,
                    this.topTextAreaHeight$ = new Ce.t(null),
                    this.topTextAreaWidth$ = new Ce.t(null),
                    this.title1$ = new Ce.t(null),
                    this.footer1$ = new Ce.t(null),
                    this.photo1$ = new Ce.t(null),
                    this.title2$ = new Ce.t(null),
                    this.footer2$ = new Ce.t(null),
                    this.photo2$ = new Ce.t(null),
                    this.title3$ = new Ce.t(null),
                    this.footer3$ = new Ce.t(null),
                    this.photo3$ = new Ce.t(null),
                    this.splitElementsSize$ = new Ce.t({
                        width: 0,
                        height: 0,
                        marginTop: 0
                    }),
                    this.moon = {
                        marginTop: 0,
                        width: 0,
                        height: 0,
                        padding: 0,
                        margin: 0,
                        background: "#FFF",
                        layout: Me.HmI.DOUBLE,
                        punchingDiePadding: 0,
                        punchingDieLineSize: 0
                    },
                    this.moonElement1 = {
                        image: "",
                        rotation: 0
                    },
                    this.moonElement2 = {
                        image: "",
                        rotation: 0
                    },
                    this.moonElement3 = {
                        image: "",
                        rotation: 0
                    }
                }
                ngAfterViewInit() {
                    (0,
                    it.z)([this.poster$, this.topTextArea$, this.topTextAreaHeight$, this.topTextAreaWidth$, this.posterConfiguration$]).pipe((0,
                    re.B)(200), (0,
                    et.Q)(this.ngUnsubscribe)).subscribe( ([ve,ne,B,de,lt]) => {
                        var St, tt;
                        B || (B = 0);
                        const $t = null !== (St = ve.size.height) && void 0 !== St ? St : 0;
                        let Nt = ve.size.height - (B + (null !== (tt = ne.topFactor) && void 0 !== tt ? tt : 0) * $t)
                          , Vt = 0;
                        !(null != lt && lt.title) && null != lt && lt.subtitle && (Vt = .011 * ve.size.height,
                        Nt -= 2 * Vt),
                        (!(null != lt && lt.title) && !(null != lt && lt.subtitle) || !(null != lt && lt.mainTextEnable)) && (Vt = .044 * ve.size.height,
                        Nt -= 2 * Vt),
                        this.isNarrowRatio(ve) && (Nt *= .97),
                        this.splitElementsSize$.next({
                            width: .98 * ve.size.width,
                            height: Nt,
                            marginTop: Vt
                        })
                    }
                    )
                }
                setAllTextSettings(ve) {
                    const ne = ve.moonConfig[0]
                      , B = ve.moonConfig[1]
                      , de = ve.moonConfig[2]
                      , lt = {
                        text: ve.mainTextEnable ? ve.title : "",
                        isDefaultFont: !ve.titleFont
                    }
                      , St = {
                        text: ve.mainTextEnable ? ve.subtitle : "",
                        isDefaultFont: !0
                    }
                      , tt = null != lt && lt.isDefaultFont ? .06 : .08;
                    this.setText(lt, this.title$, {
                        font: null != lt && lt.isDefaultFont ? Me.n3q.CAPSUULA_BOLD : Me.n3q.POSITIVE_PRINTS_SCRIPT_2,
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: tt,
                            bottomFactor: 0,
                            lineHeightFactor: tt * (null != lt && lt.isDefaultFont ? 1.8 : 1.35),
                            topFactor: St.text ? 0 : .015,
                            isBold: !1
                        }
                    }),
                    this.setText(St, this.subtitle$, {
                        font: Me.n3q.CAPSUULA,
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: .032,
                            bottomFactor: 0,
                            lineHeightFactor: .04,
                            maxLines: 2,
                            topFactor: lt.text ? -.01 : .025
                        }
                    });
                    const Nt = {
                        text: ne.title,
                        isDefaultFont: !ne.titleFontScript,
                        showEmptyLine: !0
                    }
                      , Vt = {
                        text: B.title,
                        isDefaultFont: !B.titleFontScript,
                        showEmptyLine: !0
                    }
                      , _o = {
                        text: de.title,
                        isDefaultFont: !de.titleFontScript,
                        showEmptyLine: !0
                    }
                      , Lo = Xt => ({
                        font: null != Xt && Xt.isDefaultFont ? Me.n3q.CAPSUULA_BOLD : Me.n3q.POSITIVE_PRINTS_SCRIPT_2,
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: null != Xt && Xt.isDefaultFont ? .036 : .052,
                            bottomFactor: 0,
                            lineHeightFactor: .058 * 1.34,
                            maxLines: 1,
                            topFactor: 0,
                            isBold: !1
                        }
                    });
                    this.setText(Nt, this.title1$, Lo(Nt)),
                    this.setText(Vt, this.title2$, Lo(Vt)),
                    this.setText(_o, this.title3$, Lo(_o));
                    const ao = ve.layout === Me.HmI.TRIPLE_WITH_HEART_PHOTO || ve.layout === Me.HmI.TRIPLE_WITH_PHOTO
                      , Do = {
                        font: Me.n3q.CAPSUULA,
                        portrait: {
                            sizeFactor: 0,
                            bottomFactor: 0,
                            topFactor: 0
                        },
                        horizontal: {
                            sizeFactor: .018,
                            bottomFactor: 0,
                            lineHeightFactor: .018 * 1.22,
                            heightLines: 2,
                            startFromBottom: !0,
                            topFactor: .0268
                        }
                    };
                    this.setText({
                        text: ne.footer,
                        isDefaultFont: !0,
                        showEmptyLine: !0
                    }, this.footer1$, Do),
                    this.setText({
                        text: ao ? B.photoFootnote : B.footer,
                        isDefaultFont: !0,
                        showEmptyLine: !0
                    }, this.footer2$, Do),
                    this.setText({
                        text: de.footer,
                        isDefaultFont: !0,
                        showEmptyLine: !0
                    }, this.footer3$, Do)
                }
                setTextArea(ve, ne) {
                    this.topTextArea$.next({
                        topFactor: this.isWideRatio(ve, !1) ? .07 : .082,
                        marginFactor: .09
                    });
                    let B = .12;
                    ne.mainTextEnable && (ne.title || ne.subtitle) && (B = ne.titleFont ? .068 : ne.subtitle && !ne.title ? .12 : ne.subtitle ? .07 : this.isWideRatio(ve, !1) ? .05 : .08),
                    this.textArea$.next({
                        bottomFactor: B,
                        marginFactor: .01
                    })
                }
                newTopTextareaHeight(ve) {
                    this.topTextAreaHeight$.next(ve)
                }
                newTopTextareaWidth(ve) {
                    this.topTextAreaWidth$.next(ve)
                }
                setDesign(ve, ne) {
                    var B = this;
                    return (0,
                    Ut.A)(function*() {
                        const de = (St, tt) => {
                            var $t;
                            St.selectedByDate ? (tt.image = "/assets/pp-posters/moon/".concat(B.isFinalPoster ? "_HQ_/" : "", "moon_").concat(ne.shadowMoon ? "shadow" : "transparent", "/").concat(St.moon, ".png"),
                            tt.rotation = St.moonRotation) : (tt.image = "/assets/pp-posters/moon/".concat(B.isFinalPoster ? "_HQ_/" : "", "moon_selected_").concat(ne.shadowMoon ? "shadow" : "transparent", "/").concat(St.selectPhase, ".png"),
                            null !== ($t = St.place) && void 0 !== $t && null !== ($t = $t.center) && void 0 !== $t && $t.latitude && (tt.rotation = St.place.center.latitude > 0 ? 0 : 180))
                        }
                        ;
                        de(ne.moonConfig[0], B.moonElement1),
                        de(ne.moonConfig[1], B.moonElement2),
                        de(ne.moonConfig[2], B.moonElement3),
                        B.setSizes(ve),
                        B.moon.layout = ne.layout,
                        B.moon.background = (0,
                        Qe.G)(ne.style, B.isFinalPoster, ne.customBackground, "landscape"),
                        B.photo1$.next({
                            isPhoto: !1,
                            isHeart: !1,
                            uuid: "",
                            imageUrl: "",
                            showAddPhoto: !1
                        });
                        const lt = ne.moonConfig[1];
                        B.photo2$.next({
                            isPhoto: [Me.HmI.TRIPLE_WITH_HEART_PHOTO, Me.HmI.TRIPLE_WITH_PHOTO].includes(null == ne ? void 0 : ne.layout),
                            isHeart: [Me.HmI.TRIPLE_WITH_HEART_PHOTO].includes(null == ne ? void 0 : ne.layout),
                            uuid: lt.photoFiles[0].uuid,
                            imageUrl: "".concat(B.environmentPhotoApi, "/v2/").concat(B.isFinalPoster ? "photo" : "image", "/").concat(lt.photoFiles[0].uuid, "?type=").concat(lt.cropsData[0].filter, "&left=").concat(lt.cropsData[0].cropData.x, "&top=").concat(lt.cropsData[0].cropData.y, "&width=").concat(lt.cropsData[0].cropData.width, "&height=").concat(lt.cropsData[0].cropData.height, "&rotate=").concat(lt.cropsData[0].rotate, "&flipped=").concat(lt.cropsData[0].flip),
                            showAddPhoto: !lt.photoFiles[0].uuid
                        }),
                        B.photo3$.next({
                            isPhoto: !1,
                            isHeart: !1,
                            uuid: "",
                            imageUrl: "",
                            showAddPhoto: !1
                        }),
                        B.textColor$.next(B.getTextColor(ne.style, ne.customBackground))
                    })()
                }
                setSizes(ve) {
                    this.moon.width = .98 * ve.size.width / 3,
                    this.moon.height = this.moon.width,
                    this.imageInstanceSize = {
                        width: this.moon.width,
                        height: this.moon.width
                    },
                    this.moon.marginTop = .09 * this.moon.height,
                    this.moon.padding = .01 * this.moon.width,
                    this.moon.punchingDiePadding = .055 * this.moon.width,
                    this.moon.punchingDieLineSize = .061 * this.moon.width
                }
                onImageLoad() {
                    this.load++,
                    3 === this.load && (this.initiateRender(),
                    this.cdr.detectChanges())
                }
                getTextColor(ve, ne) {
                    return ve === Me.O8Z.CUSTOM ? (0,
                    ct.V)(ne) ? "#FFF" : "#000" : ve === Me.O8Z.MARSHMALLOW ? "#666666" : [Me.O8Z.WHITE, Me.O8Z.CREAM].includes(ve) ? "#000" : "#FFF"
                }
                isNarrowRatio(ve) {
                    return ve.size.height / ve.size.width >= .8
                }
                getPhotoWithType(ve) {
                    return ve
                }
                onPhotoSelect() {
                    this.photoSelect.emit([this.imageInstanceSize.width, this.imageInstanceSize.height])
                }
            }
            return (Kt = At).\u0275fac = function(ve) {
                return new (ve || Kt)(r.rXU(r.aKT),r.rXU(r.SKi),r.rXU(r.gRc))
            }
            ,
            Kt.\u0275cmp = r.VBU({
                type: Kt,
                selectors: [["pp-poster-moon-triple"]],
                inputs: {
                    photoFileGroup: "photoFileGroup",
                    photoCropGroup: "photoCropGroup",
                    photoId: "photoId",
                    multiFile: "multiFile",
                    environmentPhotoApi: "environmentPhotoApi",
                    isFileUploadingInProgress: "isFileUploadingInProgress"
                },
                outputs: {
                    photoSelect: "photoSelect",
                    setFileUpploadingProgress: "setFileUpploadingProgress"
                },
                features: [r.Vt3],
                decls: 19,
                vars: 14,
                consts: [["posterWrapper", ""], ["singleElement", ""], [3, "background"], [3, "poster", 4, "ngIf"], [4, "ngIf"], ["shape-rendering", "geometricPrecision", 2, "position", "absolute"], ["id", "circleClipPath"], ["fill", "white"], [2, "top", "0", "position", "absolute"], ["id", "heartClipPath"], ["fill", "white", "d", "M1666.1,954.9h0s-56.1,217.2-319.8,454c-238.8,214.4-457.8,325.9-457.8,325.9,0,0-219-111.5-457.8-325.9-263.6-236.7-319.8-454-319.8-454-89.7-290.5,54-462.9,54-462.9,0,0,136.4-188.9,368.9-188.9s354.6,209.8,354.6,209.8c0,0,122.1-209.8,354.6-209.8s368.9,188.9,368.9,188.9c0,0,143.7,172.4,54,462.9h.2Z"], [3, "poster"], [3, "textareaHeightCallback", "textareaWidthCallback", "poster", "color", "textArea", "title", "subtitle"], [3, "isTriple", "width", "height", "marginTop", 4, "ngIf"], [3, "isTriple"], ["first", "", 3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["second", "", 3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["third", "", 3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "moon-instance"], ["class", "moon-area", 3, "width", "height", 4, "ngIf"], [3, "poster", "color", "textArea", "title", "footer"], [1, "moon-area"], [3, "relative"], [1, "photo-instance", 3, "marginTop", "special-circle", "special-heart"], [1, "moon-image", 3, "load", "src"], [3, "showPreview", "marginTop", "previewType"], [1, "photo-instance"], [3, "src", "load", "click", 4, "ngIf"], [3, "photoFileGroup", "photoCropGroup", "photoId", "multiFile", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "withBackgroundGray", "isFileUploadingInProgress", "legalNote", "setFileUploadingProgress", 4, "ngIf"], [3, "load", "click", "src"], [3, "setFileUploadingProgress", "photoFileGroup", "photoCropGroup", "photoId", "multiFile", "isSubmitted", "acceptable", "isBase64Response", "fullHeight", "isBigPictureMode", "withBackgroundGray", "isFileUploadingInProgress", "legalNote"]],
                template: function(ve, ne) {
                    if (1 & ve && (r.j41(0, "pp-poster-background", 2, 0),
                    r.DNE(2, mo, 10, 19, "pp-poster-printing-registration", 3),
                    r.nI1(3, "async"),
                    r.k0s(),
                    r.DNE(4, Jt, 10, 24, "ng-template", null, 1, r.C5r)(6, po, 1, 0, "pp-poster-loaded-element", 4),
                    r.SS7(7)(8),
                    r.qSk(),
                    r.j41(9, "svg", 5)(10, "defs")(11, "mask", 6),
                    r.nrm(12, "circle", 7),
                    r.k0s()()(),
                    r.SS7(13)(14),
                    r.j41(15, "svg", 8)(16, "defs")(17, "mask", 9),
                    r.nrm(18, "path", 10),
                    r.k0s()()()),
                    2 & ve) {
                        r.Y8G("background", ne.moon.background),
                        r.R7$(2),
                        r.Y8G("ngIf", r.bMT(3, 12, ne.poster$)),
                        r.R7$(4),
                        r.Y8G("ngIf", ne.isImageRendered);
                        const B = ne.moon.width / 2
                          , de = .99 * B;
                        r.R7$(3),
                        r.BMQ("width", B)("height", B),
                        r.R7$(3),
                        r.BMQ("cx", B)("cy", B)("r", de);
                        const lt = ne.moon.width
                          , St = lt / 1777;
                        r.R7$(3),
                        r.BMQ("width", lt)("height", lt)("viewBox", "0 0 1777 1777"),
                        r.R7$(3),
                        r.BMQ("transform", "scale(" + St + "," + St + ")")
                    }
                },
                dependencies: [Mt.Z, s.R, _t.c, so.y, Wt.W, Ae.MD, Ae.bT, Ae.T3, Ae.Jj, jt.C, Xe.G, pt.ex, Be.h, Be.D9, ze.P],
                styles: ["[_nghost-%COMP%]{width:100%;height:100%;display:block}[_nghost-%COMP%]   img.moon-instance[_ngcontent-%COMP%]{width:100%;height:100%}[_nghost-%COMP%]     .photo-instance{width:100%;height:100%;scale:1.06}[_nghost-%COMP%]     .photo-instance img{width:100%;height:100%;object-fit:cover;box-sizing:border-box}[_nghost-%COMP%]     .photo-instance.special-heart{scale:1.1}[_nghost-%COMP%]     .photo-instance.special-heart canvas, [_nghost-%COMP%]     .photo-instance.special-heart img, [_nghost-%COMP%]     .photo-instance.special-heart pp-controls-file-uploader-photo{-webkit-mask:url(#heartClipPath);mask:url(#heartClipPath)}[_nghost-%COMP%]     .photo-instance.special-circle canvas, [_nghost-%COMP%]     .photo-instance.special-circle img, [_nghost-%COMP%]     .photo-instance.special-circle pp-controls-file-uploader-photo{-webkit-mask:url(#circleClipPath);mask:url(#circleClipPath)}"]
            }),
            At
        }
        )()
    }
}]);
