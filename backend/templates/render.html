<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map Poster Renderer</title>

    <!-- Mapbox GL JS -->
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.css' rel='stylesheet' />
    <script src='https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.js'></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=Montserrat:wght@300;400;500;600;700;800&family=Playfair+Display:wght@400;700;900&family=Bebas+Neue&family=Dancing+Script:wght@400;500;600;700&family=Pacifico&family=Great+Vibes&family=Sacramento&family=Allura&family=Satisfy&family=Lobster&family=Righteous&family=Amatic+SC:wght@400;700&family=Permanent+Marker&family=Caveat:wght@400;500;600;700&family=Indie+Flower&display=swap" rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Poppins', sans-serif;
        }

        #map-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .map-wrapper {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Single map layout */
        .layout-single #map {
            width: 100%;
            height: 100%;
        }

        /* Double map layout */
        .layout-double {
            display: flex;
        }

        .layout-double .map-wrapper {
            width: 50%;
        }

        /* Triple map layout */
        .layout-triple {
            display: flex;
        }

        .layout-triple .map-wrapper {
            width: 33.333%;
        }

        /* Shape overlays */
        .shape-circle::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle, transparent 45%, white 45%);
            pointer-events: none;
            z-index: 1000;
        }

        .shape-heart::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            clip-path: path('M197.19,79.91c-12.89,55.16-89.21,97.44-95,100.39-5.78-2.95-82.09-45.23-95-100.39-2.52-10.78-5.65-31.82,6.23-50.08,1.4-2.16,7.5-10.68,18.8-17.44C48.35,2.72,78.73-3.65,102.19,30.51,125.67-3.67,156.03,2.72,172.16,12.39c11.3,6.76,17.4,15.29,18.8,17.44,11.88,18.25,8.75,39.3,6.23,50.08Z');
            background: white;
            pointer-events: none;
            z-index: 1000;
        }

        /* Title overlay */
        .title-overlay {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 2000;
            color: #000;
            text-shadow: 0 0 10px rgba(255,255,255,0.8);
        }

        .title-large {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 10px;
            letter-spacing: 2px;
        }

        .title-small {
            font-size: 24px;
            font-weight: 400;
            letter-spacing: 1px;
        }

        /* Marker styles */
        .custom-marker {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .custom-marker svg {
            width: 35px;
            height: 35px;
        }

        /* Frame overlay */
        .frame-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 1500;
        }
    </style>
</head>
<body>
    <div id="map-container">
        <!-- Maps will be dynamically created here -->
    </div>

    <script>
        // Mapbox access token
        mapboxgl.accessToken = 'pk.eyJ1IjoiZG9kbzc5MSIsImEiOiJjbWZianUyejEwNDNsMmpxdzBjZmZnbndtIn0.t5a9KzottI8eUYz396kfbQ';

        // Global state
        window.mapRenderComplete = false;
        let maps = [];

        /**
         * Initialize map(s) for print rendering
         */
        window.initializeMapForPrint = async function(config) {
            console.log('=== STARTING MAP INITIALIZATION ===');
            console.log('Full config:', JSON.stringify(config, null, 2));

            try {
                const container = document.getElementById('map-container');
                container.className = `layout-${config.layout.type} shape-${config.layout.shape}`;
                console.log('Container class set:', container.className);

                // Determine number of maps
                const numMaps = config.maps ? config.maps.length : 1;
                console.log('Number of maps to create:', numMaps);

                // Create map containers
                for (let i = 0; i < numMaps; i++) {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'map-wrapper';
                    wrapper.id = `map-wrapper-${i}`;

                    const mapDiv = document.createElement('div');
                    mapDiv.id = `map-${i}`;
                    mapDiv.style.width = '100%';
                    mapDiv.style.height = '100%';

                    wrapper.appendChild(mapDiv);
                    container.appendChild(wrapper);
                    console.log(`Created container for map ${i}`);
                }

                // Load style
                console.log('Loading map style...');
                const styleUrl = await getStyleUrl(config);
                console.log('Style URL resolved:', styleUrl);

                // Initialize each map
                console.log('Initializing maps...');
                const mapPromises = [];
                for (let i = 0; i < numMaps; i++) {
                    const mapConfig = config.maps[i];
                    console.log(`Initializing map ${i} at [${mapConfig.center}] zoom ${mapConfig.zoom}`);
                    mapPromises.push(initializeMap(i, mapConfig, styleUrl, config));
                }

                console.log('Waiting for all maps to load...');
                await Promise.all(mapPromises);
                console.log('All maps loaded successfully');

                // Wait for all tiles to load
                console.log('Waiting 5s for tiles to finish loading...');
                await new Promise(resolve => setTimeout(resolve, 5000));

                window.mapRenderComplete = true;
                console.log('=== MAP RENDERING COMPLETE ===');

            } catch (error) {
                console.error('!!! ERROR initializing map:', error);
                console.error('Error stack:', error.stack);
                throw error;
            }
        };

        /**
         * Initialize a single map
         */
        async function initializeMap(index, mapConfig, styleUrl, globalConfig) {
            return new Promise((resolve, reject) => {
                try {
                    // Calculate pixelRatio based on DPI for high-resolution rendering
                    // DPI 150 -> 1.5x, DPI 200 -> 2x, DPI 300 -> 3x
                    const dpi = globalConfig.print?.dpi || 200;
                    const pixelRatio = Math.min(dpi / 96, 3); // Max 3x for performance

                    // CRITICAL: Adjust zoom based on poster size vs frontend preview size
                    // Frontend preview is ~640px wide, but posters can be 6,300px wide
                    // Each zoom level doubles the scale, so we need log2(ratio) adjustment
                    const frontendPreviewWidth = mapConfig.previewWidth || 640; // Default preview width
                    const posterWidth = Math.round((globalConfig.print.width / 2.54) * dpi); // Convert cm to pixels
                    const sizeRatio = posterWidth / frontendPreviewWidth;
                    const zoomAdjustment = Math.log2(sizeRatio);
                    const adjustedZoom = (mapConfig.zoom || 15) + zoomAdjustment;

                    console.log(`Zoom calculation: preview=${frontendPreviewWidth}px, poster=${posterWidth}px, ratio=${sizeRatio.toFixed(2)}x, adjustment=+${zoomAdjustment.toFixed(2)}, final zoom=${adjustedZoom.toFixed(2)}`);

                    const map = new mapboxgl.Map({
                        container: `map-${index}`,
                        style: styleUrl,
                        center: mapConfig.center,
                        zoom: adjustedZoom, // Adjusted zoom for poster size
                        bearing: mapConfig.bearing || 0, // Explicit north-up orientation
                        pitch: mapConfig.pitch || 0, // Explicit 2D view (no tilt)
                        preserveDrawingBuffer: true,
                        interactive: false,
                        attributionControl: false,
                        logoPosition: 'bottom-right',
                        antialias: true,
                        fadeDuration: 0,
                        pixelRatio: pixelRatio, // High-resolution rendering
                        maxZoom: 22, // Match frontend zoom limits
                        minZoom: 10,
                        renderWorldCopies: false, // Prevent world wrapping artifacts
                        crossSourceCollisions: false, // Improve label clarity
                        optimizeForTerrain: false // Sharper vector tiles
                    });

                    console.log(`Map ${index} initialized with bearing=${map.getBearing()}, pitch=${map.getPitch()}, pixelRatio=${pixelRatio}`);

                    maps.push(map);

                    map.on('load', async function() {
                        console.log(`Map ${index} loaded`);

                        // Verify map orientation and position
                        const mapState = {
                            center: map.getCenter(),
                            zoom: map.getZoom(),
                            bearing: map.getBearing(),
                            pitch: map.getPitch(),
                            pixelRatio: map.getPixelRatio()
                        };
                        console.log(`Map ${index} state after load:`, JSON.stringify(mapState, null, 2));

                        // Apply custom colors if using custom style
                        if (globalConfig.style === 'custom' && globalConfig.customColors) {
                            applyCustomColors(map, globalConfig.customColors);
                        }

                        // Add markers
                        if (mapConfig.markers && mapConfig.markers.length > 0) {
                            mapConfig.markers.forEach(marker => {
                                addMarker(map, marker);
                            });
                        }

                        // Add title overlay
                        if (mapConfig.title && mapConfig.title.enabled) {
                            addTitleOverlay(index, mapConfig.title);
                        }

                        // Wait for tiles
                        await new Promise(r => setTimeout(r, 2000));

                        resolve();
                    });

                    map.on('error', (e) => {
                        console.error(`Map ${index} error:`, e);
                        reject(e);
                    });

                } catch (error) {
                    reject(error);
                }
            });
        }

        /**
         * Get style URL based on configuration
         */
        async function getStyleUrl(config) {
            console.log('Getting style URL for:', config.style);

            // If it's already a Mapbox URL, use it directly
            if (config.style && config.style.startsWith('mapbox://styles/')) {
                console.log('Using Mapbox style URL:', config.style);
                return config.style;
            }

            // For custom style, use streets as base
            if (config.style === 'custom') {
                console.log('Using custom style with streets-v12 as base');
                return 'mapbox://styles/mapbox/streets-v12';
            }

            // Fallback to default
            console.warn(`Unknown style format: ${config.style}, using default`);
            return 'mapbox://styles/mapbox/streets-v12';
        }

        /**
         * Apply custom colors to map
         */
        function applyCustomColors(map, colors) {
            if (colors.background) {
                map.setPaintProperty('bg', 'background-color', colors.background);
            }

            if (colors.water) {
                ['water', 'waterway'].forEach(layer => {
                    if (map.getLayer(layer)) {
                        map.setPaintProperty(layer, 'fill-color', colors.water);
                    }
                });
            }

            if (colors.land) {
                ['landcover', 'landuse'].forEach(layer => {
                    if (map.getLayer(layer)) {
                        map.setPaintProperty(layer, 'fill-color', colors.land);
                    }
                });
            }

            if (colors.roads) {
                ['road', 'street', 'highway'].forEach(layer => {
                    if (map.getLayer(layer)) {
                        map.setPaintProperty(layer, 'line-color', colors.roads);
                    }
                });
            }
        }

        /**
         * Add marker to map
         */
        function addMarker(map, markerConfig) {
            const el = document.createElement('div');
            el.className = 'custom-marker';
            el.innerHTML = getMarkerSVG(markerConfig.icon, markerConfig.color);

            new mapboxgl.Marker(el)
                .setLngLat(markerConfig.coordinates)
                .addTo(map);
        }

        /**
         * Get marker SVG
         */
        function getMarkerSVG(icon, color) {
            const svgs = {
                heart: `<svg xmlns="http://www.w3.org/2000/svg" width="35.908" height="32.946" viewBox="0 0 35.908 32.946">
                    <path fill="${color}" d="M19.954,35.946l-2.6-2.37C8.1,25.191,2,19.661,2,12.875A9.779,9.779,0,0,1,11.875,3a10.752,10.752,0,0,1,8.079,3.752A10.752,10.752,0,0,1,28.033,3a9.779,9.779,0,0,1,9.875,9.875c0,6.787-6.1,12.316-15.351,20.719Z" transform="translate(-2 -3)"/>
                </svg>`,
                house: `<svg xmlns="http://www.w3.org/2000/svg" width="35.908" height="30.522" viewBox="0 0 35.908 30.522">
                    <path fill="${color}" d="M30.5,18.1v13.1h-8.9v-9.3h-7.4v9.3H5.4V18.1L18,6.1L30.5,18.1z M18,3.9l-15,14.3c-1.6,1.6-4-0.9-2.4-2.5L16.8,0.5c0.7-0.6,1.7-0.6,2.4,0l7.6,7.2V4.3c0-0.4,0.4-0.8,0.8-0.8h2.2c0.4,0,0.8,0.4,0.8,0.8v6.9l4.8,4.5c1.7,1.6-0.7,4.1-2.4,2.5C28,13.4,23,8.7,18,3.9L18,3.9z"/>
                </svg>`,
                star: `<svg xmlns="http://www.w3.org/2000/svg" width="35" height="35" viewBox="0 0 24 24">
                    <path fill="${color}" d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                </svg>`
            };

            return svgs[icon] || svgs.heart;
        }

        /**
         * Add title overlay
         */
        function addTitleOverlay(mapIndex, titleConfig) {
            const wrapper = document.getElementById(`map-wrapper-${mapIndex}`);

            const overlay = document.createElement('div');
            overlay.className = 'title-overlay';
            overlay.style.fontFamily = titleConfig.font || 'Poppins';

            if (titleConfig.largeText) {
                const large = document.createElement('div');
                large.className = 'title-large';
                large.textContent = titleConfig.largeText;
                overlay.appendChild(large);
            }

            if (titleConfig.smallText) {
                const small = document.createElement('div');
                small.className = 'title-small';
                small.textContent = titleConfig.smallText;
                overlay.appendChild(small);
            }

            wrapper.appendChild(overlay);
        }
    </script>
</body>
</html>
